# Workflow: pipes {#sec-workflow-pipes}

```{r}
#| results: "asis"
#| echo: false

source("_common.R")
status("complete")
```

Las canalizaciones o como se llaman más comunmente *pipes*, `|>`, es una poderosa herramienta para expresar claramente una secuencia de operaciones que transforman un objeto.
Presentamos brevemente las *pipes* en el capítulo anterior, pero antes de continuar, queremos dar algunos detalles más y hablar sobre `%>%`, un predecesor de `|>`.

Para agregar *pipe* a su código, recomendamos usar el atajo de teclado incorporado Ctrl/Cmd + Shift + M.
Deberá realizar un cambio en sus opciones de RStudio para usar `|>` en lugar de `%>%` como se muestra en @fig-pipe-options; más sobre `%>%` en breve.

```{r}
#| label: fig-pipe-options
#| echo: false
#| fig-cap: >
#|   Para insertar `|>`, asegúrese de que la opción "Usar operador de canalización nativo" esté marcada.
#| fig-alt: >
#|   Captura de pantalla que muestra la opción "Usar operador de canalización nativo" que se puede
#|   encontrar en el panel "Edición" de las opciones de "Código".

knitr::include_graphics("screenshots/rstudio-pipe-options.png")
```

## ¿Por qué usar *pipe*?

Cada verbo dplyr individual es bastante simple, por lo que resolver problemas complejos generalmente requiere combinar varios verbos.
Por ejemplo, el último capítulo terminó con una *pipe* moderadamente compleja:

```{r}
#| eval: false

flights |>  
  filter(!is.na(arr_delay), !is.na(tailnum)) |> 
  group_by(tailnum) |> 
  summarize(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )
```

Aunque esta tubería tiene cuatro pasos, es fácil de hojear porque los verbos aparecen al comienzo de cada línea: comience con los datos de `flights`, luego filtre, luego agrupe y luego resuma.

¿Qué pasaría si no tuviéramos la canalización?
Podríamos anidar cada llamada de función dentro de la llamada anterior:

```{r}
#| eval: false

summarize(
  group_by(
    filter(
      flights, 
      !is.na(arr_delay), !is.na(tailnum)
    ),
    tailnum
  ), 
  delay = mean(arr_delay, na.rm = TRUE
  ), 
  n = n()
)
```

O podríamos usar un montón de variables intermedias:

```{r}
#| eval: false

flights1 <- filter(flights, !is.na(arr_delay), !is.na(tailnum))
flights2 <- group_by(flights1, tailnum) 
flights3 <- summarize(flight2,
  delay = mean(arr_delay, na.rm = TRUE),
  n = n()
)
```

Si bien ambas formas tienen su tiempo y lugar, con *pipe* generalmente se produce un código de análisis de datos que es más fácil de escribir y leer.

## magrittr y *pipe* `%>%`

Si ha estado usando tidyverse por un tiempo, es posible que esté familiarizado con la canalización `%>%` proporcionada por el paquete **magrittr**.
El paquete magrittr está incluido en el tidyverse principal, por lo que puede usar `%>%` siempre que cargue el tidyverse:

```{r}
#| message: false

library(tidyverse)

mtcars %>% 
  group_by(cyl) %>%
  summarize(n = n())
```

Para casos simples, `|>` y `%>%` se comportan de manera idéntica.
Entonces, ¿por qué recomendamos *pipe* base?
En primer lugar, debido a que es parte de la base de R, siempre está disponible para su uso, incluso cuando no está utilizando el tidyverse.
En segundo lugar, `|>` es un poco más simple que `%>%`: en el tiempo entre la invención de `%>%` en 2014 y la inclusión de `|>` en R 4.1.0 en 2021, ganamos una mejor comprensión de *pipe*.
Esto permitió que la implementación base desechara características poco utilizadas y menos importantes.

## `|>` vs. `%>%`

Mientras que `|>` y `%>%` se comportan de manera idéntica para casos simples, existen algunas diferencias cruciales.
Es más probable que esto le afecte si es un usuario a largo plazo de `%>%` que ha aprovechado algunas de las funciones más avanzadas.
Pero aún es bueno conocerlos incluso si nunca ha usado `%>%` porque es probable que encuentre algunos de ellos al leer código capturado de forma salvaje.

-   De forma predeterminada, *pipe* pasa el objeto de su lado izquierdo al primer argumento de la función del lado derecho.
    `%>%` le permite cambiar la ubicación con un marcador de posición `.`.
    Por ejemplo, `x %>% f(1)` es equivalente a `f(x, 1)` pero `x %>% f(1, .)` es equivalente a `f(1, x)`.
    R 4.2.0 agregó un marcador de posición `_` a la canalización base, con una restricción adicional: el argumento debe tener un nombre.
    Por ejemplo, `x |> f(1, y = _)` es equivalente a `f(1, y = x)`.

-   El marcador de posición `|>` es deliberadamente simple y no puede replicar muchas características del marcador de posición `%>%`: no puede pasarlo a múltiples argumentos y no tiene ningún comportamiento especial cuando el marcador de posición se usa dentro otra función.
    Por ejemplo, `df %>% split(.$var)` es equivalente a `split(df, df$var)` y `df %>% {split(.$x, .$y)}` es equivalente a `split(df$x, df$y)`.

    Con `%>%`, puede usar `.` en el lado izquierdo de operadores como `$`, `[[`, `[` (sobre los que aprenderá en @sec-subset-many), para que pueda extraer una sola columna de un marco de datos con (p. ej.) `mtcars %>% .$cyl`.
    Una versión futura de R puede agregar soporte similar para `|>` y `_`.
    Para el caso especial de extraer una columna de un marco de datos, también puede usar `dplyr::pull()`:

    ```{r}
    mtcars |> pull(cyl)
    ```

-   `%>%` le permite eliminar los paréntesis al llamar a una función sin otros argumentos; `|>` siempre requiere los paréntesis.

-   `%>%` le permite iniciar una canalización con `.` para crear una función en lugar de ejecutar inmediatamente la canalización; esto no es compatible con la canalización base.

Afortunadamente, no hay necesidad de comprometerse por completo con una canalización u otra: puede usar la canalización base para la mayoría de los casos en los que es suficiente y usar la canalización magrittr cuando realmente necesita sus características especiales.

## `|>` vs. `+`

A veces, convertimos el final de una canalización de transformación de datos en un gráfico.
Esté atento a la transición de `|>` a `+`.
Desearíamos que esta transición no fuera necesaria, pero desafortunadamente, ggplot2 se creó antes de que se descubriera *pipe*.

```{r}
#| eval: false

diamonds |> 
  count(cut, clarity) |> 
  ggplot(aes(x = clarity, y = cut, fill = n)) + 
  geom_tile()
```

## Resumen

En este capítulo, ha aprendido más sobre *pipe*: por qué la recomendamos y algo de la historia que condujo a `|>`.
La canalización es importante porque la usará una y otra vez a lo largo de su análisis, pero con suerte, rápidamente se volverá invisible y sus dedos la escribirán (o usarán el atajo de teclado) sin que su cerebro tenga que pensar demasiado en ello.

En el próximo capítulo, volvemos a las herramientas de ciencia de datos y aprendemos sobre los datos ordenados.
Tidy data es una forma consistente de organizar sus data frame que se utiliza en todo el tidyverse.
Esta consistencia facilita su vida porque una vez que tiene datos ordenados, solo funciona con la gran mayoría de las funciones de tidyverse.
Por supuesto, la vida nunca es fácil y la mayoría de los conjuntos de datos que encuentre en la naturaleza no estarán ya ordenados.
Entonces, también le enseñaremos cómo usar el paquete tidyr para ordenar sus datos desordenados.

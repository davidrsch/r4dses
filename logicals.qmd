# Vectores lógicos {#sec-logicals}

```{r}
#| results: "asis"
#| echo: false
source("_common.R")
status("complete")
```

## Introducción

En este capítulo, aprenderá herramientas para trabajar con vectores lógicos.
Los vectores lógicos son el tipo de vector más simple porque cada elemento solo puede tener uno de tres valores posibles: TRUE, `TRUE`, FALSE, `FALSE` y faltante, `NA`.
Es relativamente raro encontrar vectores lógicos en sus datos sin procesar, pero los creará y manipulará en el curso de casi todos los análisis.

Comenzaremos discutiendo la forma más común de crear vectores lógicos: con comparaciones numéricas.
Luego, aprenderá cómo puede usar el álgebra booleana para combinar diferentes vectores lógicos, así como algunos resúmenes útiles.
Terminaremos con `if_else()` y `case_when()`, dos funciones útiles para realizar cambios condicionales impulsados por vectores lógicos.

### Requisitos previos

La mayoría de las funciones que aprenderá en este capítulo son proporcionadas por la base R, por lo que no necesitamos el tidyverse, pero igual lo cargaremos para poder usar `mutate()`, `filter()`, y amigos para trabajar con data frames.
También continuaremos extrayendo ejemplos del conjunto de datos `nycflights13::flights`.

```{r}
#| label: setup
#| message: false

library(tidyverse)
library(nycflights13)
```

Sin embargo, a medida que empecemos a cubrir más herramientas, no siempre habrá un ejemplo real perfecto.
Así que empezaremos a inventar algunos datos ficticios con `c()`:

```{r}
x <- c(1, 2, 3, 5, 7, 11, 13)
x * 2
```

Esto facilita la explicación de funciones individuales a costa de dificultar ver cómo podría aplicarse a sus problemas de datos.
Solo recuerda que cualquier manipulación que hagamos a un vector flotante, puedes hacerla a una variable dentro de un data frame con `mutate()` y amigos.

```{r}
df <- tibble(x)
df |> 
  mutate(y = x *  2)
```

## Comparaciones

Una forma muy común de crear un vector lógico es a través de una comparación numérica con `<`, `<=`, `>`, `>=`, `!=` y `==`.
Hasta ahora, en su mayoría hemos creado variables lógicas de manera transitoria dentro de `filter()` --- se calculan, usan y luego se descartan.
Por ejemplo, el siguiente filtro encuentra todas las salidas diurnas que salen aproximadamente a tiempo:

```{r}
flights |> 
  filter(dep_time > 600 & dep_time < 2000 & abs(arr_delay) < 20)
```

Es útil saber que este es un atajo y que puedes crear explícitamente las variables lógicas subyacentes con `mutate()`:

```{r}
flights |> 
  mutate(
    daytime = dep_time > 600 & dep_time < 2000,
    approx_ontime = abs(arr_delay) < 20,
    .keep = "used"
  )
```

Esto es particularmente útil para la lógica más complicada porque nombrar los pasos intermedios facilita la lectura del código y la verificación de que cada paso se haya calculado correctamente.

Con todo, el filtro inicial es equivalente a:

```{r}
#| results: false

flights |> 
  mutate(
    daytime = dep_time > 600 & dep_time < 2000,
    approx_ontime = abs(arr_delay) < 20,
  ) |> 
  filter(daytime & approx_ontime)
```

### Comparación de punto flotante {#sec-fp-comparison}

Cuidado con usar `==` con números.
Por ejemplo, parece que este vector contiene los números 1 y 2:

```{r}
x <- c(1 / 49 * 49, sqrt(2) ^ 2)
x
```

Pero si los prueba para la igualdad, obtiene FALSE, `FALSE`:

```{r}
x == c(1, 2)
```

¿Qué está sucediendo?
Las computadoras almacenan números con un número fijo de posiciones decimales, por lo que no hay forma de representar exactamente 1/49 o `sqrt(2)` y los cálculos subsiguientes estarán ligeramente desviados.
Podemos ver los valores exactos llamando a `print()` con el argumento `digits`[^logicals-1]:

[^logicals-1]: R normalmente llama a print por usted (es decir, `x` es un atajo para `print(x)`), pero llamarlo explícitamente es útil si desea proporcionar otros argumentos.

```{r}
print(x, digits = 16)
```

Puede ver por qué R por defecto redondea estos números; realmente están muy cerca de lo que esperas.

Ahora que ha visto por qué `==` está fallando, ¿qué puede hacer al respecto?
Una opción es usar `dplyr::near()` que ignora las pequeñas diferencias:

```{r}
near(x, c(1, 2))
```

### Valores faltantes {#sec-na-comparison}

Los valores faltantes representan lo desconocido, por lo que son "contagiosos": casi cualquier operación que involucre un valor desconocido también será desconocida:

```{r}
NA > 5
10 == NA
```

El resultado más confuso es este:

```{r}
NA == NA
```

Es más fácil entender por qué esto es cierto si proporcionamos artificialmente un poco más de contexto:

```{r}
# Sea x la edad de María. No sabemos cuantos años tiene.
x <- NA

# Sea y la edad de Juan. No sabemos cuantos años tiene.
y <- NA

# ¿Juan y María tienen la misma edad?
x == y
# ¡No sabemos!

```

Entonces, si desea encontrar todos los vuelos en los que falta `dep_time`, el siguiente código no funciona porque `dep_time == NA` generará `NA` para cada fila, y `filter()` elimina automáticamente los valores faltantes:

```{r}
flights |> 
  filter(dep_time == NA)
```

En su lugar, necesitaremos una nueva herramienta: `is.na()`.

### `is.na()`

`is.na(x)` funciona con cualquier tipo de vector y devuelve TRUE, `TRUE`, para los valores faltantes y FALSE, `FALSE`, para todo lo demás:

```{r}
is.na(c(TRUE, NA, FALSE))
is.na(c(1, NA, 3))
is.na(c("a", NA, "b"))
```

Podemos usar `is.na()` para encontrar todas las filas a las que les falta `dep_time`:

```{r}
flights |> 
  filter(is.na(dep_time))
```

`is.na()` también puede ser útil en `arrange()`.
`arrange()` generalmente coloca todos los valores faltantes al final, pero puede anular este valor predeterminado ordenando primero por `is.na()`:

```{r}
flights |> 
  filter(month == 1, day == 1) |> 
  arrange(dep_time)

flights |> 
  filter(month == 1, day == 1) |> 
  arrange(desc(is.na(dep_time)), dep_time)
```

Volveremos para cubrir los valores faltantes con más profundidad en @sec-missing-values.

### Ejercicios

1.  ¿Cómo funciona `dplyr::near()`? Escribe `near` para ver el código fuente.
2.  Use `mutate()`, `is.na()` y `count()` juntos para describir cómo se conectan los valores que faltan en `dep_time`, `sched_dep_time` y `dep_delay`.

## Álgebra booleana

Una vez que tenga varios vectores lógicos, puede combinarlos usando álgebra booleana.
En R, `&` es "y", `|` es "o", `!` es "no", y `xor()` es exclusivo o [^logicals-2].
@fig-bool-ops muestra el conjunto completo de operaciones booleanas y cómo funcionan.

[^logicals-2]: Es decir, `xor(x, y)` es TRUE si x es TRUE, o y es TRUE, pero no ambos.
    Así es como solemos usar "o" en inglés.
    "Ambos" no suele ser una respuesta aceptable a la pregunta "¿quieres un helado o un pastel?".

```{r}
#| label: fig-bool-ops
#| echo: false
#| out-width: NULL
#| fig-cap: > 
#|    El conjunto completo de operaciones booleanas. `x` es el círculo a la
#|    izquierda, `y` es el círculo de la derecha, y la región sombreada muestra
#|    qué partes selecciona cada operador.
#| fig-alt: >
#|    Seis diagramas de Venn, cada uno explicando un operador lógico distinto. Los
#|    círculos (conjuntos) en cada uno de los diagramas de Venn representan x e y. 1. y &
#|    !x es y pero nada de x; x & y es la intersección de x e y; x & !y es
#|    x pero ninguno de y; x es todo de x nada de y; xor(x, y) es todo
#|    excepto la intersección de x e y; y es todo de y y nada de x; y
#|    x | y es todo.
knitr::include_graphics("diagrams/transform.png", dpi = 270)
```

Además de `&` y `|`, R también tiene `&&` y `||`.
¡No los use en funciones dplyr!
Estos se denominan operadores de cortocircuito y solo devuelven un solo `TRUE` o `FALSE`.
Son importantes para la programación, no para la ciencia de datos.

### Valores Faltantes {#sec-na-boolean}

Las reglas para los valores faltantes en el álgebra booleana son un poco difíciles de explicar porque parecen inconsistentes a primera vista:

```{r}
df <- tibble(x = c(TRUE, FALSE, NA))

df |> 
  mutate(
    and = x & NA,
    or = x | NA
  )
```

Para entender lo que está pasando, piense en `NA | TRUE`.
Un valor faltante en un vector lógico significa que el valor podría ser `TRUE` o `FALSE`.
`TRUE | TRUE` y `FALSE | TRUE` son ambos `TRUE`, entonces `NA | TRUE` también debe ser `TRUE`.
Se aplica un razonamiento similar con `NA & FALSE`.

### Orden de operaciones

Tenga en cuenta que el orden de las operaciones no funciona como en inglés.
Tome el siguiente código que encuentra todos los vuelos que salieron en noviembre o diciembre:

```{r}
#| eval: false

flights |> 
   filter(month == 11 | month == 12)
```

Es posible que tenga la tentación de escribirlo como diría en inglés: "Buscar todos los vuelos que partieron en noviembre o diciembre".:

```{r}
flights |> 
   filter(month == 11 | 12)
```

Este código no da error, pero tampoco parece haber funcionado.
¿Qué está sucediendo?
Aquí, R primero evalúa `month == 11` creando un vector lógico, al que llamamos `nov`.
Calcula `nov | 12`.
Cuando usa un número con un operador lógico, convierte todo menos 0 en `TRUE`, por lo que esto es equivalente a `nov | TRUE` que siempre será `TRUE`, por lo que se seleccionarán todas las filas:

```{r}
flights |> 
  mutate(
    nov = month == 11,
    final = nov | 12,
    .keep = "used"
  )
```

### `%in%`

Una manera fácil de evitar el problema de poner tus `==`s y `|`s en el orden correcto es usar `%in%`.
`x %in% y` devuelve un vector lógico de la misma longitud que `x` que es `TRUE` cada vez que un valor en `x` está en cualquier parte de `y`.

```{r}
1:12 %in% c(1, 5, 11)
letters[1:10] %in% c("a", "e", "i", "o", "u")
```

Entonces, para encontrar todos los vuelos en noviembre y diciembre, podríamos escribir:

```{r}
#| eval: false

flights |> 
  filter(month %in% c(11, 12))
```

Tenga en cuenta que `%in%` obedece reglas diferentes para `NA` y `==`, ya que `NA %in% NA` es `TRUE`.

```{r}
c(1, 2, NA) == NA
c(1, 2, NA) %in% NA
```

Esto puede ser un atajo útil:

```{r}
flights |> 
  filter(dep_time %in% c(NA, 0800))
```

### Ejercicios

1.  Encuentre todos los vuelos en los que falte `arr_delay` pero no `dep_delay`. Encuentre todos los vuelos en los que no falten ni `arr_time` ni `sched_arr_time`, pero sí `arr_delay`.
2.  ¿A cuántos vuelos les falta `dep_time`? ¿Qué otras variables faltan en estas filas? ¿Qué podrían representar estas filas?
3.  Suponiendo que la falta de `dep_time` implica que se canceló un vuelo, mire la cantidad de vuelos cancelados por día. ¿Hay un patrón? ¿Existe una conexión entre la proporción de vuelos cancelados y el retraso promedio de los vuelos no cancelados?

## Resúmenes {#sec-logical-summaries}

Las siguientes secciones describen algunas técnicas útiles para resumir vectores lógicos.
Además de funciones que solo funcionan específicamente con vectores lógicos, también puede usar funciones que funcionan con vectores numéricos.

### Resúmenes lógicos

Hay dos resúmenes lógicos principales: `any()` y `all()`.
`any(x)` es el equivalente de `|`; devolverá `TRUE` si hay algún `TRUE` en `x`.
`all(x)` es equivalente a `&`; devolverá `TRUE` solo si todos los valores de `x` son `TRUE`.
Como todas las funciones de resumen, devolverán `NA` si hay algún valor faltante presente y, como de costumbre, puede hacer que los valores faltantes desaparezcan con `na.rm = TRUE`.

Por ejemplo, podríamos usar `all()` para averiguar si hubo días en los que se retrasó cada vuelo:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    all_delayed = all(arr_delay >= 0, na.rm = TRUE),
    any_delayed = any(arr_delay >= 0, na.rm = TRUE),
    .groups = "drop"
  )
```

En la mayoría de los casos, sin embargo, `any()` y `all()` son un poco toscos, y sería bueno poder obtener un poco más de detalles sobre cuántos valores son `TRUE` o `FALSE`.
Eso nos lleva a los resúmenes numéricos.

### Resúmenes numéricos de vectores lógicos {#sec-numeric-summaries-of-logicals}

Cuando usa un vector lógico en un contexto numérico, `TRUE` se convierte en 1 y `FALSE` se convierte en 0.
Esto hace que `sum()` y `mean()` sean muy útiles con vectores lógicos porque `sum(x)` dará el número de `TRUE` y `media(x)` la proporción de `TRUE`.
Eso nos permite ver la distribución de retrasos a lo largo de los días del año como se muestra en @fig-prop-delayed-dist

```{r}
#| label: fig-prop-delayed-dist
#| fig-cap: >
#|   Un histograma que muestra la proporción de vuelos retrasados cada día.
#| fig-alt: >
#|   La distribución es unimodal y levemente sesgada a la derecha. La distribución
#|   aumenta alrededor del 30% de vuelos retrasados.
flights |> 
  group_by(year, month, day) |> 
  summarize(
    prop_delayed = mean(arr_delay > 0, na.rm = TRUE),
    .groups = "drop"
  ) |> 
  ggplot(aes(x = prop_delayed)) + 
  geom_histogram(binwidth = 0.05)
```

O podríamos preguntar: "¿Cuántos vuelos salieron antes de las 5 am?", que a menudo son vuelos que se retrasaron desde el día anterior:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    n_early = sum(dep_time < 500, na.rm = TRUE),
    .groups = "drop"
  ) |> 
  arrange(desc(n_early))
```

### Subconjunto lógico

Hay un uso final para los vectores lógicos en los resúmenes: puede usar un vector lógico para filtrar una sola variable a un subconjunto de interés.
Esto hace uso del operador base `[` (subconjunto pronunciado), sobre el que obtendrá más información en @sec-subset-many.

Imagine que quisiéramos ver el retraso promedio solo para los vuelos que realmente se retrasaron.
Una forma de hacerlo sería filtrar primero los vuelos y luego calcular el retraso promedio:

```{r}
flights |> 
  filter(arr_delay > 0) |> 
  group_by(year, month, day) |> 
  summarize(
    behind = mean(arr_delay),
    n = n(),
    .groups = "drop"
  )
```

Esto funciona, pero ¿y si también quisiéramos calcular el retraso promedio de los vuelos que llegaron temprano?
Tendríamos que realizar un paso de filtro por separado y luego descubrir cómo combinar los dos marcos de datos juntos \[\^ lógicos-3\].
En su lugar, podría usar `[` para realizar un filtrado en línea: `arr_delay[arr_delay > 0]` generará solo los retrasos de llegada positivos.

Esto lleva a:

```{r}
flights |> 
  group_by(year, month, day) |> 
  summarize(
    behind = mean(arr_delay[arr_delay > 0], na.rm = TRUE),
    ahead = mean(arr_delay[arr_delay < 0], na.rm = TRUE),
    n = n(),
    .groups = "drop"
  )
```

También tenga en cuenta la diferencia en el tamaño del grupo: en el primer fragmento `n()` da el número de vuelos retrasados por día; en el segundo, `n()` da el número total de vuelos.

### Ejercicios

1.  ¿Qué te dirá `sum(is.na(x))`? ¿Qué tal `mean(is.na(x))`?
2.  ¿Qué devuelve `prod()` cuando se aplica a un vector lógico? ¿A qué función de resumen lógico es equivalente? ¿Qué devuelve `min()` cuando se aplica a un vector lógico? ¿A qué función de resumen lógico es equivalente? Lea la documentación y realice algunos experimentos.

## Transformaciones condicionales

One of the most powerful features of logical vectors are their use for conditional transformations, i.e. doing one thing for condition x, and something different for condition y.
There are two important tools for this: `if_else()` and `case_when()`.

### `if_else()`

If you want to use one value when a condition is `TRUE` and another value when it's `FALSE`, you can use `dplyr::if_else()`[^logicals-3].
You'll always use the first three argument of `if_else()`. The first argument, `condition`, is a logical vector, the second, `true`, gives the output when the condition is true, and the third, `false`, gives the output if the condition is false.

[^logicals-3]: dplyr's `if_else()` is very similar to base R's `ifelse()`.
    There are two main advantages of `if_else()`over `ifelse()`: you can choose what should happen to missing values, and `if_else()` is much more likely to give you a meaningful error if you variables have incompatible types.

Let's begin with a simple example of labeling a numeric vector as either "+ve" or "-ve":

```{r}
x <- c(-3:3, NA)
if_else(x > 0, "+ve", "-ve")
```

There's an optional fourth argument, `missing` which will be used if the input is `NA`:

```{r}
if_else(x > 0, "+ve", "-ve", "???")
```

You can also use vectors for the the `true` and `false` arguments.
For example, this allows us to create a minimal implementation of `abs()`:

```{r}
if_else(x < 0, -x, x)
```

So far all the arguments have used the same vectors, but you can of course mix and match.
For example, you could implement a simple version of `coalesce()` like this:

```{r}
x1 <- c(NA, 1, 2, NA)
y1 <- c(3, NA, 4, 6)
if_else(is.na(x1), y1, x1)
```

You might have noticed a small infelicity in our labeling example above: zero is neither positive nor negative.
We could resolve this by adding an additional `if_else()`:

```{r}
if_else(x == 0, "0", if_else(x < 0, "-ve", "+ve"), "???")
```

This is already a little hard to read, and you can imagine it would only get harder if you have more conditions.
Instead, you can switch to `dplyr::case_when()`.

### `case_when()`

dplyr's `case_when()` is inspired by SQL's `CASE` statement and provides a flexible way of performing different computations for different conditions.
It has a special syntax that unfortunately looks like nothing else you'll use in the tidyverse.
It takes pairs that look like `condition ~ output`.
`condition` must be a logical vector; when it's `TRUE`, `output` will be used.

This means we could recreate our previous nested `if_else()` as follows:

```{r}
x <- c(-3:3, NA)
case_when(
  x == 0   ~ "0",
  x < 0    ~ "-ve", 
  x > 0    ~ "+ve",
  is.na(x) ~ "???"
)
```

This is more code, but it's also more explicit.

To explain how `case_when()` works, lets explore some simpler cases.
If none of the cases match, the output gets an `NA`:

```{r}
case_when(
  x < 0 ~ "-ve",
  x > 0 ~ "+ve"
)
```

If you want to create a "default"/catch all value, use `TRUE` on the left hand side:

```{r}
case_when(
  x < 0 ~ "-ve",
  x > 0 ~ "+ve",
  TRUE ~ "???"
)
```

And note that if multiple conditions match, only the first will be used:

```{r}
case_when(
  x > 0 ~ "+ve",
  x > 2 ~ "big"
)
```

Just like with `if_else()` you can use variables on both sides of the `~` and you can mix and match variables as needed for your problem.
For example, we could use `case_when()` to provide some human readable labels for the arrival delay:

```{r}
flights |> 
  mutate(
    status = case_when(
      is.na(arr_delay)      ~ "cancelled",
      arr_delay < -30       ~ "very early",
      arr_delay < -15       ~ "early",
      abs(arr_delay) <= 15  ~ "on time",
      arr_delay < 60        ~ "late",
      arr_delay < Inf       ~ "very late",
    ),
    .keep = "used"
  )
```

Be wary when writing this sort of complex `case_when()` statement; my first two attempts used a mix of `<` and `>` and I kept accidentally creating overlapping conditions.

### Compatible types

Note that both `if_else()` and `case_when()` require **compatible** types in the output.
If they're not compatible, you'll see errors like this:

```{r}
#| error: true

if_else(TRUE, "a", 1)

case_when(
  x < -1 ~ TRUE,  
  x > 0  ~ lubridate::now()
)
```

Overall, relatively few types are compatible, because automatically converting one type of vector to another is a common source of errors.
Here are the most important cases that are compatible:

-   Numeric and logical vectors are compatible, as we discussed in @sec-numeric-summaries-of-logicals.
-   Strings and factors (@sec-factors) are compatible, because you can think of a factor as a string with a restricted set of values.
-   Dates and date-times, which we'll discuss in @sec-dates-and-times, are compatible because you can think of a date as a special case of date-time.
-   `NA`, which is technically a logical vector, is compatible with everything because every vector has some way of representing a missing value.

We don't expect you to memorize these rules, but they should become second nature over time because they are applied consistently throughout the tidyverse.

## Summary

The definition of a logical vector is simple because each value must be either `TRUE`, `FALSE`, or `NA`.
But logical vectors provide a huge amount of power.
In this chapter, you learned how to create logical vectors with `>`, `<`, `<=`, `=>`, `==`, `!=`, and `is.na()`, how to combine them with `!`, `&`, and `|`, and how to summarize them with `any()`, `all()`, `sum()`, and `mean()`.
You also learned the powerful `if_else()` and `case_when()` functions that allow you to return values depending on the value of a logical vector.

We'll see logical vectors again and again in the following chapters.
For example in @sec-strings you'll learn about `str_detect(x, pattern)` which returns a logical vector that's `TRUE` for the elements of `x` that match the `pattern`, and in @sec-dates-and-times you'll create logical vectors from the comparison of dates and times.
But for now, we're going to move onto the next most important type of vector: numeric vectors.

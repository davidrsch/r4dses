[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R para la Ciencia de Datos (2e)",
    "section": "",
    "text": "Bienvenida\nEste es el sitio web de la segunda edici√≥n de ‚ÄúR para la Ciencia de Datos‚Äù. Este libro le ense√±ar√° c√≥mo hacer ciencia de datos con R: aprender√° c√≥mo obtener sus datos en R, convertirlos en la estructura m√°s √∫til, transformarlos y visualizarlos.\nEn este libro, encontrar√° ejercicios pr√°cticos para aprender las habilidades necesarias para la ciencia de datos. As√≠ como un qu√≠mico aprende a limpiar tubos de ensayo y a abastecer un laboratorio, usted aprender√° a limpiar datos, dibujar diagramas y mucho m√°s. Estas son las habilidades que hacen que exista la ciencia de datos y aqu√≠ encontrar√° las mejores pr√°cticas para realizar estas tareas con R. Aprender√° a usar la gram√°tica de los gr√°ficos, la programaci√≥n literaria y la investigaci√≥n reproducible para ahorrar tiempo. Tambi√©n aprender√° a administrar los recursos cognitivos para facilitar los descubrimientos al discutir, visualizar y explorar datos.\nEste sitio web es y ser√° siempre gratuito, bajo la licencia de CC BY-NC-ND 3.0 License. Si desea una copia f√≠sica del libro, puede pedir una en Amazon. Si aprecia leer el libro gratis y desea retribuir, haga una donaci√≥n a KƒÅkƒÅp≈ç Recovery: el kƒÅkƒÅp≈ç (que aparece en la portada de R4DS) es un loro nativo de Nueva Zelanda en peligro de extinci√≥n; solo quedan 248.\nSi aprecias leer el libro gratis y quieres contribuir, haz una donaci√≥n a KƒÅkƒÅp≈ç Recovery: el kƒÅkƒÅp≈ç (que aparece en la portada de R4DS) es un loro en peligro cr√≠tico de extinci√≥n nativo de Nueva Zelanda; solo quedan 244.\nSi habla otro idioma es posible que le interesen las traducciones disponibles gratuitamente de la primera edici√≥n:\nPuede encontrar respuestas sugeridas a los ejercicios en el libro en https://mine-cetinkaya-rundel.github.io/r4ds-solutions.\nTenga en cuenta que R4DS utiliza un C√≥digo de conducta del colaborador. Al contribuir a este libro, usted acepta cumplir con sus t√©rminos.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#sobre-la-traducci√≥n",
    "href": "index.html#sobre-la-traducci√≥n",
    "title": "R para la Ciencia de Datos (2e)",
    "section": "Sobre la traducci√≥n",
    "text": "Sobre la traducci√≥n\n Esta traducci√≥n de ‚ÄúR para la Ciencia de Datos‚Äù es un proyecto personal de David D√≠az Rodr√≠guez con el objetivo de facilitar el estudio de la Ciencia de Datos con R, tanto al propio traductor como a todas aquellas personas de habla hispana que deseen aprender a realizar Ciencia de Datos con R.\nSe√±alar que esta es una traducci√≥n textual del libro por lo que cuando los autores se refieren a s√≠ mismo en primera persona, ser√° Hadley Wickham, Mine √áetinkaya-Rundel & Garrett Grolemund y no el traductor.\nLa traducci√≥n fue realizada usando Google Translate y se corrigieron algunos errores gramaticales y de coherencia. Si detecta alg√∫n error relacionado con contenido de la traducci√≥n, si√©ntase libre de abrir un issue o un pull request en este repositorio.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "preface-2e.html",
    "href": "preface-2e.html",
    "title": "Prefacio a la segunda edici√≥n",
    "section": "",
    "text": "¬°Bienvenidos a la segunda edici√≥n de ‚ÄúR para la Ciencia de Datos‚Äù! Esta es una reelaboraci√≥n importante de la primera edici√≥n, eliminando material que ya no creemos que sea √∫til, agregando material que desear√≠amos haber incluido en la primera edici√≥n y, en general, actualizando el texto y el c√≥digo para reflejar los cambios en las mejores pr√°cticas. Tambi√©n estamos muy emocionados de dar la bienvenida a un nuevo coautor: Mine √áetinkaya-Rundel, una destacada educadora en ciencia de datos y una de nuestras colegas en Posit (la compa√±√≠a anteriormente conocida como RStudio).\nA continuaci√≥n se incluye un breve resumen de los cambios m√°s importantes:\n\nLa primera parte del libro ha sido renombrada como ‚ÄúEl juego completo‚Äù. El objetivo de esta secci√≥n es brindarle los detalles aproximados del ‚Äújuego completo‚Äù de la ciencia de datos antes de sumergirnos en los detalles.\nLa segunda parte del libro es ‚ÄúVisualizar‚Äù. Esta parte brinda a las herramientas de visualizaci√≥n de datos y a las mejores pr√°cticas una cobertura m√°s completa en comparaci√≥n con la primera edici√≥n.\nLa tercera parte del libro ahora se llama ‚ÄúTransformar‚Äù y gana nuevos cap√≠tulos sobre n√∫meros, vectores l√≥gicos y valores faltantes. Anteriormente, estas eran partes del cap√≠tulo de transformaci√≥n de datos, pero necesitaban mucho m√°s espacio.\nLa cuarta parte del libro se llama ‚ÄúImportar‚Äù. Es un nuevo conjunto de cap√≠tulos que va m√°s all√° de la lectura de archivos de texto sin formato para abarcar ahora el trabajo con hojas de c√°lculo, la extracci√≥n de datos de bases de datos, el trabajo con macrodatos, el rect√°ngulo de datos jer√°rquicos y la extracci√≥n de datos de sitios web.\nLa parte ‚ÄúProgramar‚Äù contin√∫a, pero se ha reescrito de arriba a abajo para centrarse en las partes m√°s importantes de la escritura e iteraci√≥n de funciones. La escritura de funciones ahora incluye secciones sobre c√≥mo envolver funciones tidyverse (que se ocupan de los desaf√≠os de la evaluaci√≥n ordenada), ya que esto se ha vuelto mucho m√°s f√°cil en los √∫ltimos a√±os. Hemos agregado un nuevo cap√≠tulo sobre funciones importantes de R Base que es probable que vea al leer el c√≥digo R que se encuentra en la naturaleza.\nLa parte de modelado ha sido eliminada. Nunca tuvimos suficiente espacio para hacer justicia a las distintas t√©cnicas de modelaci√≥n por completo, y ahora hay muchos y mejores recursos disponibles. Por lo general, recomendamos utilizar el paquete tidymodels y leer Tidy Modeling with R de Max Kuhn y Julia Silge.\nLa parte de ‚ÄúComunicaci√≥n‚Äù tambi√©n contin√∫a, pero presenta Quarto en lugar de R Markdown. Esta edici√≥n del libro ha sido escrita en Quarto y es claramente la herramienta del futuro.\n\nOtros cambios incluyen cambiar de la canalizaci√≥n o pipe de Magrittr (%&gt;%) a la canalizaci√≥n base (|&gt;) y cambiar el c√≥digo fuente del libro de RMarkdown a Quarto.",
    "crumbs": [
      "Prefacio a la segunda edici√≥n"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introducci√≥n",
    "section": "",
    "text": "Lo que vas a aprender\nLa ciencia de datos es una disciplina apasionante que le permite transformar datos sin procesar en comprensi√≥n, perspectiva y conocimiento. El objetivo de ‚ÄúR para ciencia de datos‚Äù es ayudarlo a aprender las herramientas m√°s importantes en R que le permitir√°n hacer ciencia de datos de manera eficiente y reproducible, y divertirse en el camino üòÉ. Despu√©s de leer este libro, tendr√° las herramientas para abordar una amplia variedad de desaf√≠os de ciencia de datos utilizando las mejores partes de R.\nLa ciencia de datos es un campo amplio, y no hay forma de que puedas dominarlo todo leyendo un solo libro. Este libro tiene como objetivo brindarle una base s√≥lida en las herramientas m√°s importantes y el conocimiento suficiente para encontrar los recursos para aprender m√°s cuando sea necesario. Nuestro modelo de los pasos de un proyecto t√≠pico de ciencia de datos se parece a Figura 1.\nFigura¬†1: En nuestro modelo del proceso de ciencia de datos, comienza con la importaci√≥n de datos y ordenando. Luego, comprende sus datos con un ciclo iterativo de transformar, visualizar y modelar. Terminas el proceso comunicando sus resultados a otros humanos.\nPrimero, debe importar sus datos a R. Esto generalmente significa que toma datos almacenados en un archivo, base de datos o interfaz de programaci√≥n de aplicaciones web (API) y los carga en un marco de datos en R. Si no puede llevar sus datos a R, ¬°no puede hacer ciencia de datos en ellos!\nUna vez que haya importado sus datos, es una buena idea ordenarlos. Ordenar sus datos significa almacenarlos en una forma consistente que coincida con la sem√°ntica del conjunto de datos con la forma en que se almacenan. En resumen, cuando sus datos est√°n ordenados, cada columna es una variable y cada fila es una observaci√≥n. Los datos ordenados son importantes porque una estructura coherente le permite centrar sus esfuerzos en responder preguntas sobre los datos, sin luchar para obtener los datos en la forma correcta para diferentes funciones.\nUna vez que tenga datos ordenados, el pr√≥ximo paso com√∫n es transformarlos. La transformaci√≥n incluye la reducci√≥n de las observaciones de inter√©s (como todas las personas en una ciudad o todos los datos del √∫ltimo a√±o), la creaci√≥n de nuevas variables que son funciones de las variables existentes (como la velocidad de c√°lculo a partir de la distancia y el tiempo) y el c√°lculo de un conjunto de estad√≠sticas de resumen. (como la mediana o la media). Juntos, ordenar y transformar se denominan disputar (o manipular) porque obtener sus datos en una forma en la que es natural trabajar con ellos a menudo se siente como una pelea.\nUna vez que tenga datos ordenados con las variables que necesita, hay dos motores principales de generaci√≥n de conocimiento: visualizaci√≥n y modelado. Estos tienen fortalezas y debilidades complementarias, por lo que cualquier an√°lisis de datos real iterar√° entre ellos muchas veces.\nLa visualizaci√≥n es una actividad fundamentalmente humana. Una buena visualizaci√≥n le mostrar√° cosas que no esperaba o le generar√° nuevas preguntas sobre los datos. Una buena visualizaci√≥n tambi√©n podr√≠a indicar que est√° haciendo la pregunta incorrecta o que necesita recopilar datos diferentes. Las visualizaciones pueden sorprenderlo, pero no se escalan particularmente bien porque requieren que un ser humano las interprete.\nLos modelos son herramientas complementarias a la visualizaci√≥n. Una vez que haya hecho sus preguntas lo suficientemente precisas, puede usar un modelo para responderlas. Los modelos son una herramienta fundamentalmente matem√°tica o computacional, por lo que generalmente se escalan bien. ¬°Incluso cuando no lo hacen, por lo general es m√°s barato comprar m√°s computadoras que comprar m√°s cerebros! Pero todo modelo hace suposiciones y, por su propia naturaleza, un modelo no puede cuestionar sus propias suposiciones. Eso significa que un modelo no puede sorprenderte fundamentalmente.\nEl √∫ltimo paso de la ciencia de datos es la comunicaci√≥n, una parte absolutamente cr√≠tica de cualquier proyecto de an√°lisis de datos. No importa qu√© tan bien sus modelos y visualizaci√≥n lo hayan llevado a comprender los datos, a menos que tambi√©n pueda comunicar sus resultados a otros.\nAlrededor de todas estas herramientas est√° la programaci√≥n. La programaci√≥n es una herramienta transversal que utiliza en casi todas las partes de un proyecto de ciencia de datos. No necesita ser un programador experto para ser un cient√≠fico de datos exitoso, pero aprender m√°s sobre programaci√≥n vale la pena porque convertirse en un mejor programador le permite automatizar tareas comunes y resolver nuevos problemas con mayor facilidad.\nUsar√° estas herramientas en todos los proyectos de ciencia de datos, pero no son suficientes para la mayor√≠a de los proyectos. Hay una regla aproximada de 80-20 en juego; puede abordar aproximadamente el 80 % de cada proyecto con las herramientas que aprender√° en este libro, pero necesitar√° otras herramientas para abordar el 20 % restante. A lo largo de este libro, le indicaremos los recursos donde puede obtener m√°s informaci√≥n.",
    "crumbs": [
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "intro.html#c√≥mo-est√°-organizado-este-libro",
    "href": "intro.html#c√≥mo-est√°-organizado-este-libro",
    "title": "Introducci√≥n",
    "section": "C√≥mo est√° organizado este libro",
    "text": "C√≥mo est√° organizado este libro\nLa descripci√≥n anterior de las herramientas de la ciencia de datos est√° organizada aproximadamente seg√∫n el orden en que las usa en un an√°lisis (aunque, por supuesto, las repetir√° varias veces). En nuestra experiencia, sin embargo, aprender a importar y ordenar datos primero no es √≥ptimo porque el 80 % del tiempo es rutinario y aburrido, y el otro 20 % del tiempo es raro y frustrante. ¬°Ese es un mal lugar para comenzar a aprender un nuevo tema! En su lugar, comenzaremos con la visualizaci√≥n y transformaci√≥n de datos que ya se han importado y ordenado. De esa manera, cuando ingiere y ordena sus propios datos, su motivaci√≥n se mantendr√° alta porque sabe que el esfuerzo vale la pena.\nDentro de cada cap√≠tulo, tratamos de adherirnos a un patr√≥n concistente: comience con algunos ejemplos motivadores para que pueda ver el panorama general y luego profundice en los detalles. Cada secci√≥n del libro est√° emparejada con ejercicios para ayudarte a practicar lo que has aprendido. Aunque puede ser tentador saltarse los ejercicios, no hay mejor manera de aprender que practicar con problemas reales.",
    "crumbs": [
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "intro.html#lo-que-no-aprender√°s",
    "href": "intro.html#lo-que-no-aprender√°s",
    "title": "Introducci√≥n",
    "section": "Lo que no aprender√°s",
    "text": "Lo que no aprender√°s\nHay varios temas importantes que este libro no cubre. Creemos que es importante concentrarse despiadadamente en lo esencial para que pueda ponerse en marcha lo m√°s r√°pido posible. Eso significa que este libro no puede cubrir todos los temas importantes.\nModelado\nEl modelado es muy importante para la ciencia de datos, pero es un gran tema y, lamentablemente, no tenemos el espacio para darle la cobertura que se merece aqu√≠. Para obtener m√°s informaci√≥n sobre modelado, recomendamos Tidy Modeling with R de nuestros colegas Max Kuhn y Julia Silge. Este libro le ense√±ar√° la familia de paquetes tidymodels que, como puede adivinar por el nombre, comparten muchas convenciones con los paquetes tidyverse que usamos en este libro.\nBig data\nEste libro se enfoca orgullosamente y principalmente en peque√±os conjuntos de datos en memoria. Este es el lugar correcto para comenzar porque no puede abordar big data a menos que tenga experiencia con small data. Las herramientas que aprender√° a lo largo de la mayor parte de este libro manejar√°n f√°cilmente cientos de megabytes de datos y, con un poco de cuidado, normalmente puede usarlas para trabajar con unos pocos gigabytes de datos. Tambi√©n le mostraremos c√≥mo obtener datos de bases de datos y archivos de parquet, los cuales se usan a menudo para almacenar big data. No necesariamente podr√° trabajar con todo el conjunto de datos, pero eso no es un problema porque solo necesita un subconjunto o submuestra para responder la pregunta que le interesa.\nSi trabaja habitualmente con datos m√°s grandes (10-100 Gb, digamos), le recomendamos obtener m√°s informaci√≥n sobre [data.table] (https://github.com/Rdatatable/data.table). No lo ense√±amos aqu√≠ porque usa una interfaz diferente a tidyverse y requiere que aprendas algunas convenciones diferentes. Sin embargo, es incre√≠blemente m√°s r√°pido y vale la pena invertir algo de tiempo en aprenderlo si est√° trabajando con grandes datos.\nPython, Julia, y amigos\nEn este libro, no aprender√° nada sobre Python, Julia o cualquier otro lenguaje de programaci√≥n √∫til para la ciencia de datos. Esto no se debe a que pensemos que estas herramientas son malas. ¬°No lo son! Y en la pr√°ctica, la mayor√≠a de los equipos de ciencia de datos usan una combinaci√≥n de lenguajes, a menudo al menos R y Python.\nPero creemos firmemente que es mejor dominar una herramienta a la vez, y R es un excelente lugar para comenzar.",
    "crumbs": [
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "intro.html#requisitos-previos",
    "href": "intro.html#requisitos-previos",
    "title": "Introducci√≥n",
    "section": "Requisitos previos",
    "text": "Requisitos previos\nHemos hecho algunas suposiciones sobre lo que ya sabe para aprovechar al m√°ximo este libro. En general, debe tener conocimientos num√©ricos, y es √∫til si ya tiene algo de experiencia en programaci√≥n b√°sica. Si nunca ha programado antes, es posible que encuentre que Hands on Programming with R por Garrett puede ser un valioso complemento de este libro.\nNecesita cuatro cosas para ejecutar el c√≥digo de este libro: R, RStudio, una colecci√≥n de paquetes de R llamada tidyverse y un pu√±ado de otros paquetes. Los paquetes son las unidades fundamentales del c√≥digo de R reproducible. Incluyen funciones reutilizables, documentaci√≥n que describe c√≥mo usarlas y datos de muestra.\nR\nPara descargar R, vaya a CRAN la red comprensiva de archivos de R (por sus siglas en ingl√©s: comprehensive R archive network), https://cloud.r-project.org. Una nueva versi√≥n principal de R sale una vez al a√±o y hay 2 o 3 lanzamientos menores cada a√±o. Es una buena idea actualizar regularmente. La actualizaci√≥n puede ser un poco complicada, especialmente para las versiones principales que requieren que vuelva a instalar todos sus paquetes, pero posponerlo solo empeora las cosas. Recomendamos R 4.2.0 o posterior para este libro.\nRStudio\nRStudio es un entorno de desarrollo integrado, o IDE, para programaci√≥n R, que puede descargar desde https://posit.co/download/rstudio-desktop/. RStudio se actualiza un par de veces al a√±o y le avisar√° autom√°ticamente cuando haya una nueva versi√≥n disponible para que no tenga que volver a comprobarlo. Es una buena idea actualizar regularmente para aprovechar las √∫ltimas y mejores funciones. Para este libro, aseg√∫rese de tener al menos RStudio 2022.02.0.\nCuando inicie RStudio, Figura 2, ver√° dos regiones clave en la interfaz: el panel de la consola y el panel de salida. Por ahora, todo lo que necesita saber es que escribe el c√≥digo R en el panel de la consola y presiona enter para ejecutarlo. ¬°Aprender√°s m√°s a medida que avancemos!1\n\n\n\n\n\n\n\nFigura¬†2: El IDE de RStudio tiene dos regiones clave: escriba el c√≥digo R en el panel de la consola a la izquierda y busque gr√°ficos en el panel de salida a la derecha.\n\n\n\n\ntidyverse\nTambi√©n deber√° instalar algunos paquetes de R. Un paquete de R es una colecci√≥n de funciones, datos y documentaci√≥n que ampl√≠a las capacidades de R b√°sico. El uso de paquetes es clave para el uso exitoso de R. La mayor√≠a de los paquetes que aprender√°s en este libro forman parte del llamado tidyverse. Todos los paquetes en tidyverse comparten una filosof√≠a com√∫n de datos y programaci√≥n R y est√°n dise√±ados para trabajar juntos.\nPuedes instalar el tidyverse completo con una sola l√≠nea de c√≥digo:\n\ninstall.packages(\"tidyverse\")\n\nEn su computadora, escriba esa l√≠nea de c√≥digo en la consola y luego presione Intro para ejecutarlo. R descargar√° los paquetes de CRAN y los instalar√° en su computadora.\nNo podr√° usar las funciones, objetos o archivos de ayuda en un paquete hasta que lo cargue con library(). Una vez que haya instalado un paquete, puede cargarlo usando la funci√≥n library():\n\nlibrary(tidyverse)\n#&gt; ‚îÄ‚îÄ Attaching core tidyverse packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 2.0.0 ‚îÄ‚îÄ\n#&gt; ‚úî dplyr     1.1.4     ‚úî readr     2.1.5\n#&gt; ‚úî forcats   1.0.0     ‚úî stringr   1.5.1\n#&gt; ‚úî ggplot2   3.5.1     ‚úî tibble    3.2.1\n#&gt; ‚úî lubridate 1.9.3     ‚úî tidyr     1.3.1\n#&gt; ‚úî purrr     1.0.2     \n#&gt; ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ\n#&gt; ‚úñ dplyr::filter() masks stats::filter()\n#&gt; ‚úñ dplyr::lag()    masks stats::lag()\n#&gt; ‚Ñπ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nEsto le dice que tidyverse carga nueve paquetes: dplyr, forcats, ggplot2, lubridate, purrr, readr, stringr, tibble, tidyr. Estos se consideran el n√∫cleo del tidyverse porque los usar√° en casi todos los an√°lisis.\nLos paquetes en tidyverse cambian con bastante frecuencia. Puedes ver si hay actualizaciones disponibles ejecutando tidyverse_update().\nOtros paquetes\nHay muchos otros paquetes excelentes que no forman parte de tidyverse porque resuelven problemas en un dominio diferente o est√°n dise√±ados con un conjunto diferente de principios subyacentes. Esto no los hace mejores o peores, simplemente diferentes. En otras palabras, el complemento del tidyverse no es el desordenado sino muchos otros universos de paquetes interrelacionados. A medida que aborde m√°s proyectos de ciencia de datos con R, aprender√° nuevos paquetes y nuevas formas de pensar sobre los datos.\nUsaremos muchos paquetes de fuera del tidyverse en este libro. Por ejemplo, usaremos los siguientes paquetes porque proporcionan conjuntos de datos interesantes para que trabajemos en el proceso de aprendizaje de R:\n\ninstall.packages(\n  c(\"arrow\", \"babynames\", \"curl\", \"duckdb\", \"gapminder\",\n    \"ggrepel\", \"ggridges\", \"ggthemes\", \"hexbin\", \"janitor\", \"Lahman\",\n    \"leaflet\", \"maps\", \"nycflights13\", \"openxlsx\", \"palmerpenguins\",\n    \"repurrrsive\", \"tidymodels\", \"writexl\")\n  )\n\nTambi√©n usaremos una selecci√≥n de otros paquetes para ejemplos √∫nicos. No necesita instalarlos ahora, solo recuerde que cada vez que vea un error como este:\n\nlibrary(ggrepel)\n#&gt; Error in library(ggrepel) : there is no package called ‚Äòggrepel‚Äô\n\nDebe ejecutar install.packages(\"ggrepel\") para instalar el paquete.",
    "crumbs": [
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "intro.html#ejecutando-c√≥digo-de-r",
    "href": "intro.html#ejecutando-c√≥digo-de-r",
    "title": "Introducci√≥n",
    "section": "Ejecutando c√≥digo de R",
    "text": "Ejecutando c√≥digo de R\nLa secci√≥n anterior le mostr√≥ varios ejemplos de ejecuci√≥n de c√≥digo R. El c√≥digo en el libro se ve as√≠:\n\n1 + 2\n#&gt; [1] 3\n\nSi ejecuta el mismo c√≥digo en su consola local, se ver√° as√≠:\n&gt; 1 + 2\n[1] 3\nHay dos diferencias principales. En su consola, escribe despu√©s de &gt;, llamado prompt; no mostramos el aviso en el libro. En el libro, la salida se comenta con #&gt;; en su consola, aparece directamente despu√©s de su c√≥digo. Estas dos diferencias significan que si est√° trabajando con una versi√≥n electr√≥nica del libro, puede copiar f√°cilmente el c√≥digo del libro y colocarlo en la consola.\nA lo largo del libro, usamos un conjunto consistente de convenciones para referirnos al c√≥digo:\n\nLas funciones se muestran en una fuente de c√≥digo y van seguidas de par√©ntesis, como sum() o mean().\nOtros objetos R (como datos o argumentos de funciones) est√°n en una fuente de c√≥digo, sin par√©ntesis, como flights o x.\nA veces, para dejar claro de qu√© paquete proviene un objeto, usaremos el nombre del paquete seguido de dos puntos, como dplyr::mutate() o nycflights13::flights. Este tambi√©n es un c√≥digo R v√°lido.",
    "crumbs": [
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "intro.html#reconocimientos",
    "href": "intro.html#reconocimientos",
    "title": "Introducci√≥n",
    "section": "Reconocimientos",
    "text": "Reconocimientos\nEste libro no es solo el producto de Hadley, Mine y Garrett, sino que es el resultado de muchas conversaciones (en persona y en l√≠nea) que hemos tenido con muchas personas en la comunidad de R. Estamos incre√≠blemente agradecidos por todas las conversaciones que hemos tenido con todos ustedes; ¬°muchas gracias!\nEste libro fue escrito abiertamente, y muchas personas contribuyeron a trav√©s de solicitudes de extracci√≥n. Un agradecimiento especial a todos 259 de ustedes que contribuyeron con mejoras a trav√©s de solicitudes de extracci√≥n de GitHub (en orden alfab√©tico por nombre de usuario):",
    "crumbs": [
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "intro.html#colof√≥n",
    "href": "intro.html#colof√≥n",
    "title": "Introducci√≥n",
    "section": "Colof√≥n",
    "text": "Colof√≥n\nUna versi√≥n en l√≠nea de este libro est√° disponible en https://r4ds.hadley.nz. Continuar√° evolucionando entre las reimpresiones del libro f√≠sico. El c√≥digo fuente del libro est√° disponible en https://github.com/hadley/r4ds. El libro funciona con Quarto, lo que facilita la escritura de libros que combinan texto y c√≥digo ejecutable.",
    "crumbs": [
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "Introducci√≥n",
    "section": "",
    "text": "Si desea obtener una descripci√≥n general completa de todas las funciones de RStudio, consulte la Gu√≠a del usuario de RStudio en https://docs.posit.co/ide/user.‚Ü©Ô∏é",
    "crumbs": [
      "Introducci√≥n"
    ]
  },
  {
    "objectID": "whole-game.html",
    "href": "whole-game.html",
    "title": "El Juego Completo",
    "section": "",
    "text": "Nuestro objetivo en esta parte del libro es brindarle una descripci√≥n general r√°pida de las principales herramientas de la ciencia de datos: importar, ordenar, transformar y visualizar datos, as√≠ como se muestra en Figura 1. Queremos mostrarle el ‚Äújuego completo‚Äù de la ciencia de datos brind√°ndole lo suficiente de todas las piezas principales para que pueda abordar conjuntos de datos reales, aunque simples. Las √∫ltimas partes del libro abordar√°n cada uno de estos temas con mayor profundidad, aumentando la gama de desaf√≠os de la ciencia de datos que puede abordar.\n\n\n\n\n\n\n\nFigura¬†1: En esta secci√≥n del libro, aprender√° a importar, ordenar, transformar y visualizar datos.\n\n\n\n\nCuatro cap√≠tulos se centran en las herramientas de la ciencia de datos:\n\nLa visualizaci√≥n es un excelente lugar para comenzar con la programaci√≥n en R, porque la recompensa es muy clara: puedes hacer diagramas elegantes e informativos que te ayuden a comprender los datos. En 1¬† Visualizaci√≥n de datos, se sumergir√° en la visualizaci√≥n, aprender√° la estructura b√°sica de un gr√°fico ggplot2 y t√©cnicas poderosas para convertir datos en gr√°ficos.\nPor lo general, la visualizaci√≥n por s√≠ sola no es suficiente, por lo que en 3¬† Transformaci√≥n de datos, aprender√° los verbos clave que le permiten seleccionar variables importantes, filtrar observaciones clave, crear nuevas variables y calcular res√∫menes.\nEn 5¬† Ordenando datos, aprender√° sobre los datos ordenados, una forma consistente de almacenar sus datos que facilita la transformaci√≥n, la visualizaci√≥n y el modelado. Aprender√° los principios subyacentes y c√≥mo poner sus datos en una forma ordenada.\nAntes de que pueda transformar y visualizar sus datos, primero debe obtener sus datos en R. En 7¬† Importaci√≥n de datos aprender√° los conceptos b√°sicos para obtener archivos .csv en R.\n\nEntre estos cap√≠tulos se encuentran otros cuatro cap√≠tulos que se centran en su flujo de trabajo de R. En 2¬† Flujo de trabajo: conceptos b√°sicos, 4¬† Flujo de trabajo: estilo de c√≥digo y 6¬† Flujo de trabajo: scripts y proyectos aprender√° buenas pr√°cticas de flujo de trabajo para escribir y organizar su c√≥digo R. Estos te preparar√°n para el √©xito a largo plazo, ya que te dar√°n las herramientas para mantenerte organizado cuando abordes proyectos reales. Finalmente, 8¬† Flujo de trabajo: obtener ayuda le ense√±ar√° c√≥mo obtener ayuda y seguir aprendiendo.",
    "crumbs": [
      "El Juego Completo"
    ]
  },
  {
    "objectID": "data-visualize.html",
    "href": "data-visualize.html",
    "title": "1¬† Visualizaci√≥n de datos",
    "section": "",
    "text": "1.1 Introducci√≥n\nR tiene varios sistemas para hacer gr√°ficos, pero ggplot2 es uno de los m√°s elegantes y vers√°tiles. ggplot2 implementa la gram√°tica de gr√°ficos, un sistema coherente para describir y construir gr√°ficos. Con ggplot2, puede hacer m√°s y m√°s r√°pido aprendiendo un sistema y aplic√°ndolo en muchos lugares.\nEste cap√≠tulo le ense√±ar√° c√≥mo visualizar sus datos usando ggplot2. Comenzaremos creando un diagrama de dispersi√≥n simple y lo usaremos para presentar asignaciones aesthetics y objetos geom√©tricos, los componentes b√°sicos de ggplot2. Luego lo guiaremos a trav√©s de la visualizaci√≥n de distribuciones de variables individuales, as√≠ como la visualizaci√≥n de relaciones entre dos o m√°s variables. Terminaremos guardando sus gr√°ficas y consejos para la soluci√≥n de problemas.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Visualizaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#introducci√≥n",
    "href": "data-visualize.html#introducci√≥n",
    "title": "1¬† Visualizaci√≥n de datos",
    "section": "",
    "text": "‚ÄúEl gr√°fico simple ha tra√≠do m√°s informaci√≥n a la mente del analista de datos que cualquier otro dispositivo.‚Äù ‚Äî John Tukey\n\n\n\n\n1.1.1 Requisitos previos\nEste cap√≠tulo se centra en ggplot2, uno de los paquetes principales de tidyverse. Para acceder a los conjuntos de datos, las p√°ginas de ayuda y las funciones utilizadas en este cap√≠tulo, cargue tidyverse ejecutando:\n\nlibrary(tidyverse)\n#&gt; ‚îÄ‚îÄ Attaching core tidyverse packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 2.0.0 ‚îÄ‚îÄ\n#&gt; ‚úî dplyr     1.1.4     ‚úî readr     2.1.5\n#&gt; ‚úî forcats   1.0.0     ‚úî stringr   1.5.1\n#&gt; ‚úî ggplot2   3.5.1     ‚úî tibble    3.2.1\n#&gt; ‚úî lubridate 1.9.3     ‚úî tidyr     1.3.1\n#&gt; ‚úî purrr     1.0.2     \n#&gt; ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ\n#&gt; ‚úñ dplyr::filter() masks stats::filter()\n#&gt; ‚úñ dplyr::lag()    masks stats::lag()\n#&gt; ‚Ñπ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nEsa l√≠nea de c√≥digo carga el n√∫cleo tidyverse; los paquetes que utilizar√° en casi todos los an√°lisis de datos. Tambi√©n le dice qu√© funciones del tidyverse entran en conflicto con funciones en la base de R (o de otros paquetes que haya cargado) 1.\nSi ejecuta este c√≥digo y obtiene el mensaje de error there is no package called 'tidyverse', primero deber√° instalarlo, luego ejecutar library() una vez m√°s.\n\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n\nSolo necesita instalar un paquete una vez, pero debe cargarlo cada vez que inicie una nueva sesi√≥n.\nAdem√°s de tidyverse, tambi√©n usaremos el paquete palmerpenguins, que incluye el conjunto de datos penguins que contiene las medidas corporales de los ping√ºinos en tres islas del archipi√©lago Palmer, y el paquete ggthemes, que ofrece una paleta de colores segura para dalt√≥nicos.\n\nlibrary(palmerpenguins)\nlibrary(ggthemes)",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Visualizaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#primeros-pasos",
    "href": "data-visualize.html#primeros-pasos",
    "title": "1¬† Visualizaci√≥n de datos",
    "section": "\n1.2 Primeros pasos",
    "text": "1.2 Primeros pasos\n¬øLos ping√ºinos con aletas m√°s largas pesan m√°s o menos que los ping√ºinos con aletas m√°s cortas? Probablemente ya tenga una respuesta, pero intente que su respuesta sea precisa. ¬øC√≥mo es la relaci√≥n entre la longitud de las aletas y la masa corporal? ¬øEs positivo? ¬øNegativo? ¬øLineal? ¬øNo lineal? ¬øVar√≠a la relaci√≥n seg√∫n la especie del ping√ºino? ¬øQu√© tal por la isla donde vive el pinguino? Vamos a crear visualizaciones que podamos usar para responder estas preguntas.\n\n1.2.1 El data frame penguins\n\nPuedes probar tu respuesta con el data frame penguins que se encuentra en palmerpenguins (a.k.a. palmerpenguins::penguins). Un data frame es una colecci√≥n rectangular de variables (en las columnas) y observaciones (en las filas). penguins contiene observaciones 344 recopiladas y puestas a disposici√≥n por la Dra. Kristen Gorman y la Estaci√≥n Palmer, Ant√°rtida LTER2.\nPara facilitar la discusi√≥n, definamos algunos t√©rminos:\n\nUna variable es una cantidad, calidad o propiedad que puedes medir.\nUn valor es el estado de una variable cuando la mides. El valor de una variable puede cambiar de una medida a otra.\nUna observaci√≥n es un conjunto de mediciones realizadas en condiciones similares (usualmente realiza todas las mediciones en una observaci√≥n al mismo tiempo y en el mismo objeto). Una observaci√≥n contendr√° varios valores, cada uno asociado con una variable diferente. A veces nos referiremos a una observaci√≥n como un punto de datos.\nDatos tabulares es un conjunto de valores, cada uno asociado con una variable y una observaci√≥n. Los datos tabulares est√°n ordenados si cada valor se coloca en su propia ‚Äúcelda‚Äù, cada variable en su propia columna y cada observaci√≥n en su propia fila.\n\nEn este contexto, una variable se refiere a un atributo de todos los ping√ºinos y una observaci√≥n se refiere a todos los atributos de un solo ping√ºino.\nEscriba el nombre del data frame en la consola y R imprimir√° una vista previa de su contenido. Tenga en cuenta que dice ‚Äútibble‚Äù en la parte superior de esta vista previa. En tidyverse, usamos data frames especiales llamados tibbles sobre los que aprender√° m√°s pronto.\n\npenguins\n#&gt; # A tibble: 344 √ó 8\n#&gt;   species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;\n#&gt; 1 Adelie  Torgersen           39.1          18.7               181\n#&gt; 2 Adelie  Torgersen           39.5          17.4               186\n#&gt; 3 Adelie  Torgersen           40.3          18                 195\n#&gt; 4 Adelie  Torgersen           NA            NA                  NA\n#&gt; 5 Adelie  Torgersen           36.7          19.3               193\n#&gt; 6 Adelie  Torgersen           39.3          20.6               190\n#&gt; # ‚Ñπ 338 more rows\n#&gt; # ‚Ñπ 3 more variables: body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt;\n\nEste data frame contiene columnas 8. Para una vista alternativa, donde puede ver todas las variables y las primeras observaciones de cada variable, use glimpse(). O, si est√° en RStudio, ejecute View(penguins) para abrir un visor de datos interactivo.\n\nglimpse(penguins)\n#&gt; Rows: 344\n#&gt; Columns: 8\n#&gt; $ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, A‚Ä¶\n#&gt; $ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torge‚Ä¶\n#&gt; $ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.‚Ä¶\n#&gt; $ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.‚Ä¶\n#&gt; $ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, ‚Ä¶\n#&gt; $ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 347‚Ä¶\n#&gt; $ sex               &lt;fct&gt; male, female, female, NA, female, male, female, m‚Ä¶\n#&gt; $ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2‚Ä¶\n\nEntre las variables en penguins est√°n:\n\nspecies: una especie de ping√ºino (Adelie, Chinstrap o Gentoo).\nflipper_length_mm: longitud de la aleta de un ping√ºino, en mil√≠metros.\nbody_mass_g: masa corporal de un ping√ºino, en gramos.\n\nPara aprender m√°s sobre penguins, abra su p√°gina de ayuda ejecutando ?penguins.\n\n1.2.2 Objetivo final\nNuestro objetivo final en este cap√≠tulo es recrear la siguiente visualizaci√≥n que muestra la relaci√≥n entre la longitud de las aletas y la masa corporal de estos ping√ºinos, teniendo en cuenta la especie del ping√ºino.\n\n\n\n\n\n\n\n\n\n1.2.3 Creando un ggplot\nRecreemos esta gr√°fica paso a paso.\nCon ggplot2, comienza una gr√°fica con la funci√≥n ggplot(), definiendo un objeto de gr√°fica al que luego agrega capas. El primer argumento de ggplot() es el conjunto de datos que se usar√° en el gr√°fico, por lo que ggplot(data = penguins) crea un gr√°fico vac√≠o que est√° preparado para mostrar los datos de penguins, pero como no lo hemos dicho c√≥mo visualizarlo todav√≠a, por ahora est√° vac√≠o.\n\nggplot(data = penguins)\n\n\n\n\n\n\n\nA continuaci√≥n, debemos decirle a ggplot() c√≥mo se representar√° visualmente la informaci√≥n de nuestros datos. El argumento mapping de la funci√≥n ggplot() define c√≥mo las variables en su conjunto de datos se asignan a las propiedades visuales (aesthetics) de su gr√°fico. El argumento mapping siempre se define en la funci√≥n aes(), y los argumentos x e y de aes() especifican qu√© variables asignar a los ejes x e y. Por ahora, solo asignaremos la longitud de las aletas a la aesthetic x y la masa corporal a la aesthetic y. ggplot2 busca las variables mapeadas en el argumento data, en este caso, penguins.\nLas siguientes gr√°ficas muestran el resultado de agregar estas asignaciones.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n)\n\n\n\n\n\n\n\nNuestro lienzo vac√≠o ahora tiene m√°s estructura: est√° claro d√≥nde se mostrar√°n las longitudes de las aletas (en el eje x) y d√≥nde se mostrar√°n las masas corporales (en el eje y). Pero los propios ping√ºinos a√∫n no est√°n en la gr√°fica. Esto se debe a que a√∫n no hemos articulado, en nuestro c√≥digo, c√≥mo representar las observaciones de nuestro data frame en nuestra gr√°fica.\nPara hacerlo, necesitamos definir una geom: el objeto geom√©trico que usa una gr√°fica para representar datos. Estos objetos geom√©tricos est√°n disponibles en ggplot2 con funciones que comienzan con geom_. La gente a menudo describe las gr√°fica por el tipo de geom que utiliza la gr√°fica. Por ejemplo, los gr√°ficos de barras usan geoms de barras (geom_bar()), los gr√°ficos de l√≠neas usan geoms de l√≠neas (geom_line()), los diagramas de caja usan geoms de diagramas de caja (geom_boxplot()), los diagramas de dispersi√≥n usan geoms de puntos (geom_point()), y as√≠ sucesivamente.\nLa funci√≥n geom_point() agrega una capa de puntos a su diagrama, lo que crea un diagrama de dispersi√≥n. ggplot2 viene con muchas funciones geom, cada una de las cuales agrega un tipo diferente de capa a una gr√°fica. Aprender√°s un mont√≥n de geoms a lo largo del libro, particularmente en Cap√≠tulo 9.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n#&gt; Warning: Removed 2 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n\n\n\n\n\n\nAhora tenemos algo que se parece a lo que podr√≠amos considerar como un ‚Äúdiagrama de dispersi√≥n‚Äù. Todav√≠a no coincide con nuestra gr√°fica de ‚Äúobjetivo final‚Äù, pero usando esta gr√°fica podemos comenzar a responder la pregunta que motiv√≥ nuestra exploraci√≥n: ‚Äú¬øC√≥mo es la relaci√≥n entre la longitud de las aletas y la masa corporal?‚Äù La relaci√≥n parece ser positiva (a medida que aumenta la longitud de la aleta, tambi√©n lo hace la masa corporal), bastante lineal (los puntos se agrupan alrededor de una l√≠nea en lugar de una curva) y moderadamente fuerte (no hay demasiada dispersi√≥n alrededor de esa l√≠nea). Los ping√ºinos con aletas m√°s largas son generalmente m√°s grandes en t√©rminos de masa corporal.\nAntes de agregar m√°s capas a este gr√°fico, hagamos una pausa por un momento y revisemos el mensaje de advertencia que recibimos:\n\nRemoved 2 rows containing missing values (geom_point()).\n\nEstamos viendo este mensaje porque hay dos ping√ºinos en nuestro conjunto de datos a los que les faltan valores de masa corporal y/o longitud de aleta y ggplot2 no tiene forma de representarlos en el gr√°fico sin estos dos valores. Al igual que R, ggplot2 se suscribe a la filosof√≠a de que los valores faltantes nunca deben desaparecer en silencio. Este tipo de advertencia es probablemente uno de los tipos de advertencia m√°s comunes que ver√° cuando trabaje con datos reales: los valores faltantes son un problema muy com√∫n y aprender√° m√°s sobre ellos a lo largo del libro, particularmente en Cap√≠tulo 18. Para las gr√°ficas restantes en este cap√≠tulo, suprimiremos esta advertencia para que no se imprima junto con cada gr√°fica que hagamos\n\n1.2.4 Agregar est√©tica y capas\nLos diagramas de dispersi√≥n son √∫tiles para mostrar la relaci√≥n entre dos variables num√©ricas, pero siempre es una buena idea ser esc√©ptico ante cualquier relaci√≥n aparente entre dos variables y preguntar si puede haber otras variables que expliquen o cambien la naturaleza de esta relaci√≥n aparente. Por ejemplo, ¬øla relaci√≥n entre la longitud de las aletas y la masa corporal difiere seg√∫n la especie? Incorporemos las especies a nuestra gr√°fica y veamos si esto revela alguna informaci√≥n adicional sobre la aparente relaci√≥n entre estas variables. Haremos esto representando especies con puntos de diferentes colores.\nPara conseguirlo, ¬øtendremos que modificar la est√©tica o la geom? Si adivinaste ‚Äúen el mapeo est√©tico, dentro de aes()‚Äù, ¬°ya est√°s aprendiendo a crear visualizaciones de datos con ggplot2! Y si no, no te preocupes. A lo largo del libro, har√° muchos m√°s ggplots y tendr√° muchas m√°s oportunidades para verificar su intuici√≥n a medida que los hace.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point()\n\n\n\n\n\n\n\nCuando una variable categ√≥rica se asigna a una est√©tica, ggplot2 asignar√° autom√°ticamente un valor √∫nico de la est√©tica (aqu√≠, un color √∫nico) a cada nivel √∫nico de la variable (cada una de las tres especies), un proceso conocido como escalado . ggplot2 tambi√©n agregar√° una leyenda que explica qu√© valores corresponden a qu√© niveles.\nAhora agreguemos una capa m√°s: una curva suave que muestre la relaci√≥n entre la masa corporal y la longitud de la aleta. Antes de continuar, consulte el c√≥digo anterior y piense en c√≥mo podemos agregar esto a nuestra gr√°fica existente.\nDado que este es un nuevo objeto geom√©trico que representa nuestros datos, agregaremos un nuevo geom como una capa encima de nuestro punto geom: geom_smooth(). Y especificaremos que queremos dibujar la l√≠nea de mejor ajuste en base a un modelo lineal con method = \"lm\".\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\nAgregamos l√≠neas con √©xito, pero este gr√°fico no se parece al gr√°fico de Secci√≥n 1.2.2, que solo tiene una l√≠nea para todo el conjunto de datos en lugar de l√≠neas separadas para cada una de las especies de ping√ºinos.\nCuando las asignaciones est√©ticas se definen en ggplot(), en el nivel global, se transmiten a cada una de las capas de geom subsiguientes de la trama. Sin embargo, cada funci√≥n geom en ggplot2 tambi√©n puede tomar un argumento mapping, que permite mapeos est√©ticos en el nivel local que se agregan a los heredados del nivel global. Dado que queremos que los puntos se coloreen en funci√≥n de las especies, pero no queremos que las l√≠neas se separen para ellos, debemos especificar color = species solo para geom_point().\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n¬°Voila! Tenemos algo que se parece mucho a nuestro objetivo final, aunque todav√≠a no es perfecto. Todav√≠a necesitamos usar diferentes formas para cada especie de ping√ºinos y mejorar las etiquetas.\nPor lo general, no es una buena idea representar informaci√≥n usando solo colores en un gr√°fico, ya que las personas perciben los colores de manera diferente debido a la ceguera al color u otras diferencias en la visi√≥n del color. Por lo tanto, adem√°s del color, tambi√©n podemos asignar species a la aesthetic de shape(forma).\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\nTenga en cuenta que la leyenda se actualiza autom√°ticamente para reflejar tambi√©n las diferentes formas de los puntos.\nY finalmente, podemos mejorar las etiquetas de nuestro gr√°fico usando la funci√≥n labs() en una nueva capa. Algunos de los argumentos de labs() pueden explicarse por s√≠ mismos: title agrega un t√≠tulo y subtitle agrega un subt√≠tulo a la gr√°fica. Otros argumentos coinciden con las asignaciones aesthetics, x es la etiqueta del eje x, y es la etiqueta del eje y, y color y shape definen la etiqueta de la leyenda. Adem√°s, podemos mejorar la paleta de colores para que sea segura para los dalt√≥nicos con la funci√≥n scale_color_colorblind() del paquete ggthemes.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Masa corporal y longitud de las aletas\",\n    subtitle = \"Dimensiones para ping√ºinos Adelia, barbijo y pap√∫a\",\n    x = \"Longitud de la aleta (mm)\", y = \"Masa corporal (g)\",\n    color = \"Especies\", shape = \"Especies\"\n  ) +\n  scale_color_colorblind()\n\n\n\n\n\n\n\n¬°Finalmente tenemos una gr√°fica que encaja perfectamente con nuestro ‚Äúobjetivo final‚Äù!\n\n1.2.5 Ejercicios\n\n¬øCu√°ntas filas hay en penguins? ¬øCu√°ntas columnas?\n¬øQu√© describe la variable bill_ depth_mm en el data frame penguins? Lea la ayuda con ?penguins para averiguarlo.\nHaz un diagrama de dispersi√≥n de bill_depth_mm frente a bill_length_mm. Describe la relaci√≥n entre estas dos variables.\n¬øQu√© pasa si haces un diagrama de dispersi√≥n de species frente a bill_depth_mm? Es decir, haz un diagrama de dispersi√≥n con bill_depth_mm en el eje y y bill_length_mm en el eje x. ¬øCu√°l podr√≠a ser una mejor elecci√≥n de geom?\n\n¬øPor qu√© lo siguiente da un error y c√≥mo lo solucionar√≠a?\n\nggplot(data = penguins) + \n  geom_point()\n\n\n¬øQu√© hace el argumento na.rm en geom_point()? ¬øCu√°l es el valor predeterminado del argumento? Cree un diagrama de dispersi√≥n en el que utilice con √©xito este argumento con valor TRUE.\nAgregue el siguiente t√≠tulo al gr√°fico que hizo en el ejercicio anterior: ‚ÄúLos datos provienen del paquete palmerpenguins‚Äù. Sugerencia: Eche un vistazo a la documentaci√≥n de labs().\n\nVuelva a crear la siguiente visualizaci√≥n. ¬øA qu√© aesthetic se debe asignar bill_depth_mm? ¬øY deber√≠a mapearse a nivel global o a nivel de geom?\n\n\n\n\n\n\n\n\n\n\nEjecute este c√≥digo en su cabeza y prediga c√≥mo se ver√° la salida. Luego, ejecuta el c√≥digo en R y verifica tus predicciones.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = island)\n) +\n  geom_point() +\n  geom_smooth(se = FALSE)\n\n\n\n¬øSe ver√°n diferentes estos dos gr√°ficos? ¬øPor qu√©/ por qu√© no?\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point() +\n  geom_smooth()\n\nggplot() +\n  geom_point(\n    data = penguins,\n    mapping = aes(x = flipper_length_mm, y = body_mass_g)\n  ) +\n  geom_smooth(\n    data = penguins,\n    mapping = aes(x = flipper_length_mm, y = body_mass_g)\n  )",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Visualizaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#sec-ggplot2-calls",
    "href": "data-visualize.html#sec-ggplot2-calls",
    "title": "1¬† Visualizaci√≥n de datos",
    "section": "\n1.3 Llamadas ggplot2",
    "text": "1.3 Llamadas ggplot2\nA medida que avancemos desde estas secciones introductorias, pasaremos a una expresi√≥n m√°s concisa del c√≥digo ggplot2. Hasta ahora hemos sido muy expl√≠citos, lo cual es √∫til cuando est√°s aprendiendo:\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n\nPor lo general, los primeros uno o dos argumentos de una funci√≥n son tan importantes que debe saberlos de memoria. Los dos primeros argumentos de ggplot() son data y mapping; en el resto del libro, no proporcionaremos esos nombres. Eso ahorra escribir y, al reducir la cantidad de texto adicional, hace que sea m√°s f√°cil ver las diferencias entre los gr√°ficos. Esa es una preocupaci√≥n de programaci√≥n realmente importante a la que volveremos en Cap√≠tulo 25.\nReescribiendo la gr√°fica anterior de forma m√°s concisa se obtiene:\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()\n\nEn el futuro, tambi√©n aprender√° sobre pipe, |&gt;, que le permitir√° crear esa gr√°fica con:\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Visualizaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#visualizaci√≥n-de-distribuciones",
    "href": "data-visualize.html#visualizaci√≥n-de-distribuciones",
    "title": "1¬† Visualizaci√≥n de datos",
    "section": "\n1.4 Visualizaci√≥n de distribuciones",
    "text": "1.4 Visualizaci√≥n de distribuciones\nC√≥mo visualiza la distribuci√≥n de una variable depende del tipo de variable: categ√≥rica o num√©rica.\n\n1.4.1 Una variable categ√≥rica\nUna variable es categ√≥rica si solo puede tomar uno de un peque√±o conjunto de valores. Para examinar la distribuci√≥n de una variable categ√≥rica, puede utilizar un gr√°fico de barras. La altura de las barras muestra cu√°ntas observaciones ocurrieron con cada valor x.\n\nggplot(penguins, aes(x = species)) +\n  geom_bar()\n\n\n\n\n\n\n\nEn gr√°ficos de barras de variables categ√≥ricas con niveles no ordenados, como la ‚Äúespecies‚Äù de ping√ºinos anterior, a menudo es preferible reordenar las barras en funci√≥n de sus frecuencias. Hacerlo requiere transformar la variable en un factor (c√≥mo R maneja los datos categ√≥ricos) y luego reordenar los niveles de ese factor.\n\nggplot(penguins, aes(x = fct_infreq(species))) +\n  geom_bar()\n\n\n\n\n\n\n\nAprender√° m√°s sobre factores y funciones para manejar factores (como fct_infreq() que se muestra arriba) en Cap√≠tulo 16.\n\n1.4.2 Una variable num√©rica\nUna variable es num√©rica (o cuantitativa) si puede tomar una amplia gama de valores num√©ricos, y es sensato sumar, restar o tomar promedios con esos valores. Las variables num√©ricas pueden ser continuas o discretas.\nUna visualizaci√≥n de uso com√∫n para distribuciones de variables continuas es un histograma.\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 200)\n\n\n\n\n\n\n\nUn histograma divide el eje x en contenedores igualmente espaciados y luego usa la altura de una barra para mostrar el n√∫mero de observaciones que caen en cada contenedor. En el gr√°fico anterior, la barra m√°s alta muestra que 39 observaciones tienen un valor de body_mass_g entre 3500 y 3700 gramos, que son los bordes izquierdo y derecho de la barra.\nPuede establecer el ancho de los intervalos en un histograma con el argumento binwidth (ancho de barra), que se mide en las unidades de la variable x. Siempre debe explorar una variedad de anchos de bin cuando trabaje con histogramas, ya que diferentes anchos de bin pueden revelar patrones diferentes. En las gr√°ficas a continuaci√≥n, un ancho de bin de 20 es demasiado estrecho, lo que da como resultado demasiadas barras, lo que dificulta determinar la forma de la distribuci√≥n. Del mismo modo, un ancho de intervalo de 2000 es demasiado alto, lo que da como resultado que todos los datos se agrupan en solo tres barras y tambi√©n dificulta determinar la forma de la distribuci√≥n. Un binwidth de 200 proporciona un equilibrio razonable.\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 20)\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 2000)\n\n\n\n\n\n\n\n\n\n\nUna visualizaci√≥n alternativa para distribuciones de variables num√©ricas es una gr√°fica de densidad. Un gr√°fico de densidad es una versi√≥n suavizada de un histograma y una alternativa pr√°ctica, particularmente para datos continuos que provienen de una distribuci√≥n suave subyacente. No entraremos en c√≥mo geom_density() estima la densidad (puede leer m√°s sobre eso en la documentaci√≥n de la funci√≥n), pero expliquemos c√≥mo se dibuja la curva de densidad con una analog√≠a. Imagina un histograma hecho de bloques de madera. Luego, imagina que le tiras encima un hilo de espagueti cocido. La forma que tomar√°n los espaguetis sobre los bloques se puede considerar como la forma de la curva de densidad. Muestra menos detalles que un histograma, pero puede facilitar la obtenci√≥n r√°pida de la forma de la distribuci√≥n, en particular con respecto a las modas y la asimetr√≠a.\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_density()\n#&gt; Warning: Removed 2 rows containing non-finite outside the scale range\n#&gt; (`stat_density()`).\n\n\n\n\n\n\n\n\n1.4.3 Ejercicios\n\nHaz un gr√°fico de barras de species de penguins, donde asignas species a la aesthetic y. ¬øEn qu√© se diferencia esta gr√°fica?\n\n¬øEn qu√© se diferencian las siguientes dos gr√°ficas? ¬øQu√© aesthetic, color o fill, es m√°s √∫til para cambiar el color de las barras?\n\nggplot(penguins, aes(x = species)) +\n  geom_bar(color = \"red\")\n\nggplot(penguins, aes(x = species)) +\n  geom_bar(fill = \"red\")\n\n\n¬øQu√© hace el argumento bins en geom_histogram()?\nHaz un histograma de la variable carat en el conjunto de datos diamonds que est√° disponible cuando carga el paquete tidyverse. Experimente con diferentes binwidths. ¬øQu√© binwidth revela los patrones m√°s interesantes?",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Visualizaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#visualizando-relaciones",
    "href": "data-visualize.html#visualizando-relaciones",
    "title": "1¬† Visualizaci√≥n de datos",
    "section": "\n1.5 Visualizando relaciones",
    "text": "1.5 Visualizando relaciones\nPara visualizar una relaci√≥n, necesitamos tener al menos dos variables asignadas a la aesthetic de una gr√°fica. En las siguientes secciones, aprender√° acerca de las gr√°ficas com√∫nmente utilizadas para visualizar las relaciones entre dos o m√°s variables y las geoms utilizados para crearlas.\n\n1.5.1 Una variable num√©rica y categ√≥rica\nPara visualizar la relaci√≥n entre una variable num√©rica y categ√≥rica, podemos usar diagramas de caja uno al lado del otro. Un diagrama de caja es un tipo de abreviatura visual para las medidas de posici√≥n (percentiles) que describen una distribuci√≥n. Tambi√©n es √∫til para identificar posibles valores at√≠picos. Como se muestra en Figura¬†1.1, cada diagrama de caja consta de:\n\nUn caja que indica el rango de la mitad central de los datos, una distancia conocida como rango intercuartil (RIC), que se extiende desde el percentil 25 de la distribuci√≥n hasta el percentil 75. En el medio del cuadro hay una l√≠nea que muestra la mediana, es decir, el percentil 50, de la distribuci√≥n. Estas tres l√≠neas le dan una idea de la dispersi√≥n de la distribuci√≥n y si la distribuci√≥n es o no sim√©trica con respecto a la mediana o sesgada hacia un lado.\nPuntos visuales que muestran observaciones que caen m√°s de 1,5 veces el IQR desde cualquier borde del cuadro. Estos puntos perif√©ricos son inusuales, por lo que se grafican individualmente.\nUna l√≠nea (o bigote) que se extiende desde cada extremo de la caja y va hasta el punto no at√≠pico m√°s alejado de la distribuci√≥n.\n\n\n\n\n\n\n\n\nFigura¬†1.1: Diagrama que muestra c√≥mo se crea un diagrama de caja.\n\n\n\n\nEchemos un vistazo a la distribuci√≥n de la masa corporal por especie usando geom_boxplot():\n\nggplot(penguins, aes(x = species, y = body_mass_g)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nAlternativamente, podemos hacer gr√°ficas de densidad con geom_density().\n\nggplot(penguins, aes(x = body_mass_g, color = species)) +\n  geom_density(linewidth = 0.75)\n\n\n\n\n\n\n\nTambi√©n hemos personalizado el grosor de las l√≠neas usando el argumento linewidth para que se destaquen un poco m√°s contra el fondo.\nAdicionalmente, podemos asignar species a la est√©tica de color y fill y usar la est√©tica alpha para agregar transparencia a las curvas de densidad rellenas. Esta aesthetic toma valores entre 0 (totalmente transparente) y 1 (totalmente opaco). En la siguiente gr√°fica est√° establecido en 0.5.\n\nggplot(penguins, aes(x = body_mass_g, color = species, fill = species)) +\n  geom_density(alpha = 0.5)\n\n\n\n\n\n\n\nTenga en cuenta la terminolog√≠a que hemos utilizado aqu√≠:\n\n\nAsignamos variables a la aesthetic si queremos que el atributo visual representado por esa aesthetic var√≠e seg√∫n los valores de esa variable.\nDe lo contrario, establecemos el valor de una aesthetic.\n\n1.5.2 Dos variables categ√≥ricas\nPodemos usar diagramas de barras apiladas para visualizar la relaci√≥n entre dos variables categ√≥ricas. Por ejemplo, los siguientes dos diagramas de barras apiladas muestran la relaci√≥n entre ‚Äúisla‚Äù y ‚Äúespecies‚Äù, o espec√≠ficamente, visualizan la distribuci√≥n de ‚Äúespecies‚Äù dentro de cada isla.\nEl primer gr√°fico muestra las frecuencias de cada especie de ping√ºinos en cada isla. El gr√°fico de frecuencias muestra que hay un n√∫mero igual de Adelia en cada isla. Pero no tenemos una buena idea del equilibrio porcentual dentro de cada isla.\n\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar()\n\n\n\n\n\n\n\nEl segundo gr√°fico es un gr√°fico de frecuencia relativa, creado al configurar position = \"fill\" en la geom, es m√°s √∫til para comparar las distribuciones de especies en las islas, ya que no se ve afectado por el n√∫mero desigual de ping√ºinos en las islas. Usando este gr√°fico, podemos ver que todos los ping√ºinos Gentoo viven en la isla Biscoe y constituyen aproximadamente el 75% de los ping√ºinos en esa isla, Chinstrap todos viven en la isla Dream y constituyen aproximadamente el 50% de los ping√ºinos en esa isla, y Adelie vive en las tres islas y componen todos los ping√ºinos en Torgersen.\n\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar(position = \"fill\")\n\n\n\n\n\n\n\nAl crear estos gr√°ficos de barras, asignamos la variable que se separar√° en barras a la est√©tica x y la variable que cambiar√° los colores dentro de las barras a la est√©tica fill.\n\n1.5.3 Dos variables num√©ricas\nHasta ahora has aprendido acerca de diagramas de dispersi√≥n (creados con geom_point()) y curvas suaves (creadas con geom_smooth()) para visualizar la relaci√≥n entre dos variables num√©ricas. Una gr√°fica de dispersi√≥n es probablemente la gr√°fica m√°s utilizada para visualizar la relaci√≥n entre dos variables num√©ricas.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point()\n\n\n\n\n\n\n\n\n1.5.4 Tres o m√°s variables\nComo vimos en Secci√≥n 1.2.4, podemos incorporar m√°s variables en una trama asign√°ndolas a una est√©tica adicional. Por ejemplo, en el siguiente diagrama de dispersi√≥n, los colores de los puntos representan especies y las formas de los puntos representan islas.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species, shape = island))\n\n\n\n\n\n\n\nSin embargo, agregar demasiadas asignaciones aesthetics a una gr√°fica hace que sea desordenada y dif√≠cil de entender. Otra forma, que es particularmente √∫til para las variables categ√≥ricas, es dividir su gr√°fico en facetas, subgr√°ficos que muestran un subconjunto de los datos.\nPara facetar su gr√°fica por una sola variable, use facet_wrap(). El primer argumento de facet_wrap() es una f√≥rmula3, que se crea con ~ seguido de un nombre de variable. La variable que pasa a facet_wrap() debe ser categ√≥rica.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species, shape = species)) +\n  facet_wrap(~island)\n\n\n\n\n\n\n\nAprender√° sobre muchas otros geoms para visualizar distribuciones de variables y relaciones entre ellas en Cap√≠tulo 9.\n\n1.5.5 Ejercicios\n\nEl marco de datos mpg que se incluye con el paquete ggplot2 contiene observaciones 234 recopiladas por la Agencia de Protecci√≥n Ambiental de los EE. ¬øQu√© variables en mpg son categ√≥ricas? ¬øQu√© variables son n√∫mericas? (Sugerencia: escriba ?mpg para leer la documentaci√≥n del conjunto de datos). ¬øC√≥mo puedes ver esta informaci√≥n cuando ejecutas mpg?\nHaz un diagrama de dispersi√≥n de hwy vs.¬†displ usando el data frame mpg. A continuaci√≥n, asigne una tercera variable num√©rica a color, luego a size, luego a color y size, luego a shape. ¬øC√≥mo se comportan estas aesthetics de manera diferente para las variables categ√≥ricas frente a las num√©ricas?\nEn el diagrama de dispersi√≥n de hwy vs.¬†displ, ¬øqu√© sucede si mapeas una tercera variable a linewidth?\n¬øQu√© sucede si mapeas la misma variable a m√∫ltiples aesthetics?\nHaz un diagrama de dispersi√≥n de bill_depth_mm vs.¬†bill_length_mm y colorea los puntos por species. ¬øQu√© revela la adici√≥n de colores por especie sobre la relaci√≥n entre estas dos variables? ¬øQu√© pasa con el facetado por species?\n\n¬øPor qu√© lo siguiente produce dos leyendas separadas? ¬øC√≥mo lo arreglar√≠as para combinar las dos leyendas?\n\nggplot(\n  data = penguins,\n  mapping = aes(\n    x = bill_length_mm, y = bill_depth_mm, \n    color = species, shape = species\n  )\n) +\n  geom_point() +\n  labs(color = \"Especies\")\n\n\n\nCree los dos siguientes diagramas de barras apiladas. ¬øQu√© pregunta puedes responder con la primera? ¬øQu√© pregunta puedes responder con la segunda?\n\nggplot(penguins, aes(x = island, fill = species)) +\n  geom_bar(position = \"fill\")\nggplot(penguins, aes(x = species, fill = island)) +\n  geom_bar(position = \"fill\")",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Visualizaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#sec-ggsave",
    "href": "data-visualize.html#sec-ggsave",
    "title": "1¬† Visualizaci√≥n de datos",
    "section": "\n1.6 Guardando tus gr√°ficas",
    "text": "1.6 Guardando tus gr√°ficas\nUna vez que haya creado un gr√°fico, es posible que desee sacarlo de R guard√°ndolo como una imagen que puede usar en otro lugar. Ese es el trabajo de ggsave(), que guardar√° el gr√°fico creado m√°s reciente en el disco:\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point()\nggsave(filename = \"penguin-plot.png\")\n\nEsto guardar√° su gr√°fica en su directorio de trabajo, un concepto sobre el que aprender√° m√°s en Cap√≠tulo 6.\nSi no especifica el ancho (argumento width) y la altura (argumento height) se tomar√°n de las dimensiones del dispositivo del gr√°fico actual. Para c√≥digo reproducible, querr√° especificarlos. Puede aprender m√°s sobre ggsave() en la documentaci√≥n.\nEn general, sin embargo, recomendamos que armes tus informes finales utilizando Quarto, un sistema de creaci√≥n reproducible que te permite intercalar tu c√≥digo y tu prosa e incluir autom√°ticamente tus gr√°ficas en tus redacciones. Aprender√° m√°s sobre Quarto en Cap√≠tulo 28.\n\n1.6.1 Ejercicios\n\n\nEjecute las siguientes l√≠neas de c√≥digo. ¬øCu√°l de los dos gr√°ficos se guarda como mpg-grafica.png? ¬øPor qu√©?\n\nggplot(mpg, aes(x = class)) +\n  geom_bar()\nggplot(mpg, aes(x = cty, y = hwy)) +\n  geom_point()\nggsave(\"mpg-grafica.png\")\n\n\n¬øQu√© necesita cambiar en el c√≥digo anterior para guardar el gr√°fico como PDF en lugar de PNG? ¬øC√≥mo podr√≠a averiguar qu√© tipos de archivos de imagen funcionar√≠an en ggsave()?",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Visualizaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#problemas-comunes",
    "href": "data-visualize.html#problemas-comunes",
    "title": "1¬† Visualizaci√≥n de datos",
    "section": "\n1.7 Problemas comunes",
    "text": "1.7 Problemas comunes\nA medida que comience a ejecutar el c√≥digo de R, es probable que tenga problemas. No te preocupes ‚Äî le pasa a todo el mundo. Todos hemos estado escribiendo c√≥digo R durante a√±os, ¬°pero todos los d√≠as seguimos escribiendo c√≥digo que no funciona en el primer intento!\nComience comparando cuidadosamente el c√≥digo que est√° ejecutando con el c√≥digo del libro. R es extremadamente quisquilloso, y un car√°cter fuera de lugar puede marcar la diferencia. Aseg√∫rate de que cada ( coincida con un ) y cada \" est√© emparejado con otro \". A veces, ejecutar√° el c√≥digo y no suceder√° nada. Verifique la parte izquierda de su consola: si es un +, significa que R no cree que haya escrito una expresi√≥n completa y est√° esperando que la termine. En este caso, por lo general es f√°cil volver a empezar desde cero presionando ESCAPE para cancelar el procesamiento del comando actual.\nUn problema com√∫n al crear gr√°ficos ggplot2 es colocar el + en el lugar equivocado: tiene que estar al final de la l√≠nea, no al principio. En otras palabras, aseg√∫rese de no haber escrito accidentalmente un c√≥digo como este:\n\nggplot(data = mpg) \n+ geom_point(mapping = aes(x = displ, y = hwy))\n\nSi todav√≠a est√°s atascado, prueba la ayuda. Puede obtener ayuda sobre cualquier funci√≥n de R ejecutando ?function_name en la consola, o resaltando el nombre de la funci√≥n y presionando F1 en RStudio. No se preocupe si la ayuda no parece tan √∫til; en su lugar, salte a los ejemplos y busque el c√≥digo que coincida con lo que est√° tratando de hacer.\nSi eso no ayuda, lea atentamente el mensaje de error. ¬°A veces la respuesta estar√° enterrada all√≠! Pero cuando eres nuevo en R, incluso si la respuesta est√° en el mensaje de error, es posible que a√∫n no sepas c√≥mo entenderlo. Otra gran herramienta es Google: intente buscar en Google el mensaje de error, ya que es probable que alguien m√°s haya tenido el mismo problema y haya obtenido ayuda en l√≠nea.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Visualizaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#resumen",
    "href": "data-visualize.html#resumen",
    "title": "1¬† Visualizaci√≥n de datos",
    "section": "\n1.8 Resumen",
    "text": "1.8 Resumen\nEn este cap√≠tulo, ha aprendido los conceptos b√°sicos de la visualizaci√≥n de datos con ggplot2. Comenzamos con la idea b√°sica que sustenta ggplot2: una visualizaci√≥n es un mapeo de variables en sus datos a propiedades est√©ticas como posici√≥n, color, tama√±o y forma. Luego aprendi√≥ a aumentar la complejidad y mejorar la presentaci√≥n de sus gr√°ficos capa por capa. Tambi√©n aprendi√≥ sobre las gr√°ficas de uso com√∫n para visualizar la distribuci√≥n de una sola variable, as√≠ como para visualizar las relaciones entre dos o m√°s variables, aprovechando mapeos est√©ticos adicionales y/o dividiendo su gr√°fica en peque√±os m√∫ltiplos usando facetas.\nUsaremos visualizaciones una y otra vez a lo largo de este libro, presentaremos nuevas t√©cnicas a medida que las necesitemos y profundizaremos en la creaci√≥n de visualizaciones con ggplot2 en Cap√≠tulo 9 a trav√©s de Cap√≠tulo 11.\nCon los conceptos b√°sicos de visualizaci√≥n en su haber, en el pr√≥ximo cap√≠tulo vamos a cambiar un poco de tema y le daremos algunos consejos pr√°cticos sobre el flujo de trabajo. Intercalamos consejos de flujo de trabajo con herramientas de ciencia de datos a lo largo de esta parte del libro porque lo ayudar√° a mantenerse organizado a medida que escribe cantidades crecientes de c√≥digo de R.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Visualizaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-visualize.html#footnotes",
    "href": "data-visualize.html#footnotes",
    "title": "1¬† Visualizaci√≥n de datos",
    "section": "",
    "text": "Puede eliminar ese mensaje y forzar la resoluci√≥n de conflictos a pedido utilizando el paquete en conflicto, que se vuelve m√°s importante a medida que carga m√°s paquetes. Puede obtener m√°s informaci√≥n sobre conflictos en https://conflicted.r-lib.org.‚Ü©Ô∏é\nHorst AM, Hill AP, Gorman KB (2020). palmerpenguins: Datos de ping√ºinos del Archipi√©lago Palmer (Ant√°rtida). version 0.1.0. del paquete de R https://allisonhorst.github.io/palmerpenguins/. doi: 10.5281/zenodo.3960218.‚Ü©Ô∏é\nAqu√≠ ‚Äúformula‚Äù es el nombre de la cosa creada por ~, no un sin√≥nimo de ‚Äúecuaci√≥n‚Äù.‚Ü©Ô∏é",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Visualizaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html",
    "href": "workflow-basics.html",
    "title": "2¬† Flujo de trabajo: conceptos b√°sicos",
    "section": "",
    "text": "2.1 Conceptos b√°sicos para escribir c√≥digo\nAhora tiene algo de experiencia ejecutando c√≥digo de R. No te dimos muchos detalles, pero obviamente has descubierto los conceptos b√°sicos, ¬°o habr√≠as tirado este libro por la frustraci√≥n! La frustraci√≥n es natural cuando comienzas a programar en R porque es muy estricto con la puntuaci√≥n, e incluso un car√°cter fuera de lugar puede hacer que se queje. Pero si bien debe esperar sentirse un poco frustrado, consu√©lese con el hecho de que esta experiencia es t√≠pica y temporal: le sucede a todos, y la √∫nica forma de superarlo es seguir intent√°ndolo.\nAntes de continuar, asegur√©monos de que tiene una base s√≥lida para ejecutar c√≥digo de R y que conoce algunas de las caracter√≠sticas m√°s √∫tiles de RStudio.\nRepasemos algunos conceptos b√°sicos que hemos omitido hasta ahora con el fin de que pueda graficar lo m√°s r√°pido posible. Puedes usar R para hacer c√°lculos matem√°ticos b√°sicos:\n1 / 200 * 30\n#&gt; [1] 0.15\n(59 + 73 + 2) / 3\n#&gt; [1] 44.66667\nsin(pi / 2)\n#&gt; [1] 1\nPuede crear nuevos objetos con el operador de asignaci√≥n &lt;-:\nx &lt;- 3 * 4\nTenga en cuenta que el valor de x no se imprime, solo se almacena. Si desea ver el valor, escriba x en la consola.\nPuedes ccombinar m√∫ltiples elementos en un vector con c():\nprimos &lt;- c(2, 3, 5, 7, 11, 13)\nY la aritm√©tica b√°sica sobre vectores se aplica a cada elemento del vector:\nprimos * 2\n#&gt; [1]  4  6 10 14 22 26\nprimos - 1\n#&gt; [1]  1  2  4  6 10 12\nTodas las declaraciones de R en las que crean objetos, declaraciones de asignaci√≥n, tienen la misma forma\nnombre_del_objeto &lt;- valor\nAl leer ese c√≥digo, diga ‚Äúel nombre del objeto obtiene valor‚Äù en su cabeza.\nHar√° muchas asignaciones, y &lt;- es una molestia escribir. Puede ahorrar tiempo con el m√©todo abreviado de teclado de RStudio: Alt + - (el signo menos). Tenga en cuenta que RStudio rodea autom√°ticamente &lt;- con espacios, lo cual es una buena pr√°ctica de formateo de c√≥digo. El c√≥digo puede ser para leer en un buen d√≠a, as√≠ que t√≥mese un respiro y use espacios.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Flujo de trabajo: conceptos b√°sicos</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#comentarios",
    "href": "workflow-basics.html#comentarios",
    "title": "2¬† Flujo de trabajo: conceptos b√°sicos",
    "section": "\n2.2 Comentarios",
    "text": "2.2 Comentarios\nR ignorar√° cualquier texto en esa l√≠nea despu√©s de #. Esto le permite escribir comentarios, texto que R ignora pero que otros humanos leen. A veces incluiremos comentarios en ejemplos que explican lo que sucede con el c√≥digo.\nLos comentarios pueden ser √∫tiles para describir brevemente lo que hace el siguiente c√≥digo.\n\n# crea vector de n√∫meros primos\nprimos &lt;- c(2, 3, 5, 7, 11, 13)\n\n# multiplica primos por 2\nprimos * 2\n#&gt; [1]  4  6 10 14 22 26\n\nCon fragmentos de c√≥digo cortos como este, puede que no sea necesario dejar un comentario para cada l√≠nea de c√≥digo. Pero a medida que el c√≥digo que est√° escribiendo se vuelve m√°s complejo, los comentarios pueden ahorrarle a usted (y a sus colaboradores) mucho tiempo para averiguar qu√© se hizo en el c√≥digo.\nUse comentarios para explicar el por qu√© de su c√≥digo, no el c√≥mo o el qu√©. Siempre es posible averiguar el qu√© y el c√≥mo de su c√≥digo ley√©ndolo detenidamente, incluso si puede ser tedioso. Si describe cada paso en los comentarios y luego cambia el c√≥digo, deber√° recordar actualizar los comentarios tambi√©n o ser√° confuso cuando regrese a su c√≥digo en el futuro.\nAveriguar por qu√© se hizo algo es mucho m√°s dif√≠cil, si no imposible. Por ejemplo, geom_smooth() tiene un argumento llamado span, que controla la suavidad de la curva, con valores m√°s grandes produciendo una curva m√°s suave. Supongamos que decide cambiar el valor de span de su valor predeterminado de 0,75 a 0,3: es f√°cil para un futuro lector entender qu√© est√° pasando, pero a menos que anote su pensamiento en un comentario, nadie entender√° por qu√© cambiaste el valor predeterminado.\nPara el c√≥digo de an√°lisis de datos, use comentarios para explicar su plan general de ataque y registre informaci√≥n importante a medida que la encuentre. No hay forma de volver a capturar este conocimiento desde el c√≥digo mismo.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Flujo de trabajo: conceptos b√°sicos</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#sec-whats-in-a-name",
    "href": "workflow-basics.html#sec-whats-in-a-name",
    "title": "2¬† Flujo de trabajo: conceptos b√°sicos",
    "section": "\n2.3 ¬øQu√© hay en un nombre?",
    "text": "2.3 ¬øQu√© hay en un nombre?\nLos nombres de los objetos deben comenzar con una letra y solo pueden contener letras, n√∫meros, _ y .. Desea que los nombres de sus objetos sean descriptivos, por lo que deber√° adoptar una convenci√≥n para varias palabras. Recomendamos snake_case, donde se separan las palabras en min√∫sculas con _.\n\nyo_uso_snake_case\notrasPersonasUsanCamelCase\nalgunas.personas.usan.puntos\nY_unasPocas.Personas_RENUNCIANaconvencion\n\nVolveremos a los nombres cuando analicemos el estilo del c√≥digo en Cap√≠tulo 4.\nPuede inspeccionar un objeto escribiendo su nombre:\n\nx\n#&gt; [1] 12\n\nHaz otra asignaci√≥n:\n\neste_es_un_nombre_realmente_largo &lt;- 2.5\n\nPara inspeccionar este objeto, pruebe la funci√≥n de finalizaci√≥n de RStudio: escriba ‚Äúeste‚Äù, presione TAB, agregue caracteres hasta que tenga un prefijo √∫nico y luego presione Entrar.\nSupongamos que cometi√≥ un error y que el valor de este_es_un_nombre_realmente_largo deber√≠a ser 3,5, no 2,5. Puede usar otro m√©todo abreviado de teclado para ayudarlo a solucionarlo. Por ejemplo, puede presionar ‚Üë para traer el √∫ltimo comando que escribi√≥ y editarlo. O escribe ‚Äúeste‚Äù y luego presiona Cmd/Ctrl + ‚Üë para enumerar todos los comandos que has escrito que comienzan con esas letras. Use las teclas de flecha para navegar, luego presione enter para volver a escribir el comando. Cambie 2.5 a 3.5 y vuelva a ejecutar.\nHaz otra asignaci√≥n m√°s:\n\nr_rocks &lt;- 2^3\n\nIntentemos inspeccionarlo:\n\nr_rock\n#&gt; Error: object 'r_rock' not found\nR_rocks\n#&gt; Error: object 'R_rocks' not found\n\nEsto ilustra el contrato impl√≠cito entre usted y R: R har√° los tediosos c√°lculos por usted, pero a cambio, debe ser completamente preciso en sus instrucciones. De lo contrario, es probable que obtenga un error que dice que no se encontr√≥ el objeto que est√° buscando. Los errores tipogr√°ficos importan; R no puede leer tu mente y decir, ‚Äúoh, probablemente quer√≠an decir r_rocks cuando escribieron r_rock‚Äù. El tama√±o de las letras importa; de manera similar, R no puede leer tu mente y decir, ‚Äúoh, probablemente quer√≠an decir r_rocks cuando escribieron R_rocks‚Äù.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Flujo de trabajo: conceptos b√°sicos</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#llamando-funciones",
    "href": "workflow-basics.html#llamando-funciones",
    "title": "2¬† Flujo de trabajo: conceptos b√°sicos",
    "section": "\n2.4 Llamando funciones",
    "text": "2.4 Llamando funciones\nR tiene una gran colecci√≥n de funciones integradas que se llaman as√≠:\n\nnombre_funcion(argumento1 = val1, argumento2 = val2, ...)\n\nIntentemos usar seq(), que crea secuencias regulares de n√∫meros, y mientras estamos en eso, aprenda m√°s funciones √∫tiles de RStudio. Escriba se y presione TAB. Una ventana emergente le muestra posibles terminaciones. Especifique seq() escribiendo m√°s (una q) para eliminar la ambig√ºedad o usando las flechas ‚Üë/‚Üì para seleccionar. Observe la informaci√≥n sobre herramientas flotante que aparece, record√°ndole los argumentos y el prop√≥sito de la funci√≥n. Si desea m√°s ayuda, presione F1 para obtener todos los detalles en la pesta√±a de ayuda en el panel inferior derecho.\nCuando haya seleccionado la funci√≥n que desea, presione TAB nuevamente. RStudio agregar√° par√©ntesis de apertura (() y cierre ()) coincidentes para usted. Escriba el nombre del primer argumento, from, y establ√©zcalo en 1. Luego, escribe el nombre del segundo argumento, to, y config√∫ralo como 10. Finalmente, presione ejecutar.\n\nseq(from = 1, to = 10)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\nA menudo omitimos los nombres de los primeros argumentos en las llamadas a funciones, por lo que podemos reescribir esto de la siguiente manera:\n\nseq(1, 10)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\nEscriba el siguiente c√≥digo y observe que RStudio proporciona una asistencia similar con las comillas emparejadas:\n\nx &lt;- \"Hola mundo\"\n\nLas comillas y los par√©ntesis deben ir siempre en pareja. RStudio hace todo lo posible para ayudarlo, pero a√∫n es posible equivocarse y terminar con una falta de coincidencia. Si esto sucede, R le mostrar√° el car√°cter de continuaci√≥n ‚Äú+‚Äù:\n&gt; x &lt;- \"Hola\n+\nEl + te dice que R est√° esperando m√°s entradas; no cree que hayas terminado todav√≠a. Por lo general, esto significa que ha olvidado un \" o un ). Agregue el par faltante o presione ESCAPE para abortar la expresi√≥n y vuelva a intentarlo.\nTenga en cuenta que la pesta√±a de entorno en el panel superior derecho muestra todos los objetos que ha creado:",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Flujo de trabajo: conceptos b√°sicos</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#ejercicios",
    "href": "workflow-basics.html#ejercicios",
    "title": "2¬† Flujo de trabajo: conceptos b√°sicos",
    "section": "\n2.5 Ejercicios",
    "text": "2.5 Ejercicios\n\n\n¬øPor qu√© este c√≥digo no funciona?\n\nmi_variable &lt;- 10\nmi_varƒ±able\n#&gt; Error in eval(expr, envir, enclos): object 'mi_varƒ±able' not found\n\n¬°Mira cuidadosamente! (Esto puede parecer un ejercicio sin sentido, pero entrenar tu cerebro para notar incluso la m√°s m√≠nima diferencia valdr√° la pena cuando programes.)\n\n\nModifique cada uno de los siguientes comandos de R para que se ejecuten correctamente:\n\nlibary(todyverse)\n\nggplot(dTA = mpg) +  \n  geom_point(maping = aes(x = displ y = hwy)) +\n  geom_smooth(method = \"lm)\n\n\nPresione Option + Shift + K / Alt + Shift + K. ¬øQu√©s lo que pasa? ¬øC√≥mo puedes llegar al mismo lugar usando los men√∫s?\n\nRepasemos un ejercicio de Secci√≥n 1.6. Ejecute las siguientes l√≠neas de c√≥digo. ¬øCu√°l de los dos gr√°ficos se guarda como mpg-plot.png? ¬øPor qu√©?\n\nmi_grafica_barras &lt;- ggplot(mpg, aes(x = class)) +\n  geom_bar()\nmi_diagrama_dispersion &lt;- ggplot(mpg, aes(x = cty, y = hwy)) +\n  geom_point()\nggsave(filename = \"mpg-plot.png\", plot = mi_grafica_barras)",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Flujo de trabajo: conceptos b√°sicos</span>"
    ]
  },
  {
    "objectID": "workflow-basics.html#resumen",
    "href": "workflow-basics.html#resumen",
    "title": "2¬† Flujo de trabajo: conceptos b√°sicos",
    "section": "\n2.6 Resumen",
    "text": "2.6 Resumen\nAhora que ha aprendido un poco m√°s sobre c√≥mo funciona el c√≥digo de R y algunos consejos para ayudarlo a comprender su c√≥digo cuando regrese a √©l en el futuro. En el pr√≥ximo cap√≠tulo, continuaremos su recorrido por la ciencia de datos ense√±√°ndole sobre dplyr, el paquete de tidyverse que lo ayuda a transformar datos, ya sea seleccionando variables importantes, filtrando filas de inter√©s o calculando estad√≠sticas de resumen.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Flujo de trabajo: conceptos b√°sicos</span>"
    ]
  },
  {
    "objectID": "data-transform.html",
    "href": "data-transform.html",
    "title": "3¬† Transformaci√≥n de datos",
    "section": "",
    "text": "3.1 Introducci√≥n\nLa visualizaci√≥n es una herramienta importante para generar informaci√≥n, pero es raro que obtenga los datos exactamente en la forma correcta que necesita para hacer el gr√°fico que desea. A menudo, necesitar√° crear nuevas variables o res√∫menes para responder a tus preguntas con tus datos, o tal vez solo quiera cambiar el nombre de las variables o reordenar las observaciones para que sea un poco m√°s f√°cil trabajar con los datos. Aprender√° c√≥mo hacer todo eso (¬°y m√°s!) en este cap√≠tulo, que lo introducir√° a la transformaci√≥n de datos utilizando el paquete dplyr y un nuevo conjunto de datos en vuelos que partieron de la ciudad de Nueva York en 2013.\nEl objetivo de este cap√≠tulo es brindarle una descripci√≥n general de todas las herramientas clave para transformar un data frame. Comenzaremos con funciones que operan en filas y luego columnas de un data frame, luego regresamos para hablar m√°s sobre las canalizaciones o pipe, una herramienta importante que usa para combinar verbos. A continuaci√≥n, introduciremos la capacidad de trabajar con grupos. Terminaremos el cap√≠tulo con un caso de estudio que muestra estas funciones en acci√≥n. En cap√≠tulos posteriores volveremos a las funciones con m√°s detalle a medida que comencemos a profundizar en tipos espec√≠ficos de datos (por ejemplo, n√∫meros, cadenas, fechas).",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Transformaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-transform.html#introducci√≥n",
    "href": "data-transform.html#introducci√≥n",
    "title": "3¬† Transformaci√≥n de datos",
    "section": "",
    "text": "3.1.1 Requisitos previos\nEn este cap√≠tulo nos centraremos en el paquete dplyr, otro miembro central de tidyverse. Ilustraremos las ideas clave usando datos del paquete nycflights13 y usaremos ggplot2 para ayudarnos a comprender los datos.\n\nlibrary(nycflights13)\nlibrary(tidyverse)\n#&gt; ‚îÄ‚îÄ Attaching core tidyverse packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 2.0.0 ‚îÄ‚îÄ\n#&gt; ‚úî dplyr     1.1.4     ‚úî readr     2.1.5\n#&gt; ‚úî forcats   1.0.0     ‚úî stringr   1.5.1\n#&gt; ‚úî ggplot2   3.5.1     ‚úî tibble    3.2.1\n#&gt; ‚úî lubridate 1.9.3     ‚úî tidyr     1.3.1\n#&gt; ‚úî purrr     1.0.2     \n#&gt; ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ\n#&gt; ‚úñ dplyr::filter() masks stats::filter()\n#&gt; ‚úñ dplyr::lag()    masks stats::lag()\n#&gt; ‚Ñπ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nTome nota del mensaje de conflictos que se imprime cuando carga el tidyverse. Te dice que dplyr sobrescribe algunas funciones en base R. Si desea utilizar la versi√≥n base de estas funciones despu√©s de cargar dplyr, deber√° utilizar sus nombres completos: stats::filter() y stats::lag(). Hasta ahora hemos ignorado en su mayor√≠a de qu√© paquete proviene una funci√≥n porque la mayor√≠a de las veces no importa. Sin embargo, conocer el paquete puede ayudarlo a encontrar ayuda y funciones relacionadas, por lo que cuando necesitemos ser precisos sobre de qu√© paquete proviene una funci√≥n, usaremos la misma sintaxis que R: nombrepaquete::nombrefuncion().\n\n3.1.2 nycflights13\nPara explorar los verbos b√°sicos de dplyr, usaremos nycflights13::flights. Este conjunto de datos contiene todos los 336,776 vuelos que partieron de la ciudad de Nueva York en 2013. Los datos provienen de la Oficina de Estad√≠sticas de Transporte de EE. UU. y est√°n documentados en ?flights.\n\nflights\n#&gt; # A tibble: 336,776 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nflights es un tibble, un tipo especial de data frame utilizado por tidyverse para evitar algunos errores comunes. La diferencia m√°s importante entre los tibbles y los data frames es la forma en que se imprimen los tibbles; est√°n dise√±ados para grandes conjuntos de datos, por lo que solo muestran las primeras filas y solo las columnas que caben en una pantalla. Hay algunas opciones para ver todo. Si est√° utilizando RStudio, lo m√°s conveniente es probablemente View(flights), que abrir√° una vista interactiva, desplazable y filtrable. De lo contrario, puede usar print(flights, width = Inf) para mostrar todas las columnas, o usar glimpse():\n\nglimpse(flights)\n#&gt; Rows: 336,776\n#&gt; Columns: 19\n#&gt; $ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013‚Ä¶\n#&gt; $ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1‚Ä¶\n#&gt; $ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1‚Ä¶\n#&gt; $ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 55‚Ä¶\n#&gt; $ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 60‚Ä¶\n#&gt; $ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2,‚Ä¶\n#&gt; $ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 8‚Ä¶\n#&gt; $ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 8‚Ä¶\n#&gt; $ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7,‚Ä¶\n#&gt; $ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\"‚Ä¶\n#&gt; $ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301‚Ä¶\n#&gt; $ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N‚Ä¶\n#&gt; $ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LG‚Ä¶\n#&gt; $ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IA‚Ä¶\n#&gt; $ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149‚Ä¶\n#&gt; $ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 73‚Ä¶\n#&gt; $ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6‚Ä¶\n#&gt; $ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59‚Ä¶\n#&gt; $ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-0‚Ä¶\n\nEn ambas vistas, los nombres de las variables van seguidos de abreviaturas que indican el tipo de cada variable: &lt;int&gt; es la abreviatura de entero, &lt;dbl&gt; es la abreviatura de doble (tambi√©n conocido como n√∫mero real), &lt;chr&gt; para car√°cter (tambi√©n conocido como cadenas) y &lt;dttm&gt; para fecha y hora. Estos son importantes porque las operaciones que puede realizar en una columna dependen mucho de su ‚Äútipo‚Äù.\n\n3.1.3 B√°sicos de dplyr\nEst√° a punto de aprender los principales verbos (funciones) de dplyr que le permitir√°n resolver la gran mayor√≠a de sus desaf√≠os de manipulaci√≥n de datos. Pero antes de discutir sus diferencias individuales, vale la pena se√±alar lo que tienen en com√∫n:\n\nEl primer argumento es siempre un data frame.\nLos argumentos subsiguientes normalmente describen en qu√© columnas operar, utilizando los nombres de las variables (sin comillas).\nLa salida es siempre un nuevo data frame.\n\nDebido a que cada verbo hace una cosa bien, resolver problemas complejos generalmente requerir√° combinar varios verbos, y lo haremos con la canalizaci√≥n |&gt;. Hablaremos m√°s sobre las canalizaciones en Secci√≥n 3.4, pero en resumen, una canalizaci√≥n toma la cosa a su izquierda y la pasa a la funci√≥n a su derecha para que x |&gt; f(y) sea equivalente a f(x, y), y x |&gt; f(y) |&gt; g(z) es equivalente a g(f(x, y), z). La forma m√°s f√°cil de leer pipe es ‚Äúentonces‚Äù. Eso hace posible tener una idea del siguiente c√≥digo aunque a√∫n no haya aprendido los detalles:\n\nflights |&gt;\n  filter(dest == \"IAH\") |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    arr_delay = mean(arr_delay, na.rm = TRUE)\n  )\n\nLos verbos de dplyr est√°n organizados en cuatro grupos seg√∫n lo que operan: filas, columnas, grupos o tablas. En las siguientes secciones, aprender√° los verbos m√°s importantes para filas, columnas y grupos, luego regresaremos a los verbos de uni√≥n que funcionan en tablas en Cap√≠tulo 19. ¬°Vamos a empezar!",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Transformaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-transform.html#filas",
    "href": "data-transform.html#filas",
    "title": "3¬† Transformaci√≥n de datos",
    "section": "\n3.2 Filas",
    "text": "3.2 Filas\nLos verbos m√°s importantes que operan en las filas de un conjunto de datos son filter(), que cambia qu√© filas est√°n presentes sin cambiar su orden, y arrange(), que cambia el orden de las filas sin cambiar cu√°les est√°n presentes. Ambas funciones solo afectan a las filas y las columnas no se modifican. Tambi√©n hablaremos de distinct(), que encuentra filas con valores √∫nicos pero, a diferencia de arrange() y filter(), tambi√©n puede modificar opcionalmente las columnas.\n\n3.2.1 filter()\n\nfilter() le permite mantener filas en funci√≥n de los valores de las columnas 1. El primer argumento es el data frame. El segundo argumento y los subsiguientes son las condiciones que deben cumplirse para mantener la fila. Por ejemplo, podr√≠amos encontrar todos los vuelos que salieron con m√°s de 120 minutos (dos horas) de retraso:\n\nflights |&gt; \n  filter(dep_delay &gt; 120)\n#&gt; # A tibble: 9,723 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      848           1835       853     1001           1950\n#&gt; 2  2013     1     1      957            733       144     1056            853\n#&gt; 3  2013     1     1     1114            900       134     1447           1222\n#&gt; 4  2013     1     1     1540           1338       122     2020           1825\n#&gt; 5  2013     1     1     1815           1325       290     2120           1542\n#&gt; 6  2013     1     1     1842           1422       260     1958           1535\n#&gt; # ‚Ñπ 9,717 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nAdem√°s de &gt; (mayor que), puede usar &gt;= (mayor o igual que), &lt; (menor que), &lt;= (menor o igual que), == (igual a) y != (no igual a). Tambi√©n puede combinar condiciones con & o , para indicar ‚Äúy‚Äù (verifique ambas condiciones) o con | para indicar ‚Äúo‚Äù (verifique cualquiera de las dos condiciones):\n\n# Vuelos que partieron el 1 de enero\nflights |&gt; \n  filter(month == 1 & day == 1)\n#&gt; # A tibble: 842 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 836 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\n# Vuelos que salieron en enero o febrero\nflights |&gt; \n  filter(month == 1 | month == 2)\n#&gt; # A tibble: 51,955 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 51,949 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nHay un atajo √∫til cuando est√°s combinando | y ==: %in%. Mantiene filas donde la variable es igual a uno de los valores de la derecha:\n\n# Una forma m√°s corta de seleccionar vuelos que partieron en enero o febrero\nflights |&gt; \n  filter(month %in% c(1, 2))\n#&gt; # A tibble: 51,955 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 51,949 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nVolveremos a estas comparaciones y operadores l√≥gicos con m√°s detalle en Cap√≠tulo 12.\nCuando ejecuta filter(), dplyr ejecuta la operaci√≥n de filtrado, crea un nuevo data frame y luego lo imprime. No modifica el conjunto de datos flights existente porque las funciones dplyr nunca modifican sus entradas. Para guardar el resultado, debe usar el operador de asignaci√≥n, &lt;-:\n\nene1 &lt;- flights |&gt; \n  filter(month == 1 & day == 1)\n\n\n3.2.2 Errores comunes\nCuando comienza con R, el error m√°s f√°cil de cometer es usar = en lugar de == al probar la igualdad. filter() te avisar√° cuando esto suceda:\n\nflights |&gt; \n  filter(month = 1)\n#&gt; Error in `filter()`:\n#&gt; ! We detected a named input.\n#&gt; ‚Ñπ This usually means that you've used `=` instead of `==`.\n#&gt; ‚Ñπ Did you mean `month == 1`?\n\nOtro error es escribir declaraciones ‚Äúo‚Äù como lo har√≠a en espa√±ol:\n\nflights |&gt; \n  filter(month == 1 | 2)\n\nEsto ‚Äúfunciona‚Äù, en el sentido de que no arroja un error, pero no hace lo que quieres porque | primero verifica la condici√≥n month == 1 y luego verifica la condici√≥n 2, que no es una condici√≥n sensata para comprobar. Aprenderemos m√°s sobre lo que sucede aqu√≠ y por qu√© en Secci√≥n 12.3.2.\n\n3.2.3 arrange()\n\narrange() cambia el orden de las filas seg√∫n el valor de las columnas. Se necesita un data frame y un conjunto de nombres de columna (o expresiones m√°s complicadas) para ordenar. Si proporciona m√°s de un nombre de columna, cada columna adicional se usar√° para desempatar los valores de las columnas anteriores. Por ejemplo, el siguiente c√≥digo ordena por hora de salida, que se distribuye en cuatro columnas. Obtenemos primero los primeros a√±os, luego, dentro de un a√±o, los primeros meses, etc.\n\nflights |&gt; \n  arrange(year, month, day, dep_time)\n#&gt; # A tibble: 336,776 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nPuede usar desc() en una columna dentro de arrange() para reordenar el marco de datos en funci√≥n de esa columna en orden descendente (de mayor a menor). Por ejemplo, este c√≥digo ordena los vuelos de mayor a menor retraso:\n\nflights |&gt; \n  arrange(desc(dep_delay))\n#&gt; # A tibble: 336,776 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     9      641            900      1301     1242           1530\n#&gt; 2  2013     6    15     1432           1935      1137     1607           2120\n#&gt; 3  2013     1    10     1121           1635      1126     1239           1810\n#&gt; 4  2013     9    20     1139           1845      1014     1457           2210\n#&gt; 5  2013     7    22      845           1600      1005     1044           1815\n#&gt; 6  2013     4    10     1100           1900       960     1342           2211\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nTenga en cuenta que la cantidad de filas no ha cambiado: solo estamos organizando los datos, no los estamos filtrando.\n\n3.2.4 distinct()\n\ndistinct() encuentra todas las filas √∫nicas en un conjunto de datos, por lo que, en un sentido t√©cnico, opera principalmente en las filas. Sin embargo, la mayor√≠a de las veces, querr√° la combinaci√≥n distinta de algunas variables, por lo que tambi√©n puede proporcionar opcionalmente nombres de columna:\n\n# Eliminar filas duplicadas, si las hay\nflights |&gt; \n  distinct()\n#&gt; # A tibble: 336,776 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\n# Encuentre todos los pares √∫nicos de origen y destino\nflights |&gt; \n  distinct(origin, dest)\n#&gt; # A tibble: 224 √ó 2\n#&gt;   origin dest \n#&gt;   &lt;chr&gt;  &lt;chr&gt;\n#&gt; 1 EWR    IAH  \n#&gt; 2 LGA    IAH  \n#&gt; 3 JFK    MIA  \n#&gt; 4 JFK    BQN  \n#&gt; 5 LGA    ATL  \n#&gt; 6 EWR    ORD  \n#&gt; # ‚Ñπ 218 more rows\n\nAlternativamente, si desea mantener otras columnas al filtrar filas √∫nicas, puede usar la opci√≥n .keep_all = TRUE.\n\nflights |&gt; \n  distinct(origin, dest, .keep_all = TRUE)\n#&gt; # A tibble: 224 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 218 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nNo es una coincidencia que todos estos vuelos distintos sean el 1 de enero: distinct() encontrar√° la primera aparici√≥n de una fila √∫nica en el conjunto de datos y descartar√° el resto.\nSi quieres encontrar el n√∫mero de ocurrencias, es mejor que cambies distinct() por count(), y con el argumento sort = TRUE puedes organizarlas en orden descendente seg√∫n el n√∫mero de ocurrencias. Aprender√° m√°s sobre el conteo en Secci√≥n 13.3.\n\nflights |&gt;\n  count(origin, dest, sort = TRUE)\n#&gt; # A tibble: 224 √ó 3\n#&gt;   origin dest      n\n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n#&gt; 1 JFK    LAX   11262\n#&gt; 2 LGA    ATL   10263\n#&gt; 3 LGA    ORD    8857\n#&gt; 4 JFK    SFO    8204\n#&gt; 5 LGA    CLT    6168\n#&gt; 6 EWR    ORD    6100\n#&gt; # ‚Ñπ 218 more rows\n\n\n3.2.5 Ejercicios\n\n\nEn una canalizaci√≥n √∫nica para cada condici√≥n, busque todos los vuelos que cumplan la condici√≥n:\n\nTuvo un retraso de llegada de dos o m√°s horas.\nVol√≥ a Houston (IAH o HOU) C. Fueron operados por United, American o Delta\nSalida en verano (julio, agosto y septiembre)\nLleg√≥ m√°s de dos horas tarde, pero no se fue tarde\nSe retrasaron al menos una hora, pero recuperaron m√°s de 30 minutos en vuelo\n\n\nOrdene flights para encontrar los vuelos con mayores retrasos en la salida. Encuentra los vuelos que salieron m√°s temprano en la ma√±ana.\nOrdene flights para encontrar los vuelos m√°s r√°pidos (Sugerencia: intente ordenar por un c√°lculo).\n¬øHubo un vuelo todos los d√≠as de 2013?\n¬øQu√© vuelos viajaron la mayor distancia? ¬øCu√°l recorri√≥ la menor distancia?\n¬øImporta en qu√© orden us√≥ filter() y arrange() si est√° usando ambos? ¬øPor qu√©/por qu√© no? Piense en los resultados y cu√°nto trabajo tendr√≠an que hacer las funciones.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Transformaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-transform.html#columnas",
    "href": "data-transform.html#columnas",
    "title": "3¬† Transformaci√≥n de datos",
    "section": "\n3.3 Columnas",
    "text": "3.3 Columnas\nHay cuatro verbos importantes que afectan las columnas sin cambiar las filas: mutate() crea nuevas columnas que se derivan de las columnas existentes, select() cambia qu√© columnas est√°n presentes, rename() cambia los nombres de las columnas, y relocate() cambia las posiciones de las columnas.\n\n3.3.1 mutate()\n\nEl trabajo de mutate() es agregar nuevas columnas que se calculan a partir de las columnas existentes. En los cap√≠tulos de transformaci√≥n, aprender√° un gran conjunto de funciones que puede usar para manipular diferentes tipos de variables. Por ahora, nos apegaremos al √°lgebra b√°sica, que nos permite calcular la ganancia, cu√°nto tiempo recuper√≥ un vuelo retrasado en el aire y la velocidad en millas por hora:\n\nflights |&gt; \n  mutate(\n    ganancia = dep_delay - arr_delay,\n    velocidad = distance / air_time * 60\n  )\n#&gt; # A tibble: 336,776 √ó 21\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nDe forma predeterminada, mutate() agrega nuevas columnas en el lado derecho de su conjunto de datos, lo que dificulta ver lo que est√° sucediendo aqu√≠. Podemos usar el argumento .before para agregar las variables al lado izquierdo 2:\n\nflights |&gt; \n  mutate(\n    ganancia = dep_delay - arr_delay,\n    velocidad = distance / air_time * 60,\n    .before = 1\n  )\n#&gt; # A tibble: 336,776 √ó 21\n#&gt;   ganancia velocidad  year month   day dep_time sched_dep_time dep_delay\n#&gt;      &lt;dbl&gt;     &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;\n#&gt; 1       -9      370.  2013     1     1      517            515         2\n#&gt; 2      -16      374.  2013     1     1      533            529         4\n#&gt; 3      -31      408.  2013     1     1      542            540         2\n#&gt; 4       17      517.  2013     1     1      544            545        -1\n#&gt; 5       19      394.  2013     1     1      554            600        -6\n#&gt; 6      -16      288.  2013     1     1      554            558        -4\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 13 more variables: arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, ‚Ä¶\n\nEl . es un signo de que .before es un argumento para la funci√≥n, no el nombre de una tercera variable nueva que estamos creando. Tambi√©n puede usar .after para agregar despu√©s de una variable, y tanto en .before como en .after puede usar el nombre de la variable en lugar de una posici√≥n. Por ejemplo, podr√≠amos agregar las nuevas variables despu√©s de day:\n\nflights |&gt; \n  mutate(\n    ganancia = dep_delay - arr_delay,\n    velocidad = distance / air_time * 60,\n    .after = day\n  )\n\nAlternativamente, puede controlar qu√© variables se mantienen con el argumento .keep. Un argumento particularmente √∫til es \"used\", que especifica que solo mantenemos las columnas involucradas o creadas en el paso mutate(). Por ejemplo, la siguiente salida contendr√° solo las variables dep_delay, arr_delay, air_time, gain, hours y gain_per_hour.\n\nflights |&gt; \n  mutate(\n    ganancia = dep_delay - arr_delay,\n    horas = air_time / 60,\n    ganancia_por_hora = ganancia / horas,\n    .keep = \"used\"\n  )\n\nTenga en cuenta que, dado que no hemos asignado el resultado del c√°lculo anterior a flights, las nuevas variables ganancia, horas y ganancia_por_hora solo se imprimir√°n, pero no se almacenar√°n en un data frame. Y si queremos que est√©n disponibles en un data frame para uso futuro, debemos pensar detenidamente si queremos que el resultado se asigne de nuevo a flights, sobrescribiendo el data frame original con muchas m√°s variables, o a un nuevo objeto. A menudo, la respuesta correcta es un nuevo objeto que se nombra de manera informativa para indicar su contenido, por ejemplo, delay_gain, pero tambi√©n puede tener buenas razones para sobrescribir flights.\n\n3.3.2 select()\n\nNo es raro obtener conjuntos de datos con cientos o incluso miles de variables. En esta situaci√≥n, el primer desaf√≠o suele ser centrarse en las variables que le interesan. select() le permite acercarse r√°pidamente a un subconjunto √∫til utilizando operaciones basadas en los nombres de las variables:\n\n\nSeleccionar columnas por nombre\n\nflights |&gt;\n  select(year, month, day)\n\n\n\nSeleccionar todas las columnas entre year y day\n\nflights |&gt; \n  select(year:day)\n\n\n\nSeleccionar todas las columnas excepto aquellas entre year y day (incluyendolas)\n\nflights |&gt; \n  select(!year:day)\n\nHist√≥ricamente, esta operaci√≥n se realizaba con - en lugar de !, por lo que es probable que la veas en la naturaleza. Estos dos operadores tienen el mismo prop√≥sito pero con sutiles diferencias de comportamiento. Recomendamos usar ! porque se lee como ‚Äúno‚Äù y combina bien con & y |.\n\n\nSeleccionar todas las columnas que son caracteres\n\nflights |&gt; \n  select(where(is.character))\n\n\n\nHay una serie de funciones auxiliares que puede usar dentro de select():\n\n\nstarts_with(\"abc\"): coincide con los nombres que comienzan con ‚Äúabc‚Äù.\n\nends_with(\"xyz\"): encuentra nombres que terminan en ‚Äúxyz‚Äù.\n\ncontains(\"ijk\"): encuentra nombres que contienen ‚Äúijk‚Äù.\n\nnum_range(\"x\", 1:3): coincide con x1, x2 y x3.\n\nVer ?select para m√°s detalles. Una vez que conozca las expresiones regulares (el tema de Cap√≠tulo 15), tambi√©n podr√° usar matches() para seleccionar variables que coincidan con un patr√≥n.\nPuede cambiar el nombre de las variables a medida que las selecciona con select() usando =. El nuevo nombre aparece en el lado izquierdo de =, y la variable antigua aparece en el lado derecho:\n\nflights |&gt; \n  select(tail_num = tailnum)\n#&gt; # A tibble: 336,776 √ó 1\n#&gt;   tail_num\n#&gt;   &lt;chr&gt;   \n#&gt; 1 N14228  \n#&gt; 2 N24211  \n#&gt; 3 N619AA  \n#&gt; 4 N804JB  \n#&gt; 5 N668DN  \n#&gt; 6 N39463  \n#&gt; # ‚Ñπ 336,770 more rows\n\n\n3.3.3 rename()\n\nSi desea conservar todas las variables existentes y cambiar el nombre de algunas, puede usar rename() en lugar de select():\n\nflights |&gt; \n  rename(tail_num = tailnum)\n#&gt; # A tibble: 336,776 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nSi tiene un mont√≥n de columnas con nombres inconsistentes y ser√≠a doloroso arreglarlas todas a mano, consulte janitor::clean_names() que proporciona una limpieza automatizada √∫til.\n\n3.3.4 relocate()\n\nUsa relocate() para mover las variables. Es posible que desee recopilar variables relacionadas juntas o mover variables importantes al frente. Por defecto relocate() mueve las variables al frente:\n\nflights |&gt; \n  relocate(time_hour, air_time)\n#&gt; # A tibble: 336,776 √ó 19\n#&gt;   time_hour           air_time  year month   day dep_time sched_dep_time\n#&gt;   &lt;dttm&gt;                 &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1 2013-01-01 05:00:00      227  2013     1     1      517            515\n#&gt; 2 2013-01-01 05:00:00      227  2013     1     1      533            529\n#&gt; 3 2013-01-01 05:00:00      160  2013     1     1      542            540\n#&gt; 4 2013-01-01 05:00:00      183  2013     1     1      544            545\n#&gt; 5 2013-01-01 06:00:00      116  2013     1     1      554            600\n#&gt; 6 2013-01-01 05:00:00      150  2013     1     1      554            558\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 12 more variables: dep_delay &lt;dbl&gt;, arr_time &lt;int&gt;, ‚Ä¶\n\nTambi√©n puedes especificar d√≥nde ponerlos usando los argumentos .before y .after, al igual que en mutate():\n\nflights |&gt; \n  relocate(year:dep_time, .after = time_hour)\nflights |&gt; \n  relocate(starts_with(\"arr\"), .before = dep_time)\n\n\n3.3.5 Ejercicios\n\nCompare dep_time, sched_dep_time, and dep_delay.\nHaga una lluvia de ideas sobre tantas formas como sea posible para seleccionar dep_time, dep_delay, arr_time y arr_delay de flights.\n¬øQu√© sucede si especifica el nombre de la misma variable varias veces en una llamada select()?\n\n¬øQu√© hace la funci√≥n any_of()? ¬øPor qu√© podr√≠a ser √∫til junto con este vector?\n\nvariables &lt;- c(\"year\", \"month\", \"day\", \"dep_delay\", \"arr_delay\")\n\n\n\n¬øTe sorprende el resultado de ejecutar el siguiente c√≥digo? ¬øC√≥mo tratan los ayudantes de select con las may√∫sculas y min√∫sculas de forma predeterminada? ¬øC√≥mo se puede cambiar ese valor predeterminado?\n\nflights |&gt; select(contains(\"TIME\"))\n\n\nCambie el nombre de air_time a air_time_min para indicar las unidades de medida y mu√©valo al comienzo del data frame.\n\n¬øPor qu√© no funciona lo siguiente y qu√© significa el error?\n\nflights |&gt; \n  select(tailnum) |&gt; \n  arrange(arr_delay)\n#&gt; Error in `arrange()`:\n#&gt; ‚Ñπ In argument: `..1 = arr_delay`.\n#&gt; Caused by error:\n#&gt; ! object 'arr_delay' not found",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Transformaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-transform.html#sec-the-pipe",
    "href": "data-transform.html#sec-the-pipe",
    "title": "3¬† Transformaci√≥n de datos",
    "section": "\n3.4 Canalizaciones o pipe",
    "text": "3.4 Canalizaciones o pipe\nLe mostramos ejemplos simples de las canalizaciones anteriormente, pero su verdadero poder surge cuando comienza a combinar varios verbos. Por ejemplo, imagine que desea encontrar vuelos r√°pidos al aeropuerto IAH de Houston: debe combinar filter(), mutate(), select() y arrange():\n\nflights |&gt; \n  filter(dest == \"IAH\") |&gt; \n  mutate(speed = distance / air_time * 60) |&gt;\n  select(year:day, dep_time, carrier, flight, speed) |&gt;\n  arrange(desc(speed))\n#&gt; # A tibble: 7,198 √ó 7\n#&gt;    year month   day dep_time carrier flight speed\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n#&gt; 1  2013     7     9      707 UA         226  522.\n#&gt; 2  2013     8    27     1850 UA        1128  521.\n#&gt; 3  2013     8    28      902 UA        1711  519.\n#&gt; 4  2013     8    28     2122 UA        1022  519.\n#&gt; 5  2013     6    11     1628 UA        1178  515.\n#&gt; 6  2013     8    27     1017 UA         333  515.\n#&gt; # ‚Ñπ 7,192 more rows\n\nAunque esta canalizaci√≥n tiene cuatro pasos, es f√°cil de hojear porque los verbos aparecen al comienzo de cada l√≠nea: comience con los datos de flights, luego filtra por destino, luego crea la columana speed con mutate, luego selecciona las columnas deseadas y culmina ordenandolas en orden descendente por la columna speed.\n¬øQu√© pasar√≠a si no tuvi√©ramos la canalizaci√≥n? Podr√≠amos anidar cada llamada de funci√≥n dentro de la llamada anterior:\n\narrange(\n  select(\n    mutate(\n      filter(\n        flights,\n        dest == \"IAH\"\n      ),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n\nO podr√≠amos usar un mont√≥n de objetos intermedios:\n\nflights1 &lt;- filter(flights, dest == \"IAH\")\nflights2 &lt;- mutate(flights1, speed = distance / air_time * 60)\nflights3 &lt;- select(flights2, year:day, dep_time, carrier, flight, speed)\narrange(flights3, desc(speed))\n\nSi bien ambas formas tienen su tiempo y lugar, la canalizaci√≥n generalmente produce un c√≥digo de an√°lisis de datos que es m√°s f√°cil de escribir y leer.\nPara agregar la canalizaci√≥n a su c√≥digo, recomendamos usar el atajo de teclado incorporado Ctrl/Cmd + Shift + M. Deber√° realizar un cambio en sus opciones de RStudio para usar |&gt; en lugar de %&gt;% como se muestra en Figura¬†3.1; m√°s sobre %&gt;% en breve.\n485\n\n\n\n\n\n\n\nFigura¬†3.1: Para insertar |&gt;, aseg√∫rese de que la opci√≥n ‚ÄúUse native pipe operator‚Äù est√© marcada.\n\n\n\n\n\n\n\n\n\n\nmagrittr\n\n\n\nSi ha estado usando tidyverse por un tiempo, es posible que est√© familiarizado con la canalizaci√≥n %&gt;% proporcionada por el paquete magrittr. El paquete magrittr est√° incluido en el tidyverse principal, por lo que puede usar %&gt;% siempre que cargue el tidyverse:\n\nlibrary(tidyverse)\n\nmtcars %&gt;% \n  group_by(cyl) %&gt;%\n  summarize(n = n())\n\nPara casos simples, |&gt; y %&gt;% se comportan de manera id√©ntica. Entonces, ¬øpor qu√© recomendamos la canalizaci√≥n base? En primer lugar, debido a que es parte de la base R, siempre est√° disponible para su uso, incluso cuando no est√° utilizando el tidyverse. En segundo lugar, |&gt; es un poco m√°s simple que %&gt;%: en el tiempo entre la invenci√≥n de %&gt;% en 2014 y la inclusi√≥n de |&gt; en R 4.1.0 en 2021, ganamos una mejor comprensi√≥n de la canalizaci√≥n. Esto permiti√≥ que la implementaci√≥n base desechara caracter√≠sticas poco utilizadas y menos importantes.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Transformaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-transform.html#grupos",
    "href": "data-transform.html#grupos",
    "title": "3¬† Transformaci√≥n de datos",
    "section": "\n3.5 Grupos",
    "text": "3.5 Grupos\nHasta ahora ha aprendido acerca de las funciones que funcionan con filas y columnas. dplyr se vuelve a√∫n m√°s poderoso cuando agrega la capacidad de trabajar con grupos. En esta secci√≥n, nos centraremos en las funciones m√°s importantes: group_by(), summarize() y la familia de funciones slice.\n\n3.5.1 group_by()\n\nUse group_by() para dividir su conjunto de datos en grupos significativos para su an√°lisis:\n\nflights |&gt; \n  group_by(month)\n#&gt; # A tibble: 336,776 √ó 19\n#&gt; # Groups:   month [12]\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\ngroup_by() no cambia los datos pero, si observa detenidamente el resultado, notar√° que la salida indica que est√° ‚Äúagrupado por‚Äù mes (Groups: month [12]). Esto significa que las operaciones posteriores ahora funcionar√°n ‚Äúpor mes‚Äù. group_by() agrega esta caracter√≠stica agrupada (referida como clase) al marco de datos, lo que cambia el comportamiento de los verbos subsiguientes aplicados a los datos.\n\n3.5.2 summarize()\n\nLa operaci√≥n agrupada m√°s importante es un resumen, que, si se usa para calcular una sola estad√≠stica de resumen, reduce el data frame para tener una sola fila para cada grupo. En dplyr, esta operaci√≥n la realiza summarize()3, como se muestra en el siguiente ejemplo, que calcula el retraso de salida promedio por mes:\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(\n    avg_delay = mean(dep_delay)\n  )\n#&gt; # A tibble: 12 √ó 2\n#&gt;   month avg_delay\n#&gt;   &lt;int&gt;     &lt;dbl&gt;\n#&gt; 1     1        NA\n#&gt; 2     2        NA\n#&gt; 3     3        NA\n#&gt; 4     4        NA\n#&gt; 5     5        NA\n#&gt; 6     6        NA\n#&gt; # ‚Ñπ 6 more rows\n\n¬°UH oh! Algo sali√≥ mal y todos nuestros resultados son NAs (pronunciado ‚ÄúN-A‚Äù), el s√≠mbolo de R para el valor faltante. Esto sucedi√≥ porque a algunos de los vuelos observados les faltaban datos en la columna de demora, por lo que cuando calculamos la media que incluye esos valores, obtuvimos un resultado NA. Volveremos a discutir los valores faltantes en detalle en Cap√≠tulo 18, pero por ahora le diremos a la funci√≥n mean() que ignore todos los valores faltantes configurando el argumento na.rm en TRUE:\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE)\n  )\n#&gt; # A tibble: 12 √ó 2\n#&gt;   month avg_delay\n#&gt;   &lt;int&gt;     &lt;dbl&gt;\n#&gt; 1     1      10.0\n#&gt; 2     2      10.8\n#&gt; 3     3      13.2\n#&gt; 4     4      13.9\n#&gt; 5     5      13.0\n#&gt; 6     6      20.8\n#&gt; # ‚Ñπ 6 more rows\n\nPuede crear cualquier cantidad de res√∫menes en una sola llamada a summarize(). Aprender√° varios res√∫menes √∫tiles en los pr√≥ximos cap√≠tulos, pero un resumen muy √∫til es n(), que devuelve el n√∫mero de filas en cada grupo:\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    n = n()\n  )\n#&gt; # A tibble: 12 √ó 3\n#&gt;   month avg_delay     n\n#&gt;   &lt;int&gt;     &lt;dbl&gt; &lt;int&gt;\n#&gt; 1     1      10.0 27004\n#&gt; 2     2      10.8 24951\n#&gt; 3     3      13.2 28834\n#&gt; 4     4      13.9 28330\n#&gt; 5     5      13.0 28796\n#&gt; 6     6      20.8 28243\n#&gt; # ‚Ñπ 6 more rows\n\n¬°Los medios y los conteos pueden llevarlo sorprendentemente lejos en la ciencia de datos!\n\n3.5.3 Las funciones slice_\n\nHay cinco funciones √∫tiles que le permiten extraer filas espec√≠ficas dentro de cada grupo:\n\n\ndf |&gt; slice_head(n = 1) toma la primera fila de cada grupo.\n\ndf |&gt; slice_tail(n = 1) toma la √∫ltima fila de cada grupo.\n\ndf |&gt; slice_min(x, n = 1) toma la fila con el valor m√°s peque√±o de la columna x.\n\ndf |&gt; slice_max(x, n = 1) toma la fila con el mayor valor de la columna x.\n\ndf |&gt; slice_sample(n = 1) toma una fila aleatoria.\n\nPuede variar n para seleccionar m√°s de una fila, o en lugar de n =, puede usar prop = 0.1 para seleccionar (p.¬†ej.) el 10 % de las filas de cada grupo. Por ejemplo, el siguiente c√≥digo encuentra los vuelos que se retrasan m√°s al llegar a cada destino:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  slice_max(arr_delay, n = 1) |&gt; \n  relocate(dest)\n#&gt; # A tibble: 108 √ó 19\n#&gt; # Groups:   dest [105]\n#&gt;   dest   year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;   &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1 ABQ    2013     7    22     2145           2007        98      132\n#&gt; 2 ACK    2013     7    23     1139            800       219     1250\n#&gt; 3 ALB    2013     1    25      123           2000       323      229\n#&gt; 4 ANC    2013     8    17     1740           1625        75     2042\n#&gt; 5 ATL    2013     7    22     2257            759       898      121\n#&gt; 6 AUS    2013     7    10     2056           1505       351     2347\n#&gt; # ‚Ñπ 102 more rows\n#&gt; # ‚Ñπ 11 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, ‚Ä¶\n\nTenga en cuenta que hay 105 destinos, pero aqu√≠ tenemos 108 filas. ¬øQu√© pasa? slice_min() y slice_max() mantienen valores empatados por lo que n = 1 significa darme todas las filas con el valor m√°s alto. Si desea exactamente una fila por grupo, puede configurar whit_ties = FALSE.\nEsto es similar a calcular el retraso m√°ximo con summarize(), pero obtienes la fila correspondiente completa (o filas si hay un empate) en lugar de la estad√≠stica de resumen √∫nica.\n\n3.5.4 Agrupaci√≥n por m√∫ltiples variables\nPuede crear grupos utilizando m√°s de una variable. Por ejemplo, podr√≠amos hacer un grupo para cada fecha.\n\ndaily &lt;- flights |&gt;  \n  group_by(year, month, day)\ndaily\n#&gt; # A tibble: 336,776 √ó 19\n#&gt; # Groups:   year, month, day [365]\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nCuando resume un tibble agrupado por m√°s de una variable, cada resumen elimina el √∫ltimo grupo. En retrospectiva, esta no fue una excelente manera de hacer que esta funci√≥n funcionara, pero es dif√≠cil cambiarla sin romper el c√≥digo existente. Para que sea obvio lo que sucede, dplyr muestra un mensaje que le indica c√≥mo puede cambiar este comportamiento:\n\ndaily_flights &lt;- daily |&gt; \n  summarize(n = n())\n#&gt; `summarise()` has grouped output by 'year', 'month'. You can override using\n#&gt; the `.groups` argument.\n\nSi est√° satisfecho con este comportamiento, puede solicitarlo expl√≠citamente para suprimir el mensaje:\n\ndaily_flights &lt;- daily |&gt; \n  summarize(\n    n = n(), \n    .groups = \"drop_last\"\n  )\n\nAlternativamente, cambie el comportamiento predeterminado configurando un valor diferente, por ejemplo, \"drop\" para eliminar todas las agrupaciones o \"keep\" para conservar los mismos grupos.\n\n3.5.5 Desagrupar\nTambi√©n es posible que desee eliminar la agrupaci√≥n de un data frame sin utilizar summarize(). Puedes hacer esto con ungroup().\n\ndaily |&gt; \n  ungroup()\n#&gt; # A tibble: 336,776 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nAhora veamos qu√© sucede cuando resume un data frame no agrupado.\n\ndaily |&gt; \n  ungroup() |&gt;\n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    flights = n()\n  )\n#&gt; # A tibble: 1 √ó 2\n#&gt;   avg_delay flights\n#&gt;       &lt;dbl&gt;   &lt;int&gt;\n#&gt; 1      12.6  336776\n\nComo puede ver, cuando resume un data frame sin agrupar, obtiene una sola fila porque dplyr trata todas las filas en un data frame sin agrupar como pertenecientes a un grupo.\n\n3.5.6 .by\n\ndplyr 1.1.0 incluye una nueva sintaxis experimental para la agrupaci√≥n por operaci√≥n, el argumento .by. group_by() y ungroup() no van a desaparecer, pero ahora tambi√©n puedes usar el argumento .by para agrupar dentro de una sola operaci√≥n:\n\nflights |&gt; \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = month\n  )\n\nO si desea agrupar por m√∫ltiples variables:\n\nflights |&gt; \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = c(origin, dest)\n  )\n\n.by funciona con todos los verbos y tiene la ventaja de que no necesita usar el argumento .groups para suprimir el mensaje de agrupaci√≥n o ungroup() cuando haya terminado.\nNo nos enfocamos en esta sintaxis en este cap√≠tulo porque era muy nueva cuando se escribi√≥ el libro. Quer√≠amos mencionarlo porque creemos que es muy prometedor y es probable que sea bastante popular. Puede obtener m√°s informaci√≥n al respecto en la [publicaci√≥n de blog de dplyr 1.1.0] (https://www.tidyverse.org/blog/2023/02/dplyr-1-1-0-per-operation-grouping/).\n\n3.5.7 Ejercicios\n\n¬øQu√© operador tiene el peor promedio de retrasos? Desaf√≠o: ¬øpuede desentra√±ar los efectos de los malos aeropuertos frente a los malos transportistas? ¬øPor qu√©/por qu√© no? (Pista: piense en flights |&gt; group_by(carrier, dest) |&gt; summarize(n()))\nEncuentra los vuelos que m√°s se retrasan a la salida de cada destino.\n¬øC√≥mo var√≠an los retrasos a lo largo del d√≠a? Ilustra tu respuesta con un gr√°fico.\n¬øQu√© sucede si proporcionas una n negativa a slice_min() y amigos?\nExplique lo que hace count() en t√©rminos de los verbos dplyr que acaba de aprender. ¬øQu√© hace el argumento sort para count()?\n\nSupongamos que tenemos el siguiente data frame diminuto:\n\ndf &lt;- tibble(\n  x = 1:5,\n  y = c(\"a\", \"b\", \"a\", \"a\", \"b\"),\n  z = c(\"K\", \"K\", \"L\", \"L\", \"K\")\n)\n\n\n\nEscriba c√≥mo cree que se ver√° la salida, luego verifique si estuvo en lo correcto y describa qu√© hace group_by().\n\ndf |&gt;\n  group_by(y)\n\n\n\nEscriba c√≥mo cree que se ver√° la salida, luego verifique si estuvo en lo correcto y describa qu√© hace arrange(). Tambi√©n comente en qu√© se diferencia del group_by() en la parte (a).\n\ndf |&gt;\n  arrange(y)\n\n\n\nEscriba c√≥mo cree que se ver√° la salida, luego verifique si estuvo en lo correcto y describa qu√© hace la canalizaci√≥n.\n\ndf |&gt;\n  group_by(y) |&gt;\n  summarize(mean_x = mean(x))\n\n\n\nEscriba c√≥mo cree que se ver√° la salida, luego verifique si estuvo en lo correcto y describa qu√© hace la canalizaci√≥n. Luego, comenta lo que dice el mensaje.\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  summarize(mean_x = mean(x))\n\n\n\nEscriba c√≥mo cree que se ver√° la salida, luego verifique si estuvo en lo correcto y describa qu√© hace la canalizaci√≥n. ¬øEn qu√© se diferencia la salida de la del inciso d)?\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  summarize(mean_x = mean(x), .groups = \"drop\")\n\n\n\nEscriba c√≥mo cree que se ver√° la salida, luego verifique si estuvo en lo correcto y describa qu√© hace la canalizaci√≥n. ¬øEn qu√© se diferencian las salidas de las dos canalizaciones?\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  summarize(mean_x = mean(x))\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  mutate(mean_x = mean(x))",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Transformaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-transform.html#sec-sample-size",
    "href": "data-transform.html#sec-sample-size",
    "title": "3¬† Transformaci√≥n de datos",
    "section": "\n3.6 Caso de estudio: agregados y tama√±o de la muestra",
    "text": "3.6 Caso de estudio: agregados y tama√±o de la muestra\nSiempre que realice una agregaci√≥n, siempre es una buena idea incluir un conteo (n()). De esa manera, puede asegurarse de no sacar conclusiones basadas en cantidades muy peque√±as de datos. Demostraremos esto con algunos datos de b√©isbol del paquete Lahman. En concreto, compararemos la proporci√≥n de veces que un jugador acierta (H) frente al n√∫mero de veces que intenta poner la pelota en juego (AB):\n\nbatters &lt;- Lahman::Batting |&gt; \n  group_by(playerID) |&gt; \n  summarize(\n    performance = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),\n    n = sum(AB, na.rm = TRUE)\n  )\nbatters\n#&gt; # A tibble: 20,469 √ó 3\n#&gt;   playerID  performance     n\n#&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 aardsda01      0          4\n#&gt; 2 aaronha01      0.305  12364\n#&gt; 3 aaronto01      0.229    944\n#&gt; 4 aasedo01       0          5\n#&gt; 5 abadan01       0.0952    21\n#&gt; 6 abadfe01       0.111      9\n#&gt; # ‚Ñπ 20,463 more rows\n\nCuando graficamos la habilidad del bateador (medida por el promedio de bateo, performance) contra el n√∫mero de oportunidades para batear la pelota (medida por veces al bate, n), se ven dos patrones:\n\nLa variaci√≥n en el performance es mayor entre los jugadores con menos turnos al bate. La forma de esta gr√°fica es muy caracter√≠stica: cada vez que grafica una media (u otras estad√≠sticas de resumen) frente al tama√±o del grupo, ver√° que la variaci√≥n disminuye a medida que aumenta el tama√±o de la muestra 4.\nHay una correlaci√≥n positiva entre la habilidad (performance) y las oportunidades de golpear la pelota (n) porque los equipos quieren dar a sus mejores bateadores la mayor cantidad de oportunidades para golpear la pelota.\n\n\nbatters |&gt; \n  filter(n &gt; 100) |&gt; \n  ggplot(aes(x = n, y = performance)) +\n  geom_point(alpha = 1 / 10) + \n  geom_smooth(se = FALSE)\n\n\n\n\n\n\n\nTenga en cuenta el pr√°ctico patr√≥n para combinar ggplot2 y dplyr. Solo debe recordar cambiar de |&gt;, para el procesamiento de conjuntos de datos, a + para agregar capas a su gr√°fico.\nEsto tambi√©n tiene implicaciones importantes para la clasificaci√≥n. Si clasifica ingenuamente en desc (performance), las personas con los mejores promedios de bateo son claramente las que intentaron poner la pelota en juego muy pocas veces y dieron un hit, no son necesariamente los jugadores m√°s h√°biles :\n\nbatters |&gt; \n  arrange(desc(performance))\n#&gt; # A tibble: 20,469 √ó 3\n#&gt;   playerID  performance     n\n#&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 abramge01           1     1\n#&gt; 2 alberan01           1     1\n#&gt; 3 banisje01           1     1\n#&gt; 4 bartocl01           1     1\n#&gt; 5 bassdo01            1     1\n#&gt; 6 birasst01           1     2\n#&gt; # ‚Ñπ 20,463 more rows\n\nPuede encontrar una buena explicaci√≥n de este problema y c√≥mo superarlo en http://varianceexplained.org/r/empirical_bayes_baseball/ y https://www.evanmiller.org/how-not-to-sort-by-average-rating.html.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Transformaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-transform.html#resumen",
    "href": "data-transform.html#resumen",
    "title": "3¬† Transformaci√≥n de datos",
    "section": "\n3.7 Resumen",
    "text": "3.7 Resumen\nEn este cap√≠tulo, ha aprendido las herramientas que proporciona dplyr para trabajar con data frames. Las herramientas se agrupan aproximadamente en tres categor√≠as: las que manipulan las filas (como filter() y arrange()), las que manipulan las columnas (como select() y mutate()), y las que que manipulan grupos (como group_by() y summarize()). En este cap√≠tulo, nos hemos centrado en estas herramientas de ‚Äúdata frame completo‚Äù, pero a√∫n no ha aprendido mucho sobre lo que puede hacer con la variable individual. Volveremos a eso en la parte Transformar del libro, donde cada cap√≠tulo le brindar√° herramientas para un tipo espec√≠fico de variable.\nEn el pr√≥ximo cap√≠tulo, regresaremos al flujo de trabajo para discutir la importancia del estilo del c√≥digo, manteniendo su c√≥digo bien organizado para que usted y otros puedan leerlo y comprenderlo f√°cilmente.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Transformaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-transform.html#footnotes",
    "href": "data-transform.html#footnotes",
    "title": "3¬† Transformaci√≥n de datos",
    "section": "",
    "text": "M√°s adelante, aprender√° sobre la familia slice_*(), que le permite elegir filas en funci√≥n de sus posiciones.‚Ü©Ô∏é\nRecuerde que en RStudio, la forma m√°s f√°cil de ver un conjunto de datos con muchas columnas es View().‚Ü©Ô∏é\nO summarise(), si prefiere ingl√©s brit√°nico.‚Ü©Ô∏é\n*cough* the law of large numbers *cough*.‚Ü©Ô∏é",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Transformaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "workflow-style.html",
    "href": "workflow-style.html",
    "title": "4¬† Flujo de trabajo: estilo de c√≥digo",
    "section": "",
    "text": "4.1 Nombres\nUn buen estilo de codificaci√≥n es como la puntuaci√≥n correcta: puede arregl√°rselas sin ella, pero seguro que hace que todo sea m√°s f√°cil de leer. Incluso como un programador muy nuevo, es una buena idea trabajar en su estilo de c√≥digo. El uso de un estilo consistente hace que sea m√°s f√°cil para los dem√°s (¬°incluido el futuro usted!) Leer su trabajo y es particularmente importante si necesita ayuda de otra persona. Este cap√≠tulo presentar√° los puntos m√°s importantes de la gu√≠a de estilo de tidyverse, que se utiliza a lo largo de este libro.\nDise√±ar su c√≥digo se sentir√° un poco tedioso al principio, pero si lo practica, pronto se convertir√° en una segunda naturaleza. Adem√°s, hay algunas herramientas excelentes para cambiar r√°pidamente el estilo del c√≥digo existente, como el paquete styler de Lorenz Walthert. Una vez que lo haya instalado con install.packages(\"styler\"), una manera f√°cil de usarlo es a trav√©s de la paleta de comandos de RStudio. La paleta de comandos le permite usar cualquier comando integrado de RStudio y muchos complementos proporcionados por paquetes. Abra la paleta presionando Cmd/Ctrl + Shift + P, luego escriba ‚Äústyler‚Äù para ver todos los accesos directos que ofrece styler. Figura¬†4.1 muestra los resultados.\nUsaremos los paquetes tidyverse y nycflights13 para ejemplos de c√≥digo en este cap√≠tulo.\nHablamos brevemente sobre nombres en Secci√≥n 2.3. Recuerde que los nombres de variables (los creados por &lt;- y los creados por mutate()) deben usar solo letras min√∫sculas, n√∫meros y _. Use _ para separar palabras dentro de un nombre.\n# Ejemplo de como debe ser:\nvuelos_cortos &lt;- flights |&gt; filter(air_time &lt; 60)\n\n# Ejemplo de como no debe ser:\nVUELOSCORTOS &lt;- flights |&gt; filter(air_time &lt; 60)\nComo regla general, es mejor preferir nombres largos y descriptivos que sean f√°ciles de entender en lugar de nombres concisos que se escriban r√°pidamente. Los nombres cortos ahorran relativamente poco tiempo al escribir c√≥digo (especialmente porque el autocompletado lo ayudar√° a terminar de escribirlos), pero puede llevar mucho tiempo cuando vuelve al c√≥digo antiguo y se ve obligado a descifrar una abreviatura cr√≠ptica.\nSi tiene un mont√≥n de nombres para cosas relacionadas, haga todo lo posible para ser coherente. Es f√°cil que surjan inconsistencias cuando olvidas una convenci√≥n anterior, as√≠ que no te sientas mal si tienes que volver atr√°s y cambiar el nombre de las cosas. En general, si tiene un mont√≥n de variables que son una variaci√≥n de un tema, es mejor que les d√© un prefijo com√∫n en lugar de un sufijo com√∫n porque la funci√≥n de autocompletar funciona mejor al comienzo de una variable.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Flujo de trabajo: estilo de c√≥digo</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#espacios",
    "href": "workflow-style.html#espacios",
    "title": "4¬† Flujo de trabajo: estilo de c√≥digo",
    "section": "\n4.2 Espacios",
    "text": "4.2 Espacios\nColoque espacios a cada lado de los operadores matem√°ticos aparte de ^ (es decir, +, -, ==, &lt;, ‚Ä¶), y alrededor del operador de asignaci√≥n (&lt;-).\n\n# Ejemplo de como debe ser:\nz &lt;- (a + b)^2 / d\n\n# Ejemplo de como no debe ser:\nz&lt;-( a + b ) ^ 2/d\n\nNo ponga espacios dentro o fuera de los par√©ntesis para las llamadas a funciones normales. Siempre ponga un espacio despu√©s de una coma, como en espa√±ol est√°ndar.\n\n# Ejemplo de como debe ser:\nmean(x, na.rm = TRUE)\n\n# Ejemplo de como no debe ser:\nmean (x ,na.rm=TRUE)\n\nEst√° bien agregar espacios adicionales si mejora la alineaci√≥n. Por ejemplo, si est√° creando m√∫ltiples variables en mutate(), es posible que desee agregar espacios para que todos los = se alineen.1 Esto hace que sea m√°s f√°cil hojear el c√≥digo.\n\nflights |&gt; \n  mutate(\n    speed      = distance/air_time,\n    dep_hour   = dep_time %/% 100,\n    dep_minute = dep_time %%  100\n  )",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Flujo de trabajo: estilo de c√≥digo</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#sec-pipes",
    "href": "workflow-style.html#sec-pipes",
    "title": "4¬† Flujo de trabajo: estilo de c√≥digo",
    "section": "\n4.3 Pipes",
    "text": "4.3 Pipes\n|&gt; siempre debe tener un espacio antes y, por lo general, debe ser lo √∫ltimo en una l√≠nea. Esto hace que sea m√°s f√°cil agregar nuevos pasos, reorganizar pasos existentes, modificar elementos dentro de un paso y obtener una vista de 10,000 pies hojeando los verbos en el lado izquierdo.\n\n# Ejemplo de como debe ser: \nflights |&gt;  \n  filter(!is.na(arr_delay), !is.na(tailnum)) |&gt; \n  count(dest)\n\n# Ejemplo de como no debe ser:\nflights|&gt;filter(!is.na(arr_delay), !is.na(tailnum))|&gt;count(dest)\n\nSi la funci√≥n que est√° canalizando tiene argumentos con nombre (como mutate() o summarize()), coloque cada argumento en una nueva l√≠nea. Si la funci√≥n no tiene argumentos con nombre (como select() o filter()), mant√©n todo en una l√≠nea a menos que no encaje, en cuyo caso deber√≠as poner cada argumento en su propia l√≠nea.\n\n# Ejemplo de como debe ser:\nflights |&gt;  \n  group_by(tailnum) |&gt; \n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE),\n    n = n()\n  )\n\n# Ejemplo de como no debe ser:\nflights |&gt;\n  group_by(\n    tailnum\n  ) |&gt; \n  summarize(delay = mean(arr_delay, na.rm = TRUE), n = n())\n\nDespu√©s del primer paso de la canalizaci√≥n, sangra cada l√≠nea con dos espacios. RStudio colocar√° autom√°ticamente los espacios despu√©s de un salto de l√≠nea despu√©s de |&gt; . Si est√° colocando cada argumento en su propia l√≠nea, sangre con dos espacios adicionales. Aseg√∫rese de que ) est√© en su propia l√≠nea y sin sangr√≠a para que coincida con la posici√≥n horizontal del nombre de la funci√≥n.\n\n# Ejemplo de como debe ser:\nflights |&gt;  \n  group_by(tailnum) |&gt; \n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE),\n    n = n()\n  )\n\n# Ejemplo de como no debe ser:\nflights|&gt;\n  group_by(tailnum) |&gt; \n  summarize(\n             delay = mean(arr_delay, na.rm = TRUE), \n             n = n()\n           )\n\n# Avoid\nflights|&gt;\n  group_by(tailnum) |&gt; \n  summarize(\n  delay = mean(arr_delay, na.rm = TRUE), \n  n = n()\n  )\n\nEst√° bien eludir algunas de estas reglas si su canalizaci√≥n se ajusta f√°cilmente a una l√≠nea. Pero en nuestra experiencia colectiva, es com√∫n que los fragmentos cortos crezcan m√°s, por lo que generalmente ahorrar√° tiempo a largo plazo si comienza con todo el espacio vertical que necesita.\n\n# Esto encaja de forma compacta en una l√≠nea.\ndf |&gt; mutate(y = x + 1)\n\n# Si bien esto ocupa 4 veces m√°s l√≠neas, se extiende f√°cilmente a\n# m√°s variables y m√°s pasos en el futuro\ndf |&gt; \n  mutate(\n    y = x + 1\n  )\n\nFinalmente, tenga cuidado al escribir canalizaciones muy largas, digamos m√°s de 10-15 l√≠neas. Trate de dividirlas en subtareas m√°s peque√±as, dando a cada tarea un nombre informativo. Los nombres ayudar√°n al lector a comprender lo que est√° sucediendo y facilitar√°n la verificaci√≥n de que los resultados intermedios son los esperados. Siempre que pueda dar a algo un nombre informativo, debe darle un nombre informativo, por ejemplo, cuando cambia fundamentalmente la estructura de los datos, por ejemplo, despu√©s de pivotar o resumir. ¬°No esperes hacerlo bien la primera vez! Esto significa romper canalizaciones√≠as largas si hay estados intermedios que pueden obtener buenos nombres.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Flujo de trabajo: estilo de c√≥digo</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#ggplot2",
    "href": "workflow-style.html#ggplot2",
    "title": "4¬† Flujo de trabajo: estilo de c√≥digo",
    "section": "\n4.4 ggplot2",
    "text": "4.4 ggplot2\nLas mismas reglas b√°sicas que se aplican a pipe tambi√©n se aplican a ggplot2; simplemente trate + de la misma manera que |&gt;.\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE)\n  ) |&gt; \n  ggplot(aes(x = month, y = delay)) +\n  geom_point() + \n  geom_line()\n\nNuevamente, si no puede incluir todos los argumentos de una funci√≥n en una sola l√≠nea, coloque cada argumento en su propia l√≠nea:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(\n    distance = mean(distance),\n    speed = mean(distance / air_time, na.rm = TRUE)\n  ) |&gt; \n  ggplot(aes(x = distance, y = speed)) +\n  geom_smooth(\n    method = \"loess\",\n    span = 0.5,\n    se = FALSE, \n    color = \"white\", \n    linewidth = 4\n  ) +\n  geom_point()\n\nEst√© atento a la transici√≥n de |&gt; a +. Desear√≠amos que esta transici√≥n no fuera necesaria, pero desafortunadamente, ggplot2 se escribi√≥ antes de que se descubriera la canalizaci√≥n.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Flujo de trabajo: estilo de c√≥digo</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#seccionamiento-de-comentarios",
    "href": "workflow-style.html#seccionamiento-de-comentarios",
    "title": "4¬† Flujo de trabajo: estilo de c√≥digo",
    "section": "\n4.5 Seccionamiento de comentarios",
    "text": "4.5 Seccionamiento de comentarios\nA medida que sus secuencias de comandos se hacen m√°s largas, puede usar comentarios de secci√≥n para dividir su archivo en partes manejables:\n\n# Cargar datos ----------------------------------\n\n# Graficar datos --------------------------------\n\nRStudio proporciona un atajo de teclado para crear estos encabezados (Cmd/Ctrl + Shift + R), y los mostrar√° en el men√∫ desplegable de navegaci√≥n de c√≥digo en la parte inferior izquierda del editor, como se muestra en Figura¬†4.2.\n\n\n\n\n\n\n\nFigura¬†4.2: Despu√©s de agregar comentarios de secci√≥n a su secuencia de comandos, puede navegar f√°cilmente a ellos usando la herramienta de navegaci√≥n de c√≥digo en el editor de secuencias de comandos abajo a la izquierda.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Flujo de trabajo: estilo de c√≥digo</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#ejercicios",
    "href": "workflow-style.html#ejercicios",
    "title": "4¬† Flujo de trabajo: estilo de c√≥digo",
    "section": "\n4.6 Ejercicios",
    "text": "4.6 Ejercicios\n\n\nCambie el estilo de las siguientes canalizaciones siguiendo las pautas anteriores.\n\nflights|&gt;filter(dest==\"IAH\")|&gt;group_by(year,month,day)|&gt;summarize(n=n(),\ndelay=mean(arr_delay,na.rm=TRUE))|&gt;filter(n&gt;10)\n\nflights|&gt;filter(carrier==\"UA\",dest%in%c(\"IAH\",\"HOU\"),sched_dep_time&gt;\n0900,sched_arr_time&lt;2000)|&gt;group_by(flight)|&gt;summarize(delay=mean(\narr_delay,na.rm=TRUE),cancelled=sum(is.na(arr_delay)),n=n())|&gt;filter(n&gt;10)",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Flujo de trabajo: estilo de c√≥digo</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#resumen",
    "href": "workflow-style.html#resumen",
    "title": "4¬† Flujo de trabajo: estilo de c√≥digo",
    "section": "\n4.7 Resumen",
    "text": "4.7 Resumen\nEn este cap√≠tulo, ha aprendido los principios m√°s importantes del estilo de c√≥digo. Al principio, pueden parecer un conjunto de reglas arbitrarias (¬°porque lo son!), pero con el tiempo, a medida que escriba m√°s c√≥digo y comparta c√≥digo con m√°s personas, ver√° lo importante que es un estilo coherente. Y no se olvide del paquete styler: es una excelente manera de mejorar r√°pidamente la calidad del c√≥digo mal dise√±ado.\nEn el pr√≥ximo cap√≠tulo, volvemos a las herramientas de ciencia de datos y aprendemos sobre los datos ordenados. Tidy data es una forma consistente de organizar sus data frames que se utiliza en todo el tidyverse. Esta consistencia facilita su vida porque una vez que tiene datos ordenados, solo funciona con la gran mayor√≠a de las funciones de tidyverse. Por supuesto, la vida nunca es f√°cil y la mayor√≠a de los conjuntos de datos que encuentre en la naturaleza no estar√°n ya ordenados. Entonces, tambi√©n le ense√±aremos c√≥mo usar el paquete tidyr para ordenar sus datos desordenados.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Flujo de trabajo: estilo de c√≥digo</span>"
    ]
  },
  {
    "objectID": "workflow-style.html#footnotes",
    "href": "workflow-style.html#footnotes",
    "title": "4¬† Flujo de trabajo: estilo de c√≥digo",
    "section": "",
    "text": "Dado que dep_time est√° en formato HMM o HHMM, usamos la divisi√≥n de enteros (%/%) para obtener la hora y el resto (tambi√©n conocido como m√≥dulo, %%) para obtener los minutos.‚Ü©Ô∏é",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Flujo de trabajo: estilo de c√≥digo</span>"
    ]
  },
  {
    "objectID": "data-tidy.html",
    "href": "data-tidy.html",
    "title": "5¬† Ordenando datos",
    "section": "",
    "text": "5.1 Introducci√≥n\nEn este cap√≠tulo, aprender√° una forma consistente de organizar sus datos en R utilizando un sistema llamado tidy data (datos ordenados). Obtener sus datos en este formato requiere algo de trabajo por adelantado, pero ese trabajo vale la pena a largo plazo. Una vez que tenga datos ordenados y las herramientas ordenadas proporcionadas por los paquetes en tidyverse, pasar√° mucho menos tiempo pasando datos de una representaci√≥n a otra, lo que le permitir√° dedicar m√°s tiempo a las preguntas de datos que le interesan.\nEn este cap√≠tulo, primero aprender√° la definici√≥n de datos ordenados y la ver√° aplicada a un conjunto de datos simple. Luego nos sumergiremos en la herramienta principal que usar√° para ordenar los datos: pivotar. Pivotar le permite cambiar la forma de sus datos sin cambiar ninguno de los valores.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Ordenando datos</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#introducci√≥n",
    "href": "data-tidy.html#introducci√≥n",
    "title": "5¬† Ordenando datos",
    "section": "",
    "text": "‚ÄúLas familias felices son todas iguales; cada familia infeliz es infeliz a su manera.‚Äù\n‚Äî Leo Tolstoy\n\n\n‚ÄúLos conjuntos de datos ordenados son todos iguales, pero cada conjunto de datos desordenado es desordenado a su manera.‚Äù\n‚Äî Hadley Wickham\n\n\n\n\n5.1.1 Requisitos previos\nEn este cap√≠tulo, nos centraremos en tidyr, un paquete que proporciona un mont√≥n de herramientas para ayudar a ordenar sus desordenados conjuntos de datos. tidyr es miembro del n√∫cleo tidyverse.\n\nlibrary(tidyverse)\n\nA partir de este cap√≠tulo, suprimiremos el mensaje de carga de library(tidyverse).",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Ordenando datos</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#sec-tidy-data",
    "href": "data-tidy.html#sec-tidy-data",
    "title": "5¬† Ordenando datos",
    "section": "\n5.2 Tidy data",
    "text": "5.2 Tidy data\nPuede representar los mismos datos subyacentes de varias formas. El siguiente ejemplo muestra los mismos datos organizados de tres maneras diferentes. Cada conjunto de datos muestra los mismos valores de cuatro variables: pa√≠s (country), a√±o (year), poblaci√≥n (population) y n√∫mero de casos (cases) documentados de TB (tuberculosis), pero cada conjunto de datos organiza los valores de manera diferente.\n\ntable1\n#&gt; # A tibble: 6 √ó 4\n#&gt;   country      year  cases population\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071\n#&gt; 2 Afghanistan  2000   2666   20595360\n#&gt; 3 Brazil       1999  37737  172006362\n#&gt; 4 Brazil       2000  80488  174504898\n#&gt; 5 China        1999 212258 1272915272\n#&gt; 6 China        2000 213766 1280428583\n\ntable2\n#&gt; # A tibble: 12 √ó 4\n#&gt;   country      year type           count\n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999 cases            745\n#&gt; 2 Afghanistan  1999 population  19987071\n#&gt; 3 Afghanistan  2000 cases           2666\n#&gt; 4 Afghanistan  2000 population  20595360\n#&gt; 5 Brazil       1999 cases          37737\n#&gt; 6 Brazil       1999 population 172006362\n#&gt; # ‚Ñπ 6 more rows\n\ntable3\n#&gt; # A tibble: 6 √ó 3\n#&gt;   country      year rate             \n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;            \n#&gt; 1 Afghanistan  1999 745/19987071     \n#&gt; 2 Afghanistan  2000 2666/20595360    \n#&gt; 3 Brazil       1999 37737/172006362  \n#&gt; 4 Brazil       2000 80488/174504898  \n#&gt; 5 China        1999 212258/1272915272\n#&gt; 6 China        2000 213766/1280428583\n\nTodas estas son representaciones de los mismos datos subyacentes, pero no son igualmente f√°ciles de usar. Uno de ellos, table1, ser√° mucho m√°s f√°cil de trabajar dentro del tidyverse porque esta ordenada.\nHay tres reglas interrelacionadas que hacen que un conjunto de datos est√© ordenado:\n\nCada variable es una columna; cada columna es una variable.\nCada observaci√≥n es una fila; cada fila es una observaci√≥n.\nCada valor es una celda; cada celda es un valor √∫nico.\n\nFigura¬†5.1 muestra las reglas visualmente.\n\n\n\n\n\n\n\nFigura¬†5.1: Las siguientes tres reglas hacen que un conjunto de datos est√© ordenado: las variables son columnas, las observaciones son filas y los valores son celdas.\n\n\n\n\n¬øPor qu√© asegurarse de que sus datos est√©n ordenados? Hay dos ventajas principales:\n\nHay una ventaja general en elegir una forma consistente de almacenar datos. Si tiene una estructura de datos consistente, es m√°s f√°cil aprender las herramientas que funcionan con ella porque tienen una uniformidad subyacente.\nHay una ventaja espec√≠fica en colocar variables en columnas porque permite que brille la naturaleza vectorizada de R. Como aprendi√≥ en Secci√≥n 3.3.1 y Secci√≥n 3.5.2, la mayor√≠a de las funciones integradas de R funcionan con vectores de valores. Eso hace que la transformaci√≥n de datos ordenados se sienta particularmente natural.\n\ndplyr, ggplot2 y todos los dem√°s paquetes en tidyverse est√°n dise√±ados para funcionar con datos ordenados. Aqu√≠ hay algunos peque√±os ejemplos que muestran c√≥mo podr√≠a trabajar con table1.\n\n# Tasa de c√°lculo por 10.000\ntable1 |&gt;\n  mutate(rate = cases / population * 10000)\n#&gt; # A tibble: 6 √ó 5\n#&gt;   country      year  cases population  rate\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071 0.373\n#&gt; 2 Afghanistan  2000   2666   20595360 1.29 \n#&gt; 3 Brazil       1999  37737  172006362 2.19 \n#&gt; 4 Brazil       2000  80488  174504898 4.61 \n#&gt; 5 China        1999 212258 1272915272 1.67 \n#&gt; 6 China        2000 213766 1280428583 1.67\n\n# Calcular casos por a√±o\ntable1 |&gt; \n  group_by(year) |&gt; \n  summarize(total_cases = sum(cases))\n#&gt; # A tibble: 2 √ó 2\n#&gt;    year total_cases\n#&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1  1999      250740\n#&gt; 2  2000      296920\n\n# Visualice los cambios a lo largo del tiempo\nggplot(table1, aes(x = year, y = cases)) +\n  geom_line(aes(group = country), color = \"grey50\") +\n  geom_point(aes(color = country, shape = country)) +\n  scale_x_continuous(breaks = c(1999, 2000)) # x-axis breaks at 1999 and 2000\n\n\n\n\n\n\n\n\n5.2.1 Ejercicios\n\nPara cada una de las tablas de muestra, describa lo que representa cada observaci√≥n y cada columna.\n\nHaz un bosquejo del proceso que usar√≠as para calcular la rate desde table2. Deber√° realizar cuatro operaciones:\n\nExtraiga el n√∫mero de casos de TB por pa√≠s por a√±o.\nExtraiga la poblaci√≥n coincidente por pa√≠s por a√±o.\nDivida los casos por la poblaci√≥n y multiplique por 10000.\nGu√°rdelo nuevamente en el lugar apropiado.\n\nTodav√≠a no ha aprendido todas las funciones que necesitar√≠a para realizar estas operaciones, pero a√∫n deber√≠a poder pensar en las transformaciones que necesitar√≠a.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Ordenando datos</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#sec-pivoting",
    "href": "data-tidy.html#sec-pivoting",
    "title": "5¬† Ordenando datos",
    "section": "\n5.3 Alargar datos",
    "text": "5.3 Alargar datos\nLos principios de los datos ordenados pueden parecer tan obvios que se pregunta si alguna vez se encontrar√° con un conjunto de datos que no est√© ordenado. Desafortunadamente, sin embargo, la mayor√≠a de los datos reales est√°n desordenados. Hay dos razones principales:\n\nLos datos a menudo se organizan para facilitar alg√∫n objetivo que no sea el an√°lisis. Por ejemplo, es com√∫n que los datos est√©n estructurados para facilitar la entrada de datos, no el an√°lisis.\nLa mayor√≠a de las personas no est√°n familiarizadas con los principios de los datos ordenados, y es dif√≠cil derivarlos usted mismo a menos que pase mucho tiempo trabajando con datos.\n\nEsto significa que la mayor√≠a de los an√°lisis reales requerir√°n al menos un poco de limpieza. Comenzar√° averiguando cu√°les son las variables y observaciones subyacentes. A veces esto es f√°cil; otras veces necesitar√° consultar con las personas que generaron originalmente los datos. A continuaci√≥n, pivotar√° sus datos en una forma ordenada, con variables en las columnas y observaciones en las filas.\ntidyr proporciona dos funciones para pivotar datos: pivot_longer() y pivot_wider(). Empezaremos con pivot_longer() porque es el caso m√°s com√∫n. Veamos unos ejemplos.\n\n5.3.1 Datos en nombres de columna\nEl conjunto de datos billboard registra el rango de las canciones en la cartelera en el a√±o 2000:\n\nbillboard\n#&gt; # A tibble: 317 √ó 79\n#&gt;   artist       track               date.entered   wk1   wk2   wk3   wk4   wk5\n#&gt;   &lt;chr&gt;        &lt;chr&gt;               &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 2 Pac        Baby Don't Cry (Ke‚Ä¶ 2000-02-26      87    82    72    77    87\n#&gt; 2 2Ge+her      The Hardest Part O‚Ä¶ 2000-09-02      91    87    92    NA    NA\n#&gt; 3 3 Doors Down Kryptonite          2000-04-08      81    70    68    67    66\n#&gt; 4 3 Doors Down Loser               2000-10-21      76    76    72    69    67\n#&gt; 5 504 Boyz     Wobble Wobble       2000-04-15      57    34    25    17    17\n#&gt; 6 98^0         Give Me Just One N‚Ä¶ 2000-08-19      51    39    34    26    26\n#&gt; # ‚Ñπ 311 more rows\n#&gt; # ‚Ñπ 71 more variables: wk6 &lt;dbl&gt;, wk7 &lt;dbl&gt;, wk8 &lt;dbl&gt;, wk9 &lt;dbl&gt;, ‚Ä¶\n\nEn este conjunto de datos, cada observaci√≥n es una canci√≥n. Las primeras tres columnas (artist, track y date.entered) son variables que describen la canci√≥n. Luego tenemos 76 columnas (wk1-wk76) que describen el rango de la canci√≥n en cada semana1. Aqu√≠, los nombres de las columnas son una variable (la semana) y los valores de las celdas son otra (el rango).\nPara ordenar estos datos, usaremos pivot_longer():\n\nbillboard |&gt; \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\"\n  )\n#&gt; # A tibble: 24,092 √ó 5\n#&gt;    artist track                   date.entered week   rank\n#&gt;    &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n#&gt;  1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n#&gt;  2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n#&gt;  3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n#&gt;  4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n#&gt;  5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n#&gt;  6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n#&gt;  7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n#&gt;  8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n#&gt;  9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n#&gt; 10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n#&gt; # ‚Ñπ 24,082 more rows\n\nDespu√©s de los datos, hay tres argumentos clave:\n\n\ncols especifica qu√© columnas deben girarse, es decir, qu√© columnas no son variables. Este argumento usa la misma sintaxis que select(), as√≠ que aqu√≠ podr√≠amos usar !c(artist, track, date.entered) o starts_with(\"wk\").\n\nnames_to nombra la variable almacenada en los nombres de columna, llamamos a esa variable week.\n\nvalues_to nombra la variable almacenada en los valores de celda, llamamos a esa variable rank.\n\nTenga en cuenta que en el c√≥digo se citan \"week\" y \"rank\" porque son variables nuevas que estamos creando, a√∫n no existen en los datos cuando ejecutamos la llamada pivot_longer().\nAhora dirijamos nuestra atenci√≥n al marco de datos m√°s largo resultante. ¬øQu√© sucede si una canci√≥n est√° en el top 100 durante menos de 76 semanas? Tome ‚ÄúBaby Don‚Äôt Cry‚Äù de 2 Pac, por ejemplo. El resultado anterior sugiere que estuvo solo en el top 100 durante 7 semanas, y todas las semanas restantes se completan con valores faltantes. Estas NA no representan realmente observaciones desconocidas; est√°n obligados a existir por la estructura del conjunto de datos 2, por lo que podemos pedirle a pivot_longer() que se deshaga de ellos configurando values_drop_na = TRUE:\n\nbillboard |&gt; \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\",\n    values_drop_na = TRUE\n  )\n#&gt; # A tibble: 5,307 √ó 5\n#&gt;   artist track                   date.entered week   rank\n#&gt;   &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n#&gt; 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n#&gt; 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n#&gt; 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n#&gt; 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n#&gt; 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n#&gt; # ‚Ñπ 5,301 more rows\n\nEl n√∫mero de filas ahora es mucho menor, lo que indica que se eliminaron muchas filas con NA.\nTambi√©n puede preguntarse qu√© sucede si una canci√≥n est√° en el top 100 durante m√°s de 76 semanas. No podemos decirlo a partir de estos datos, pero puede suponer que se agregar√°n columnas adicionales wk77, wk78, ‚Ä¶ al conjunto de datos.\nEstos datos ahora est√°n ordenados, pero podr√≠amos hacer que el c√°lculo futuro sea un poco m√°s f√°cil al convertir week en un n√∫mero usando mutate() y readr::parse_number(). parse_number() es una funci√≥n √∫til que extraer√° el primer n√∫mero de una cadena, ignorando el resto del texto.\n\nbillboard_longer &lt;- billboard |&gt; \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\",\n    values_drop_na = TRUE\n  ) |&gt; \n  mutate(\n    week = parse_number(week)\n  )\nbillboard_longer\n#&gt; # A tibble: 5,307 √ó 5\n#&gt;   artist track                   date.entered  week  rank\n#&gt;   &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26       1    87\n#&gt; 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26       2    82\n#&gt; 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26       3    72\n#&gt; 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26       4    77\n#&gt; 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26       5    87\n#&gt; 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26       6    94\n#&gt; # ‚Ñπ 5,301 more rows\n\nAhora que tenemos todos los n√∫meros de semana en una variable y todos los valores de clasificaci√≥n en otra, estamos en una buena posici√≥n para visualizar c√≥mo var√≠an las clasificaciones de las canciones con el tiempo. El c√≥digo se muestra a continuaci√≥n y el resultado est√° en Figura¬†5.2. Podemos ver que muy pocas canciones permanecen en el top 100 por m√°s de 20 semanas.\n\nbillboard_longer |&gt; \n  ggplot(aes(x = week, y = rank, group = track)) + \n  geom_line(alpha = 0.25) + \n  scale_y_reverse()\n\n\n\n\n\n\nFigura¬†5.2: Un gr√°fico de l√≠neas que muestra c√≥mo cambia la clasificaci√≥n de una canci√≥n con el tiempo.\n\n\n\n\n\n5.3.2 ¬øC√≥mo funciona el pivoteo?\nAhora que ha visto c√≥mo podemos usar el pivote para remodelar nuestros datos, tomemos un poco de tiempo para ganar algo de intuici√≥n sobre lo que hace el pivote con los datos. Comencemos con un conjunto de datos muy simple para que sea m√°s f√°cil ver lo que est√° sucediendo. Supongamos que tenemos tres pacientes con ids A, B y C, y tomamos dos medidas de presi√≥n arterial en cada paciente. Crearemos los datos con tribble(), una funci√≥n √∫til para construir peque√±os tibbles a mano:\n\ndf &lt;- tribble(\n  ~id,  ~bp1, ~bp2,\n  \"A\",  100,  120,\n  \"B\",  140,  115,\n  \"C\",  120,  125\n)\n\nQueremos que nuestro nuevo conjunto de datos tenga tres variables: id (ya existe), measurement (los nombres de las columnas) y value (los valores de las celdas). Para lograr esto, necesitamos pivotear df por m√°s tiempo:\n\ndf |&gt; \n  pivot_longer(\n    cols = bp1:bp2,\n    names_to = \"measurement\",\n    values_to = \"value\"\n  )\n#&gt; # A tibble: 6 √ó 3\n#&gt;   id    measurement value\n#&gt;   &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;\n#&gt; 1 A     bp1           100\n#&gt; 2 A     bp2           120\n#&gt; 3 B     bp1           140\n#&gt; 4 B     bp2           115\n#&gt; 5 C     bp1           120\n#&gt; 6 C     bp2           125\n\n¬øC√≥mo funciona la remodelaci√≥n? Es m√°s f√°cil verlo si lo pensamos columna por columna. Como se muestra en Figura¬†5.3, los valores en la columna que ya era una variable en el conjunto de datos original (id) deben repetirse, una vez por cada columna que se pivote.\n\n\n\n\n\n\n\nFigura¬†5.3: Las columnas que ya son variables deben repetirse, una vez por cada columna que se pivota.\n\n\n\n\nLos nombres de las columnas se convierten en valores en una nueva variable, cuyo nombre es definido por names_to, como se muestra en Figura¬†5.4. Deben repetirse una vez para cada fila en el conjunto de datos original.\n\n\n\n\n\n\n\nFigura¬†5.4: Los nombres de columna de las columnas pivoteadas se convierten en valores en una nueva columna. Los valores necesitan repetirse una vez por cada fila en el conjunto de datos original\n\n\n\n\nLos valores de celda tambi√©n se convierten en valores en una nueva variable, con un nombre definido por values_to. Se desenrollan fila por fila. Figura¬†5.5 ilustra el proceso.\n\n\n\n\n\n\n\nFigura¬†5.5: El n√∫mero de valores se conserva (no se repite), pero se desenrolla fila por fila.\n\n\n\n\n\n5.3.3 Muchas variables en los nombres de las columnas\nUna situaci√≥n m√°s desafiante ocurre cuando tiene m√∫ltiples piezas de informaci√≥n abarrotadas en los nombres de las columnas y desea almacenarlas en nuevas variables separadas. Por ejemplo, tome el conjunto de datos who2, la fuente de table_1 y amigos que vi√≥ con anterioridad:\n\nwho2\n#&gt; # A tibble: 7,240 √ó 58\n#&gt;   country      year sp_m_014 sp_m_1524 sp_m_2534 sp_m_3544 sp_m_4554\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan  1980       NA        NA        NA        NA        NA\n#&gt; 2 Afghanistan  1981       NA        NA        NA        NA        NA\n#&gt; 3 Afghanistan  1982       NA        NA        NA        NA        NA\n#&gt; 4 Afghanistan  1983       NA        NA        NA        NA        NA\n#&gt; 5 Afghanistan  1984       NA        NA        NA        NA        NA\n#&gt; 6 Afghanistan  1985       NA        NA        NA        NA        NA\n#&gt; # ‚Ñπ 7,234 more rows\n#&gt; # ‚Ñπ 51 more variables: sp_m_5564 &lt;dbl&gt;, sp_m_65 &lt;dbl&gt;, sp_f_014 &lt;dbl&gt;, ‚Ä¶\n\nEste conjunto de datos, recopilado por la Organizaci√≥n Mundial de la Salud, registra informaci√≥n sobre diagn√≥sticos de tuberculosis. Hay dos columnas que ya son variables y son f√°ciles de interpretar: country y year. Les siguen 56 columnas como sp_m_014, ep_m_4554 y rel_m_3544. Si observa estas columnas durante el tiempo suficiente, notar√° que hay un patr√≥n. Cada nombre de columna se compone de tres piezas separadas por _. La primera pieza, sp/rel/ep, describe el m√©todo utilizado para el diagn√≥stico, la segunda pieza, m/f es el g√©nero (codificado como una variable binaria en este conjunto de datos) , y la tercera pieza, 014/1524/2534/3544/4554/5564/``65 es el rango de edad (014 representa 0-14, por ejemplo).\nEntonces, en este caso, tenemos seis piezas de informaci√≥n registradas en who2: el pa√≠s y el a√±o (ya columnas); el m√©todo de diagn√≥stico, la categor√≠a de g√©nero y la categor√≠a de rango de edad (contenidas en los otros nombres de columna); y el recuento de pacientes en esa categor√≠a (valores de celda). Para organizar estas seis piezas de informaci√≥n en seis columnas separadas, usamos pivot_longer() con un vector de nombres de columna para names_to e instructores para dividir los nombres de las variables originales en partes para names_sep, as√≠ como un nombre de columna para values_to:\n\nwho2 |&gt; \n  pivot_longer(\n    cols = !(country:year),\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), \n    names_sep = \"_\",\n    values_to = \"count\"\n  )\n#&gt; # A tibble: 405,440 √ó 6\n#&gt;   country      year diagnosis gender age   count\n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan  1980 sp        m      014      NA\n#&gt; 2 Afghanistan  1980 sp        m      1524     NA\n#&gt; 3 Afghanistan  1980 sp        m      2534     NA\n#&gt; 4 Afghanistan  1980 sp        m      3544     NA\n#&gt; 5 Afghanistan  1980 sp        m      4554     NA\n#&gt; 6 Afghanistan  1980 sp        m      5564     NA\n#&gt; # ‚Ñπ 405,434 more rows\n\nUna alternativa a names_sep es names_pattern, que puede usar para extraer variables de escenarios de nombres m√°s complicados, una vez que haya aprendido acerca de las expresiones regulares en Cap√≠tulo 15.\nConceptualmente, esta es solo una variaci√≥n menor del caso m√°s simple que ya ha visto. Figura¬†5.6 muestra la idea b√°sica: ahora, en lugar de que los nombres de las columnas giren en una sola columna, giran en varias columnas. Puede imaginar que esto suceda en dos pasos (primero girando y luego separando), pero debajo del cap√≥ sucede en un solo paso porque eso es m√°s r√°pido.\n\n\n\n\n\n\n\nFigura¬†5.6: Girar columnas con m√∫ltiples piezas de informaci√≥n en los nombres significa que cada nombre de columna ahora completa valores en m√∫ltiples columnas de salida.\n\n\n\n\n\n5.3.4 Datos y nombres de variables en los encabezados de las columnas\nEl siguiente paso en complejidad es cuando los nombres de las columnas incluyen una combinaci√≥n de valores de variables y nombres de variables. Por ejemplo, tome el conjunto de datos household:\n\nhousehold\n#&gt; # A tibble: 5 √ó 5\n#&gt;   family dob_child1 dob_child2 name_child1 name_child2\n#&gt;    &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;       &lt;chr&gt;      \n#&gt; 1      1 1998-11-26 2000-01-29 Susan       Jose       \n#&gt; 2      2 1996-06-22 NA         Mark        &lt;NA&gt;       \n#&gt; 3      3 2002-07-11 2004-04-05 Sam         Seth       \n#&gt; 4      4 2004-10-10 2009-08-27 Craig       Khai       \n#&gt; 5      5 2000-12-05 2005-02-28 Parker      Gracie\n\nEste conjunto de datos contiene informaci√≥n sobre cinco familias, con los nombres y fechas de nacimiento de hasta dos ni√±os. El nuevo desaf√≠o en este conjunto de datos es que los nombres de las columnas contienen los nombres de dos variables (dob, name) y los valores de otra (child, con valores 1 o 2). Para resolver este problema, nuevamente necesitamos proporcionar un vector a names_to pero esta vez usamos el centinela especial \".value\"; este no es el nombre de una variable sino un valor √∫nico que le dice a pivot_longer() que haga algo diferente. Esto anula el argumento values_to habitual para usar el primer componente del nombre de la columna din√°mica como nombre de variable en la salida.\n\nhousehold |&gt; \n  pivot_longer(\n    cols = !family, \n    names_to = c(\".value\", \"child\"), \n    names_sep = \"_\", \n    values_drop_na = TRUE\n  )\n#&gt; # A tibble: 9 √ó 4\n#&gt;   family child  dob        name \n#&gt;    &lt;int&gt; &lt;chr&gt;  &lt;date&gt;     &lt;chr&gt;\n#&gt; 1      1 child1 1998-11-26 Susan\n#&gt; 2      1 child2 2000-01-29 Jose \n#&gt; 3      2 child1 1996-06-22 Mark \n#&gt; 4      3 child1 2002-07-11 Sam  \n#&gt; 5      3 child2 2004-04-05 Seth \n#&gt; 6      4 child1 2004-10-10 Craig\n#&gt; # ‚Ñπ 3 more rows\n\nNuevamente usamos values_drop_na = TRUE, ya que la forma de la entrada fuerza la creaci√≥n de variables faltantes expl√≠citas (por ejemplo, para familias con un solo hijo).\nFigura¬†5.7 ilustra la idea b√°sica con un ejemplo m√°s simple. Cuando usa \".value\" en names_to, los nombres de las columnas en la entrada contribuyen tanto a los valores como a los nombres de las variables en la salida.\n\n\n\n\n\n\n\nFigura¬†5.7: Pivotar con names_to = c(\".value\", \"num\") divide los nombres de las columnas en dos componentes: la primera parte determina la columna de salida nombre (x o y), y la segunda parte determina el valor de la columna num.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Ordenando datos</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#ampliaci√≥n-de-datos",
    "href": "data-tidy.html#ampliaci√≥n-de-datos",
    "title": "5¬† Ordenando datos",
    "section": "\n5.4 Ampliaci√≥n de datos",
    "text": "5.4 Ampliaci√≥n de datos\nHasta ahora hemos usado pivot_longer() para resolver la clase com√∫n de problemas donde los valores terminan en los nombres de las columnas. A continuaci√≥n, pivotaremos (HA HA) a pivot_wider(), que hace un conjunto de datos m√°s ancho al incrementar el n√∫mero de columnas y reducir las filas lo que ayuda cuando una observaci√≥n se distribuye en varias filas. Esto parece surgir con menos frecuencia en la naturaleza, pero parece surgir mucho cuando se trata de datos gubernamentales.\nComenzaremos analizando cms_patient_experience, un conjunto de datos de los servicios de los Centros de Medicare y Medicaid que recopila datos sobre las experiencias de los pacientes:\n\ncms_patient_experience\n#&gt; # A tibble: 500 √ó 5\n#&gt;   org_pac_id org_nm                     measure_cd   measure_title   prf_rate\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                      &lt;chr&gt;        &lt;chr&gt;              &lt;dbl&gt;\n#&gt; 1 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_1  CAHPS for MIPS‚Ä¶       63\n#&gt; 2 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_2  CAHPS for MIPS‚Ä¶       87\n#&gt; 3 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_3  CAHPS for MIPS‚Ä¶       86\n#&gt; 4 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_5  CAHPS for MIPS‚Ä¶       57\n#&gt; 5 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_8  CAHPS for MIPS‚Ä¶       85\n#&gt; 6 0446157747 USC CARE MEDICAL GROUP INC CAHPS_GRP_12 CAHPS for MIPS‚Ä¶       24\n#&gt; # ‚Ñπ 494 more rows\n\nLa unidad central que se estudia es una organizaci√≥n, pero cada organizaci√≥n se distribuye en seis filas, con una fila para cada medici√≥n realizada en la organizaci√≥n de la encuesta. Podemos ver el conjunto completo de valores para measure_cd y measure_title usando distinct():\n\ncms_patient_experience |&gt; \n  distinct(measure_cd, measure_title)\n#&gt; # A tibble: 6 √ó 2\n#&gt;   measure_cd   measure_title                                                 \n#&gt;   &lt;chr&gt;        &lt;chr&gt;                                                         \n#&gt; 1 CAHPS_GRP_1  CAHPS for MIPS SSM: Getting Timely Care, Appointments, and In‚Ä¶\n#&gt; 2 CAHPS_GRP_2  CAHPS for MIPS SSM: How Well Providers Communicate            \n#&gt; 3 CAHPS_GRP_3  CAHPS for MIPS SSM: Patient's Rating of Provider              \n#&gt; 4 CAHPS_GRP_5  CAHPS for MIPS SSM: Health Promotion and Education            \n#&gt; 5 CAHPS_GRP_8  CAHPS for MIPS SSM: Courteous and Helpful Office Staff        \n#&gt; 6 CAHPS_GRP_12 CAHPS for MIPS SSM: Stewardship of Patient Resources\n\nNinguna de estas columnas har√° nombres de variables particularmente buenos: measure_cd no sugiere el significado de la variable y measure_title es una oraci√≥n larga que contiene espacios. Usaremos measure_cd como la fuente para nuestros nuevos nombres de columna por ahora, pero en un an√°lisis real, es posible que desee crear sus propios nombres de variables que sean cortos y significativos.\n`pivot_wider() tiene la interfaz opuesta a pivot_longer(): en lugar de elegir nuevos nombres de columna, debemos proporcionar las columnas existentes que definen los valores (values_from) y el nombre de la columna (names_from):\n\ncms_patient_experience |&gt; \n  pivot_wider(\n    names_from = measure_cd,\n    values_from = prf_rate\n  )\n#&gt; # A tibble: 500 √ó 9\n#&gt;   org_pac_id org_nm                   measure_title   CAHPS_GRP_1 CAHPS_GRP_2\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                    &lt;chr&gt;                 &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1 0446157747 USC CARE MEDICAL GROUP ‚Ä¶ CAHPS for MIPS‚Ä¶          63          NA\n#&gt; 2 0446157747 USC CARE MEDICAL GROUP ‚Ä¶ CAHPS for MIPS‚Ä¶          NA          87\n#&gt; 3 0446157747 USC CARE MEDICAL GROUP ‚Ä¶ CAHPS for MIPS‚Ä¶          NA          NA\n#&gt; 4 0446157747 USC CARE MEDICAL GROUP ‚Ä¶ CAHPS for MIPS‚Ä¶          NA          NA\n#&gt; 5 0446157747 USC CARE MEDICAL GROUP ‚Ä¶ CAHPS for MIPS‚Ä¶          NA          NA\n#&gt; 6 0446157747 USC CARE MEDICAL GROUP ‚Ä¶ CAHPS for MIPS‚Ä¶          NA          NA\n#&gt; # ‚Ñπ 494 more rows\n#&gt; # ‚Ñπ 4 more variables: CAHPS_GRP_3 &lt;dbl&gt;, CAHPS_GRP_5 &lt;dbl&gt;, ‚Ä¶\n\nLa salida no se ve muy bien; todav√≠a parece que tenemos varias filas para cada organizaci√≥n. Eso es porque, tambi√©n necesitamos decirle a pivot_wider() qu√© columna o columnas tienen valores que identifican de manera √∫nica cada fila; en este caso esas son las variables que comienzan con \"org\":\n\ncms_patient_experience |&gt; \n  pivot_wider(\n    id_cols = starts_with(\"org\"),\n    names_from = measure_cd,\n    values_from = prf_rate\n  )\n#&gt; # A tibble: 95 √ó 8\n#&gt;   org_pac_id org_nm           CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3 CAHPS_GRP_5\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                  &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1 0446157747 USC CARE MEDICA‚Ä¶          63          87          86          57\n#&gt; 2 0446162697 ASSOCIATION OF ‚Ä¶          59          85          83          63\n#&gt; 3 0547164295 BEAVER MEDICAL ‚Ä¶          49          NA          75          44\n#&gt; 4 0749333730 CAPE PHYSICIANS‚Ä¶          67          84          85          65\n#&gt; 5 0840104360 ALLIANCE PHYSIC‚Ä¶          66          87          87          64\n#&gt; 6 0840109864 REX HOSPITAL INC          73          87          84          67\n#&gt; # ‚Ñπ 89 more rows\n#&gt; # ‚Ñπ 2 more variables: CAHPS_GRP_8 &lt;dbl&gt;, CAHPS_GRP_12 &lt;dbl&gt;\n\nEsto nos da la salida que estamos buscando.\n\n5.4.1 ¬øC√≥mo funciona pivot_wider()?\nPara entender c√≥mo funciona pivot_wider(), comencemos nuevamente con un conjunto de datos muy simple. Esta vez tenemos dos pacientes con ids A y B, tenemos tres mediciones de presi√≥n arterial en el paciente A y dos en el paciente B:\n\ndf &lt;- tribble(\n  ~id, ~measurement, ~value,\n  \"A\",        \"bp1\",    100,\n  \"B\",        \"bp1\",    140,\n  \"B\",        \"bp2\",    115, \n  \"A\",        \"bp2\",    120,\n  \"A\",        \"bp3\",    105\n)\n\nTomaremos los valores de la columna value y los nombres de la columna measurement:\n\ndf |&gt; \n  pivot_wider(\n    names_from = measurement,\n    values_from = value\n  )\n#&gt; # A tibble: 2 √ó 4\n#&gt;   id      bp1   bp2   bp3\n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 A       100   120   105\n#&gt; 2 B       140   115    NA\n\nPara comenzar el proceso, pivot_wider() necesita primero averiguar qu√© ir√° en las filas y columnas. Los nuevos nombres de columna ser√°n los valores √∫nicos de measurement.\n\ndf |&gt; \n  distinct(measurement) |&gt; \n  pull()\n#&gt; [1] \"bp1\" \"bp2\" \"bp3\"\n\nDe forma predeterminada, las filas de la salida est√°n determinadas por todas las variables que no se incluir√°n en los nuevos nombres o valores. Estos se llaman id_cols. Aqu√≠ solo hay una columna, pero en general puede haber cualquier cantidad de columnas.\n\ndf |&gt; \n  select(-measurement, -value) |&gt; \n  distinct()\n#&gt; # A tibble: 2 √ó 1\n#&gt;   id   \n#&gt;   &lt;chr&gt;\n#&gt; 1 A    \n#&gt; 2 B\n\npivot_wider() luego combina estos resultados para generar un data frame vac√≠o:\n\ndf |&gt; \n  select(-measurement, -value) |&gt; \n  distinct() |&gt; \n  mutate(x = NA, y = NA, z = NA)\n#&gt; # A tibble: 2 √ó 4\n#&gt;   id    x     y     z    \n#&gt;   &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt;\n#&gt; 1 A     NA    NA    NA   \n#&gt; 2 B     NA    NA    NA\n\nLuego completa todos los valores faltantes usando los datos en la entrada. En este caso, no todas las celdas de la salida tienen un valor correspondiente en la entrada, ya que no hay una tercera medici√≥n de la presi√≥n arterial para el paciente B, por lo que falta esa celda. Volveremos a esta idea de que pivot_wider() puede ‚Äúhacer‚Äù valores faltantes en Cap√≠tulo 18.\nTambi√©n puede preguntarse qu√© sucede si hay varias filas en la entrada que corresponden a una celda en la salida. El siguiente ejemplo tiene dos filas que corresponden a el id ‚ÄúA‚Äù y a measurement ‚Äúbp1‚Äù:\n\ndf &lt;- tribble(\n  ~id, ~measurement, ~value,\n  \"A\",        \"bp1\",    100,\n  \"A\",        \"bp1\",    102,\n  \"A\",        \"bp2\",    120,\n  \"B\",        \"bp1\",    140,\n  \"B\",        \"bp2\",    115\n)\n\nSi intentamos pivotar esto, obtenemos una salida que contiene columnas de lista, sobre las que aprender√° m√°s en Cap√≠tulo 23:\n\ndf |&gt; \n  pivot_wider(\n    names_from = measurement,\n    values_from = value\n  )\n#&gt; Warning: Values from `value` are not uniquely identified; output will contain\n#&gt; list-cols.\n#&gt; ‚Ä¢ Use `values_fn = list` to suppress this warning.\n#&gt; ‚Ä¢ Use `values_fn = {summary_fun}` to summarise duplicates.\n#&gt; ‚Ä¢ Use the following dplyr code to identify duplicates.\n#&gt;   {data} |&gt;\n#&gt;   dplyr::summarise(n = dplyr::n(), .by = c(id, measurement)) |&gt;\n#&gt;   dplyr::filter(n &gt; 1L)\n#&gt; # A tibble: 2 √ó 3\n#&gt;   id    bp1       bp2      \n#&gt;   &lt;chr&gt; &lt;list&gt;    &lt;list&gt;   \n#&gt; 1 A     &lt;dbl [2]&gt; &lt;dbl [1]&gt;\n#&gt; 2 B     &lt;dbl [1]&gt; &lt;dbl [1]&gt;\n\nComo a√∫n no sabe c√≥mo trabajar con este tipo de datos, querr√° seguir la sugerencia de la advertencia para averiguar d√≥nde est√° el problema:\n\ndf |&gt; \n  group_by(id, measurement) |&gt; \n  summarize(n = n(), .groups = \"drop\") |&gt; \n  filter(n &gt; 1) \n#&gt; # A tibble: 1 √ó 3\n#&gt;   id    measurement     n\n#&gt;   &lt;chr&gt; &lt;chr&gt;       &lt;int&gt;\n#&gt; 1 A     bp1             2\n\nLuego, depende de usted averiguar qu√© sali√≥ mal con sus datos y reparar el da√±o subyacente o usar sus habilidades de agrupaci√≥n y resumen para asegurarse de que cada combinaci√≥n de valores de fila y columna solo tenga una fila.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Ordenando datos</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#resumen",
    "href": "data-tidy.html#resumen",
    "title": "5¬† Ordenando datos",
    "section": "\n5.5 Resumen",
    "text": "5.5 Resumen\nEn este cap√≠tulo aprendiste sobre datos ordenados: datos que tienen variables en columnas y observaciones en filas. Los datos ordenados facilitan el trabajo en el tidyverse, porque es una estructura consistente que la mayor√≠a de las funciones entienden, el principal desaf√≠o es transformar los datos de cualquier estructura en la que los reciba a un formato ordenado. Con ese fin, aprendi√≥ sobre pivot_longer() y pivot_wider(), que le permiten ordenar muchos conjuntos de datos desordenados. Los ejemplos que presentamos aqu√≠ son una selecci√≥n de los de vignette(\"pivot\", package = \"tidyr\"), por lo que si encuentra un problema con el que este cap√≠tulo no le ayuda, esa vi√±eta es un buen lugar para probar pr√≥ximo.\nOtro desaf√≠o es que, para un conjunto de datos dado, puede ser imposible etiquetar la versi√≥n m√°s larga o m√°s amplia como la ‚Äúordenada‚Äù. Esto es en parte un reflejo de nuestra definici√≥n de datos ordenados, donde dijimos que los datos ordenados tienen una variable en cada columna, pero en realidad no definimos qu√© es una variable (y es sorprendentemente dif√≠cil hacerlo). Est√° totalmente bien ser pragm√°tico y decir que una variable es lo que hace que su an√°lisis sea m√°s f√°cil. Entonces, si no sabe c√≥mo hacer algunos c√°lculos, considere cambiar la organizaci√≥n de sus datos; ¬°no tenga miedo de desordenar, transformar y volver a ordenar seg√∫n sea necesario!\nSi disfrut√≥ de este cap√≠tulo y desea obtener m√°s informaci√≥n sobre la teor√≠a subyacente, puede obtener m√°s informaci√≥n sobre la historia y los fundamentos te√≥ricos en el art√≠culo Tidy Data publicado. en el Journal of Statistical Software.\nAhora que est√° escribiendo una cantidad sustancial de c√≥digo R, es hora de aprender m√°s sobre c√≥mo organizar su c√≥digo en archivos y directorios. En el pr√≥ximo cap√≠tulo, aprender√° todo acerca de las ventajas de los scripts y proyectos, y algunas de las muchas herramientas que brindan para facilitarle la vida.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Ordenando datos</span>"
    ]
  },
  {
    "objectID": "data-tidy.html#footnotes",
    "href": "data-tidy.html#footnotes",
    "title": "5¬† Ordenando datos",
    "section": "",
    "text": "La canci√≥n se incluir√° siempre que haya estado entre las 100 mejores en alg√∫n momento del a√±o 2000, y se rastrear√° hasta 72 semanas despu√©s de su aparici√≥n.‚Ü©Ô∏é\nVolveremos sobre esta idea en Cap√≠tulo 18.‚Ü©Ô∏é",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Ordenando datos</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html",
    "href": "workflow-scripts.html",
    "title": "6¬† Flujo de trabajo: scripts y proyectos",
    "section": "",
    "text": "6.1 Scripts\nEste cap√≠tulo le presentar√° dos herramientas esenciales para organizar su c√≥digo: scripts y proyectos.\nHasta ahora, ha utilizado la consola para ejecutar c√≥digo. Ese es un excelente lugar para comenzar, pero encontrar√° que se atasca bastante r√°pido a medida que crea gr√°ficos ggplot2 m√°s complejos y canalizaciones dplyr m√°s largas. Para disponer de m√°s espacio para trabajar, utilice el editor de secuencias de comandos. √Åbralo haciendo clic en el men√∫ Archivo, seleccionando Nuevo archivo, luego R script, o usando el atajo de teclado Cmd/Ctrl + Shift + N. Ahora ver√° cuatro paneles, como en Figura¬†6.1. El editor de secuencias de comandos es un gran lugar para experimentar con su c√≥digo. Cuando desee cambiar algo, no tiene que volver a escribirlo todo, simplemente puede editar el script y volver a ejecutarlo. Y una vez que haya escrito el c√≥digo que funciona y hace lo que desea, puede guardarlo como un archivo de secuencia de comandos para volver f√°cilmente a √©l m√°s tarde.\nFigura¬†6.1: Al abrir el editor de secuencias de comandos, se agrega un nuevo panel en la parte superior izquierda de la IDE.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Flujo de trabajo: scripts y proyectos</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#scripts",
    "href": "workflow-scripts.html#scripts",
    "title": "6¬† Flujo de trabajo: scripts y proyectos",
    "section": "",
    "text": "6.1.1 C√≥digo en ejecuci√≥n\nEl editor de secuencias de comandos es un lugar excelente para crear gr√°ficas de ggplot2 complejas o largas secuencias de manipulaciones de dplyr. La clave para usar el editor de secuencias de comandos de manera efectiva es memorizar uno de los atajos de teclado m√°s importantes: Cmd/Ctrl + Enter. Esto ejecuta la expresi√≥n de R actual en la consola. Por ejemplo, tome el siguiente c√≥digo.\n\nlibrary(dplyr)\nlibrary(nycflights13)\n\nnot_cancelled &lt;- flights |&gt; \n  filter(!is.na(dep_delay)‚ñà, !is.na(arr_delay))\n\nnot_cancelled |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(mean = mean(dep_delay))\n\nSi su cursor est√° en ‚ñà, al presionar Cmd/Ctrl + Enter se ejecutar√° el comando completo que genera not_cancelled. Tambi√©n mover√° el cursor a la siguiente declaraci√≥n (comenzando con not_cancelled |&gt;). Eso hace que sea m√°s f√°cil recorrer el script completo presionando repetidamente Cmd/Ctrl + Enter.\nEn lugar de ejecutar su c√≥digo expresi√≥n por expresi√≥n, tambi√©n puede ejecutar el script completo en un solo paso con Cmd/Ctrl + Shift + S. Hacer esto regularmente es una excelente manera de asegurarse de haber capturado todas las partes importantes de su c√≥digo en el script.\nLe recomendamos que siempre comience su script con los paquetes que necesita. De esa forma, si comparte su c√≥digo con otras personas, pueden ver f√°cilmente qu√© paquetes necesitan instalar. Tenga en cuenta, sin embargo, que nunca debe incluir install.packages() en un script que comparta. ¬°Es desconsiderado entregar un script que cambiar√° algo en su computadora si no tienen cuidado!\nCuando trabaje en cap√≠tulos futuros, le recomendamos que comience con el editor de scripts y practique los atajos de teclado. Con el tiempo, enviar c√≥digo a la consola de esta manera se volver√° tan natural que ni siquiera pensar√° en ello.\n\n6.1.2 Diagn√≥sticos de RStudio\nEn el editor de secuencias de comandos, RStudio resaltar√° los errores de sintaxis con una l√≠nea ondulada roja y una cruz en la barra lateral:\n\n\n\n\n\n\n\n\nPase el cursor sobre la cruz para ver cu√°l es el problema:\n\n\n\n\n\n\n\n\nRStudio tambi√©n le informar√° sobre posibles problemas:\n\n\n\n\n\n\n\n\n\n6.1.3 Guardar y nombrar\nRStudio guarda autom√°ticamente el contenido del editor de secuencias de comandos cuando sale y lo vuelve a cargar autom√°ticamente cuando lo vuelve a abrir. Sin embargo, es una buena idea evitar Untitled1, Untitled2, Untitled3, etc. y, en su lugar, guardar sus scripts y darles nombres informativos.\nPuede ser tentador nombrar sus archivos code.R o miscript.R, pero debe pensar un poco m√°s antes de elegir un nombre para su archivo. Tres principios importantes para la denominaci√≥n de archivos son los siguientes:\n\nLos nombres de los archivos deben ser legibles por m√°quina: evite espacios, s√≠mbolos y caracteres especiales. No conf√≠e en la distinci√≥n entre may√∫sculas y min√∫sculas para distinguir archivos.\nLos nombres de los archivos deben ser legibles por personas: use nombres de archivos para describir lo que hay en el archivo.\nLos nombres de archivo deber√≠an funcionar bien con el orden predeterminado: comience los nombres de archivo con n√∫meros para que la ordenaci√≥n alfab√©tica los coloque en el orden en que se usan.\n\nPor ejemplo, suponga que tiene los siguientes archivos en una carpeta de proyecto.\nalternative model.R\ncode for exploratory analysis.r\nfinalreport.qmd\nFinalReport.qmd\nfig 1.png\nFigure_02.png\nmodel_first_try.R\nrun-first.r\ntemp.txt\nHay una variedad de problemas aqu√≠: es dif√≠cil encontrar qu√© archivo ejecutar primero, los nombres de los archivos contienen espacios, hay dos archivos con el mismo nombre pero con may√∫sculas diferentes (finalreport vs.¬†FinalReport[^workflow-scripts-1 ]), y algunos nombres no describen su contenido (run-first y temp).\nAqu√≠ hay una mejor manera de nombrar y organizar el mismo conjunto de archivos:\n01-load-data.R\n02-exploratory-analysis.R\n03-model-approach-1.R\n04-model-approach-2.R\nfig-01.png\nfig-02.png\nreport-2022-03-20.qmd\nreport-2022-04-02.qmd\nreport-draft-notes.txt\nLa numeraci√≥n de los scripts clave hace que sea obvio en qu√© orden ejecutarlos y un esquema de nombres consistente hace que sea m√°s f√°cil ver qu√© var√≠a. Adem√°s, las cifras se etiquetan de manera similar, los informes se distinguen por las fechas incluidas en los nombres de los archivos y se cambia el nombre de temp a report-draft-notes para describir mejor su contenido. Si tiene muchos archivos en un directorio, se recomienda llevar la organizaci√≥n un paso m√°s all√° y colocar diferentes tipos de archivos (guiones, figuras, etc.) en diferentes directorios.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Flujo de trabajo: scripts y proyectos</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#proyectos",
    "href": "workflow-scripts.html#proyectos",
    "title": "6¬† Flujo de trabajo: scripts y proyectos",
    "section": "\n6.2 Proyectos",
    "text": "6.2 Proyectos\nUn d√≠a, deber√° salir de R, hacer otra cosa y volver a su an√°lisis m√°s tarde. Un d√≠a, estar√° trabajando en m√∫ltiples an√°lisis simult√°neamente y querr√° mantenerlos separados. Un d√≠a, deber√° traer datos del mundo exterior a R y enviar resultados num√©ricos y cifras de R al mundo.\nPara manejar estas situaciones de la vida real, debe tomar dos decisiones:\n\n¬øCu√°l es la fuente de la verdad? ¬øQu√© guardar√° como registro duradero de lo que sucedi√≥?\n¬øD√≥nde vive su an√°lisis?\n\n\n6.2.1 ¬øCu√°l es la fuente de la verdad?\nComo principiante, est√° bien confiar en su entorno actual para contener todos los objetos que ha creado a lo largo de su an√°lisis. Sin embargo, para que sea m√°s f√°cil trabajar en proyectos m√°s grandes o colaborar con otros, su fuente de verdad deben ser los scripts R. Con sus scripts de R (y sus archivos de datos), puede recrear el entorno. Solo con su entorno, es mucho m√°s dif√≠cil recrear sus scripts de R: tendr√° que volver a escribir una gran cantidad de c√≥digo de la memoria (inevitablemente cometiendo errores en el camino) o tendr√° que extraer cuidadosamente su historial de R.\nPara ayudar a mantener sus scripts de R como la fuente de la verdad para su an√°lisis, le recomendamos que indique a RStudio que no conserve su espacio de trabajo entre sesiones. Puede hacer esto ejecutando usethis::use_blank_slate()1 o imitando las opciones que se muestran en Figura¬†6.2. Esto le causar√° un poco de dolor a corto plazo, porque ahora, cuando reinicie RStudio, ya no recordar√° el c√≥digo que ejecut√≥ la √∫ltima vez ni los objetos que cre√≥ o los conjuntos de datos que ley√≥ estar√°n disponibles para su uso. Pero este dolor a corto plazo le ahorra una agon√≠a a largo plazo porque lo obliga a capturar todas los procedimientos importantes en su c√≥digo. No hay nada peor que descubrir tres meses despu√©s del hecho de que solo almacen√≥ los resultados de un c√°lculo importante en su entorno, no el c√°lculo en s√≠ mismo en su c√≥digo.\n\n\n\n\n\n\n\nFigura¬†6.2: Copie estas opciones en sus opciones de RStudio para iniciar siempre su sesi√≥n de RStudio con borr√≥n y cuenta nueva.\n\n\n\n\nHay un gran par de atajos de teclado que funcionar√°n juntos para asegurarse de que ha capturado las partes importantes de su c√≥digo en el editor:\n\nPresione Cmd/Ctrl + Shift + 0/F10 para reiniciar R.\nPresione Cmd/Ctrl + Shift + S para volver a ejecutar el script actual.\n\nUsamos colectivamente este patr√≥n cientos de veces a la semana.\nAlternativamente, si no usa atajos de teclado, puede ir a Sesi√≥n &gt; Reiniciar R y luego resaltar y volver a ejecutar su secuencia de comandos actual.\n\n\n\n\n\n\nServidor RStudio\n\n\n\nSi est√° utilizando el servidor RStudio, su sesi√≥n R nunca se reinicia de manera predeterminada. Cuando cierra la pesta√±a del servidor RStudio, puede parecer que est√° cerrando R, pero el servidor en realidad lo mantiene funcionando en segundo plano. La pr√≥xima vez que regrese, estar√° exactamente en el mismo lugar donde se fue. Esto hace que sea a√∫n m√°s importante reiniciar R regularmente para que comience con una lista de actualizaci√≥n.\n\n\n\n6.2.2 ¬øD√≥nde vive su an√°lisis?\nR tiene una poderosa noci√≥n del directorio de trabajo. Aqu√≠ es donde R busca los archivos que le pides que cargue, y donde colocar√° los archivos que le pides que guarde. RStudio muestra su directorio de trabajo actual en la parte superior de la consola:\n\n\n\n\n\n\n\n\nY puede imprimir esto en c√≥digo de R ejecutando getwd():\n\ngetwd()\n#&gt; [1] \"/Users/hadley/Documents/r4ds\"\n\nEn esta sesi√≥n de R, el directorio de trabajo actual (piense en √©l como ‚Äúinicio‚Äù) est√° en la carpeta Documentos de hadley, en una subcarpeta llamada r4ds. Este c√≥digo devolver√° un resultado diferente cuando lo ejecute, porque su computadora tiene una estructura de directorio diferente a la de Hadley.\nComo usuario principiante de R, est√° bien dejar que su directorio de trabajo sea su directorio de inicio, directorio de documentos o cualquier otro directorio extra√±o en su computadora. Pero llevas varios cap√≠tulos en este libro y ya no eres un principiante. Muy pronto deber√≠a evolucionar para organizar sus proyectos en directorios y, cuando trabaje en un proyecto, establecer el directorio de trabajo de R en el directorio asociado.\nPuede configurar el directorio de trabajo desde R pero nosotros no lo recomendamos:\n\nsetwd(\"/path/to/my/CoolProject\")\n\nHay una mejor manera; una manera que tambi√©n lo coloca en el camino para administrar su trabajo de R como un experto. As√≠ es el proyecto de RStudio.\n\n6.2.3 Proyectos de RStudio\nMantener todos los archivos asociados con un proyecto determinado (datos de entrada, scripts R, resultados anal√≠ticos y figuras) juntos en un directorio es una pr√°ctica tan sabia y com√∫n que RStudio tiene soporte incorporado para esto a trav√©s de proyectos. Hagamos un proyecto para que lo use mientras trabaja en el resto de este libro. Haga clic en Archivo &gt; Nuevo proyecto, luego siga los pasos que se muestran en Figura¬†6.3.\n\n\n\n\n\n\n\nFigura¬†6.3: Para crear un nuevo proyecto: (arriba) primero haga clic en Nuevo directorio, luego (en el medio) haga clic en Nuevo proyecto, luego (abajo) complete el nombre del directorio (proyecto), elija un buen subdirectorio para su inicio y haga clic en Crear proyecto.\n\n\n\n\nLlame a su proyecto r4ds y piense detenidamente en qu√© subdirectorio coloca el proyecto. Si no lo guarda en un lugar sensato, ¬°ser√° dif√≠cil encontrarlo en el futuro!\nUna vez que se complete este proceso, obtendr√° un nuevo proyecto de RStudio solo para este libro. Verifique que el ‚Äúhogar‚Äù de su proyecto sea el directorio de trabajo actual:\n\ngetwd()\n#&gt; [1] /Users/hadley/Documents/r4ds\n\nAhora ingrese los siguientes comandos en el editor de secuencias de comandos y guarde el archivo, llam√°ndolo ‚Äúdiamantes.R‚Äù. Luego, cree una nueva carpeta llamada ‚Äúdatos‚Äù. Puede hacerlo haciendo clic en el bot√≥n ‚ÄúNueva carpeta‚Äù en el panel Archivos en RStudio. Finalmente, ejecute el script completo que guardar√° un archivo PNG y CSV en el directorio de su proyecto. No se preocupe por los detalles, los aprender√° m√°s adelante en el libro.\n\nlibrary(tidyverse)\n\nggplot(diamonds, aes(x = carat, y = price)) + \n  geom_hex()\nggsave(\"diamonds.png\")\n\nwrite_csv(diamonds, \"datos/diamonds.csv\")\n\nSalga de RStudio. Inspeccione la carpeta asociada con su proyecto ‚Äî observe el archivo .Rproj. Haga doble clic en ese archivo para volver a abrir el proyecto. Observe que vuelve a donde lo dej√≥: es el mismo directorio de trabajo e historial de comandos, y todos los archivos en los que estaba trabajando todav√≠a est√°n abiertos. Sin embargo, debido a que sigui√≥ nuestras instrucciones anteriores, tendr√° un entorno completamente nuevo, lo que garantiza que est√° comenzando desde cero.\nDe la forma espec√≠fica de su sistema operativo favorito, busque diamonds.png en su computadora y encontrar√° el PNG (no es de extra√±ar), pero tambi√©n el script que lo cre√≥ (diamonds.R). ¬°Esta es una gran victoria! Un d√≠a querr√°s rehacer una figura o simplemente entender de d√≥nde vino. Si guarda rigurosamente las figuras en archivos con c√≥digo de R y nunca con el mouse o el portapapeles, ¬°podr√° reproducir trabajos antiguos con facilidad!\n\n6.2.4 Rutas relativas y absolutas\nUna vez que est√© dentro de un proyecto, solo debe usar rutas relativas, no rutas absolutas. ¬øCual es la diferencia? Una ruta relativa es relativa al directorio de trabajo, es decir, el hogar del proyecto. Cuando Hadley escribi√≥ data/diamonds.csv arriba, era un atajo para /Users/hadley/Documents/r4ds/data/diamonds.csv. Pero lo que es m√°s importante, si Mine ejecutara este c√≥digo en su computadora, apuntar√≠a a /Users/Mine/Documents/r4ds/data/diamonds.csv. Esta es la raz√≥n por la que las rutas relativas son importantes: funcionar√°n independientemente de d√≥nde termine la carpeta del proyecto R.\nLas rutas absolutas apuntan al mismo lugar independientemente de su directorio de trabajo. Se ven un poco diferentes dependiendo de su sistema operativo. En Windows, comienzan con una letra de unidad (por ejemplo, C:) o dos barras invertidas (por ejemplo, \\\\servername) y en Mac/Linux comienzan con una barra inclinada ‚Äú/‚Äù (por ejemplo, /users/hadley). Nunca debe usar rutas absolutas en sus scripts, porque dificultan el uso compartido: nadie m√°s tendr√° exactamente la misma configuraci√≥n de directorio que usted.\nHay otra diferencia importante entre los sistemas operativos: c√≥mo se separan los componentes de la ruta. Mac y Linux usan barras inclinadas (por ejemplo, data/diamonds.csv) y Windows usa barras invertidas (por ejemplo, data\\diamonds.csv). R puede funcionar con cualquier tipo (sin importar qu√© plataforma est√© usando actualmente), pero desafortunadamente, las barras invertidas significan algo especial para R, y para obtener una sola barra invertida en la ruta, ¬°debe escribir dos barras invertidas! Eso hace que la vida sea frustrante, por lo que recomendamos usar siempre el estilo Linux/Mac con barras diagonales.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Flujo de trabajo: scripts y proyectos</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#ejercicios",
    "href": "workflow-scripts.html#ejercicios",
    "title": "6¬† Flujo de trabajo: scripts y proyectos",
    "section": "\n6.3 Ejercicios",
    "text": "6.3 Ejercicios\n\nVaya a la cuenta de Twitter RStudio Tips, https://twitter.com/rstudiotips y encuentre un consejo que parezca interesante. ¬°Practica usarlo!\n¬øQu√© otros errores comunes informar√° el diagn√≥stico de RStudio? Lea https://support.posit.co/hc/en-us/articles/205753617-Code-Diagnostics para averiguarlo.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Flujo de trabajo: scripts y proyectos</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#resumen",
    "href": "workflow-scripts.html#resumen",
    "title": "6¬† Flujo de trabajo: scripts y proyectos",
    "section": "\n6.4 Resumen",
    "text": "6.4 Resumen\nEn este cap√≠tulo, ha aprendido a organizar su c√≥digo R en scripts (archivos) y proyectos (directorios). Al igual que el estilo de c√≥digo, esto puede parecer un trabajo pesado al principio. Pero a medida que acumule m√°s c√≥digo en m√∫ltiples proyectos, aprender√° a apreciar c√≥mo un poco de organizaci√≥n inicial puede ahorrarle mucho tiempo en el futuro.\nEn resumen, los guiones y los proyectos le brindan un flujo de trabajo s√≥lido que le ser√° √∫til en el futuro:\n\nCree un proyecto de RStudio para cada proyecto de an√°lisis de datos.\nGuarde sus scripts (con nombres informativos) en el proyecto, ed√≠telos, ejec√∫telos en bits o como un todo. Reinicie R con frecuencia para asegurarse de haber capturado todo en sus scripts.\nSolo use rutas relativas, no rutas absolutas.\n\nEntonces todo lo que necesita est√° en un solo lugar y claramente separado de todos los dem√°s proyectos en los que est√° trabajando.\nHasta ahora, hemos trabajado con conjuntos de datos incluidos en paquetes de R. Esto hace que sea m√°s f√°cil obtener algo de pr√°ctica con datos preparados previamente, pero obviamente sus datos no estar√°n disponibles de esta manera. Entonces, en el pr√≥ximo cap√≠tulo, aprender√° c√≥mo cargar datos desde el disco en su sesi√≥n R usando el paquete readr.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Flujo de trabajo: scripts y proyectos</span>"
    ]
  },
  {
    "objectID": "workflow-scripts.html#footnotes",
    "href": "workflow-scripts.html#footnotes",
    "title": "6¬† Flujo de trabajo: scripts y proyectos",
    "section": "",
    "text": "Si no tiene instalado usethis, puede instalarlo con install.packages(\"usethis\").‚Ü©Ô∏é",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Flujo de trabajo: scripts y proyectos</span>"
    ]
  },
  {
    "objectID": "data-import.html",
    "href": "data-import.html",
    "title": "7¬† Importaci√≥n de datos",
    "section": "",
    "text": "7.1 Introducci√≥n\nTrabajar con datos proporcionados por paquetes de R es una excelente manera de aprender herramientas de ciencia de datos, pero desea aplicar lo que ha aprendido a sus propios datos en alg√∫n momento. En este cap√≠tulo, aprender√° los aspectos b√°sicos de la lectura de archivos de datos en R.\nEspec√≠ficamente, este cap√≠tulo se centrar√° en la lectura de archivos rectangulares de texto sin formato. Comenzaremos con consejos pr√°cticos para manejar caracter√≠sticas como nombres de columnas, tipos y datos faltantes. Luego aprender√° a leer datos de varios archivos a la vez y a escribir datos de R en un archivo. Finalmente, aprender√° c√≥mo crear data frames en R.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Importaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-import.html#introducci√≥n",
    "href": "data-import.html#introducci√≥n",
    "title": "7¬† Importaci√≥n de datos",
    "section": "",
    "text": "7.1.1 Requisitos previos\nEn este cap√≠tulo, aprender√° a cargar archivos planos en R con el paquete readr, que forma parte del n√∫cleo tidyverse.\n\nlibrary(tidyverse)",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Importaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-import.html#lectura-de-datos-de-un-archivo",
    "href": "data-import.html#lectura-de-datos-de-un-archivo",
    "title": "7¬† Importaci√≥n de datos",
    "section": "\n7.2 Lectura de datos de un archivo",
    "text": "7.2 Lectura de datos de un archivo\nPara comenzar, nos centraremos en el tipo de archivo de datos m√°s rectangular m√°s com√∫n: CSV, que es la abreviatura de valores separados por comas. As√≠ es como se ve un archivo CSV simple. La primera fila, com√∫nmente llamada fila de encabezado, proporciona los nombres de las columnas y las seis filas siguientes proporcionan los datos. Las columnas est√°n separadas, tambi√©n conocidas como delimitadas, por comas.\n\nStudent ID,Full Name,favourite.food,mealPlan,AGE\n1,Sunil Huffmann,Strawberry yoghurt,Lunch only,4\n2,Barclay Lynn,French fries,Lunch only,5\n3,Jayendra Lyne,N/A,Breakfast and lunch,7\n4,Leon Rossini,Anchovies,Lunch only,\n5,Chidiegwu Dunkel,Pizza,Breakfast and lunch,five\n6,G√ºven√ß Attila,Ice cream,Lunch only,6\n\nTabla¬†7.1 muestra una representaci√≥n de los mismos datos que una tabla.\n\n\n\nTabla¬†7.1: Datos del archivo students.csv como una tabla.\n\n\n\n\n\n\n\n\n\n\n\nStudent ID\nFull Name\nfavourite.food\nmealPlan\nAGE\n\n\n\n1\nSunil Huffmann\nStrawberry yoghurt\nLunch only\n4\n\n\n2\nBarclay Lynn\nFrench fries\nLunch only\n5\n\n\n3\nJayendra Lyne\nN/A\nBreakfast and lunch\n7\n\n\n4\nLeon Rossini\nAnchovies\nLunch only\nNA\n\n\n5\nChidiegwu Dunkel\nPizza\nBreakfast and lunch\nfive\n\n\n6\nG√ºven√ß Attila\nIce cream\nLunch only\n6\n\n\n\n\n\n\n\n\nPodemos leer este archivo en R usando read_csv(). El primer argumento es el m√°s importante: la ruta al archivo. Puede pensar en la ruta como la direcci√≥n del archivo: el archivo se llama students.csv y vive en la carpeta data.\n\nstudents &lt;- read_csv(\"data/students.csv\")\n#&gt; Rows: 6 Columns: 5\n#&gt; ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#&gt; Delimiter: \",\"\n#&gt; chr (4): Full Name, favourite.food, mealPlan, AGE\n#&gt; dbl (1): Student ID\n#&gt; \n#&gt; ‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nEl c√≥digo anterior funcionar√° si tiene el archivo students.csv en una carpeta data en su proyecto. Puede descargar el archivo students.csv desde https://pos.it/r4ds-students-csv o puede leerlo directamente desde esa URL con:\n\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\")\n\nCuando ejecuta read_csv(), imprime un mensaje que le indica el n√∫mero de filas y columnas de datos, el delimitador que se us√≥ y las especificaciones de las columnas (nombres de columnas organizados por el tipo de datos que contiene la columna). Tambi√©n imprime informaci√≥n sobre c√≥mo recuperar la especificaci√≥n de columna completa y c√≥mo silenciar este mensaje. Este mensaje es una parte integral de readr, y regresaremos a √©l en Secci√≥n 7.3.\n\n7.2.1 Consejo practico\nUna vez que lee los datos, el primer paso generalmente consiste en transformarlos de alguna manera para que sea m√°s f√°cil trabajar con ellos en el resto de su an√°lisis. Echemos otro vistazo a los datos de students con eso en mente.\n\nstudents\n#&gt; # A tibble: 6 √ó 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 G√ºven√ß Attila    Ice cream          Lunch only          6\n\nEn la columna favourite.food, hay un mont√≥n de art√≠culos de comida, y luego la cadena de caracteres N/A, que deber√≠a haber sido un NA real que R reconocer√° como ‚Äúno disponible‚Äù. Esto es algo que podemos abordar usando el argumento na. Por defecto read_csv() solo reconoce cadenas vac√≠as (\"\") como NAs, y queremos que tambi√©n reconozca la cadena de caracteres \"N/A.\n\nstudents &lt;- read_csv(\"data/students.csv\", na = c(\"N/A\", \"\"))\n\nstudents\n#&gt; # A tibble: 6 √ó 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 G√ºven√ß Attila    Ice cream          Lunch only          6\n\nTambi√©n puede notar que las columnas Student ID y Full Name est√°n rodeadas de acentos graves. Eso es porque contienen espacios, rompiendo las reglas usuales de R para nombres de variables; son nombres no sint√°cticos. Para hacer referencia a estas variables, debe rodearlas con acentos graves, `:\n\nstudents |&gt; \n  rename(\n    student_id = `Student ID`,\n    full_name = `Full Name`\n  )\n#&gt; # A tibble: 6 √ó 5\n#&gt;   student_id full_name        favourite.food     mealPlan            AGE  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 G√ºven√ß Attila    Ice cream          Lunch only          6\n\nUn enfoque alternativo es usar janitor::clean_names() para usar algunas heur√≠sticas para convertirlos todos en un caso de serpiente a la vez 1.\n\nstudents |&gt; janitor::clean_names()\n#&gt; # A tibble: 6 √ó 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 G√ºven√ß Attila    Ice cream          Lunch only          6\n\nOtra tarea com√∫n despu√©s de leer datos es considerar tipos de variables. Por ejemplo, meal_plan es una variable categ√≥rica con un conjunto conocido de valores posibles, que en R deber√≠a representarse como un factor:\n\nstudents |&gt;\n  janitor::clean_names() |&gt;\n  mutate(meal_plan = factor(meal_plan))\n#&gt; # A tibble: 6 √ó 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 G√ºven√ß Attila    Ice cream          Lunch only          6\n\nTenga en cuenta que los valores en la variable meal_plan se han mantenido igual, pero el tipo de variable indicado debajo del nombre de la variable ha cambiado de car√°cter (&lt;chr&gt;) a factor (&lt;fct&gt;). Aprender√° m√°s sobre los factores en Cap√≠tulo 16.\nAntes de analizar estos datos, probablemente querr√° arreglar las columna age. Actualmente, age es una variable de car√°cter porque una de las observaciones se escribe como five en lugar de un 5 num√©rico. Discutimos los detalles para solucionar este problema en Cap√≠tulo 20.\n\nstudents &lt;- students |&gt;\n  janitor::clean_names() |&gt;\n  mutate(\n    meal_plan = factor(meal_plan),\n    age = parse_number(if_else(age == \"five\", \"5\", age))\n  )\n\nstudents\n#&gt; # A tibble: 6 √ó 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 G√ºven√ß Attila    Ice cream          Lunch only              6\n\nUna nueva funci√≥n aqu√≠ es if_else(), que tiene tres argumentos. El primer argumento test debe ser un vector l√≥gico. El resultado contendr√° el valor del segundo argumento, yes, cuando test es TRUE, y el valor del tercer argumento, no, cuando es FALSE. Aqu√≠ decimos que si age es la cadena de caracteres \"five\", convi√©rtala en \"5\", y si no, d√©jela como age. Aprender√° m√°s sobre if_else() y los vectores l√≥gicos en Cap√≠tulo 12.\n\n7.2.2 Otros argumentos\nHay un par de otros argumentos importantes que debemos mencionar, y ser√°n m√°s f√°ciles de demostrar si primero le mostramos un truco √∫til: read_csv() puede leer archivos CSV que ha creado en una cadena:\n\nread_csv(\n  \"a,b,c\n  1,2,3\n  4,5,6\"\n)\n#&gt; # A tibble: 2 √ó 3\n#&gt;       a     b     c\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n\nPor lo general, read_csv() usa la primera l√≠nea de los datos para los nombres de las columnas, lo cual es una convenci√≥n muy com√∫n. Pero no es raro que se incluyan algunas l√≠neas de metadatos en la parte superior del archivo. Puede usar skip = n para omitir las primeras n l√≠neas o usar comment = \"#\" para descartar todas las l√≠neas que comienzan con (por ejemplo) #:\n\nread_csv(\n  \"La primera l√≠nea de metadatos\n  La segunda l√≠nea de metadatos\n  x,y,z\n  1,2,3\",\n  skip = 2\n)\n#&gt; # A tibble: 1 √ó 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n\nread_csv(\n  \"# Un comentario que quiero saltar\n  x,y,z\n  1,2,3\",\n  comment = \"#\"\n)\n#&gt; # A tibble: 1 √ó 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n\nEn otros casos, es posible que los datos no tengan nombres de columna. Puedes usar col_names = FALSE para decirle a read_csv() que no trate la primera fila como encabezados y, en su lugar, etiqu√©talos secuencialmente desde X1 a Xn:\n\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = FALSE\n)\n#&gt; # A tibble: 2 √ó 3\n#&gt;      X1    X2    X3\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n\nAlternativamente, puede pasar col_names un vector de caracteres que se usar√° como los nombres de las columnas:\n\nread_csv(\n  \"1,2,3\n  4,5,6\",\n  col_names = c(\"x\", \"y\", \"z\")\n)\n#&gt; # A tibble: 2 √ó 3\n#&gt;       x     y     z\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2     3\n#&gt; 2     4     5     6\n\nEstos argumentos son todo lo que necesita saber para leer la mayor√≠a de los archivos CSV que encontrar√° en la pr√°ctica. (Por lo dem√°s, deber√° inspeccionar cuidadosamente su archivo .csv y leer la documentaci√≥n de los muchos otros argumentos de read_csv()).\n\n7.2.3 Otros tipos de archivos\nUna vez que haya dominado read_csv(), usar las otras funciones de readr es sencillo; es solo una cuesti√≥n de saber qu√© funci√≥n alcanzar:\n\nread_csv2() lee archivos separados por punto y coma. Estos usan ; en lugar de , para separar campos y son comunes en pa√≠ses que usan , como marcador decimal.\nread_tsv() lee archivos delimitados por tabuladores.\nread_delim() lee archivos con cualquier delimitador, intentando adivinar autom√°ticamente el delimitador si no lo especificas.\nread_fwf() lee archivos de ancho fijo. Puede especificar campos por sus anchos con fwf_widths() o por sus posiciones con fwf_positions().\nread_table() lee una variaci√≥n com√∫n de archivos de ancho fijo donde las columnas est√°n separadas por espacios en blanco.\nread_log() lee archivos de registro de estilo Apache.\n\n7.2.4 Ejercicios\n\n¬øQu√© funci√≥n usar√≠a para leer un archivo donde los campos se separaron con ‚Äú|‚Äù?\nAparte de file, skip y comment, ¬øqu√© otros argumentos tienen en com√∫n read_csv() y read_tsv()?\n¬øCu√°les son los argumentos m√°s importantes para read_fwf()?\n\nA veces, las cadenas de un archivo CSV contienen comas. Para evitar que causen problemas, deben estar rodeados por un car√°cter de comillas, como \" o '. Por defecto, read_csv() asume que el car√°cter de comillas ser√° \". Para leer el siguiente texto en un data frame, ¬øqu√© argumento para read_csv() necesita especificar?\n\n\"x,y\\n1,'a,b'\"\n\n\n\nIdentifique qu√© est√° mal con cada uno de los siguientes archivos CSV en l√≠nea. ¬øQu√© sucede cuando ejecutas el c√≥digo?\n\nread_csv(\"a,b\\n1,2,3\\n4,5,6\")\nread_csv(\"a,b,c\\n1,2\\n1,2,3,4\")\nread_csv(\"a,b\\n\\\"1\")\nread_csv(\"a,b\\n1,2\\na,b\")\nread_csv(\"a;b\\n1;3\")\n\n\n\nPractique referirse a nombres no sint√°cticos en el siguiente marco de datos:\n\nExtrayendo la variable llamada 1.\nTrazar un diagrama de dispersi√≥n de 1 frente a 2. C. Crear una nueva columna llamada 3, que es 2 dividido por 1.\nCambiar el nombre de las columnas a uno, dos y tres.\n\n\nannoying &lt;- tibble(\n  `1` = 1:10,\n  `2` = `1` * 2 + rnorm(length(`1`))\n)",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Importaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-import.html#sec-col-types",
    "href": "data-import.html#sec-col-types",
    "title": "7¬† Importaci√≥n de datos",
    "section": "\n7.3 Controlar tipos de columna",
    "text": "7.3 Controlar tipos de columna\nUn archivo CSV no contiene ninguna informaci√≥n sobre el tipo de cada variable (es decir, si es un n√∫mero l√≥gico, una cadena, etc.), por lo que readr intentar√° adivinar el tipo. Esta secci√≥n describe c√≥mo funciona el proceso de adivinaci√≥n, c√≥mo resolver algunos problemas comunes que hacen que falle y, si es necesario, c√≥mo proporcionar los tipos de columna usted mismo. Finalmente, mencionaremos algunas estrategias generales que son √∫tiles si readr est√° fallando catastr√≥ficamente y necesita obtener m√°s informaci√≥n sobre la estructura de su archivo.\n\n7.3.1 Adivinar tipos\nreadr usa una heur√≠stica para averiguar los tipos de columna. Para cada columna, extrae los valores de 1000[^data-import-2] filas espaciadas uniformemente desde la primera fila hasta la √∫ltima, ignorando los valores faltantes. Luego trabaja a trav√©s de las siguientes preguntas:\n[^importaci√≥n de datos-2]: puede anular el valor predeterminado de 1000 con el argumento guess_max.\n\n¬øContiene solo F, T, FALSE o TRUE (ignorando may√∫sculas y min√∫sculas)? Si es as√≠, es una l√≥gica.\n¬øContiene solo n√∫meros (por ejemplo, 1, -4.5, 5e6, Inf)? Si es as√≠, es un n√∫mero.\n¬øCoincide con el est√°ndar ISO8601? Si es as√≠, es una fecha o fecha-hora. (Volveremos a las fechas y horas con m√°s detalle en Secci√≥n 17.2).\nDe lo contrario, debe ser una cadena.\n\nPuedes ver ese comportamiento en acci√≥n en este sencillo ejemplo:\n\nread_csv(\"\n  logico,numerico,fecha,cadena\n  TRUE,1,2021-01-15,abc\n  false,4.5,2021-02-15,def\n  T,Inf,2021-02-16,ghi\"\n)\n#&gt; Rows: 3 Columns: 4\n#&gt; ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#&gt; Delimiter: \",\"\n#&gt; chr  (1): cadena\n#&gt; dbl  (1): numerico\n#&gt; lgl  (1): logico\n#&gt; date (1): fecha\n#&gt; \n#&gt; ‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#&gt; # A tibble: 3 √ó 4\n#&gt;   logico numerico fecha      cadena\n#&gt;   &lt;lgl&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt; \n#&gt; 1 TRUE        1   2021-01-15 abc   \n#&gt; 2 FALSE       4.5 2021-02-15 def   \n#&gt; 3 TRUE      Inf   2021-02-16 ghi\n\nEsta heur√≠stica funciona bien si tiene un conjunto de datos limpio, pero en la vida real encontrar√° una selecci√≥n de fallas extra√±as y hermosas.\n\n7.3.2 Valores faltantes, tipos de columnas y problemas\nLa forma m√°s com√∫n en que falla la detecci√≥n de columnas es que una columna contiene valores inesperados y obtiene una columna de caracteres en lugar de un tipo m√°s espec√≠fico. Una de las causas m√°s comunes de esto es un valor faltante, registrado usando algo diferente al NA que espera stringr.\nTome este simple archivo CSV de 1 columna como ejemplo:\n\ncsv &lt;- \"\n  x\n  10\n  .\n  20\n  30\"\n\nSi lo leemos sin argumentos adicionales, x se convierte en una columna de caracteres:\n\ndf &lt;- read_csv(csv)\n#&gt; Rows: 4 Columns: 1\n#&gt; ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#&gt; Delimiter: \",\"\n#&gt; chr (1): x\n#&gt; \n#&gt; ‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nEn este caso muy peque√±o, puede ver f√°cilmente el valor faltante .. Pero, ¬øqu√© sucede si tiene miles de filas con solo unos pocos valores faltantes representados por . salpicados entre ellos? Un enfoque es decirle a readr que x es una columna num√©rica y luego ver d√≥nde falla. Puede hacerlo con el argumento col_types, que toma una lista con nombre:\n\ndf &lt;- read_csv(csv, col_types = list(x = col_double()))\n#&gt; Warning: One or more parsing issues, call `problems()` on your data frame for\n#&gt; details, e.g.:\n#&gt;   dat &lt;- vroom(...)\n#&gt;   problems(dat)\n\nAhora read_csv() informa que hubo un problema y nos dice que podemos averiguar m√°s con problems():\n\nproblems(df)\n#&gt; # A tibble: 1 √ó 5\n#&gt;     row   col expected actual file                            \n#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;                           \n#&gt; 1     3     1 a double .      /tmp/Rtmp2rilfU/file592c60e1ba60\n\nEsto nos dice que hubo un problema en la fila 3, columna 1 donde readr esperaba un doble pero obtuvo un .. Eso sugiere que este conjunto de datos usa . para valores faltantes. Entonces establecemos na = \".\", la adivinaci√≥n autom√°tica tiene √©xito, d√°ndonos la columna num√©rica que queremos:\n\ndf &lt;- read_csv(csv, na = \".\")\n#&gt; Rows: 4 Columns: 1\n#&gt; ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#&gt; Delimiter: \",\"\n#&gt; dbl (1): x\n#&gt; \n#&gt; ‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n7.3.3 Tipos de columna\nreadr proporciona un total de nueve tipos de columnas para su uso:\n\n\ncol_logical() y col_double() leen n√∫meros l√≥gicos y reales. Son relativamente raramente necesarios (excepto como se indic√≥ anteriormente), ya que readr generalmente los adivinar√° por usted.\n\ncol_integer() lee n√∫meros enteros. Distinguimos enteros y dobles en este libro porque son funcionalmente equivalentes, pero leer enteros expl√≠citamente puede ser √∫til en ocasiones porque ocupan la mitad de la memoria de los dobles.\n\ncol_character() lee cadenas de texto. Esto puede ser √∫til para especificar expl√≠citamente cuando tiene una columna que es un identificador num√©rico, es decir, una larga serie de d√≠gitos que identifica un objeto pero no tiene sentido aplicarle operaciones matem√°ticas. Los ejemplos incluyen n√∫meros de tel√©fono, n√∫meros de seguro social, n√∫meros de tarjetas de cr√©dito, etc.\n\ncol_factor(), col_date() y col_datetime() crean factores, fechas y fecha-hora respectivamente; aprender√° m√°s sobre ellos cuando lleguemos a esos tipos de datos en Cap√≠tulo 16 y Cap√≠tulo 17.\n\ncol_number() es un analizador num√©rico permisivo que ignorar√° los componentes no num√©ricos y es particularmente √∫til para las monedas. Aprender√° m√°s al respecto en Cap√≠tulo 13.\n\ncol_skip() salta una columna por lo que no se incluye en el resultado.\n\nTambi√©n es posible anular la columna predeterminada cambiando de list() a cols():\n\ncsv &lt;- \"\nx,y,z\n1,2,3\"\n\nread_csv(csv, col_types = cols(.default = col_character()))\n#&gt; # A tibble: 1 √ó 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     2     3\n\nOtro ayudante √∫til es cols_only() que leer√° solo las columnas que especifique:\n\nread_csv(\n  \"x,y,z\n  1,2,3\",\n  col_types = cols_only(x = col_character())\n)\n#&gt; # A tibble: 1 √ó 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 1",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Importaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-import.html#sec-readr-directory",
    "href": "data-import.html#sec-readr-directory",
    "title": "7¬† Importaci√≥n de datos",
    "section": "\n7.4 Lectura de datos de varios archivos",
    "text": "7.4 Lectura de datos de varios archivos\nA veces, sus datos se dividen en varios archivos en lugar de estar contenidos en un solo archivo. Por ejemplo, puede tener datos de ventas de varios meses, con los datos de cada mes en un archivo separado: 01-sales.csv para enero, 02-sales.csv para febrero y 03-sales.csv para marzo. Con read_csv() puedes leer estos datos a la vez y apilarlos uno encima del otro en un solo data frame.\n\nsales_files &lt;- c(\"data/01-sales.csv\", \"data/02-sales.csv\", \"data/03-sales.csv\")\nread_csv(sales_files, id = \"file\")\n#&gt; Rows: 19 Columns: 6\n#&gt; ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#&gt; Delimiter: \",\"\n#&gt; chr (1): month\n#&gt; dbl (4): year, brand, item, n\n#&gt; \n#&gt; ‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#&gt; # A tibble: 19 √ó 6\n#&gt;   file              month    year brand  item     n\n#&gt;   &lt;chr&gt;             &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 data/01-sales.csv January  2019     1  1234     3\n#&gt; 2 data/01-sales.csv January  2019     1  8721     9\n#&gt; 3 data/01-sales.csv January  2019     1  1822     2\n#&gt; 4 data/01-sales.csv January  2019     2  3333     1\n#&gt; 5 data/01-sales.csv January  2019     2  2156     9\n#&gt; 6 data/01-sales.csv January  2019     2  3987     6\n#&gt; # ‚Ñπ 13 more rows\n\nCon el par√°metro id adicional, hemos agregado una nueva columna llamada file al data frame resultante que identifica el archivo del que provienen los datos. Esto es especialmente √∫til en circunstancias en las que los archivos que est√° leyendo no tienen una columna de identificaci√≥n que pueda ayudarlo a rastrear las observaciones hasta sus fuentes originales.\nSi tiene muchos archivos que desea leer, puede resultar engorroso escribir sus nombres en una lista. En su lugar, puede usar la funci√≥n b√°sica list.files() para encontrar los archivos haciendo coincidir un patr√≥n en los nombres de los archivos. Aprender√° m√°s sobre estos patrones en Cap√≠tulo 15.\n\nsales_files &lt;- list.files(\"data\", pattern = \"sales\\\\.csv$\", full.names = TRUE)\nsales_files\n#&gt; [1] \"data/01-sales.csv\" \"data/02-sales.csv\" \"data/03-sales.csv\"",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Importaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-import.html#sec-writing-to-a-file",
    "href": "data-import.html#sec-writing-to-a-file",
    "title": "7¬† Importaci√≥n de datos",
    "section": "\n7.5 Escribir en un archivo",
    "text": "7.5 Escribir en un archivo\nreadr tambi√©n viene con dos funciones √∫tiles para volver a escribir datos en el disco: write_csv() y write_tsv(). Ambas funciones aumentan las posibilidades de que el archivo de salida se vuelva a leer correctamente mediante el uso de la codificaci√≥n UTF-8 est√°ndar para cadenas y el formato ISO8601 para fecha y hora.\nLos argumentos m√°s importantes son x (el marco de datos para guardar) y file (la ubicaci√≥n para guardarlo). Tambi√©n puede especificar c√≥mo se escriben los valores faltantes con na y si desea agregar a un archivo existente.\n\nwrite_csv(students, \"students.csv\")\n\nAhora volvamos a leer ese archivo csv. Tenga en cuenta que la informaci√≥n de tipo se pierde cuando guarda en csv:\n\nstudents\n#&gt; # A tibble: 6 √ó 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 G√ºven√ß Attila    Ice cream          Lunch only              6\nwrite_csv(students, \"students-2.csv\")\nread_csv(\"students-2.csv\")\n#&gt; # A tibble: 6 √ó 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 G√ºven√ß Attila    Ice cream          Lunch only              6\n\nEsto hace que los CSV sean un poco poco confiables para almacenar en cach√© los resultados intermedios: debe volver a crear la especificaci√≥n de la columna cada vez que carga. Hay dos alternativas principales:\n\n\nwrite_rds() y read_rds() son envoltorios uniformes alrededor de las funciones base readRDS() y saveRDS(). Estos almacenan datos en el formato binario personalizado de R llamado RDS:\n\nwrite_rds(students, \"students.rds\")\nread_rds(\"students.rds\")\n#&gt; # A tibble: 6 √ó 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 G√ºven√ß Attila    Ice cream          Lunch only              6\n\n\n\nEl paquete arrow le permite leer y escribir archivos de parquet, un formato de archivo binario r√°pido que se puede compartir entre lenguajes de programaci√≥n. Volveremos a arrow con m√°s profundidad en Cap√≠tulo 22.\n\nlibrary(arrow)\nwrite_parquet(students, \"students.parquet\")\nread_parquet(\"students.parquet\")\n#&gt; # A tibble: 6 √ó 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    NA                 Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 G√ºven√ß Attila    Ice cream          Lunch only              6\n\n\n\nParquet tiende a ser mucho m√°s r√°pido que RDS y se puede usar fuera de R, pero requiere el paquete arrow.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Importaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-import.html#entrada-de-datos",
    "href": "data-import.html#entrada-de-datos",
    "title": "7¬† Importaci√≥n de datos",
    "section": "\n7.6 Entrada de datos",
    "text": "7.6 Entrada de datos\nA veces necesitar√° ensamblar un tibble ‚Äúa mano‚Äù haciendo una peque√±a entrada de datos en su script de R. Hay dos funciones √∫tiles para ayudarlo a hacer esto, que difieren en si dise√±a el tibble por columnas o por filas. tibble() funciona por columna:\n\ntibble(\n  x = c(1, 2, 5), \n  y = c(\"h\", \"m\", \"g\"),\n  z = c(0.08, 0.83, 0.60)\n)\n#&gt; # A tibble: 3 √ó 3\n#&gt;       x y         z\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     1 h      0.08\n#&gt; 2     2 m      0.83\n#&gt; 3     5 g      0.6\n\nTenga en cuenta que todas las columnas en tibble deben tener el mismo tama√±o, por lo que obtendr√° un error si no lo son:\n\ntibble(\n  x = c(1, 2),\n  y = c(\"h\", \"m\", \"g\"),\n  z = c(0.08, 0.83, 0.6)\n)\n#&gt; Error in `tibble()`:\n#&gt; ! Tibble columns must have compatible sizes.\n#&gt; ‚Ä¢ Size 2: Existing data.\n#&gt; ‚Ä¢ Size 3: Column `y`.\n#&gt; ‚Ñπ Only values of size one are recycled.\n\nDistribuir los datos por columna puede dificultar ver c√≥mo se relacionan las filas, por lo que una alternativa es tribble(), abreviatura de tibble transpuesto (transposed tibble, en ingl√©s), que le permite distribuir sus datos fila por fila. tribble() est√° personalizado para la entrada de datos en el c√≥digo: los encabezados de las columnas comienzan con ~ y las entradas est√°n separadas por comas. Esto hace posible dise√±ar peque√±as cantidades de datos en un formato f√°cil de leer:\n\ntribble(\n  ~x, ~y, ~z,\n  \"h\", 1, 0.08,\n  \"m\", 2, 0.83,\n  \"g\", 5, 0.60,\n)\n#&gt; # A tibble: 3 √ó 3\n#&gt;   x         y     z\n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 h         1  0.08\n#&gt; 2 m         2  0.83\n#&gt; 3 g         5  0.6\n\nUsaremos tibble() y tribble() m√°s adelante en el libro para construir peque√±os ejemplos para demostrar c√≥mo funcionan varias funciones.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Importaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-import.html#resumen",
    "href": "data-import.html#resumen",
    "title": "7¬† Importaci√≥n de datos",
    "section": "\n7.7 Resumen",
    "text": "7.7 Resumen\nEn este cap√≠tulo, ha aprendido a cargar archivos CSV con read_csv() y a realizar su propia entrada de datos con tibble() y tribble(). Ha aprendido c√≥mo funcionan los archivos csv, algunos de los problemas que puede encontrar y c√≥mo solucionarlos. Llegaremos a la importaci√≥n de datos varias veces en este libro: Cap√≠tulo 20 desde Excel y Google Sheets, Cap√≠tulo 21 le mostrar√° c√≥mo cargar datos desde bases de datos, Cap√≠tulo 22 desde archivos parquet, @ sec-rectangling de JSON y Cap√≠tulo 24 de sitios web.\nEstamos casi al final de esta secci√≥n del libro, pero hay un √∫ltimo tema importante que cubrir: c√≥mo obtener ayuda. Entonces, en el pr√≥ximo cap√≠tulo, aprender√° algunos buenos lugares para buscar ayuda, c√≥mo crear un reprex para maximizar sus posibilidades de obtener una buena ayuda y algunos consejos generales para mantenerse al d√≠a con el mundo de R.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Importaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "data-import.html#footnotes",
    "href": "data-import.html#footnotes",
    "title": "7¬† Importaci√≥n de datos",
    "section": "",
    "text": "El paquete janitor no es parte de tidyverse, pero ofrece funciones √∫tiles para la limpieza de datos y funciona bien dentro de las canalizaciones de datos que usa |&gt;.‚Ü©Ô∏é",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Importaci√≥n de datos</span>"
    ]
  },
  {
    "objectID": "workflow-help.html",
    "href": "workflow-help.html",
    "title": "8¬† Flujo de trabajo: obtener ayuda",
    "section": "",
    "text": "8.1 Google es tu amigo\nEste libro no es una isla; no existe un solo recurso que te permita dominar R. A medida que comience a aplicar las t√©cnicas descritas en este libro a sus propios datos, pronto encontrar√° preguntas que no respondemos. Esta secci√≥n describe algunos consejos sobre c√≥mo obtener ayuda y ayudarlo a seguir aprendiendo.\nSi te quedas atascado, empieza con Google. Por lo general, agregar ‚ÄúR‚Äù a una consulta es suficiente para restringirla a resultados relevantes: si la b√∫squeda no es √∫til, a menudo significa que no hay resultados espec√≠ficos de R disponibles. Adem√°s, agregar nombres de paquetes como ‚Äútidyverse‚Äù o ‚Äúggplot2‚Äù ayudar√° a reducir los resultados a un c√≥digo que tambi√©n le resulte m√°s familiar, por ejemplo, ‚Äúc√≥mo hacer un diagrama de caja en R‚Äù frente a ‚Äúc√≥mo hacer un diagrama de caja en R con ggplot2‚Äù. Google es particularmente √∫til para los mensajes de error. Si recibe un mensaje de error y no tiene idea de lo que significa, intente buscarlo en Google. Lo m√°s probable es que alguien m√°s se haya confundido en el pasado, y habr√° ayuda en alg√∫n lugar de la web. (Si el mensaje de error no est√° en ingl√©s, ejecute Sys.setenv(LANGUAGE = \"en\") y vuelva a ejecutar el c√≥digo; es m√°s probable que encuentre ayuda para los mensajes de error en ingl√©s).\nSi Google no ayuda, prueba Stack Overflow. Comience dedicando un poco de tiempo a buscar una respuesta existente, incluida [R], para restringir su b√∫squeda a preguntas y respuestas que usen R.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Flujo de trabajo: obtener ayuda</span>"
    ]
  },
  {
    "objectID": "workflow-help.html#haciendo-un-reprex",
    "href": "workflow-help.html#haciendo-un-reprex",
    "title": "8¬† Flujo de trabajo: obtener ayuda",
    "section": "\n8.2 Haciendo un reprex",
    "text": "8.2 Haciendo un reprex\nSi tu b√∫squeda en Google no encuentra nada √∫til, es una muy buena idea preparar un reprex, abreviatura de ejemplo m√≠nimo reproducible (en ingl√©s, reproducible example). Un buen reprex facilita que otras personas te ayuden y, a menudo, resolver√°s el problema por ti mismo mientras lo haces. Hay dos partes para crear un reprex:\n\nPrimero, debe hacer que su c√≥digo sea reproducible. Esto significa que necesita capturar todo, es decir, incluir cualquier llamada a library() y crear todos los objetos necesarios. La forma m√°s f√°cil de asegurarse de que ha hecho esto es usar el paquete reprex.\nEn segundo lugar, debe hacerlo m√≠nimo. Elimina todo lo que no est√© directamente relacionado con tu problema. Esto generalmente implica crear un objeto de R mucho m√°s peque√±o y simple que el que enfrenta en la vida real o incluso usar datos integrados.\n\n¬°Eso suena como un monton de trabajo! Y puede ser, pero tiene una gran recompensa:\n\nEl 80% de las veces, la creaci√≥n de un excelente reprex revela el origen de su problema. Es sorprendente la frecuencia con la que el proceso de escribir un ejemplo m√≠nimo e independiente le permite responder a su propia pregunta.\nEl otro 20% del tiempo, habr√° capturado la esencia de su problema de una manera que sea f√°cil de manejar para otros. ¬°Esto mejora sustancialmente sus posibilidades de obtener ayuda!\n\nAl crear un reprex a mano, es f√°cil pasar por alto algo accidentalmente, lo que significa que su c√≥digo no se puede ejecutar en la computadora de otra persona. Evite este problema utilizando el paquete reprex, que se instala como parte de tidyverse. Digamos que copia este c√≥digo en su portapapeles (o, en RStudio Server o Cloud, selecci√≥nelo):\n\ny &lt;- 1:4\nmean(y)\n\nLuego llame a reprex(), donde la salida predeterminada tiene formato para GitHub:\nreprex::reprex()\nSe mostrar√° una vista previa de HTML muy bien representada en el Visor de RStudio (si est√° en RStudio) o en su navegador predeterminado de lo contrario. El reprex se copia autom√°ticamente en su portapapeles (en RStudio Server o Cloud, deber√° copiarlo usted mismo):\n``` r\ny &lt;- 1:4\nmean(y)\n#&gt; [1] 2.5\n```\nEste texto tiene un formato especial, llamado Markdown, que se puede pegar en sitios como StackOverflow o Github y autom√°ticamente lo renderizar√°n para que parezca c√≥digo. As√≠ es como se ver√≠a ese Markdown representado en GitHub:\n\ny &lt;- 1:4\nmean(y)\n#&gt; [1] 2.5\n\nCualquier otra persona puede copiar, pegar y ejecutar esto inmediatamente.\nHay tres cosas que debe incluir para que su ejemplo sea reproducible: paquetes requeridos, datos y c√≥digo.\n\nLos paquetes deben cargarse en la parte superior del script para que sea f√°cil ver cu√°les necesita el ejemplo. Este es un buen momento para comprobar que est√° utilizando la √∫ltima versi√≥n de cada paquete; es posible que haya descubierto un error que se solucion√≥ desde que instal√≥ o actualiz√≥ el paquete por √∫ltima vez. Para los paquetes en tidyverse, la forma m√°s f√°cil de verificar es ejecutar tidyverse_update().\n\nLa forma m√°s f√°cil de incluir datos es usar dput() para generar el c√≥digo de R necesario para recrearlo. Por ejemplo, para recrear el conjunto de datos mtcars en R, realice los siguientes pasos:\n\nEjecute dput(mtcars) en R\nCopie la salida\nEn reprex, escriba mtcars &lt;-, luego pegue.\n\nTrate de usar el subconjunto m√°s peque√±o de sus datos que a√∫n revele el problema.\n\n\nDedique un poco de tiempo a asegurarse de que su c√≥digo sea f√°cil de leer para otros:\n\nAseg√∫rese de haber utilizado espacios y de que los nombres de las variables sean concisos pero informativos.\nUtilice comentarios para indicar d√≥nde radica su problema.\nHaz tu mejor esfuerzo para eliminar todo lo que no est√© relacionado con el problema.\n\nCuanto m√°s corto sea su c√≥digo, m√°s f√°cil ser√° de entender y m√°s f√°cil de arreglar.\n\n\nTermine comprobando que realmente ha creado un ejemplo reproducible iniciando una nueva sesi√≥n de R y copiando y pegando su secuencia de comandos.\nCrear reprexes no es trivial, y se necesitar√° algo de pr√°ctica para aprender a crear reprexes buenos y realmente m√≠nimos.\nSin embargo, aprender a hacer preguntas que incluyan el c√≥digo e invertir el tiempo para hacerlo reproducible seguir√° dando sus frutos a medida que aprenda y domine R.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Flujo de trabajo: obtener ayuda</span>"
    ]
  },
  {
    "objectID": "workflow-help.html#invertir-en-ti-mismo",
    "href": "workflow-help.html#invertir-en-ti-mismo",
    "title": "8¬† Flujo de trabajo: obtener ayuda",
    "section": "\n8.3 Invertir en ti mismo",
    "text": "8.3 Invertir en ti mismo\nTambi√©n debe pasar alg√∫n tiempo prepar√°ndose para resolver problemas antes de que ocurran. Invertir un poco de tiempo en aprender R cada d√≠a valdr√° la pena a largo plazo. Una forma es seguir lo que hace el equipo de tidyverse en el blog de tidyverse. Para mantenerse al d√≠a con la comunidad R de manera m√°s amplia, recomendamos leer R Weekly: es un esfuerzo de la comunidad para agregar las noticias m√°s interesantes de la comunidad de R cada semana.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Flujo de trabajo: obtener ayuda</span>"
    ]
  },
  {
    "objectID": "workflow-help.html#resumen",
    "href": "workflow-help.html#resumen",
    "title": "8¬† Flujo de trabajo: obtener ayuda",
    "section": "\n8.4 Resumen",
    "text": "8.4 Resumen\nEste cap√≠tulo concluye la parte de El Juego Completo del libro. Ahora ha visto las partes m√°s importantes del proceso de ciencia de datos: visualizaci√≥n, transformaci√≥n, limpieza e importaci√≥n. Ahora tiene una visi√≥n hol√≠stica de todo el proceso y comenzamos a entrar en los detalles de las piezas peque√±as.\nLa siguiente parte del libro, Visualizar, profundiza en la gram√°tica de los gr√°ficos y la creaci√≥n de visualizaciones de datos con ggplot2, muestra c√≥mo usar las herramientas que ha aprendido hasta ahora para realizar an√°lisis exploratorios de datos e introduce buenas pr√°cticas para crear gr√°ficos para comunicarse.",
    "crumbs": [
      "El Juego Completo",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Flujo de trabajo: obtener ayuda</span>"
    ]
  },
  {
    "objectID": "visualize.html",
    "href": "visualize.html",
    "title": "Visualizar",
    "section": "",
    "text": "Despu√©s de leer la primera parte del libro, comprende (al menos superficialmente) las herramientas m√°s importantes para hacer ciencia de datos. Ahora es el momento de empezar a sumergirse en los detalles. En esta parte del libro, aprender√° a visualizar datos con mayor profundidad.\n\n\n\n\n\n\n\nFigura¬†1: La visualizaci√≥n de datos suele ser el primer paso en la exploraci√≥n de datos.\n\n\n\n\nCada cap√≠tulo trata de uno a algunos aspectos de la creaci√≥n de una visualizaci√≥n de datos.\n\nEn 9¬† Capas aprender√°s sobre la gram√°tica en capas de los gr√°ficos.\nEn 10¬† An√°lisis exploratorio de datos, combinar√°s la visualizaci√≥n con tu curiosidad y escepticismo para hacer y responder preguntas interesantes sobre datos.\nFinalmente, en 11¬† Comunicaci√≥n aprender√° c√≥mo tomar sus gr√°ficos exploratorios, elevarlos y convertirlos en gr√°ficos expositivos, gr√°ficos que ayudan al reci√©n llegado a su an√°lisis a comprender lo que sucede de la manera m√°s r√°pida y sencilla posible.\n\nEstos tres cap√≠tulos lo inician en el mundo de la visualizaci√≥n, pero hay mucho m√°s que aprender. El mejor lugar para obtener m√°s informaci√≥n es el libro ggplot2: ggplot2: gr√°ficos elegantes para el an√°lisis de datos(3e). Profundiza mucho m√°s en la teor√≠a subyacente y tiene muchos m√°s ejemplos de c√≥mo combinar las piezas individuales para resolver problemas pr√°cticos. Otro gran recurso es la galer√≠a de extensiones ggplot2 https://exts.ggplot2.tidyverse.org/gallery/. Este sitio enumera muchos de los paquetes que ampl√≠an ggplot2 con nuevos geoms y escalas. Es un excelente lugar para comenzar si est√° tratando de hacer algo que parece dif√≠cil con ggplot2.",
    "crumbs": [
      "Visualizar"
    ]
  },
  {
    "objectID": "layers.html",
    "href": "layers.html",
    "title": "9¬† Capas",
    "section": "",
    "text": "9.1 Introducci√≥n\nEn Cap√≠tulo 1, aprendi√≥ mucho m√°s que solo c√≥mo hacer diagramas de dispersi√≥n, gr√°ficos de barras y diagramas de caja. Aprendiste una base que puedes usar para hacer cualquier tipo de gr√°fico con ggplot2.\nEn este cap√≠tulo, ampliar√° esa base a medida que aprenda sobre la gram√°tica en capas de los gr√°ficos. Comenzaremos con una inmersi√≥n m√°s profunda en mapeos est√©ticos, objetos geom√©tricos y facetas. Luego, aprender√° sobre las transformaciones estad√≠sticas que ggplot2 hace bajo el cap√≥ al crear un gr√°fico. Estas transformaciones se utilizan para calcular nuevos valores para graficar, como las alturas de las barras en un diagrama de barras o las medianas en un diagrama de caja. Tambi√©n aprender√° sobre los ajustes de posici√≥n, que modifican c√≥mo se muestran los geoms en sus gr√°ficos. Finalmente, presentaremos brevemente los sistemas de coordenadas.\nNo cubriremos todas las funciones y opciones para cada una de estas capas, pero lo guiaremos a trav√©s de la funcionalidad m√°s importante y de uso com√∫n proporcionada por ggplot2 y le presentaremos los paquetes que ampl√≠an ggplot2.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Capas</span>"
    ]
  },
  {
    "objectID": "layers.html#introducci√≥n",
    "href": "layers.html#introducci√≥n",
    "title": "9¬† Capas",
    "section": "",
    "text": "9.1.1 Requisitos previos\nEste cap√≠tulo se centra en ggplot2. Para acceder a los conjuntos de datos, las p√°ginas de ayuda y las funciones utilizadas en este cap√≠tulo, cargue tidyverse ejecutando este c√≥digo:\n\nlibrary(tidyverse)",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Capas</span>"
    ]
  },
  {
    "objectID": "layers.html#asignaciones-de-aesthetic",
    "href": "layers.html#asignaciones-de-aesthetic",
    "title": "9¬† Capas",
    "section": "\n9.2 Asignaciones de aesthetic",
    "text": "9.2 Asignaciones de aesthetic\n\n‚ÄúEl mayor valor de una imagen es cuando nos obliga a notar lo que nunca esper√°bamos ver.‚Äù ‚Äî John Tukey\n\nRecuerde que el marco de datos mpg incluido con el paquete ggplot2 contiene observaciones 234 en modelos de autom√≥viles 38.\n\nmpg\n#&gt; # A tibble: 234 √ó 11\n#&gt;   manufacturer model displ  year   cyl trans      drv     cty   hwy fl   \n#&gt;   &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;\n#&gt; 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p    \n#&gt; 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p    \n#&gt; 3 audi         a4      2    2008     4 manual(m6) f        20    31 p    \n#&gt; 4 audi         a4      2    2008     4 auto(av)   f        21    30 p    \n#&gt; 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p    \n#&gt; 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p    \n#&gt; # ‚Ñπ 228 more rows\n#&gt; # ‚Ñπ 1 more variable: class &lt;chr&gt;\n\nEntre las variables en mpg est√°n:\n\ndispl: Tama√±o del motor de un autom√≥vil, en litros. Una variable num√©rica.\nhwy: La eficiencia de combustible de un autom√≥vil en la carretera, en millas por gal√≥n (mpg). Un autom√≥vil con una eficiencia de combustible baja consume m√°s combustible que un autom√≥vil con una eficiencia de combustible alta cuando recorren la misma distancia. Una variable num√©rica.\nclass: Tipo de coche. Una variable categ√≥rica.\n\nComencemos visualizando la relaci√≥n entre displ y hwy para varias clases de autos. Podemos hacer esto con un diagrama de dispersi√≥n donde las variables num√©ricas se asignan a la est√©tica x e y y la variable categ√≥rica se asigna a una est√©tica como color o shape.\n# Izquierda\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point()\n\n# Derecha\nggplot(mpg, aes(x = displ, y = hwy, shape = class)) +\n  geom_point()\n#&gt; Warning: The shape palette can deal with a maximum of 6 discrete values because more\n#&gt; than 6 becomes difficult to discriminate\n#&gt; ‚Ñπ you have requested 7 values. Consider specifying shapes manually if you\n#&gt;   need that many have them.\n#&gt; Warning: Removed 62 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n\n\n\n\n\n\n\n\n\nCuando class se asigna a shape, recibimos dos advertencias:\n\n1: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; you have 7. Consider specifying shapes manually if you must have them.\n2: Removed 62 rows containing missing values (geom_point()).\n\nDado que ggplot2 solo usar√° seis formas a la vez, de manera predeterminada, los grupos adicionales no se trazar√°n cuando use la aesthetic shape. La segunda advertencia est√° relacionada: hay 62 SUV (todoterrenos) en el conjunto de datos y no est√°n representados.\nDe manera similar, tambi√©n podemos mapear la est√©tica class a size o alpha, que controlan el tama√±o y la transparencia de los puntos, respectivamente.\n# Izquierda\nggplot(mpg, aes(x = displ, y = hwy, size = class)) +\n  geom_point()\n#&gt; Warning: Using size for a discrete variable is not advised.\n\n# Derecha\nggplot(mpg, aes(x = displ, y = hwy, alpha = class)) +\n  geom_point()\n#&gt; Warning: Using alpha for a discrete variable is not advised.\n\n\n\n\n\n\n\n\n\n\nAmbos producen advertencias tambi√©n:\n\nUsing alpha for a discrete variable is not advised.\n\nAsignar una variable discreta (categ√≥rica) no ordenada (class) a una aesthetic ordenada (size o alpha) generalmente no es una buena idea porque implica una clasificaci√≥n que de hecho no existe.\nUna vez que mapeas una aesthetic, ggplot2 se encarga del resto. Selecciona una escala razonable para usar con la aesthetic y construye una leyenda que explica el mapeo entre niveles y valores. Para las aesthetics x e y, ggplot2 no crea una leyenda, pero crea una l√≠nea de eje con marcas y una etiqueta. La l√≠nea del eje proporciona la misma informaci√≥n que una leyenda; explica el mapeo entre ubicaciones y valores.\nTambi√©n puede establecer las propiedades visuales de su geom manualmente como un argumento de su funci√≥n geom (fuera de aes()) en lugar de depender de un mapeo de variables para determinar la apariencia. Por ejemplo, podemos hacer que todos los puntos de nuestro gr√°fico sean azules:\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(color = \"blue\")\n\n\n\n\n\n\n\nAqu√≠, el color no transmite informaci√≥n sobre una variable, sino que solo cambia la apariencia de la gr√°fica. Deber√° elegir un valor que tenga sentido para esa est√©tica:\n\nEl nombre de un color como una cadena de caracteres, por ejemplo, color = \"blue\".\nEl tama√±o de un punto en mm, por ejemplo, size = 1.\nLa forma de un punto como un n√∫mero, por ejemplo, shape = 1, como se muestra en Figura¬†9.1.\n\n\n\n\n\n\n\n\nFigura¬†9.1: R tiene 26 formas integradas que se identifican con n√∫meros. Hay algunos duplicados aparentes: por ejemplo, 0, 15 y 22 son todos cuadrados. La diferencia proviene de la interacci√≥n de las asthetics color y fill. Las formas huecas (0‚Äì14) tienen un borde determinado por color; las formas s√≥lidas (15‚Äì20) se rellenan con color; las formas rellenas (21‚Äì25) tienen un borde de color y se rellenan con fill. Las formas se organizan para mantener formas similares una al lado de la otra..\n\n\n\n\nHasta ahora hemos discutido la est√©tica que podemos mapear o establecer en un diagrama de dispersi√≥n, cuando usamos un geom_point. Puede obtener m√°s informaci√≥n sobre todas las asignaciones est√©ticas posibles en la vi√±eta de especificaciones est√©ticas en https://ggplot2.tidyverse.org/articles/ggplot2-specs.html.\nLa est√©tica espec√≠fica que puede usar para una gr√°fica depende de la geom que use para representar los datos. En la siguiente secci√≥n profundizaremos en las geomas.\n\n9.2.1 Ejercicios\n\nCree un diagrama de dispersi√≥n de hwy vs.¬†displ donde los puntos son tri√°ngulos rellenos de rosa.\n\n¬øPor qu√© el siguiente c√≥digo no dio como resultado un gr√°fico con puntos azules?\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy, color = \"blue\"))\n\n\n¬øQu√© hace la est√©tica stroke? ¬øCon qu√© formas trabaja? (Pista: usa ?geom_point)\n¬øQu√© sucede si asigna una est√©tica a algo que no sea un nombre de variable, como aes (color = displ &lt; 5)? Tenga en cuenta que tambi√©n deber√° especificar x e y.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Capas</span>"
    ]
  },
  {
    "objectID": "layers.html#sec-geometric-objects",
    "href": "layers.html#sec-geometric-objects",
    "title": "9¬† Capas",
    "section": "\n9.3 Objetos geom√©tricos",
    "text": "9.3 Objetos geom√©tricos\n¬øEn qu√© se parecen estas dos gr√°ficas?\n\n\n\n\n\n\n\n\n\n\nAmbas gr√°ficas contienen la misma variable x, la misma variable y, y ambas describen los mismos datos. Pero las gr√°ficas no son id√©nticas. Cada gr√°fico utiliza un objeto geom√©trico diferente, geom, para representar los datos. La gr√°fica de la izquierda usa geom_point, y la gr√°fica de la derecha usa geom_smooth, una l√≠nea suave ajustada a los datos.\nPara cambiar la geom en su gr√°fico, cambie la funci√≥n geom que agrega a ggplot(). Por ejemplo, para hacer los diagramas de arriba, puedes usar el siguiente c√≥digo:\n\n# Izquierda\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point()\n\n# Derecha\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_smooth()\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\nCada funci√≥n geom en ggplot2 toma un argumento mapping, definido localmente en la capa geom o globalmente en la capa ggplot(). Sin embargo, no todas las est√©ticas funcionan con todas las geom. Puede establecer la forma de un punto, pero no puede establecer la ‚Äúforma‚Äù de una l√≠nea. Si lo intenta, ggplot2 ignorar√° silenciosamente ese mapeo est√©tico. Por otro lado, podr√≠a establecer el tipo de l√≠nea de una l√≠nea. geom_smooth() dibujar√° una l√≠nea diferente, con un tipo de l√≠nea diferente, para cada valor √∫nico de la variable que asignas al tipo de l√≠nea.\n# Izquierda\nggplot(mpg, aes(x = displ, y = hwy, shape = drv)) + \n  geom_smooth()\n\n# Derecha\nggplot(mpg, aes(x = displ, y = hwy, linetype = drv)) + \n  geom_smooth()\n\n\n\n\n\n\n\n\n\n\nAqu√≠, geom_smooth() separa los autos en tres l√≠neas seg√∫n su valor drv, que describe el tren de transmisi√≥n de un auto. Una l√≠nea describe todos los puntos que tienen un valor 4, una l√≠nea describe todos los puntos que tienen un valor f y una l√≠nea describe todos los puntos que tienen un valor r. Aqu√≠, 4 significa tracci√≥n en las cuatro ruedas, f para tracci√≥n delantera y r para tracci√≥n trasera.\nSi esto suena extra√±o, podemos hacerlo m√°s claro superponiendo las l√≠neas sobre los datos sin procesar y luego coloreando todo de acuerdo con drv.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) + \n  geom_point() +\n  geom_smooth(aes(linetype = drv))\n\n\n\n\n\n\n\nObserve que este gr√°fico contiene dos geomas en el mismo gr√°fico.\nMuchos geoms, como geom_smooth(), utilizan un √∫nico objeto geom√©trico para mostrar varias filas de datos. Para estos geoms, puede establecer la est√©tica group en una variable categ√≥rica para dibujar m√∫ltiples objetos. ggplot2 dibujar√° un objeto separado para cada valor √∫nico de la variable de agrupaci√≥n. En la pr√°ctica, ggplot2 agrupar√° autom√°ticamente los datos de estos geoms siempre que asigne una est√©tica a una variable discreta (como en el ejemplo de linetype). Es conveniente confiar en esta caracter√≠stica porque la est√©tica group por s√≠ misma no agrega una leyenda o caracter√≠sticas distintivas a las geomas.\n# Izquierda\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth()\n\n# Centro              \nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth(aes(group = drv))\n\n# Derecha    \nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth(aes(color = drv), show.legend = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n\n\nSi coloca asignaciones en una funci√≥n geom, ggplot2 las tratar√° como asignaciones locales para la capa. Utilizar√° estas asignaciones para extender o sobrescribir las asignaciones globales solo para esa capa. Esto hace posible mostrar diferentes est√©ticas en diferentes capas.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(aes(color = class)) + \n  geom_smooth()\n\n\n\n\n\n\n\nPuede usar la misma idea para especificar datos diferentes para cada capa. Aqu√≠, usamos puntos rojos y c√≠rculos abiertos para resaltar los autos de dos plazas. El argumento de datos locales en geom_point() anula el argumento de datos globales en ggplot() solo para esa capa.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  geom_point(\n    data = mpg |&gt; filter(class == \"2seater\"), \n    color = \"red\"\n  ) +\n  geom_point(\n    data = mpg |&gt; filter(class == \"2seater\"), \n    shape = \"circle open\", size = 3, color = \"red\"\n  )\n\n\n\n\n\n\n\nLas geomas son los bloques de construcci√≥n fundamentales de ggplot2. Puede transformar por completo el aspecto de su gr√°fico cambiando su geom, y diferentes geoms pueden revelar diferentes caracter√≠sticas de sus datos. Por ejemplo, el histograma y el diagrama de densidad a continuaci√≥n revelan que la distribuci√≥n del kilometraje en carretera es bimodal y sesgada hacia la derecha, mientras que el diagrama de caja revela dos posibles valores at√≠picos.\n# Izquierda\nggplot(mpg, aes(x = hwy)) +\n  geom_histogram(binwidth = 2)\n\n# Centro\nggplot(mpg, aes(x = hwy)) +\n  geom_density()\n\n# Derecha\nggplot(mpg, aes(x = hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot2 proporciona m√°s de 40 geoms, pero estos no cubren todos los gr√°ficos posibles que uno podr√≠a hacer. Si necesita un geom diferente, le recomendamos que busque primero en los paquetes de extensi√≥n para ver si alguien m√°s ya lo ha implementado (vea https://exts.ggplot2.tidyverse.org/gallery/ para ver una muestra). Por ejemplo, el paquete ggridges (https://wilkelab.org/ggridges) es √∫til para hacer gr√°ficos de l√≠neas de crestas, que pueden ser √∫tiles para visualizar la densidad de una variable num√©rica para diferentes niveles de una variable categ√≥rica. En la siguiente gr√°fica, no solo usamos un nuevo geom (geom_density_ridges()), sino que tambi√©n asignamos la misma variable a m√∫ltiples est√©ticas (drv a y, fill y color) as√≠ como establecer una est√©tica (alpha = 0.5) para hacer que las curvas de densidad sean transparentes.\n\nlibrary(ggridges)\n\nggplot(mpg, aes(x = hwy, y = drv, fill = drv, color = drv)) +\n  geom_density_ridges(alpha = 0.5, show.legend = FALSE)\n#&gt; Picking joint bandwidth of 1.28\n\n\n\n\n\n\n\nEl mejor lugar para obtener una descripci√≥n completa de todos los geoms que ofrece ggplot2, as√≠ como de todas las funciones del paquete, es la p√°gina de referencia: https://ggplot2.tidyverse.org/reference. Para obtener m√°s informaci√≥n sobre cualquier geom individual, use la ayuda (por ejemplo, ? geom_smooth).\n\n9.3.1 Ejercicios\n\n¬øQu√© geom usar√≠as para dibujar un gr√°fico de l√≠neas? ¬øUn diagrama de caja? ¬øUn histograma? ¬øUn gr√°fico de √°reas?\n\nAnteriormente en este cap√≠tulo usamos show.legend sin explicarlo:\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth(aes(color = drv), show.legend = FALSE)\n\n¬øQu√© hace show.legend = FALSE aqu√≠? ¬øQu√© pasa si lo quitas? ¬øPor qu√© crees que lo usamos antes?\n\n¬øQu√© hace el argumento se para geom_smooth()?\n\nVuelva a crear el c√≥digo R necesario para generar los siguientes gr√°ficos. Tenga en cuenta que siempre que se use una variable categ√≥rica en el gr√°fico, es drv.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Capas</span>"
    ]
  },
  {
    "objectID": "layers.html#facetas",
    "href": "layers.html#facetas",
    "title": "9¬† Capas",
    "section": "\n9.4 Facetas",
    "text": "9.4 Facetas\nEn Cap√≠tulo 1, aprendi√≥ sobre facetas con facet_wrap(), que divide una gr√°fica en sub-gr√°ficas, cada una de las cuales muestra un subconjunto de los datos en funci√≥n de una variable categ√≥rica.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_wrap(~cyl)\n\n\n\n\n\n\n\nPara facetar su gr√°fico con la combinaci√≥n de dos variables, cambie de facet_wrap() a facet_grid(). El primer argumento de facet_grid() tambi√©n es una f√≥rmula, pero ahora es una f√≥rmula de doble cara: rows ~ cols.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_grid(drv ~ cyl)\n\n\n\n\n\n\n\nPor defecto, cada una de las facetas comparte la misma escala y rango para los ejes x e y. Esto es √∫til cuando desea comparar datos entre facetas, pero puede ser limitante cuando desea visualizar mejor la relaci√≥n dentro de cada faceta. Establecer el argumento scales en una funci√≥n de facetado en \"free_x\" permitir√° diferentes escalas del eje x en columnas, \"free_y\" permitir√° diferentes escalas en el eje y en filas, y \"free\" permitir√° diferentes escalas en ambos ejes.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_grid(drv ~ cyl, scales = \"free\")\n\n\n\n\n\n\n\n\n9.4.1 Ejercicios\n\n¬øQu√© sucede si facetas en una variable continua?\n\n¬øQu√© significan las celdas vac√≠as en el gr√°fico con facet_grid(drv ~ cyl)? Ejecute el siguiente c√≥digo. ¬øC√≥mo se relacionan con la gr√°fica resultante?\n\nggplot(mpg) + \n  geom_point(aes(x = drv, y = cyl))\n\n\n\n¬øQu√© gr√°ficas hace el siguiente c√≥digo? ¬øQu√© hace .?\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ .)\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) +\n  facet_grid(. ~ cyl)\n\n\n\nTome la primera gr√°fica facetada en esta secci√≥n:\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) + \n  facet_wrap(~ cyl, nrow = 2)\n\n¬øCu√°les son las ventajas de usar facetas en lugar de la est√©tica del color? ¬øCuales son las desventajas? ¬øC√≥mo podr√≠a cambiar el equilibrio si tuviera un conjunto de datos m√°s grande?\n\nLee ?facet_wrap. ¬øQu√© hace nrow? ¬øQu√© hace ncol? ¬øQu√© otras opciones controlan el dise√±o de los paneles individuales? ¬øPor qu√© facet_grid() no tiene argumentos nrow y ncol?\n\n¬øCu√°l de las siguientes gr√°ficas facilita la comparaci√≥n del tama√±o del motor (displ) entre autom√≥viles con diferentes trenes motrices? ¬øQu√© dice esto acerca de cu√°ndo colocar una variable de facetado en filas o columnas?\n\nggplot(mpg, aes(x = displ)) + \n  geom_histogram() + \n  facet_grid(drv ~ .)\n\nggplot(mpg, aes(x = displ)) + \n  geom_histogram() +\n  facet_grid(. ~ drv)\n\n\n\nVuelva a crear la siguiente gr√°fica usando facet_wrap() en lugar de facet_grid(). ¬øC√≥mo cambian las posiciones de las etiquetas de las facetas?\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ .)",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Capas</span>"
    ]
  },
  {
    "objectID": "layers.html#transformaciones-estad√≠sticas",
    "href": "layers.html#transformaciones-estad√≠sticas",
    "title": "9¬† Capas",
    "section": "\n9.5 Transformaciones estad√≠sticas",
    "text": "9.5 Transformaciones estad√≠sticas\nConsidere un gr√°fico de barras b√°sico, dibujado con geom_bar() o geom_col(). El siguiente gr√°fico muestra el n√∫mero total de diamantes en el conjunto de datos de diamonds, agrupados por corte curt. El conjunto de datos de diamond est√° en el paquete ggplot2 y contiene informaci√≥n sobre ~54 000 diamantes, incluido el precio price, el quilate carat, el color, la claridad clarity y el corte cut de cada diamante. El gr√°fico muestra que hay m√°s diamantes disponibles con cortes de alta calidad que con cortes de baja calidad.\n\nggplot(diamonds, aes(x = cut)) + \n  geom_bar()\n\n\n\n\n\n\n\nEn el eje x, el gr√°fico muestra cut, una variable de diamond. En el eje y, muestra el conteo, ¬°pero el conteo no es una variable en diamond! ¬øDe d√≥nde viene el conteo? Muchos gr√°ficos, como diagramas de dispersi√≥n, trazan los valores sin procesar de su conjunto de datos. Otros gr√°ficos, como gr√°ficos de barras, calculan nuevos valores para trazar:\n\nLos gr√°ficos de barras, los histogramas y los pol√≠gonos de frecuencia agrupan sus datos y luego trazan los recuentos de contenedores, la cantidad de puntos que caen en cada contenedor.\nLos suavizadores ajustan un modelo a sus datos y luego trazan predicciones del modelo.\nLos diagramas de caja calculan el resumen de cinco n√∫meros de la distribuci√≥n y luego muestran ese resumen como un cuadro con formato especial.\n\nEl algoritmo utilizado para calcular nuevos valores para un gr√°fico se llama stat, abreviatura de transformaci√≥n estad√≠stica. Figura¬†9.2 muestra c√≥mo funciona este proceso con geom_bar().\n\n\n\n\n\n\n\nFigura¬†9.2: Cuando creamos un gr√°fico de barras, primero comenzamos con los datos sin procesar, luego agregarlo para contar el n√∫mero de observaciones en cada barra, y finalmente mapear esas variables calculadas para trazar las aesthetics.\n\n\n\n\nPuede saber qu√© estad√≠stica usa un geom inspeccionando el valor predeterminado para el argumento stat. Por ejemplo, ?geom_bar muestra que el valor predeterminado para stat es ‚Äúcount‚Äù, lo que significa que geom_bar() usa stat_count(). stat_count() est√° documentado en la misma p√°gina que geom_bar(). Si se desplaza hacia abajo, la secci√≥n llamada ‚ÄúVariables calculadas‚Äù explica que calcula dos nuevas variables: count y prop.\nCada geom tiene una estad√≠stica predeterminada; y cada estad√≠stica tiene un geom predeterminado. Esto significa que normalmente puede usar geoms sin preocuparse por la transformaci√≥n estad√≠stica subyacente. Sin embargo, hay tres razones por las que podr√≠a necesitar usar una estad√≠stica expl√≠citamente:\n\n\nEs posible que desee anular la estad√≠stica predeterminada. En el siguiente c√≥digo, cambiamos la estad√≠stica de geom_bar() de contar (el valor predeterminado) a identidad. Esto nos permite asignar la altura de las barras a los valores brutos de una variable y.\n\ndiamonds |&gt;\n  count(cut) |&gt;\n  ggplot(aes(x = cut, y = n)) +\n  geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\n\n\nEs posible que desee anular la asignaci√≥n predeterminada de variables transformadas a est√©tica. Por ejemplo, es posible que desee mostrar un gr√°fico de barras de proporciones, en lugar de recuentos:\n\nggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) + \n  geom_bar()\n\n\n\n\n\n\n\nPara encontrar las posibles variables que puede calcular la estad√≠stica, busque la secci√≥n titulada ‚Äúvariables calculadas‚Äù en la ayuda de geom_bar().\n\n\nEs posible que desee llamar m√°s la atenci√≥n sobre la transformaci√≥n estad√≠stica en su c√≥digo. Por ejemplo, puede usar stat_summary(), que resume los valores de y para cada valor √∫nico de x, para llamar la atenci√≥n sobre el resumen que est√° calculando:\n\nggplot(diamonds) + \n  stat_summary(\n    aes(x = cut, y = depth),\n    fun.min = min,\n    fun.max = max,\n    fun = median\n  )\n\n\n\n\n\n\n\n\n\nggplot2 proporciona m√°s de 20 estad√≠sticas para su uso. Cada estad√≠stica es una funci√≥n, por lo que puede obtener ayuda de la forma habitual, p.ej., ?stat_bin.\n\n9.5.1 Ejercicios\n\n¬øCu√°l es el geom predeterminado asociado con stat_summary()? ¬øC√≥mo podr√≠a reescribir el diagrama anterior para usar esa funci√≥n geom en lugar de la funci√≥n stat?\n¬øQu√© hace geom_col()? ¬øEn qu√© se diferencia de geom_bar()?\nLa mayor√≠a de los geoms y estad√≠sticas vienen en pares que casi siempre se usan en conjunto. Haz una lista de todas las parejas. ¬øQu√© tienen en com√∫n? (Sugerencia: lea la documentaci√≥n).\n¬øQu√© variables calcula stat_smooth()? ¬øQu√© argumentos controlan su comportamiento?\n\nEn nuestro gr√°fico de barras de proporciones, debemos establecer group = 1. ¬øPor qu√©? En otras palabras, ¬øcu√°l es el problema con estos dos gr√°ficos?\n\nggplot(diamonds, aes(x = cut, y = after_stat(prop))) + \n  geom_bar()\nggplot(diamonds, aes(x = cut, fill = color, y = after_stat(prop))) + \n  geom_bar()",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Capas</span>"
    ]
  },
  {
    "objectID": "layers.html#ajustes-de-posici√≥n",
    "href": "layers.html#ajustes-de-posici√≥n",
    "title": "9¬† Capas",
    "section": "\n9.6 Ajustes de posici√≥n",
    "text": "9.6 Ajustes de posici√≥n\nHay una pieza m√°s de magia asociada con los gr√°ficos de barras. Puede colorear un gr√°fico de barras utilizando la est√©tica color o, m√°s √∫til, la est√©tica fill:\n# Izquierda\nggplot(mpg, aes(x = drv, color = drv)) + \n  geom_bar()\n\n# Derecha\nggplot(mpg, aes(x = drv, fill = drv)) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\n\nTenga en cuenta lo que sucede si asigna la est√©tica de relleno a otra variable, como class: las barras se apilan autom√°ticamente. Cada rect√°ngulo de color representa una combinaci√≥n de drv y class.\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar()\n\n\n\n\n\n\n\nEl apilamiento se realiza autom√°ticamente usando el ajuste de posici√≥n especificado por el argumento position. Si no desea un gr√°fico de barras apiladas, puede usar una de las otras tres opciones: \"identity\", \"dodge\" o \"fill\".\n\n\nposition = \"identity\" colocar√° cada objeto exactamente donde cae en el contexto del gr√°fico. Esto no es muy √∫til para las barras, porque las superpone. Para ver esa superposici√≥n, necesitamos hacer que las barras sean ligeramente transparentes configurando alpha en un valor peque√±o, o completamente transparentes configurando fill = NA.\n# Izquierda\nggplot(mpg, aes(x = drv, fill = class)) +\n  geom_bar(alpha = 1/5, position = \"identity\")\n\n# Derecha\nggplot(mpg, aes(x = drv, color = class)) +  \n  geom_bar(fill = NA, position = \"identity\")\n\n\n\n\n\n\n\n\n\n\nEl ajuste de posici√≥n de identidad es m√°s √∫til para geomas 2d, como puntos, donde es el valor predeterminado.\n\nposition = \"fill\" funciona como apilar, pero hace que cada conjunto de barras apiladas tenga la misma altura. Esto facilita la comparaci√≥n de proporciones entre grupos.\n\nposition = \"dodge\" coloca objetos superpuestos directamente al lado uno del otro. Esto facilita la comparaci√≥n de valores individuales.\n# Izquierda\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"fill\")\n\n# Derecha\nggplot(mpg, aes(x = drv, fill = class)) +  \n  geom_bar(position = \"dodge\")\n\n\n\n\n\n\n\n\n\n\n\n\nHay otro tipo de ajuste que no es √∫til para gr√°ficos de barras, pero puede ser muy √∫til para diagramas de dispersi√≥n. Recuerde nuestro primer diagrama de dispersi√≥n. ¬øNot√≥ que la gr√°fica muestra solo 126 puntos, aunque hay 234 observaciones en el conjunto de datos?\n\n\n\n\n\n\n\n\nLos valores subyacentes de hwy y displ se redondean para que los puntos aparezcan en una cuadr√≠cula y muchos puntos se superpongan entre s√≠. Este problema se conoce como overplotting. Este arreglo hace que sea dif√≠cil ver la distribuci√≥n de los datos. ¬øLos puntos de datos est√°n repartidos por igual a lo largo del gr√°fico, o hay una combinaci√≥n especial de ‚Äòhwy‚Äô y ‚Äòdispl‚Äô que contiene 109 valores?\nPuede evitar esta cuadr√≠cula configurando el ajuste de posici√≥n en ‚Äújitter‚Äù. position = \"jitter\" agrega una peque√±a cantidad de ruido aleatorio a cada punto. Esto dispersa los puntos porque es probable que dos puntos no reciban la misma cantidad de ruido aleatorio.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(position = \"jitter\")\n\n\n\n\n\n\n\nAgregar aleatoriedad parece una forma extra√±a de mejorar su gr√°fico, pero mientras hace que su gr√°fico sea menos preciso a escalas peque√±as, hace que su gr√°fico sea m√°s revelador a escalas grandes. Debido a que esta es una operaci√≥n tan √∫til, ggplot2 viene con una forma abreviada de geom_point(position = \"jitter\"): geom_jitter().\nPara obtener m√°s informaci√≥n sobre un ajuste de posici√≥n, consulte la p√°gina de ayuda asociada con cada ajuste: ?position_dodge, ?position_fill, ?position_identity, ?position_jitter y ?position_stack.\n\n9.6.1 Ejercicios\n\n\n¬øCu√°l es el problema con la gr√°fica siguiente? ¬øC√≥mo podr√≠as mejorarlo?\n\nggplot(mpg, aes(x = cty, y = hwy)) + \n  geom_point()\n\n\n\n¬øCu√°l es, en todo caso, la diferencia entre las dos gr√°ficas? ¬øPor qu√©?\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point()\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(position = \"identity\")\n\n\n¬øQu√© par√°metros de geom_jitter() controlan la cantidad de fluctuaci√≥n?\nCompare y contraste geom_jitter() con geom_count().\n¬øCu√°l es el ajuste de posici√≥n predeterminado para geom_boxplot()? Cree una visualizaci√≥n del conjunto de datos mpg que lo demuestre.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Capas</span>"
    ]
  },
  {
    "objectID": "layers.html#sistemas-de-coordenadas",
    "href": "layers.html#sistemas-de-coordenadas",
    "title": "9¬† Capas",
    "section": "\n9.7 Sistemas de coordenadas",
    "text": "9.7 Sistemas de coordenadas\nLos sistemas de coordenadas son probablemente la parte m√°s complicada de ggplot2. El sistema de coordenadas predeterminado es el sistema de coordenadas cartesianas en el que las posiciones x e y act√∫an de forma independiente para determinar la ubicaci√≥n de cada punto. Hay otros dos sistemas de coordenadas que ocasionalmente son √∫tiles.\n\n\ncoord_quickmap() establece la relaci√≥n de aspecto correctamente para los mapas gegr√°ficos. Esto es muy importante si est√° trazando datos espaciales con ggplot2. No tenemos el espacio para discutir mapas en este libro, pero puede obtener m√°s informaci√≥n en el [cap√≠tulo de mapas] (https://ggplot2-book.org/maps.html) de ggplot2: Gr√°ficos elegantes para el an√°lisis de datos .\nnz &lt;- map_data(\"nz\")\n\nggplot(nz, aes(x = long, y = lat, group = group)) +\n  geom_polygon(fill = \"white\", color = \"black\")\n\nggplot(nz, aes(x = long, y = lat, group = group)) +\n  geom_polygon(fill = \"white\", color = \"black\") +\n  coord_quickmap()\n\n\n\n\n\n\n\n\n\n\n\n\ncoord_polar() utiliza coordenadas polares. Las coordenadas polares revelan una conexi√≥n interesante entre un gr√°fico de barras y un gr√°fico de Coxcomb.\nbar &lt;- ggplot(data = diamonds) + \n  geom_bar(\n    mapping = aes(x = clarity, fill = clarity), \n    show.legend = FALSE,\n    width = 1\n  ) + \n  theme(aspect.ratio = 1)\n\nbar + coord_flip()\nbar + coord_polar()\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.7.1 Ejercicios\n\nConvierte un gr√°fico de barras apiladas en un gr√°fico circular usando coord_polar().\n¬øCu√°l es la diferencia entre coord_quickmap() y coord_map()?\n\n¬øQu√© te dice la siguiente gr√°fica sobre la relaci√≥n entre mpg en ciudad y en carretera? ¬øPor qu√© es importante coord_fixed()? ¬øQu√© hace geom_abline()?\n\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +\n  geom_point() + \n  geom_abline() +\n  coord_fixed()",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Capas</span>"
    ]
  },
  {
    "objectID": "layers.html#la-gram√°tica-en-capas-de-los-gr√°ficos",
    "href": "layers.html#la-gram√°tica-en-capas-de-los-gr√°ficos",
    "title": "9¬† Capas",
    "section": "\n9.8 La gram√°tica en capas de los gr√°ficos",
    "text": "9.8 La gram√°tica en capas de los gr√°ficos\nPodemos ampliar la plantilla de gr√°ficos que aprendi√≥ en Secci√≥n 1.3 agregando ajustes de posici√≥n, estad√≠sticas, sistemas de coordenadas y facetas:\nggplot(data = &lt;DATA&gt;) + \n  &lt;GEOM_FUNCTION&gt;(\n     mapping = aes(&lt;MAPPINGS&gt;),\n     stat = &lt;STAT&gt;, \n     position = &lt;POSITION&gt;\n  ) +\n  &lt;COORDINATE_FUNCTION&gt; +\n  &lt;FACET_FUNCTION&gt;\nNuestra nueva plantilla toma siete par√°metros, las palabras entre par√©ntesis que aparecen en la plantilla. En la pr√°ctica, rara vez necesita proporcionar los siete par√°metros para hacer un gr√°fico porque ggplot2 proporcionar√° valores predeterminados √∫tiles para todo excepto los datos, las asignaciones y la funci√≥n geom.\nLos siete par√°metros de la plantilla componen la gram√°tica de los gr√°ficos, un sistema formal para la construcci√≥n de gr√°ficas. La gram√°tica de los gr√°ficos se basa en la idea de que puede describir de manera √∫nica cualquier gr√°fico como una combinaci√≥n de un conjunto de datos, una geom, un conjunto de asignaciones, una estad√≠stica, un ajuste de posici√≥n, un sistema de coordenadas y un esquema de facetas y un tema.\nPara ver c√≥mo funciona esto, considere c√≥mo podr√≠a construir un gr√°fico b√°sico desde cero: podr√≠a comenzar con un conjunto de datos y luego transformarlo en la informaci√≥n que desea mostrar (con una estad√≠stica). A continuaci√≥n, podr√≠a elegir un objeto geom√©trico para representar cada observaci√≥n en los datos transformados. Luego podr√≠a usar las propiedades est√©ticas de los geoms para representar variables en los datos. Asignar√≠a los valores de cada variable a los niveles de una est√©tica. Estos pasos se ilustran en Figura¬†9.3. Luego, seleccionar√≠a un sistema de coordenadas para colocar los geomas, utilizando la ubicaci√≥n de los objetos (que en s√≠ misma es una propiedad est√©tica) para mostrar los valores de las variables x e y.\n\n\n\n\n\n\n\nFigura¬†9.3: Pasos para pasar de datos sin procesar a una tabla de frecuencias a un gr√°fico de barras donde las alturas de la barra representan las frecuencias.\n\n\n\n\nEn este punto, tendr√≠a un gr√°fico completo, pero podr√≠a ajustar a√∫n m√°s las posiciones de las geomas dentro del sistema de coordenadas (un ajuste de posici√≥n) o dividir el gr√°fico en subgr√°ficos (facetas). Tambi√©n puede ampliar el gr√°fico agregando una o m√°s capas adicionales, donde cada capa adicional utiliza un conjunto de datos, una geom, un conjunto de asignaciones, una estad√≠stica y un ajuste de posici√≥n.\nPodr√≠as usar este m√©todo para construir cualquier gr√°fico que imagines. En otras palabras, puede usar la plantilla de c√≥digo que aprendi√≥ en este cap√≠tulo para crear cientos de miles de gr√°ficos √∫nicos.\nSi desea obtener m√°s informaci√≥n sobre los fundamentos te√≥ricos de ggplot2, puede disfrutar leyendo ‚ÄúLa gram√°tica en capas de los gr√°ficos‚Äù, el art√≠culo cient√≠fico que describe la teor√≠a de ggplot2 en detalle.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Capas</span>"
    ]
  },
  {
    "objectID": "layers.html#resumen",
    "href": "layers.html#resumen",
    "title": "9¬† Capas",
    "section": "\n9.9 Resumen",
    "text": "9.9 Resumen\nEn este cap√≠tulo, aprendi√≥ sobre la gram√°tica en capas de los gr√°ficos, comenzando con la est√©tica y las geometr√≠as para construir un gr√°fico simple, facetas para dividir el gr√°fico en subconjuntos, estad√≠sticas para comprender c√≥mo se calculan los geoms, ajustes de posici√≥n para controlar los detalles finos de la posici√≥n cuando los geoms podr√≠an de lo contrario superponerse y los sistemas de coordenadas le permiten cambiar fundamentalmente lo que significan x e y. Una capa que a√∫n no hemos abordado es el tema, que presentaremos en Secci√≥n 11.5.\nDos recursos muy √∫tiles para obtener una descripci√≥n general de la funcionalidad completa de ggplot2 son la hoja de trucos de ggplot2 (que puede encontrar en https://posit.co/resources/cheatsheets) y el sitio web del paquete ggplot2 (https://ggplot2. tidyverse.org).\nUna lecci√≥n importante que debe aprender de este cap√≠tulo es que cuando sienta la necesidad de un geom que ggplot2 no proporciona, siempre es una buena idea investigar si alguien m√°s ya resolvi√≥ su problema creando un paquete de extensi√≥n ggplot2 que ofrece esa geom.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Capas</span>"
    ]
  },
  {
    "objectID": "EDA.html",
    "href": "EDA.html",
    "title": "10¬† An√°lisis exploratorio de datos",
    "section": "",
    "text": "10.1 Introducci√≥n\nEste cap√≠tulo le mostrar√° c√≥mo usar la visualizaci√≥n y la transformaci√≥n para explorar sus datos de manera sistem√°tica, una tarea que los estad√≠sticos llaman an√°lisis exploratorio de datos, o EDA para abreviar, Exploratory Data Analysis. EDA es un ciclo iterativo. T√∫:\nEDA no es un proceso formal con un conjunto estricto de reglas. M√°s que nada, EDA es un estado de √°nimo. Durante las fases iniciales de EDA, debe sentirse libre de investigar cada idea que se le ocurra. Algunas de estas ideas funcionar√°n y otras ser√°n callejones sin salida. A medida que contin√∫e su exploraci√≥n, se concentrar√° en algunas ideas particularmente productivas que eventualmente escribir√° y comunicar√° a otros.\nEDA es una parte importante de cualquier an√°lisis de datos, incluso si las principales preguntas de investigaci√≥n se le entregan en bandeja, porque siempre necesita investigar la calidad de sus datos. La limpieza de datos es solo una aplicaci√≥n de EDA: hace preguntas sobre si sus datos cumplen con sus expectativas o no. Para realizar la limpieza de datos, deber√° implementar todas las herramientas de EDA: visualizaci√≥n, transformaci√≥n y modelado.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>An√°lisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "EDA.html#introducci√≥n",
    "href": "EDA.html#introducci√≥n",
    "title": "10¬† An√°lisis exploratorio de datos",
    "section": "",
    "text": "Genera preguntas sobre tus datos.\nBusque respuestas visualizando, transformando y modelando sus datos.\nUse lo que aprendi√≥ para refinar sus preguntas y/o generar nuevas preguntas.\n\n\n\n\n10.1.1 Requisitos previos\nEn este cap√≠tulo, combinaremos lo que ha aprendido sobre dplyr y ggplot2 para hacer preguntas de forma interactiva, responderlas con datos y luego hacer nuevas preguntas.\n\nlibrary(tidyverse)",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>An√°lisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "EDA.html#preguntas",
    "href": "EDA.html#preguntas",
    "title": "10¬† An√°lisis exploratorio de datos",
    "section": "\n10.2 Preguntas",
    "text": "10.2 Preguntas\n\n‚ÄúNo hay preguntas estad√≠sticas rutinarias, solo rutinas estad√≠sticas cuestionables.‚Äù ‚Äî Sir David Cox\n\n\n‚ÄúEs mucho mejor una respuesta aproximada a la pregunta correcta, que a menudo es vaga, que una respuesta exacta a la pregunta equivocada, que siempre se puede precisar.‚Äù ‚Äî John Tukey\n\nSu objetivo durante EDA es desarrollar una comprensi√≥n de sus datos. La forma m√°s f√°cil de hacer esto es usar preguntas como herramientas para guiar su investigaci√≥n. Cuando hace una pregunta, la pregunta enfoca su atenci√≥n en una parte espec√≠fica de su conjunto de datos y lo ayuda a decidir qu√© gr√°ficos, modelos o transformaciones hacer.\nEDA es fundamentalmente un proceso creativo. Y como la mayor√≠a de los procesos creativos, la clave para hacer preguntas de calidad es generar una gran cantidad de preguntas. Es dif√≠cil hacer preguntas reveladoras al comienzo de su an√°lisis porque no sabe qu√© informaci√≥n se puede obtener de su conjunto de datos. Por otro lado, cada nueva pregunta que haga lo expondr√° a un nuevo aspecto de sus datos y aumentar√° sus posibilidades de hacer un descubrimiento. Puede profundizar r√°pidamente en las partes m√°s interesantes de sus datos, y desarrollar un conjunto de preguntas que invitan a la reflexi√≥n, si hace un seguimiento de cada pregunta con una nueva pregunta basada en lo que encuentre.\nNo hay una regla sobre qu√© preguntas debe hacer para guiar su investigaci√≥n. Sin embargo, dos tipos de preguntas siempre ser√°n √∫tiles para hacer descubrimientos dentro de sus datos. Puede redactar libremente estas preguntas como:\n\n¬øQu√© tipo de variaci√≥n ocurre dentro de mis variables?\n¬øQu√© tipo de covariaci√≥n ocurre entre mis variables?\n\nEl resto de este cap√≠tulo analizar√° estas dos preguntas. Explicaremos qu√© son la variaci√≥n y la covariaci√≥n, y le mostraremos varias formas de responder cada pregunta.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>An√°lisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "EDA.html#variaci√≥n",
    "href": "EDA.html#variaci√≥n",
    "title": "10¬† An√°lisis exploratorio de datos",
    "section": "\n10.3 Variaci√≥n",
    "text": "10.3 Variaci√≥n\nVariaci√≥n es la tendencia de los valores de una variable a cambiar de una medida a otra. Puedes ver la variaci√≥n f√°cilmente en la vida real; si mide cualquier variable continua dos veces, obtendr√° dos resultados diferentes. Esto es cierto incluso si mide cantidades que son constantes, como la velocidad de la luz. Cada una de sus medidas incluir√° una peque√±a cantidad de error que var√≠a de una medida a otra. Las variables tambi√©n pueden variar si mide diferentes sujetos (por ejemplo, el color de los ojos de diferentes personas) o en diferentes momentos (por ejemplo, los niveles de energ√≠a de un electr√≥n en diferentes momentos). Cada variable tiene su propio patr√≥n de variaci√≥n, que puede revelar informaci√≥n interesante sobre c√≥mo var√≠a entre mediciones en la misma observaci√≥n, as√≠ como entre observaciones. La mejor forma de comprender ese patr√≥n es visualizar la distribuci√≥n de los valores de la variable, que aprendiste en Cap√≠tulo 1.\nComenzaremos nuestra exploraci√≥n visualizando la distribuci√≥n de pesos (quilates carat) de ~54,000 diamantes del conjunto de datos diamonds. Dado que carat es una variable num√©rica, podemos usar un histograma:\n\nggplot(diamonds, aes(x = carat)) +\n  geom_histogram(binwidth = 0.5)\n\n\n\n\n\n\n\nAhora que puede visualizar la variaci√≥n, ¬øqu√© debe buscar en sus gr√°ficos? ¬øY qu√© tipo de preguntas de seguimiento debe hacer? Hemos reunido una lista a continuaci√≥n de los tipos de informaci√≥n m√°s √∫tiles que encontrar√° en sus gr√°ficos, junto con algunas preguntas de seguimiento para cada tipo de informaci√≥n. La clave para hacer buenas preguntas de seguimiento ser√° confiar en su curiosidad (¬øSobre qu√© quiere aprender m√°s?) as√≠ como en su escepticismo (¬øC√≥mo podr√≠a ser enga√±oso?).\n\n10.3.1 Valores t√≠picos\nTanto en los gr√°ficos de barras como en los histogramas, las barras altas muestran los valores comunes de una variable y las barras m√°s cortas muestran los valores menos comunes. Los lugares que no tienen barras revelan valores que no se vieron en sus datos. Para convertir esta informaci√≥n en preguntas √∫tiles, busque cualquier cosa inesperada:\n\n¬øQu√© valores son los m√°s comunes? ¬øPor qu√©?\n¬øQu√© valores son raros? ¬øPor qu√©? ¬øEso coincide con sus expectativas?\n¬øPuedes ver alg√∫n patr√≥n inusual? ¬øQu√© podr√≠a explicarlos?\n\nEchemos un vistazo a la distribuci√≥n de quilates, carat, para diamantes m√°s peque√±os.\n\nsmaller &lt;- diamonds |&gt; \n  filter(carat &lt; 3)\n\nggplot(smaller, aes(x = carat)) +\n  geom_histogram(binwidth = 0.01)\n\n\n\n\n\n\n\nEste histograma sugiere varias preguntas interesantes:\n\n¬øPor qu√© hay m√°s diamantes en quilates enteros y fracciones comunes de quilates?\n¬øPor qu√© hay m√°s diamantes ligeramente a la derecha de cada pico que ligeramente a la izquierda de cada pico?\n\nLas visualizaciones tambi√©n pueden revelar grupos, lo que sugiere que existen subgrupos en sus datos. Para comprender los subgrupos, pregunte:\n\n¬øEn qu√© se parecen las observaciones dentro de cada subgrupo?\n¬øEn qu√© se diferencian entre s√≠ las observaciones en grupos separados?\n¬øC√≥mo puedes explicar o describir los clusters?\n¬øPor qu√© la apariencia de los cl√∫steres podr√≠a ser enga√±osa?\n\nAlgunas de estas preguntas se pueden responder con los datos, mientras que otras requerir√°n experiencia en el dominio de los datos. Muchos de ellos le pedir√°n que explore una relaci√≥n entre variables, por ejemplo, para ver si los valores de una variable pueden explicar el comportamiento de otra variable. Llegaremos a eso en breve.\n\n10.3.2 Valores inusuales\nLos valores at√≠picos son observaciones que son inusuales; puntos de datos que no parecen ajustarse al patr√≥n. A veces, los valores at√≠picos son errores de entrada de datos, a veces son simplemente valores en los extremos que se observaron en esta recopilaci√≥n de datos, y otras veces sugieren nuevos descubrimientos importantes. Cuando tiene muchos datos, los valores at√≠picos a veces son dif√≠ciles de ver en un histograma. Por ejemplo, tome la distribuci√≥n de la variable y del conjunto de datos de diamantes. La √∫nica evidencia de valores at√≠picos son los l√≠mites inusualmente amplios en el eje x.\n\nggplot(diamonds, aes(x = y)) + \n  geom_histogram(binwidth = 0.5)\n\n\n\n\n\n\n\nHay tantas observaciones en los contenedores comunes que los contenedores raros son muy cortos, por lo que es muy dif√≠cil verlos (aunque tal vez si miras fijamente a 0 ver√°s algo). Para que sea m√°s f√°cil ver los valores inusuales, necesitamos ampliar los valores peque√±os del eje y con coord_cartesian():\n\nggplot(diamonds, aes(x = y)) + \n  geom_histogram(binwidth = 0.5) +\n  coord_cartesian(ylim = c(0, 50))\n\n\n\n\n\n\n\ncoord_cartesian() tambi√©n tiene un argumento xlim() para cuando necesite hacer zoom en el eje x. ggplot2 tambi√©n tiene funciones xlim() y ylim() que funcionan de forma ligeramente diferente: desechan los datos fuera de los l√≠mites.\nEsto nos permite ver que hay tres valores inusuales: 0, ~30 y ~60. Los sacamos con dplyr:\n\nunusual &lt;- diamonds |&gt; \n  filter(y &lt; 3 | y &gt; 20) |&gt; \n  select(price, x, y, z) |&gt;\n  arrange(y)\nunusual\n#&gt; # A tibble: 9 √ó 4\n#&gt;   price     x     y     z\n#&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  5139  0      0    0   \n#&gt; 2  6381  0      0    0   \n#&gt; 3 12800  0      0    0   \n#&gt; 4 15686  0      0    0   \n#&gt; 5 18034  0      0    0   \n#&gt; 6  2130  0      0    0   \n#&gt; 7  2130  0      0    0   \n#&gt; 8  2075  5.15  31.8  5.12\n#&gt; 9 12210  8.09  58.9  8.06\n\nLa variable y mide una de las tres dimensiones de estos diamantes, en mm. Sabemos que los diamantes no pueden tener un ancho de 0 mm, por lo que estos valores deben ser incorrectos. Al hacer EDA, hemos descubierto datos faltantes que estaban codificados como 0, que nunca hubi√©ramos encontrado simplemente buscando NAs. En el futuro, podr√≠amos optar por volver a codificar estos valores como ‚ÄúNA‚Äù para evitar c√°lculos enga√±osos. Tambi√©n podemos sospechar que las medidas de 32 mm y 59 mm son inveros√≠miles: esos diamantes miden m√°s de una pulgada de largo, ¬°pero no cuestan cientos de miles de d√≥lares!\nEs una buena pr√°ctica repetir su an√°lisis con y sin los valores at√≠picos. Si tienen un efecto m√≠nimo en los resultados y no puede averiguar por qu√© est√°n ah√≠, es razonable omitirlos y continuar. Sin embargo, si tienen un efecto sustancial en sus resultados, no debe dejarlos sin justificaci√≥n. Deber√° averiguar qu√© los caus√≥ (por ejemplo, un error de ingreso de datos) y revelar que los elimin√≥ en su informe.\n\n10.3.3 Ejercicios\n\nExplore la distribuci√≥n de cada una de las variables x, y y z en diamantes. ¬øQu√© aprendes? Piensa en un diamante y en c√≥mo podr√≠as decidir qu√© dimensi√≥n es la longitud, el ancho y la profundidad.\nExplora la distribuci√≥n del precio price. ¬øDescubriste algo inusual o sorprendente? (Sugerencia: piense detenidamente en el binwidth y aseg√∫rese de probar una amplia gama de valores).\n¬øCu√°ntos diamantes son de 0,99 quilates? ¬øCu√°ntos son de 1 quilate? ¬øCu√°l crees que es la causa de la diferencia?\nCompare y contraste coord_cartesian() frente a xlim() o ylim() al hacer zoom en un histograma. ¬øQu√© sucede si dejas binwidth sin configurar? ¬øQu√© sucede si intenta hacer zoom para que solo se muestre la mitad de una barra?",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>An√°lisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "EDA.html#sec-unusual-values-eda",
    "href": "EDA.html#sec-unusual-values-eda",
    "title": "10¬† An√°lisis exploratorio de datos",
    "section": "\n10.4 Valores inusuales",
    "text": "10.4 Valores inusuales\nSi ha encontrado valores inusuales en su conjunto de datos y simplemente desea continuar con el resto de su an√°lisis, tiene dos opciones.\n\n\nSuelta toda la fila con los valores extra√±os:\n\ndiamonds2 &lt;- diamonds |&gt; \n  filter(between(y, 3, 20))\n\nNo recomendamos esta opci√≥n porque un valor no v√°lido no implica que todos los dem√°s valores de esa observaci√≥n tambi√©n lo sean. Adem√°s, si tiene datos de baja calidad, en el momento en que haya aplicado este enfoque a cada variable, es posible que no le queden datos.\n\n\nEn su lugar, recomendamos reemplazar los valores inusuales con valores faltantes. La forma m√°s f√°cil de hacer esto es usar mutate() para reemplazar la variable con una copia modificada. Puedes usar la funci√≥n if_else() para reemplazar valores inusuales con NA:\n\ndiamonds2 &lt;- diamonds |&gt; \n  mutate(y = if_else(y &lt; 3 | y &gt; 20, NA, y))\n\n\n\nIt‚Äôs not obvious where you should plot missing values, so ggplot2 doesn‚Äôt include them in the plot, but it does warn that they‚Äôve been removed:\n\nggplot(diamonds2, aes(x = x, y = y)) + \n  geom_point()\n#&gt; Warning: Removed 9 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n\n\n\n\n\n\n\nPara suprimir esa advertencia, configure na.rm = TRUE:\n\nggplot(diamonds2, aes(x = x, y = y)) + \n  geom_point(na.rm = TRUE)\n\nOtras veces, desea comprender qu√© hace que las observaciones con valores faltantes sean diferentes a las observaciones con valores registrados. Por ejemplo, en nycflights13::flights1, los valores faltantes en la variable dep_time indican que el vuelo fue cancelado. Por lo tanto, es posible que desee comparar los horarios de salida programados para los horarios cancelados y no cancelados. Puede hacer esto creando una nueva variable, usando is.na() para verificar si falta dep_time.\n\nnycflights13::flights |&gt; \n  mutate(\n    cancelled = is.na(dep_time),\n    sched_hour = sched_dep_time %/% 100,\n    sched_min = sched_dep_time %% 100,\n    sched_dep_time = sched_hour + (sched_min / 60)\n  ) |&gt; \n  ggplot(aes(x = sched_dep_time)) + \n  geom_freqpoly(aes(color = cancelled), binwidth = 1/4)\n\n\n\n\n\n\n\nSin embargo, esta gr√°fica no es muy buena porque hay muchos m√°s vuelos no cancelados que vuelos cancelados. En la siguiente secci√≥n exploraremos algunas t√©cnicas para mejorar esta comparaci√≥n.\n\n10.4.1 Ejercicios\n\n¬øQu√© sucede con los valores faltantes en un histograma? ¬øQu√© sucede con los valores faltantes en un gr√°fico de barras? ¬øPor qu√© hay una diferencia en c√≥mo se manejan los valores perdidos en histogramas y gr√°ficos de barras?\n¬øQu√© hace na.rm = TRUE en mean() y sum()?\nVuelva a crear el diagrama de frecuencia de scheduled_dep_time coloreado seg√∫n si el vuelo se cancel√≥ o no. Tambi√©n facetado por la variable cancelled. Experimente con diferentes valores de la variable scales en la funci√≥n de creaci√≥n de facetas para mitigar el efecto de m√°s vuelos no cancelados que vuelos cancelados.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>An√°lisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "EDA.html#covariaci√≥n",
    "href": "EDA.html#covariaci√≥n",
    "title": "10¬† An√°lisis exploratorio de datos",
    "section": "\n10.5 Covariaci√≥n",
    "text": "10.5 Covariaci√≥n\nSi la variaci√≥n describe el comportamiento dentro de una variable, la covariaci√≥n describe el comportamiento entre variables. Covariaci√≥n es la tendencia de los valores de dos o m√°s variables a variar juntos de manera relacionada. La mejor manera de detectar la covariaci√≥n es visualizar la relaci√≥n entre dos o m√°s variables.\n\n10.5.1 Una variable categ√≥rica y una num√©rica\nPor ejemplo, exploremos c√≥mo var√≠a el precio de un diamante con su calidad (medida por su corte cut) usando geom_freqpoly():\n\nggplot(diamonds, aes(x = price)) + \n  geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)\n\n\n\n\n\n\n\nTenga en cuenta que ggplot2 usa una escala de colores ordenada por cut porque est√° definida como una variable de factor ordenada en los datos. Aprender√° m√°s sobre estos en Secci√≥n 16.6.\nLa apariencia predeterminada de geom_freqpoly() no es tan √∫til aqu√≠ porque la altura, determinada por el conteo general, difiere mucho entre los cortes, cut, lo que dificulta ver las diferencias en las formas de sus distribuciones.\nPara facilitar la comparaci√≥n, necesitamos intercambiar lo que se muestra en el eje y. En lugar de mostrar el conteo, mostraremos la densidad, que es el conteo estandarizado para que el √°rea debajo de cada pol√≠gono de frecuencia sea uno.\n\nggplot(diamonds, aes(x = price, y = after_stat(density))) + \n  geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)\n\n\n\n\n\n\n\nTenga en cuenta que estamos asignando la densidad a y, pero dado que density no es una variable en el conjunto de datos diamonds, primero debemos calcularla. Usamos la funci√≥n after_stat() para hacerlo.\nHay algo bastante sorprendente en esta gr√°fica: ¬°parece que los diamantes justos (la calidad m√°s baja) tienen el precio promedio m√°s alto! Pero tal vez eso se deba a que los pol√≠gonos de frecuencia son un poco dif√≠ciles de interpretar: est√°n sucediendo muchas cosas en este gr√°fico.\nUna gr√°fica visualmente m√°s simple para explorar esta relaci√≥n es usar diagramas de caja uno al lado del otro.\n\nggplot(diamonds, aes(x = cut, y = price)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nVemos mucha menos informaci√≥n sobre la distribuci√≥n, pero los diagramas de caja son mucho m√°s compactos, por lo que podemos compararlos m√°s f√°cilmente (y encajar m√°s en un diagrama). ¬°Es compatible con el hallazgo contrario a la intuici√≥n de que los diamantes de mejor calidad suelen ser m√°s baratos! En los ejercicios, se le desafiar√° a averiguar por qu√©.\ncut es un factor ordenado: regular es peor que bueno, que es peor que muy bueno y as√≠ sucesivamente. Muchas variables categ√≥ricas no tienen ese orden intr√≠nseco, por lo que es posible que desee reordenarlas para que la visualizaci√≥n sea m√°s informativa. Una forma de hacerlo es con fct_reorder(). Aprender√° m√°s sobre esa funci√≥n en Secci√≥n 16.4, pero quer√≠amos darle una vista previa r√°pida aqu√≠ porque es muy √∫til. Por ejemplo, tome la variable class en el conjunto de datos mpg. Puede que le interese saber c√≥mo var√≠a el kilometraje en carretera seg√∫n las clases:\n\nggplot(mpg, aes(x = class, y = hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nPara que la tendencia sea m√°s f√°cil de ver, podemos reordenar class en funci√≥n del valor medio de carretera hwy:\n\nggplot(mpg, aes(x = fct_reorder(class, hwy, median), y = hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nSi tiene nombres de variables largos, geom_boxplot() funcionar√° mejor si lo gira 90¬∞. Puede hacerlo intercambiando las asignaciones est√©ticas x e y.\n\nggplot(mpg, aes(x = hwy, y = fct_reorder(class, hwy, median))) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n10.5.1.1 Ejercicios\n\nUtilice lo que ha aprendido para mejorar la visualizaci√≥n de las horas de salida de los vuelos cancelados frente a los no cancelados.\nCon base en EDA, ¬øqu√© variable en el conjunto de datos de diamantes parece ser la m√°s importante para predecir el precio de un diamante? ¬øC√≥mo se correlaciona esa variable con el corte? ¬øPor qu√© la combinaci√≥n de esas dos relaciones hace que los diamantes de menor calidad sean m√°s caros?\nEn lugar de intercambiar las variables x e y, agregue coord_flip() como una nueva capa al diagrama de caja vertical para crear uno horizontal. ¬øC√≥mo se compara esto con intercambiar las variables?\nUn problema con los diagramas de caja es que se desarrollaron en una era de conjuntos de datos mucho m√°s peque√±os y tienden a mostrar una cantidad prohibitivamente grande de ‚Äúvalores at√≠picos‚Äù. Un enfoque para remediar este problema es la gr√°fica de valores de letras. Instale el paquete lvplot e intente usar geom_lv() para mostrar la distribuci√≥n del precio frente al corte. ¬øQu√© aprendes? ¬øC√≥mo interpretas las gr√°ficas?\nCree una visualizaci√≥n de los precios de los diamantes frente a una variable categ√≥rica del conjunto de datos diamoonds usando geom_violin(), luego geom_histogram() facetado, luego geom_freqpoly() coloreado y luego geom_density() coloreado. Compara y contrasta las cuatro gr√°ficas. ¬øCu√°les son los pros y los contras de cada m√©todo para visualizar la distribuci√≥n de una variable num√©rica en funci√≥n de los niveles de una variable categ√≥rica?\nSi tiene un conjunto de datos peque√±o, a veces es √∫til usar geom_jitter() para evitar el trazado excesivo y ver m√°s f√°cilmente la relaci√≥n entre una variable continua y categ√≥rica. El paquete ggbeeswarm proporciona una serie de m√©todos similares a geom_jitter(). Enum√©relos y describa brevemente lo que hace cada uno.\n\n10.5.2 Dos variables categ√≥ricas\nPara visualizar la covariaci√≥n entre variables categ√≥ricas, deber√° contar el n√∫mero de observaciones para cada combinaci√≥n de niveles de estas variables categ√≥ricas. Una forma de hacerlo es confiar en el geom_count() incorporado:\n\nggplot(diamonds, aes(x = cut, y = color)) +\n  geom_count()\n\n\n\n\n\n\n\nEl tama√±o de cada c√≠rculo en la gr√°fica muestra cu√°ntas observaciones ocurrieron en cada combinaci√≥n de valores. La covariaci√≥n aparecer√° como una fuerte correlaci√≥n entre valores espec√≠ficos de x y valores espec√≠ficos de y.\nOtro enfoque para explorar la relaci√≥n entre estas variables es calcular los recuentos con dplyr:\n\ndiamonds |&gt; \n  count(color, cut)\n#&gt; # A tibble: 35 √ó 3\n#&gt;   color cut           n\n#&gt;   &lt;ord&gt; &lt;ord&gt;     &lt;int&gt;\n#&gt; 1 D     Fair        163\n#&gt; 2 D     Good        662\n#&gt; 3 D     Very Good  1513\n#&gt; 4 D     Premium    1603\n#&gt; 5 D     Ideal      2834\n#&gt; 6 E     Fair        224\n#&gt; # ‚Ñπ 29 more rows\n\nLuego visualiza con geom_tile() y la est√©tica de relleno:\n\ndiamonds |&gt; \n  count(color, cut) |&gt;  \n  ggplot(aes(x = color, y = cut)) +\n  geom_tile(aes(fill = n))\n\n\n\n\n\n\n\nSi las variables categ√≥ricas no est√°n ordenadas, es posible que desee utilizar el paquete de seriaci√≥n para reordenar simult√°neamente las filas y las columnas a fin de revelar patrones interesantes con mayor claridad. Para gr√°ficas m√°s grandes, es posible que desee probar el paquete heatmaply, que crea gr√°ficas interactivas.\n\n10.5.2.1 Ejercicios\n\n¬øC√≥mo podr√≠a cambiar la escala del conjunto de datos de conteo anterior para mostrar m√°s claramente la distribuci√≥n del corte dentro del color o el color dentro del corte?\n¬øQu√© perspectivas de datos diferentes obtiene con un gr√°fico de barras segmentado si el color se asigna a la est√©tica x y cut se asigna a la est√©tica fill? Calcular las cuentas que caen en cada uno de los segmentos.\nUtilice geom_tile() junto con dplyr para explorar c√≥mo var√≠an los retrasos promedio en la salida de los vuelos seg√∫n el destino y el mes del a√±o. ¬øQu√© hace que la trama sea dif√≠cil de leer? ¬øC√≥mo podr√≠as mejorarlo?\n\n10.5.3 Dos variables numericas\nYa has visto una excelente forma de visualizar la covariaci√≥n entre dos variables num√©ricas: dibujar un diagrama de dispersi√≥n con geom_point(). Puede ver la covariaci√≥n como un patr√≥n en los puntos. Por ejemplo, puedes ver una relaci√≥n positiva entre el tama√±o en quilates y el precio de un diamante: los diamantes con m√°s quilates tienen un precio m√°s alto. La relaci√≥n es exponencial.\n\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_point()\n\n\n\n\n\n\n\n(En esta secci√≥n, usaremos el conjunto de datos smaller para centrarnos en la mayor parte de los diamantes que tienen menos de 3 quilates)\nLos diagramas de dispersi√≥n se vuelven menos √∫tiles a medida que crece el tama√±o de su conjunto de datos, porque los puntos comienzan a superponerse y se acumulan en √°reas de negro uniforme, lo que dificulta juzgar las diferencias en la densidad de los datos en el espacio bidimensional, adem√°s de hacerlo dif√≠cil detectar la tendencia. Ya ha visto una forma de solucionar el problema: usar la est√©tica alpha para agregar transparencia.\n\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_point(alpha = 1 / 100)\n\n\n\n\n\n\n\nPero usar la transparencia puede ser un desaf√≠o para conjuntos de datos muy grandes. Otra soluci√≥n es usar bin. Previamente us√≥ geom_histogram() y geom_freqpoly() para agrupar en una dimensi√≥n. Ahora aprender√° a usar geom_bin2d() y geom_hex() para agrupar en dos dimensiones.\ngeom_bin2d() y geom_hex() dividen el plano de coordenadas en contenedores 2d y luego usan un color de relleno para mostrar cu√°ntos puntos caen en cada contenedor. geom_bin2d() crea contenedores rectangulares. geom_hex() crea contenedores hexagonales. Deber√° instalar el paquete hexbin para usar geom_hex().\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_bin2d()\n\n# install.packages(\"hexbin\")\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_hex()\n\n\n\n\n\n\n\n\n\n\nOtra opci√≥n es agrupar una variable continua para que act√∫e como una variable categ√≥rica. Luego puede usar una de las t√©cnicas para visualizar la combinaci√≥n de una variable categ√≥rica y continua que aprendi√≥. Por ejemplo, podr√≠a agrupar carat y luego, para cada grupo, mostrar un diagrama de caja:\n\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_boxplot(aes(group = cut_width(carat, 0.1)))\n\n\n\n\n\n\n\ncut_width(x, ancho), como se us√≥ anteriormente, divide x en contenedores de ancho ancho. De manera predeterminada, los diagramas de caja se ven m√°s o menos iguales (aparte del n√∫mero de valores at√≠picos) independientemente de cu√°ntas observaciones haya, por lo que es dif√≠cil saber si cada diagrama de caja resume una cantidad diferente de puntos. Una forma de demostrarlo es hacer que el ancho del diagrama de caja sea proporcional al n√∫mero de puntos con varwidth = TRUE.\n\n10.5.3.1 Ejercicios\n\nEn lugar de resumir la distribuci√≥n condicional con un diagrama de caja, podr√≠a usar un pol√≠gono de frecuencia. ¬øQu√© debe tener en cuenta al usar cut_width() frente a cut_number()? ¬øC√≥mo impacta eso en una visualizaci√≥n de la distribuci√≥n 2d de quilate carat y precio price?\nVisualice la distribuci√≥n de quilates, dividida por precio.\n¬øC√≥mo se compara la distribuci√≥n de precios de los diamantes muy grandes con la de los diamantes peque√±os? ¬øEs como esperabas o te sorprende?\nCombine dos de las t√©cnicas que ha aprendido para visualizar la distribuci√≥n combinada de corte, quilate y precio.\n\nLos gr√°ficos bidimensionales revelan valores at√≠picos que no son visibles en los gr√°ficos unidimensionales. Por ejemplo, algunos puntos en la siguiente gr√°fica tienen una combinaci√≥n inusual de valores x e y, lo que hace que los puntos sean at√≠picos aunque sus valores x e y parezcan normales cuando se examinan por separado. ¬øPor qu√© un diagrama de dispersi√≥n es una mejor visualizaci√≥n que un diagrama en bins para este caso?\n\ndiamonds |&gt; \n  filter(x &gt;= 4) |&gt;\n  ggplot(aes(x = x, y = y)) +\n  geom_point() +\n  coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))\n\n\n\nEn lugar de crear cuadros de igual ancho con cut_width(), podr√≠amos crear cuadros que contengan aproximadamente el mismo n√∫mero de puntos con cut_number(). ¬øCu√°les son las ventajas y desventajas de este enfoque?\n\nggplot(smaller, aes(x = carat, y = price)) +\n  geom_boxplot(aes(group = cut_number(carat, 20)))",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>An√°lisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "EDA.html#patrones-y-modelos",
    "href": "EDA.html#patrones-y-modelos",
    "title": "10¬† An√°lisis exploratorio de datos",
    "section": "\n10.6 Patrones y modelos",
    "text": "10.6 Patrones y modelos\nSi existe una relaci√≥n sistem√°tica entre dos variables, aparecer√° como un patr√≥n en los datos. Si detecta un patr√≥n, preg√∫ntese:\n\n¬øPodr√≠a este patr√≥n deberse a una coincidencia (es decir, al azar)?\n¬øC√≥mo puedes describir la relaci√≥n impl√≠cita en el patr√≥n?\n¬øQu√© tan fuerte es la relaci√≥n impl√≠cita en el patr√≥n?\n¬øQu√© otras variables podr√≠an afectar la relaci√≥n?\n¬øCambia la relaci√≥n si observa subgrupos individuales de datos?\n\nLos patrones en sus datos brindan pistas sobre las relaciones, es decir, revelan la covariaci√≥n. Si piensas en la variaci√≥n como un fen√≥meno que crea incertidumbre, la covariaci√≥n es un fen√≥meno que la reduce. Si dos variables covar√≠an, puede usar los valores de una variable para hacer mejores predicciones sobre los valores de la segunda. Si la covariaci√≥n se debe a una relaci√≥n causal (un caso especial), puede usar el valor de una variable para controlar el valor de la segunda.\nLos modelos son una herramienta para extraer patrones de los datos. Por ejemplo, considere los datos de los diamantes. Es dif√≠cil entender la relaci√≥n entre corte y precio, porque el corte y el quilate, y el quilate y el precio est√°n estrechamente relacionados. Es posible usar un modelo para eliminar la fuerte relaci√≥n entre el precio y el quilate para que podamos explorar las sutilezas que quedan. El siguiente c√≥digo se ajusta a un modelo que predice price a partir de carat y luego calcula los residuos (la diferencia entre el valor predicho y el valor real). Los residuales nos dan una idea del precio del diamante, una vez eliminado el efecto del quilate. Tenga en cuenta que en lugar de utilizar los valores brutos de price y carat, primero los transformamos logar√≠tmicamente y ajustamos un modelo a los valores transformados logar√≠tmicamente. Luego, exponenciamos los residuos para volver a colocarlos en la escala de precios brutos.\n\nlibrary(tidymodels)\n\ndiamonds &lt;- diamonds |&gt;\n  mutate(\n    log_price = log(price),\n    log_carat = log(carat)\n  )\n\ndiamonds_fit &lt;- linear_reg() |&gt;\n  fit(log_price ~ log_carat, data = diamonds)\n\ndiamonds_aug &lt;- augment(diamonds_fit, new_data = diamonds) |&gt;\n  mutate(.resid = exp(.resid))\n\nggplot(diamonds_aug, aes(x = carat, y = .resid)) + \n  geom_point()\n\n\n\n\n\n\n\nUna vez que haya eliminado la fuerte relaci√≥n entre el quilate y el precio, puede ver lo que espera en la relaci√≥n entre el corte y el precio: en relaci√≥n con su tama√±o, los diamantes de mejor calidad son m√°s caros.\n\nggplot(diamonds_aug, aes(x = cut, y = .resid)) + \n  geom_boxplot()\n\n\n\n\n\n\n\nNo estamos discutiendo el modelado en este libro porque comprender qu√© son los modelos y c√≥mo funcionan es m√°s f√°cil una vez que tiene a mano las herramientas de organizaci√≥n de datos y programaci√≥n.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>An√°lisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "EDA.html#resumen",
    "href": "EDA.html#resumen",
    "title": "10¬† An√°lisis exploratorio de datos",
    "section": "\n10.7 Resumen",
    "text": "10.7 Resumen\nEn este cap√≠tulo, aprendi√≥ una variedad de herramientas para ayudarlo a comprender la variaci√≥n dentro de sus datos. Ha visto t√©cnicas que funcionan con una sola variable a la vez y con un par de variables. Esto puede parecer una restricci√≥n dolorosa si tiene decenas o cientos de variables en sus datos, pero son la base sobre la que se construyen todas las dem√°s t√©cnicas.\nEn el pr√≥ximo cap√≠tulo, nos centraremos en las herramientas que podemos utilizar para comunicar nuestros resultados.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>An√°lisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "EDA.html#footnotes",
    "href": "EDA.html#footnotes",
    "title": "10¬† An√°lisis exploratorio de datos",
    "section": "",
    "text": "Recuerda que cuando necesitemos ser expl√≠cito sobre el origen de una funci√≥n (o conjunto de datos), usaremos la forma especial package::funcion() o package::conjuntodedatos.‚Ü©Ô∏é",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>An√°lisis exploratorio de datos</span>"
    ]
  },
  {
    "objectID": "communication.html",
    "href": "communication.html",
    "title": "11¬† Comunicaci√≥n",
    "section": "",
    "text": "11.1 Introducci√≥n\nEn Cap√≠tulo 10, aprendi√≥ a usar gr√°ficos como herramientas para exploraci√≥n. Cuando hace gr√°ficos exploratorios, sabe, incluso antes de mirar, qu√© variables mostrar√° el gr√°fico. Hiciste cada gr√°fica con un prop√≥sito, pod√≠as mirarla r√°pidamente y luego pasar a la siguiente gr√°fica. En el curso de la mayor√≠a de los an√°lisis, producir√° decenas o cientos de gr√°ficas, la mayor√≠a de las cuales se desechan de inmediato.\nAhora que comprende sus datos, necesita comunicar su comprensi√≥n a los dem√°s. Es probable que su audiencia no comparta su conocimiento previo y no est√© profundamente interesado en los datos. Para ayudar a otros a construir r√°pidamente un buen modelo mental de los datos, deber√° invertir un esfuerzo considerable para hacer que sus diagramas se expliquen por s√≠ mismos tanto como sea posible. En este cap√≠tulo, aprender√° algunas de las herramientas que proporciona ggplot2 para hacerlo.\nEste cap√≠tulo se centra en las herramientas que necesita para crear buenos gr√°ficos. Suponemos que sabe lo que quiere y solo necesita saber c√≥mo hacerlo. Por esa raz√≥n, recomendamos combinar este cap√≠tulo con un buen libro de visualizaci√≥n general. Nos gusta especialmente The Truthful Art, de Albert Cairo. No ense√±a la mec√°nica de crear visualizaciones, sino que se enfoca en lo que necesita pensar para crear gr√°ficos efectivos.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Comunicaci√≥n</span>"
    ]
  },
  {
    "objectID": "communication.html#introducci√≥n",
    "href": "communication.html#introducci√≥n",
    "title": "11¬† Comunicaci√≥n",
    "section": "",
    "text": "11.1.1 Requisitos previos\nEn este cap√≠tulo, nos centraremos una vez m√°s en ggplot2. Tambi√©n usaremos un poco de dplyr para la manipulaci√≥n de datos, scales para anular las rupturas, etiquetas, transformaciones y paletas predeterminadas, y algunos paquetes de extensi√≥n de ggplot2, incluido ggrepel (https://ggrepel. slowkow.com) de Kamil Slowikowski y patchwork (https://patchwork.data-imaginist.com) por Thomas Lin Pedersen. No olvides que necesitar√°s instalar esos paquetes con install.packages() si a√∫n no los tienes.\n\nlibrary(tidyverse)\nlibrary(scales)\nlibrary(ggrepel)\nlibrary(patchwork)",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Comunicaci√≥n</span>"
    ]
  },
  {
    "objectID": "communication.html#etiquetas",
    "href": "communication.html#etiquetas",
    "title": "11¬† Comunicaci√≥n",
    "section": "\n11.2 Etiquetas",
    "text": "11.2 Etiquetas\nEl lugar m√°s f√°cil para comenzar a convertir un gr√°fico exploratorio en un gr√°fico expositivo es con buenas etiquetas. Agregas etiquetas con la funci√≥n labs().\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  labs(\n    x = \"Motor desplazamiento (L)\",\n    y = \"Econom√≠a de combustible en carretera (mpg)\",\n    color = \"Tipo de coche\",\n    title = \"Eficiencia de combustible generalmente disminuye con el tama√±o del motor\",\n    subtitle = \"Dos plazas son una excepci√≥n debido a su peso ligero\",\n    caption = \"Datos de fueleconomy.gov\"\n  )\n\n\n\n\n\n\n\nEl prop√≥sito del t√≠tulo de una trama es resumir el hallazgo principal. Evite t√≠tulos que solo describan cu√°l es la trama, p.ej., ‚ÄúUn diagrama de dispersi√≥n de la cilindrada del motor frente a la econom√≠a de combustible‚Äù.\nSi necesita agregar m√°s texto, hay otras dos etiquetas √∫tiles: subtitle agrega detalles adicionales en una fuente m√°s peque√±a debajo del t√≠tulo y caption agrega texto en la parte inferior derecha de la trama, que a menudo se usa para describir la fuente del datos. Tambi√©n puede usar labs() para reemplazar los t√≠tulos de los ejes y las leyendas. Por lo general, es una buena idea reemplazar los nombres cortos de las variables con descripciones m√°s detalladas e incluir las unidades.\nEs posible usar ecuaciones matem√°ticas en lugar de cadenas de texto. Simplemente cambia \"\" por quote() y lee acerca de las opciones disponibles en ?plotmath:\n\ndf &lt;- tibble(\n  x = 1:10,\n  y = cumsum(x^2)\n)\n\nggplot(df, aes(x, y)) +\n  geom_point() +\n  labs(\n    x = quote(x[i]),\n    y = quote(sum(x[i] ^ 2, i == 1, n))\n  )\n\n\n\n\n\n\n\n\n11.2.1 Ejercicios\n\nCree un gr√°fico en los datos de econom√≠a de combustible con etiquetas personalizadas de t√≠tulo, subt√≠tulo, t√≠tulo, x, y y color.\n\nVuelva a crear la siguiente gr√°fica usando los datos de econom√≠a de combustible. Tenga en cuenta que tanto los colores como las formas de los puntos var√≠an seg√∫n el tipo de transmisi√≥n.\n\n\n\n\n\n\n\n\n\nTome un gr√°fico exploratorio que haya creado en el √∫ltimo mes y agregue t√≠tulos informativos para que sea m√°s f√°cil de entender para otros.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Comunicaci√≥n</span>"
    ]
  },
  {
    "objectID": "communication.html#anotaciones",
    "href": "communication.html#anotaciones",
    "title": "11¬† Comunicaci√≥n",
    "section": "\n11.3 Anotaciones",
    "text": "11.3 Anotaciones\nAdem√°s de etiquetar los componentes principales de su gr√°fico, suele ser √∫til etiquetar observaciones individuales o grupos de observaciones. La primera herramienta que tienes a tu disposici√≥n es geom_text(). geom_text() es similar a geom_point(), pero tiene una est√©tica adicional: label. Esto hace posible agregar etiquetas textuales a sus gr√°ficas.\nHay dos posibles fuentes de etiquetas. Primero, es posible que tenga un tibble que proporcione etiquetas. En la siguiente gr√°fica, sacamos los autos con el tama√±o de motor m√°s alto en cada tipo de unidad y guardamos su informaci√≥n como un nuevo data frames llamado label_info.\n\nlabel_info &lt;- mpg |&gt;\n  group_by(drv) |&gt;\n  arrange(desc(displ)) |&gt;\n  slice_head(n = 1) |&gt;\n  mutate(\n    drive_type = case_when(\n      drv == \"f\" ~ \"front-wheel drive\",\n      drv == \"r\" ~ \"rear-wheel drive\",\n      drv == \"4\" ~ \"4-wheel drive\"\n    )\n  ) |&gt;\n  select(displ, hwy, drv, drive_type)\n\nlabel_info\n#&gt; # A tibble: 3 √ó 4\n#&gt; # Groups:   drv [3]\n#&gt;   displ   hwy drv   drive_type       \n#&gt;   &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;            \n#&gt; 1   6.5    17 4     4-wheel drive    \n#&gt; 2   5.3    25 f     front-wheel drive\n#&gt; 3   7      24 r     rear-wheel drive\n\nLuego, usamos este nuevo data frame para etiquetar directamente los tres grupos para reemplazar la leyenda con etiquetas colocadas directamente en la gr√°fica. Usando los argumentos fontface y size podemos personalizar el aspecto de las etiquetas de texto. Son m√°s grandes que el resto del texto de la gr√°fica y est√°n en negrita. (theme(legend.position = \"none\") desactiva todas las leyenda ‚Äî hablaremos de ello m√°s adelante).\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(se = FALSE) +\n  geom_text(\n    data = label_info, \n    aes(x = displ, y = hwy, label = drive_type),\n    fontface = \"bold\", size = 5, hjust = \"right\", vjust = \"bottom\"\n  ) +\n  theme(legend.position = \"none\")\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\nTenga en cuenta el uso de hjust (justificaci√≥n horizontal) y vjust (justificaci√≥n vertical) para controlar la alineaci√≥n de la etiqueta. Podemos usar la funci√≥n geom_label_repel() del paquete ggrepel para solucionar ambos problemas. Este √∫til paquete ajustar√° autom√°ticamente las etiquetas para que no se superpongan:\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(se = FALSE) +\n  geom_label_repel(\n    data = label_info, \n    aes(x = displ, y = hwy, label = drive_type),\n    fontface = \"bold\", size = 5, nudge_y = 2\n  ) +\n  theme(legend.position = \"none\")\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\nTambi√©n puede usar la misma idea para resaltar ciertos puntos en un diagrama con geom_text_repel() del paquete ggrepel. Tenga en cuenta otra t√©cnica √∫til utilizada aqu√≠: agregamos una segunda capa de puntos grandes y huecos para resaltar a√∫n m√°s los puntos etiquetados.\n\npotential_outliers &lt;- mpg |&gt;\n  filter(hwy &gt; 40 | (hwy &gt; 20 & displ &gt; 5))\n  \nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_text_repel(data = potential_outliers, aes(label = model)) +\n  geom_point(data = potential_outliers, color = \"red\") +\n  geom_point(\n    data = potential_outliers,\n    color = \"red\", size = 3, shape = \"circle open\")\n\n\n\n\n\n\n\nRecuerde, adem√°s de geom_text() y geom_label(), tiene muchos otros geoms en ggplot2 disponibles para ayudar a anotar su gr√°fico. Un par de ideas:\n\nUse geom_hline() y geom_vline() para agregar l√≠neas de referencia. A menudo los hacemos gruesos (linewidth = 2) y blancos (color = white), y los dibujamos debajo de la capa de datos principal. Eso los hace f√°ciles de ver, sin desviar la atenci√≥n de los datos.\nUsa geom_rect() para dibujar un rect√°ngulo alrededor de los puntos de inter√©s. Los l√≠mites del rect√°ngulo est√°n definidos por la est√©tica xmin, xmax, ymin, ymax. Alternativamente, consulte el paquete ggforce, espec√≠ficamente geom_mark_hull(), que le permite anotar subconjuntos de puntos con cascos.\nUsa geom_segment() con el argumento arrow para llamar la atenci√≥n sobre un punto con una flecha. Use la est√©tica x e y para definir la ubicaci√≥n inicial, y xend y yend para definir la ubicaci√≥n final.\n\nOtra funci√≥n √∫til para agregar anotaciones a los gr√°ficos es annotate(). Como regla general, los geoms son generalmente √∫tiles para resaltar un subconjunto de datos, mientras que annotate() es √∫til para agregar uno o algunos elementos de anotaci√≥n a una gr√°fica.\nPara demostrar el uso de annotate(), creemos un texto para agregar a nuestra trama. El texto es un poco largo, por lo que usaremos stringr::str_wrap() para agregar autom√°ticamente saltos de l√≠nea dado el n√∫mero de caracteres que desea por l√≠nea:\n\ntrend_text &lt;- \"Los tama√±os de motor m√°s grandes tienden a tener menor econom√≠a de combustible.\" |&gt;\n  str_wrap(width = 30)\ntrend_text\n#&gt; [1] \"Los tama√±os de motor m√°s\\ngrandes tienden a tener menor\\neconom√≠a de combustible.\"\n\nLuego, agregamos dos capas de anotaci√≥n: una con una etiqueta geom y la otra con un segmento geom. La est√©tica x e y en ambos definen d√≥nde debe comenzar la anotaci√≥n, y la est√©tica xend y yend en la anotaci√≥n del segmento definen la ubicaci√≥n final del segmento. Tenga en cuenta tambi√©n que el segmento tiene el estilo de una flecha.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  annotate(\n    geom = \"label\", x = 3.5, y = 38,\n    label = trend_text,\n    hjust = \"left\", color = \"red\"\n  ) +\n  annotate(\n    geom = \"segment\",\n    x = 3, y = 35, xend = 5, yend = 25, color = \"red\",\n    arrow = arrow(type = \"closed\")\n  )\n\n\n\n\n\n\n\nLa anotaci√≥n es una herramienta poderosa para comunicar los puntos principales y las caracter√≠sticas interesantes de sus visualizaciones. ¬°El √∫nico l√≠mite es su imaginaci√≥n (y su paciencia con las anotaciones de posicionamiento para que sean est√©ticamente agradables)!\n\n11.3.1 Ejercicios\n\nUsa geom_text() con infinitas posiciones para colocar texto en las cuatro esquinas del gr√°fico.\nUse annotate() para agregar un punto geom en el medio de su √∫ltimo gr√°fico sin tener que crear un tibble. Personaliza la forma, el tama√±o o el color del punto.\n¬øC√≥mo interact√∫an las etiquetas con geom_text() con las facetas? ¬øC√≥mo se puede agregar una etiqueta a una sola faceta? ¬øC√≥mo se puede poner una etiqueta diferente en cada faceta? (Sugerencia: piense en el conjunto de datos que se pasa a geom_text().).\n¬øQu√© argumentos de geom_label() controlan la apariencia del cuadro de fondo?\n¬øCu√°les son los cuatro argumentos de arrow()? ¬øC√≥mo trabajan? Cree una serie de diagramas que demuestren las opciones m√°s importantes.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Comunicaci√≥n</span>"
    ]
  },
  {
    "objectID": "communication.html#escalas",
    "href": "communication.html#escalas",
    "title": "11¬† Comunicaci√≥n",
    "section": "\n11.4 Escalas",
    "text": "11.4 Escalas\nLa tercera forma en que puede mejorar su gr√°fica para la comunicaci√≥n es ajustar las escalas. Las escalas controlan c√≥mo los mapeos est√©ticos se manifiestan visualmente.\n\n11.4.1 Escalas predeterminadas\nNormalmente, ggplot2 agrega escalas autom√°ticamente. Por ejemplo, cuando escribe:\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class))\n\nggplot2 agrega autom√°ticamente escalas predeterminadas detr√°s de escena:\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  scale_x_continuous() +\n  scale_y_continuous() +\n  scale_color_discrete()\n\nTenga en cuenta el esquema de nombres para las escalas: scale_ seguido del nombre de la est√©tica, luego _, luego el nombre de la escala. Las escalas predeterminadas se nombran seg√∫n el tipo de variable con la que se alinean: continuous, discrete, datetime, o date. scale_x_continuous() coloca los valores num√©ricos de displ en una recta num√©rica continua en el eje x, scale_color_discrete() elige colores para cada una de las clases de autom√≥viles, etc. Hay muchas escalas no predeterminadas que aprender√° a continuaci√≥n.\nLas escalas predeterminadas se eligieron cuidadosamente para hacer un buen trabajo con una amplia gama de entradas. Sin embargo, es posible que desee anular los valores predeterminados por dos razones:\n\nEs posible que desee modificar algunos de los par√°metros de la escala predeterminada. Esto le permite hacer cosas como cambiar las pausas en los ejes o las etiquetas de las teclas en la leyenda.\nEs posible que desee reemplazar la escala por completo y usar un algoritmo completamente diferente. A menudo, puede hacerlo mejor que el predeterminado porque sabe m√°s sobre los datos.\n\n11.4.2 Marcas de eje y teclas de leyenda\nEn conjunto, los ejes y las leyendas se denominan gu√≠as. Los ejes se utilizan para la est√©tica x e y; las leyendas se usan para todo lo dem√°s.\nHay dos argumentos principales que afectan la apariencia de las marcas en los ejes y las teclas en la leyenda: breaks y labels. Con breaks controla la posici√≥n de los ticks o los valores asociados con las teclas. Con labels controla la etiqueta de texto asociada con cada marca/tecla. El uso m√°s com√∫n de breaks es anular la opci√≥n predeterminada:\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_y_continuous(breaks = seq(15, 40, by = 5))\n\n\n\n\n\n\n\nPuede usar labels de la misma manera (un vector de caracteres de la misma longitud que breaks), pero tambi√©n puede establecerlo en NULL para suprimir las etiquetas por completo. Esto puede ser √∫til para mapas o para publicar gr√°ficas donde no puede compartir los n√∫meros absolutos. Tambi√©n puede usar breaks y labels para controlar la apariencia de las leyendas. Para escalas discretas para variables categ√≥ricas, las etiquetas, labels, pueden ser una lista con nombre de los nombres de los niveles existentes y las etiquetas deseadas para ellos.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous(labels = NULL) +\n  scale_y_continuous(labels = NULL) +\n  scale_color_discrete(labels = c(\"4\" = \"4 ruedas\", \"f\" = \"delantera\", \"r\" = \"trasera\"))\n\n\n\n\n\n\n\nEl argumento labels junto con las funciones de etiquetado del paquete scales tambi√©n es √∫til para formatear n√∫meros como moneda, porcentaje, etc. El gr√°fico de la izquierda muestra el etiquetado predeterminado con label_dollar(), que agrega un signo de d√≥lar y una coma separadora de mil. El gr√°fico de la derecha agrega m√°s personalizaci√≥n al dividir los valores en d√≥lares por 1000 y agregar un sufijo ‚ÄúK‚Äù (para ‚Äúmiles‚Äù), adem√°s de agregar cortes personalizados. Tenga en cuenta que las rupturas (breaks) est√°n en la escala original de los datos.\n# Izquierda\nggplot(diamonds, aes(x = price, y = cut)) +\n  geom_boxplot(alpha = 0.05) +\n  scale_x_continuous(labels = label_dollar())\n\n# Derecha\nggplot(diamonds, aes(x = price, y = cut)) +\n  geom_boxplot(alpha = 0.05) +\n  scale_x_continuous(\n    labels = label_dollar(scale = 1/1000, suffix = \"K\"), \n    breaks = seq(1000, 19000, by = 6000)\n  )\n\n\n\n\n\n\n\n\n\n\nOtra funci√≥n de etiqueta √∫til es label_percent():\n\nggplot(diamonds, aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"fill\") +\n  scale_y_continuous(name = \"Porcentaje\", labels = label_percent())\n\n\n\n\n\n\n\nOtro uso de las rupturas (breaks) es cuando tiene relativamente pocos puntos de datos y desea resaltar exactamente d√≥nde ocurren las observaciones. Por ejemplo, tome esta gr√°fica que muestra cu√°ndo comenz√≥ y termin√≥ su mandato cada presidente de EE. UU.\n\npresidential |&gt;\n  mutate(id = 33 + row_number()) |&gt;\n  ggplot(aes(x = start, y = id)) +\n  geom_point() +\n  geom_segment(aes(xend = end, yend = id)) +\n  scale_x_date(name = NULL, breaks = presidential$start, date_labels = \"'%y\")\n\n\n\n\n\n\n\nTenga en cuenta que para el argumento breaks sacamos la variable start como un vector con presidential$start porque no podemos hacer un mapeo est√©tico para este argumento. Tambi√©n tenga en cuenta que la especificaci√≥n de rupturas y etiquetas para las escalas de fecha y hora es un poco diferente:\n\ndate_labels toma una especificaci√≥n de formato, de la misma forma que parse_datetime().\ndate_breaks (no se muestra aqu√≠), toma una cadena como ‚Äú2 d√≠as‚Äù o ‚Äú1 mes‚Äù.\n\n11.4.3 Dise√±o de leyenda\nLa mayor√≠a de las veces usar√° breaks y labels para ajustar los ejes. Si bien ambos tambi√©n funcionan para leyendas, hay algunas otras t√©cnicas que es m√°s probable que uses.\nPara controlar la posici√≥n general de la leyenda, debe usar una configuraci√≥n theme(). Volveremos a los temas al final del cap√≠tulo, pero en resumen, controlan las partes de la gr√°fica que no son datos. La configuraci√≥n del tema legend.position controla d√≥nde se dibuja la leyenda:\nbase &lt;- ggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class))\n\nbase + theme(legend.position = \"right\") # por defecto\nbase + theme(legend.position = \"left\")\nbase + \n  theme(legend.position = \"top\") +\n  guides(color = guide_legend(nrow = 3))\nbase + \n  theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(nrow = 3))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSi su diagrama es corto y ancho, coloque la leyenda en la parte superior o inferior, y si es alto y angosto, coloque la leyenda a la izquierda o a la derecha. Tambi√©n puede usar legend.position = \"none\" para suprimir la visualizaci√≥n de la leyenda por completo.\nPara controlar la visualizaci√≥n de leyendas individuales, use guides() junto con guide_legend() o guide_colorbar(). El siguiente ejemplo muestra dos configuraciones importantes: controlar el n√∫mero de filas que usa la leyenda con nrow y anular una de las est√©ticas para agrandar los puntos. Esto es particularmente √∫til si ha usado un alpha bajo para mostrar muchos puntos en un gr√°fico.\n\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(nrow = 2, override.aes = list(size = 4)))\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\nTenga en cuenta que el nombre del argumento en guides() coincide con el nombre de la est√©tica, al igual que en labs().\n\n11.4.4 Sustituci√≥n de una escala\nEn lugar de simplemente ajustar un poco los detalles, puede reemplazar la escala por completo. Hay dos tipos de escalas que probablemente querr√° cambiar: escalas de posici√≥n continua y escalas de color. Afortunadamente, los mismos principios se aplican a todas las dem√°s est√©ticas, por lo que una vez que haya dominado la posici√≥n y el color, podr√° elegir r√°pidamente otros reemplazos de escala.\nEs muy √∫til para trazar transformaciones de su variable. Por ejemplo, es m√°s f√°cil ver la relaci√≥n precisa entre quilate,carat, y precio, price, si le aplicamos una transformaci√≥n logar√≠tmica:\n# Izquierda\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_bin2d()\n\n# Derecha\nggplot(diamonds, aes(x = log10(carat), y = log10(price))) +\n  geom_bin2d()\n\n\n\n\n\n\n\n\n\n\nSin embargo, la desventaja de esta transformaci√≥n es que los ejes ahora est√°n etiquetados con los valores transformados, lo que dificulta la interpretaci√≥n del gr√°fico. En lugar de hacer la transformaci√≥n en el mapeo est√©tico, podemos hacerlo con la escala. Esto es visualmente id√©ntico, excepto que los ejes est√°n etiquetados en la escala de datos original.\n\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_bin2d() + \n  scale_x_log10() + \n  scale_y_log10()\n\n\n\n\n\n\n\nOtra escala que se personaliza con frecuencia es el color. La escala categ√≥rica predeterminada selecciona colores que est√°n espaciados uniformemente alrededor de la rueda de colores. Las alternativas √∫tiles son las escalas ColorBrewer que se han ajustado a mano para que funcionen mejor para las personas con tipos comunes de daltonismo. Los dos gr√°ficos a continuaci√≥n se ven similares, pero hay suficiente diferencia en los tonos de rojo y verde para que los puntos de la derecha puedan ser distinguidos incluso por personas con daltonismo rojo-verde.1\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv))\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  scale_color_brewer(palette = \"Set1\")\n\n\n\n\n\n\n\n\n\n\nNo olvides las t√©cnicas m√°s simples para mejorar la accesibilidad. Si solo hay unos pocos colores, puede agregar un mapeo de forma redundante. Esto tambi√©n ayudar√° a garantizar que su gr√°fica sea interpretable en blanco y negro.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv, shape = drv)) +\n  scale_color_brewer(palette = \"Set1\")\n\n\n\n\n\n\n\nLas escalas ColorBrewer est√°n documentadas en l√≠nea en https://colorbrewer2.org/ y est√°n disponibles en R a trav√©s del paquete RColorBrewer, de Erich Neuwirth. Figura¬†11.1 muestra la lista completa de todas las paletas. Las paletas secuencial (superior) y divergente (inferior) son particularmente √∫tiles si sus valores categ√≥ricos est√°n ordenados o tienen un ‚Äúmedio‚Äù. Esto suele ocurrir si ha utilizado cut() para convertir una variable continua en una variable categ√≥rica.\n\n\n\n\n\n\n\nFigura¬†11.1: All colorBrewer scales.\n\n\n\n\nCuando tenga un mapeo predefinido entre valores y colores, use scale_color_manual(). Por ejemplo, si mapeamos el partido presidencial al color, queremos usar el mapeo est√°ndar de rojo para los republicanos y azul para los dem√≥cratas. Un enfoque para asignar estos colores es usar c√≥digos de color hexadecimales:\n\npresidential |&gt;\n  mutate(id = 33 + row_number()) |&gt;\n  ggplot(aes(x = start, y = id, color = party)) +\n  geom_point() +\n  geom_segment(aes(xend = end, yend = id)) +\n  scale_color_manual(values = c(Republican = \"#E81B23\", Democratic = \"#00AEF3\"))\n\n\n\n\n\n\n\nPara el color continuo, puede utilizar scale_color_gradient() o scale_fill_gradient() integrados. Si tiene una escala divergente, puede usar scale_color_gradient2(). Eso te permite dar, por ejemplo, valores positivos y negativos de diferentes colores. A veces, eso tambi√©n es √∫til si desea distinguir puntos por encima o por debajo de la media.\nOtra opci√≥n es utilizar las escalas de color de viridis. Los dise√±adores, Nathaniel Smith y St√©fan van der Walt, dise√±aron cuidadosamente esquemas de color continuos que son perceptibles para las personas con diversas formas de daltonismo, as√≠ como perceptivamente uniformes tanto en color como en blanco y negro. Estas escalas est√°n disponibles como paletas continuas (c), discretas (d) y agrupadas (b) en ggplot2.\ndf &lt;- tibble(\n  x = rnorm(10000),\n  y = rnorm(10000)\n)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed() +\n  labs(title = \"Default, continuous\", x = NULL, y = NULL)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed() +\n  scale_fill_viridis_c() +\n  labs(title = \"Viridis, continuous\", x = NULL, y = NULL)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed() +\n  scale_fill_viridis_b() +\n  labs(title = \"Viridis, binned\", x = NULL, y = NULL)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTenga en cuenta que todas las escalas de color vienen en dos variedades: scale_color_*() y scale_fill_*() para la est√©tica color y fill respectivamente (las escalas de color est√°n disponibles en la ortograf√≠a del Reino Unido y EE. UU.).\n\n11.4.5 Zoom\nHay tres formas de controlar los l√≠mites de la gr√°fica:\n\nAjustar qu√© datos se trazan.\nFijaci√≥n de los l√≠mites en cada escala.\nConfiguraci√≥n de xlim y ylim en coord_cartesian().\n\nDemostraremos estas opciones en una serie de gr√°ficos. La gr√°fica de la izquierda muestra la relaci√≥n entre el tama√±o del motor y la eficiencia del combustible, coloreada por tipo de tren de transmisi√≥n. El gr√°fico de la derecha muestra las mismas variables, pero subconjuntos de los datos que se trazan. La creaci√≥n de subconjuntos de datos ha afectado las escalas x e y, as√≠ como la curva suave.\n# Izquierda\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  geom_smooth()\n\n# Derecha\nmpg |&gt;\n  filter(displ &gt;= 5 & displ &lt;= 6 & hwy &gt;= 10 & hwy &lt;= 25) |&gt;\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  geom_smooth()\n\n\n\n\n\n\n\n\n\n\nComparemos esto con los dos gr√°ficos a continuaci√≥n, donde el gr√°fico de la izquierda establece los l√≠mites, limits, en las escalas individuales y el gr√°fico de la derecha los establece en coord_cartesian(). Podemos ver que reducir los l√≠mites es equivalente a dividir los datos en subconjuntos. Por lo tanto, para ampliar una regi√≥n de la gr√°fica, generalmente es mejor usar coord_cartesian().\n# Left\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  geom_smooth() +\n  scale_x_continuous(limits = c(5, 6)) +\n  scale_y_continuous(limits = c(10, 25))\n\n# Right\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = drv)) +\n  geom_smooth() +\n  coord_cartesian(xlim = c(5, 6), ylim = c(10, 25))\n\n\n\n\n\n\n\n\n\n\nPor otro lado, establecer los l√≠mites, limits en escalas individuales generalmente es m√°s √∫til si desea expandir los l√≠mites, por ejemplo, para hacer coincidir las escalas en diferentes gr√°ficos. Por ejemplo, si extraemos dos clases de autos y los representamos por separado, es dif√≠cil comparar los gr√°ficos porque las tres escalas (el eje X, el eje Y y la est√©tica del color) tienen rangos diferentes.\n\nsuv &lt;- mpg |&gt; filter(class == \"suv\")\ncompact &lt;- mpg |&gt; filter(class == \"compact\")\n\n# Izquierda\nggplot(suv, aes(x = displ, y = hwy, color = drv)) +\n  geom_point()\n\n# Derecha\nggplot(compact, aes(x = displ, y = hwy, color = drv)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\nUna forma de superar este problema es compartir escalas en varias gr√°ficas, entrenando las escalas con los ‚Äúl√≠mites‚Äù de los datos completos.\nx_scale &lt;- scale_x_continuous(limits = range(mpg$displ))\ny_scale &lt;- scale_y_continuous(limits = range(mpg$hwy))\ncol_scale &lt;- scale_color_discrete(limits = unique(mpg$drv))\n\n# Izquierda\nggplot(suv, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  x_scale +\n  y_scale +\n  col_scale\n\n# Derecha\nggplot(compact, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  x_scale +\n  y_scale +\n  col_scale\n\n\n\n\n\n\n\n\n\n\nEn este caso particular, podr√≠a haber utilizado simplemente facetas, pero esta t√©cnica es √∫til de manera m√°s general, si por ejemplo, desea distribuir gr√°ficos en varias p√°ginas de un informe.\n\n11.4.6 Ejercicios\n\n\n¬øPor qu√© el siguiente c√≥digo no anula la escala predeterminada?\n\ndf &lt;- tibble(\n  x = rnorm(10000),\n  y = rnorm(10000)\n)\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  scale_color_gradient(low = \"white\", high = \"red\") +\n  coord_fixed()\n\n\n¬øCu√°l es el primer argumento de cada escala? ¬øC√≥mo se compara con labs()?\n\nCambie la visualizaci√≥n de los t√©rminos presidenciales por:\n\nCombinando las dos variantes que personalizan los colores y las separaciones del eje x.\nMejorando la visualizaci√≥n del eje y.\nEtiquetar cada t√©rmino con el nombre del presidente.\nAdici√≥n de etiquetas de gr√°fica informativas.\nColocar descansos cada 4 a√±os (¬°es m√°s complicado de lo que parece!).\n\n\n\nPrimero, crea la siguiente gr√°fica. Luego, modifique el c√≥digo usando override.aes para que la leyenda sea m√°s f√°cil de ver.\n\n\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_point(aes(color = cut), alpha = 1/20)",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Comunicaci√≥n</span>"
    ]
  },
  {
    "objectID": "communication.html#sec-themes",
    "href": "communication.html#sec-themes",
    "title": "11¬† Comunicaci√≥n",
    "section": "\n11.5 Temas",
    "text": "11.5 Temas\nFinalmente, puede personalizar los elementos que no son datos de su gr√°fico con un tema:\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  theme_bw()\n\n\n\n\n\n\n\nggplot2 incluye los ocho temas que se muestran en Figura¬†11.2, con theme_gray() como predeterminado.2 Muchos m√°s est√°n incluidos en paquetes complementarios como ggthemes (https://jrnold.github.io/ggthemes), de Jeffrey Arnold. Tambi√©n puede crear sus propios temas, si est√° tratando de hacer coincidir un estilo corporativo o de revista en particular.\n\n\n\n\n\n\n\nFigura¬†11.2: Los ocho temas integrados en ggplot2.\n\n\n\n\nTambi√©n es posible controlar los componentes individuales de cada tema, como el tama√±o y el color de la fuente utilizada para el eje y. Ya hemos visto que legend.position controla d√≥nde se dibuja la leyenda. Hay muchos otros aspectos de la leyenda que se pueden personalizar con theme(). Por ejemplo, en el siguiente gr√°fico, cambiamos la direcci√≥n de la leyenda y le ponemos un borde negro alrededor. Tenga en cuenta que la personalizaci√≥n del cuadro de leyenda y los elementos del t√≠tulo de la trama del tema se realizan con las funciones element_*(). Estas funciones especifican el estilo de los componentes que no son datos, por ejemplo, el texto del t√≠tulo est√° en negrita en el argumento face de element_text() y el color del borde de la leyenda est√° definido en el argumento color de element_rect(). Los elementos del tema que controlan la posici√≥n del t√≠tulo y la leyenda son plot.title.position y plot.caption.position, respectivamente. En el gr√°fico siguiente, estos se establecen en \"plot\" para indicar que estos elementos est√°n alineados con toda el √°rea del gr√°fico, en lugar del panel de gr√°fico (el valor predeterminado). Se utilizan algunos otros componentes de theme() √∫tiles para cambiar la ubicaci√≥n del formato del t√≠tulo y el texto del subt√≠tulo.\n\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  labs(\n    title = \"Los tama√±os de motor m√°s grandes tienden a tener una menor econom√≠a de combustible\",\n    caption = \"Source: https://fueleconomy.gov.\"\n  ) +\n  theme(\n    legend.position = c(0.6, 0.7),\n    legend.direction = \"horizontal\",\n    legend.box.background = element_rect(color = \"black\"),\n    plot.title = element_text(face = \"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\",\n    plot.caption = element_text(hjust = 0)\n  )\n#&gt; Warning: A numeric `legend.position` argument in `theme()` was deprecated in ggplot2\n#&gt; 3.5.0.\n#&gt; ‚Ñπ Please use the `legend.position.inside` argument of `theme()` instead.\n\n\n\n\n\n\n\nPara obtener una descripci√≥n general de todos los componentes theme(), consulte la ayuda con ?theme. El libro de ggplot2 tambi√©n es un excelente lugar para consultar todos los detalles sobre temas.\n\n11.5.1 Ejercicios\n\nElija un tema ofrecido por el paquete ggthemes y apl√≠quelo a la √∫ltima gr√°fica que hizo.\nHaz que las etiquetas de los ejes de tu gr√°fico sean azules y en negrita.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Comunicaci√≥n</span>"
    ]
  },
  {
    "objectID": "communication.html#disposici√≥n",
    "href": "communication.html#disposici√≥n",
    "title": "11¬† Comunicaci√≥n",
    "section": "\n11.6 Disposici√≥n",
    "text": "11.6 Disposici√≥n\nHasta ahora hablamos sobre c√≥mo crear y modificar una sola gr√°fica. ¬øQu√© sucede si tiene varias gr√°ficas que desea dise√±ar de cierta manera? El paquete patchwork le permite combinar gr√°ficas separadas en el mismo gr√°fico. Cargamos este paquete anteriormente en el cap√≠tulo.\nPara colocar dos gr√°ficas una al lado de la otra, simplemente puede agregarlas una a la otra. Tenga en cuenta que primero debe crear los gr√°ficos y guardarlos como objetos (en el siguiente ejemplo, se denominan p1 y p2). Luego, los colocas uno al lado del otro con +.\n\np1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  labs(title = \"Gr√°fica 1\")\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + \n  geom_boxplot() + \n  labs(title = \"Gr√°fica 2\")\np1 + p2\n\n\n\n\n\n\n\nEs importante tener en cuenta que en el fragmento de c√≥digo anterior no usamos una nueva funci√≥n del paquete patchwork. En cambio, el paquete agreg√≥ una nueva funcionalidad al operador +.\nTambi√©n puede crear dise√±os de trama complejos con patchwork. A continuaci√≥n, | coloca p1 y p3 uno al lado del otro y / mueve p2 a la siguiente l√≠nea.\n\np3 &lt;- ggplot(mpg, aes(x = cty, y = hwy)) + \n  geom_point() + \n  labs(title = \"Gr√°fica 3\")\n(p1 | p3) / p2\n\n\n\n\n\n\n\nAdem√°s, patchwork le permite recopilar leyendas de varias gr√°ficas en una leyenda com√∫n, personalizar la ubicaci√≥n de la leyenda y las dimensiones de las gr√°ficas, y agregar un t√≠tulo, subt√≠tulo, descripci√≥n, etc. com√∫n a sus gr√°ficas. A continuaci√≥n creamos 5 parcelas. Desactivamos las leyendas en los diagramas de caja y el diagrama de dispersi√≥n y recopilamos las leyendas para los diagramas de densidad en la parte superior del diagrama con & theme(legend.position = \"top\"). Tenga en cuenta el uso del operador & aqu√≠ en lugar del habitual +. Esto se debe a que estamos modificando el tema de la gr√°fica de retazos en lugar de las ggplots individuales. La leyenda se coloca en la parte superior, dentro de guide_area(). Finalmente, tambi√©n hemos personalizado las alturas de los diversos componentes de nuestro mosaico: la gu√≠a tiene una altura de 1, los diagramas de caja 3, los diagramas de densidad 2 y el diagrama de dispersi√≥n facetado 4. Patchwork divide el √°rea que ha asignado para su gr√°fica utilizando esta escala y coloca los componentes en consecuencia.\n\np1 &lt;- ggplot(mpg, aes(x = drv, y = cty, color = drv)) + \n  geom_boxplot(show.legend = FALSE) + \n  labs(title = \"Gr√°fica 1\")\n\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy, color = drv)) + \n  geom_boxplot(show.legend = FALSE) + \n  labs(title = \"Gr√°fica 2\")\n\np3 &lt;- ggplot(mpg, aes(x = cty, color = drv, fill = drv)) + \n  geom_density(alpha = 0.5) + \n  labs(title = \"Gr√°fica 3\")\n\np4 &lt;- ggplot(mpg, aes(x = hwy, color = drv, fill = drv)) + \n  geom_density(alpha = 0.5) + \n  labs(title = \"Gr√°fica 4\")\n\np5 &lt;- ggplot(mpg, aes(x = cty, y = hwy, color = drv)) + \n  geom_point(show.legend = FALSE) + \n  facet_wrap(~drv) +\n  labs(title = \"Plot 5\")\n\n(guide_area() / (p1 + p2) / (p3 + p4) / p5) +\n  plot_annotation(\n    title = \"Kilometraje en ciudad y carretera para autom√≥viles con diferentes trenes de transmisi√≥n\",\n    caption = \"Fuente: https://fueleconomy.gov\"\n  ) +\n  plot_layout(\n    guides = \"collect\",\n    heights = c(1, 3, 2, 4)\n    ) &\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\nSi desea obtener m√°s informaci√≥n sobre la combinaci√≥n y el dise√±o de varias gr√°ficas con patchwork, le recomendamos consultar las gu√≠as en el sitio web del paquete: https://patchwork.data-imaginist.com.\n\n11.6.1 Ejercicios\n\n\n¬øQu√© sucede si omite los par√©ntesis en el siguiente dise√±o de gr√°fico? ¬øPuedes explicar por qu√© sucede esto?\n\np1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  labs(title = \"Plot 1\")\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + \n  geom_boxplot() + \n  labs(title = \"Plot 2\")\np3 &lt;- ggplot(mpg, aes(x = cty, y = hwy)) + \n  geom_point() + \n  labs(title = \"Plot 3\")\n\n(p1 | p2) / p3\n\n\n\nUsando las tres gr√°ficas del ejercicio anterior, recrea el siguiente mosaico.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Comunicaci√≥n</span>"
    ]
  },
  {
    "objectID": "communication.html#resumen",
    "href": "communication.html#resumen",
    "title": "11¬† Comunicaci√≥n",
    "section": "\n11.7 Resumen",
    "text": "11.7 Resumen\nEn este cap√≠tulo, aprendi√≥ a agregar etiquetas de trazado, como t√≠tulo, subt√≠tulo, leyenda, as√≠ como a modificar etiquetas de eje predeterminadas, usar anotaciones para agregar texto informativo a su trazado o resaltar puntos de datos espec√≠ficos, personalizar las escalas de los ejes y cambiar el tema de su gr√°fica. Tambi√©n aprendi√≥ a combinar varios gr√°ficos en un solo gr√°fico usando dise√±os de gr√°ficos simples y complejos.\nSi bien hasta ahora ha aprendido c√≥mo crear muchos tipos diferentes de gr√°ficos y c√≥mo personalizarlos usando una variedad de t√©cnicas, apenas hemos ara√±ado la superficie de lo que puede crear con ggplot2. Si desea obtener una comprensi√≥n completa de ggplot2, le recomendamos leer el libro, ggplot2: Elegant Graphics for Data Analysis. Otros recursos √∫tiles son el R Graphics Cookbook de Winston Chang y Fundamentals of Data Visualization de Claus Wilke.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Comunicaci√≥n</span>"
    ]
  },
  {
    "objectID": "communication.html#footnotes",
    "href": "communication.html#footnotes",
    "title": "11¬† Comunicaci√≥n",
    "section": "",
    "text": "puede usar una herramienta como SimDaltonism para simular el daltonismo para probar estas im√°genes.‚Ü©Ô∏é\nmuchas personas se preguntan por qu√© el tema predeterminado tiene un fondo gris. Esta fue una elecci√≥n deliberada porque presenta los datos sin dejar de hacer visibles las l√≠neas de la cuadr√≠cula. Las l√≠neas de cuadr√≠cula blancas son visibles (lo cual es importante porque ayudan significativamente a los juicios de posici√≥n), pero tienen poco impacto visual y podemos ignorarlas f√°cilmente. El fondo gris le da a la trama un color tipogr√°fico similar al del texto, asegurando que los gr√°ficos encajen con el flujo de un documento sin sobresalir con un fondo blanco brillante. Finalmente, el fondo gris crea un campo continuo de color que asegura que la trama se perciba como una sola entidad visual.‚Ü©Ô∏é",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Comunicaci√≥n</span>"
    ]
  },
  {
    "objectID": "transform.html",
    "href": "transform.html",
    "title": "Transformar",
    "section": "",
    "text": "La segunda parte del libro fue una inmersi√≥n profunda en la visualizaci√≥n de datos. En esta parte del libro, aprender√° sobre los tipos de variables m√°s importantes que encontrar√° dentro de un data frame y aprender√° las herramientas que puede usar para trabajar con ellos.\n\n\n\n\n\n\n\nFigura¬†1: Las opciones para la transformaci√≥n de datos dependen en gran medida del tipo de datos involucrados, el tema de esta parte del libro.\n\n\n\n\nPuede leer estos cap√≠tulos cuando los necesite; est√°n dise√±ados para ser en gran medida independientes para que puedan leerse desordenados.\n\n12¬† Vectores l√≥gicos te ense√±a sobre vectores l√≥gicos. Estos son el tipo de vector m√°s simple, pero son extremadamente poderosos. Aprender√° c√≥mo crearlos con comparaciones num√©ricas, c√≥mo combinarlos con √°lgebra booleana, c√≥mo usarlos en res√∫menes y c√≥mo usarlos para transformaciones condicionales.\n13¬† N√∫meros se sumerge en herramientas para vectores de n√∫meros, la potencia de la ciencia de datos. Aprender√° m√°s sobre contar y un mont√≥n de funciones importantes de transformaci√≥n y resumen.\n14¬† Caracteres te dar√° las herramientas para trabajar con cadenas de caracteres: las cortar√°s, las cortar√°s en dados y las volver√°s a unir. Este cap√≠tulo se centra principalmente en el paquete stringr, pero tambi√©n aprender√° algunas funciones tidyr m√°s dedicadas a extraer datos de cadenas caracteres.\n15¬† Expresiones regulares le presenta las expresiones regulares, una poderosa herramienta para manipular cadenas de caracteres. Este cap√≠tulo lo llevar√° de pensar que un gato camin√≥ sobre su teclado a leer y escribir patrones de cadenas de caracteres complejos.\n16¬† Factores introduce factores: el tipo de datos que utiliza R para almacenar datos categ√≥ricos. Usa un factor cuando la variable tiene un conjunto fijo de valores posibles, o cuando desea usar un orden no alfab√©tico de una cadena de caracteres.\n17¬† Fechas y horas le dar√° las herramientas clave para trabajar con fechas y fechas-horas. Desafortunadamente, cuanto m√°s aprende sobre las fechas y horas, m√°s complicadas parecen volverse, pero con la ayuda del paquete lubridate, aprender√° a superar los desaf√≠os m√°s comunes.\n18¬† Valores faltanres analiza los valores perdidos en profundidad. Los hemos discutido un par de veces de forma aislada, pero ahora es el momento de discutirlos de manera integral, ayud√°ndolo a comprender la diferencia entre los valores faltantes impl√≠citos y expl√≠citos, y c√≥mo y por qu√© podr√≠a convertir entre ellos.\n19¬† Uniones termina esta parte del libro brind√°ndole herramientas para unir dos (o m√°s) marcos de datos. Aprender sobre combinaciones lo obligar√° a lidiar con la idea de las claves y pensar en c√≥mo identifica cada fila en un conjunto de datos.",
    "crumbs": [
      "Transformar"
    ]
  },
  {
    "objectID": "logicals.html",
    "href": "logicals.html",
    "title": "12¬† Vectores l√≥gicos",
    "section": "",
    "text": "12.1 Introducci√≥n\nEn este cap√≠tulo, aprender√° herramientas para trabajar con vectores l√≥gicos. Los vectores l√≥gicos son el tipo de vector m√°s simple porque cada elemento solo puede tener uno de tres valores posibles: TRUE, TRUE, FALSE, FALSE y faltante, NA. Es relativamente raro encontrar vectores l√≥gicos en sus datos sin procesar, pero los crear√° y manipular√° en el curso de casi todos los an√°lisis.\nComenzaremos discutiendo la forma m√°s com√∫n de crear vectores l√≥gicos: con comparaciones num√©ricas. Luego, aprender√° c√≥mo puede usar el √°lgebra booleana para combinar diferentes vectores l√≥gicos, as√≠ como algunos res√∫menes √∫tiles. Terminaremos con if_else() y case_when(), dos funciones √∫tiles para realizar cambios condicionales impulsados por vectores l√≥gicos.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Vectores l√≥gicos</span>"
    ]
  },
  {
    "objectID": "logicals.html#introducci√≥n",
    "href": "logicals.html#introducci√≥n",
    "title": "12¬† Vectores l√≥gicos",
    "section": "",
    "text": "12.1.1 Requisitos previos\nLa mayor√≠a de las funciones que aprender√° en este cap√≠tulo son proporcionadas por la base R, por lo que no necesitamos el tidyverse, pero igual lo cargaremos para poder usar mutate(), filter(), y amigos para trabajar con data frames. Tambi√©n continuaremos extrayendo ejemplos del conjunto de datos nycflights13::flights.\n\nlibrary(tidyverse)\nlibrary(nycflights13)\n\nSin embargo, a medida que empecemos a cubrir m√°s herramientas, no siempre habr√° un ejemplo real perfecto. As√≠ que empezaremos a inventar algunos datos ficticios con c():\n\nx &lt;- c(1, 2, 3, 5, 7, 11, 13)\nx * 2\n#&gt; [1]  2  4  6 10 14 22 26\n\nEsto facilita la explicaci√≥n de funciones individuales a costa de dificultar ver c√≥mo podr√≠a aplicarse a sus problemas de datos. Solo recuerda que cualquier manipulaci√≥n que hagamos a un vector flotante, puedes hacerla a una variable dentro de un data frame con mutate() y amigos.\n\ndf &lt;- tibble(x)\ndf |&gt; \n  mutate(y = x * 2)\n#&gt; # A tibble: 7 √ó 2\n#&gt;       x     y\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n#&gt; 4     5    10\n#&gt; 5     7    14\n#&gt; 6    11    22\n#&gt; # ‚Ñπ 1 more row",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Vectores l√≥gicos</span>"
    ]
  },
  {
    "objectID": "logicals.html#comparaciones",
    "href": "logicals.html#comparaciones",
    "title": "12¬† Vectores l√≥gicos",
    "section": "\n12.2 Comparaciones",
    "text": "12.2 Comparaciones\nUna forma muy com√∫n de crear un vector l√≥gico es a trav√©s de una comparaci√≥n num√©rica con &lt;, &lt;=, &gt;, &gt;=, != y ==. Hasta ahora, en su mayor√≠a hemos creado variables l√≥gicas de manera transitoria dentro de filter() ‚Äî se calculan, usan y luego se descartan. Por ejemplo, el siguiente filtro encuentra todas las salidas diurnas que llegan aproximadamente a tiempo:\n\nflights |&gt; \n  filter(dep_time &gt; 600 & dep_time &lt; 2000 & abs(arr_delay) &lt; 20)\n#&gt; # A tibble: 172,286 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      601            600         1      844            850\n#&gt; 2  2013     1     1      602            610        -8      812            820\n#&gt; 3  2013     1     1      602            605        -3      821            805\n#&gt; 4  2013     1     1      606            610        -4      858            910\n#&gt; 5  2013     1     1      606            610        -4      837            845\n#&gt; 6  2013     1     1      607            607         0      858            915\n#&gt; # ‚Ñπ 172,280 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nEs √∫til saber que este es un atajo y que puedes crear expl√≠citamente las variables l√≥gicas subyacentes con mutate():\n\nflights |&gt; \n  mutate(\n    daytime = dep_time &gt; 600 & dep_time &lt; 2000,\n    approx_ontime = abs(arr_delay) &lt; 20,\n    .keep = \"used\"\n  )\n#&gt; # A tibble: 336,776 √ó 4\n#&gt;   dep_time arr_delay daytime approx_ontime\n#&gt;      &lt;int&gt;     &lt;dbl&gt; &lt;lgl&gt;   &lt;lgl&gt;        \n#&gt; 1      517        11 FALSE   TRUE         \n#&gt; 2      533        20 FALSE   FALSE        \n#&gt; 3      542        33 FALSE   FALSE        \n#&gt; 4      544       -18 FALSE   TRUE         \n#&gt; 5      554       -25 FALSE   FALSE        \n#&gt; 6      554        12 FALSE   TRUE         \n#&gt; # ‚Ñπ 336,770 more rows\n\nEsto es particularmente √∫til para la l√≥gica m√°s complicada porque nombrar los pasos intermedios facilita la lectura del c√≥digo y la verificaci√≥n de que cada paso se haya calculado correctamente.\nCon todo, el filtro inicial es equivalente a:\n\nflights |&gt; \n  mutate(\n    daytime = dep_time &gt; 600 & dep_time &lt; 2000,\n    approx_ontime = abs(arr_delay) &lt; 20,\n  ) |&gt; \n  filter(daytime & approx_ontime)\n\n\n12.2.1 Comparaci√≥n de punto flotante\nCuidado con usar == con n√∫meros. Por ejemplo, parece que este vector contiene los n√∫meros 1 y 2:\n\nx &lt;- c(1 / 49 * 49, sqrt(2) ^ 2)\nx\n#&gt; [1] 1 2\n\nPero si los prueba para la igualdad, obtiene FALSE, FALSE:\n\nx == c(1, 2)\n#&gt; [1] FALSE FALSE\n\n¬øQu√© est√° sucediendo? Las computadoras almacenan n√∫meros con un n√∫mero fijo de posiciones decimales, por lo que no hay forma de representar exactamente 1/49 o sqrt(2) y los c√°lculos subsiguientes estar√°n ligeramente desviados. Podemos ver los valores exactos llamando a print() con el argumento digits1:\n\nprint(x, digits = 16)\n#&gt; [1] 0.9999999999999999 2.0000000000000004\n\nPuede ver por qu√© R por defecto redondea estos n√∫meros; realmente est√°n muy cerca de lo que esperas.\nAhora que ha visto por qu√© == est√° fallando, ¬øqu√© puede hacer al respecto? Una opci√≥n es usar dplyr::near() que ignora las peque√±as diferencias:\n\nnear(x, c(1, 2))\n#&gt; [1] TRUE TRUE\n\n\n12.2.2 Valores faltantes\nLos valores faltantes representan lo desconocido, por lo que son ‚Äúcontagiosos‚Äù: casi cualquier operaci√≥n que involucre un valor desconocido tambi√©n ser√° desconocida:\n\nNA &gt; 5\n#&gt; [1] NA\n10 == NA\n#&gt; [1] NA\n\nEl resultado m√°s confuso es este:\n\nNA == NA\n#&gt; [1] NA\n\nEs m√°s f√°cil entender por qu√© esto es cierto si proporcionamos artificialmente un poco m√°s de contexto:\n\n# No sabemos cu√°ntos a√±os tiene Mar√≠a.\nedad_maria &lt;- NA\n\n# No sabemos cu√°ntos a√±os tiene Juan.\nedad_juan &lt;- NA\n\n# ¬øMar√≠a y Juan tienen la misma edad?\nedad_maria == edad_juan\n#&gt; [1] NA\n# ¬°No sabemos!\n\nEntonces, si desea encontrar todos los vuelos en los que falta dep_time, el siguiente c√≥digo no funciona porque dep_time == NA generar√° NA para cada fila, y filter() elimina autom√°ticamente los valores faltantes:\n\nflights |&gt; \n  filter(dep_time == NA)\n#&gt; # A tibble: 0 √ó 19\n#&gt; # ‚Ñπ 19 variables: year &lt;int&gt;, month &lt;int&gt;, day &lt;int&gt;, dep_time &lt;int&gt;,\n#&gt; #   sched_dep_time &lt;int&gt;, dep_delay &lt;dbl&gt;, arr_time &lt;int&gt;, ‚Ä¶\n\nEn su lugar, necesitaremos una nueva herramienta: is.na().\n\n12.2.3 is.na()\n\nis.na(x) funciona con cualquier tipo de vector y devuelve TRUE, TRUE, para los valores faltantes y FALSE, FALSE, para todo lo dem√°s:\n\nis.na(c(TRUE, NA, FALSE))\n#&gt; [1] FALSE  TRUE FALSE\nis.na(c(1, NA, 3))\n#&gt; [1] FALSE  TRUE FALSE\nis.na(c(\"a\", NA, \"b\"))\n#&gt; [1] FALSE  TRUE FALSE\n\nPodemos usar is.na() para encontrar todas las filas a las que les falta dep_time:\n\nflights |&gt; \n  filter(is.na(dep_time))\n#&gt; # A tibble: 8,255 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1       NA           1630        NA       NA           1815\n#&gt; 2  2013     1     1       NA           1935        NA       NA           2240\n#&gt; 3  2013     1     1       NA           1500        NA       NA           1825\n#&gt; 4  2013     1     1       NA            600        NA       NA            901\n#&gt; 5  2013     1     2       NA           1540        NA       NA           1747\n#&gt; 6  2013     1     2       NA           1620        NA       NA           1746\n#&gt; # ‚Ñπ 8,249 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nis.na() tambi√©n puede ser √∫til en arrange(). arrange() generalmente coloca todos los valores faltantes al final, pero puede anular este valor predeterminado ordenando primero por is.na():\n\nflights |&gt; \n  filter(month == 1, day == 1) |&gt; \n  arrange(dep_time)\n#&gt; # A tibble: 842 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 836 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nflights |&gt; \n  filter(month == 1, day == 1) |&gt; \n  arrange(desc(is.na(dep_time)), dep_time)\n#&gt; # A tibble: 842 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1       NA           1630        NA       NA           1815\n#&gt; 2  2013     1     1       NA           1935        NA       NA           2240\n#&gt; 3  2013     1     1       NA           1500        NA       NA           1825\n#&gt; 4  2013     1     1       NA            600        NA       NA            901\n#&gt; 5  2013     1     1      517            515         2      830            819\n#&gt; 6  2013     1     1      533            529         4      850            830\n#&gt; # ‚Ñπ 836 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nVolveremos para cubrir los valores faltantes con m√°s profundidad en Cap√≠tulo 18.\n\n12.2.4 Ejercicios\n\n¬øC√≥mo funciona dplyr::near()? Escribe near para ver el c√≥digo fuente. ¬øEs sqrt(2)^2 cerca de 2?\nUse mutate(), is.na() y count() juntos para describir c√≥mo se conectan los valores que faltan en dep_time, sched_dep_time y dep_delay.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Vectores l√≥gicos</span>"
    ]
  },
  {
    "objectID": "logicals.html#√°lgebra-booleana",
    "href": "logicals.html#√°lgebra-booleana",
    "title": "12¬† Vectores l√≥gicos",
    "section": "\n12.3 √Ålgebra booleana",
    "text": "12.3 √Ålgebra booleana\nUna vez que tenga varios vectores l√≥gicos, puede combinarlos usando √°lgebra booleana. En R, & es ‚Äúy‚Äù, | es ‚Äúo‚Äù, ! es ‚Äúno‚Äù, y xor() es exclusivo o 2. Por ejemplo, df |&gt; filter(!is.na(x)) encuentra todas las filas donde no falta x y df |&gt; filter(x &lt; -10 | x &gt; 0) encuentra todas las filas donde x es menor que -10 o mayor que 0. Figura¬†12.1 muestra el conjunto completo de operaciones booleanas y c√≥mo funcionan.\n\n\n\n\n\n\n\nFigura¬†12.1: El conjunto completo de operaciones booleanas. x es el c√≠rculo a la izquierda, y es el c√≠rculo de la derecha, y la regi√≥n sombreada muestra qu√© partes selecciona cada operador.\n\n\n\n\nAdem√°s de & y |, R tambi√©n tiene && y ||. ¬°No los use en funciones dplyr! Estos se denominan operadores de cortocircuito y solo devuelven un solo TRUE o FALSE. Son importantes para la programaci√≥n, no para la ciencia de datos.\n\n12.3.1 Valores Faltantes\nLas reglas para los valores faltantes en el √°lgebra booleana son un poco dif√≠ciles de explicar porque parecen inconsistentes a primera vista:\n\ndf &lt;- tibble(x = c(TRUE, FALSE, NA))\n\ndf |&gt; \n  mutate(\n    and = x & NA,\n    or = x | NA\n  )\n#&gt; # A tibble: 3 √ó 3\n#&gt;   x     and   or   \n#&gt;   &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt;\n#&gt; 1 TRUE  NA    TRUE \n#&gt; 2 FALSE FALSE NA   \n#&gt; 3 NA    NA    NA\n\nPara entender lo que est√° pasando, piense en NA | TRUE (NA o TRUE). Un valor faltante en un vector l√≥gico significa que el valor podr√≠a ser TRUE o FALSE. TRUE | TRUE y FALSE | TRUE son ambos TRUE porque al menos uno de ellos es TRUE. NA | TRUE tambi√©n debe ser TRUE porque NA puede ser TRUE o FALSE. Sin embargo NA | FALSE es FALSE porque NA puede ser TRUE o FALSE Se aplica un razonamiento similar con NA & FALSE.\n\n12.3.2 Orden de operaciones\nTenga en cuenta que el orden de las operaciones no funciona como en ingl√©s. Tome el siguiente c√≥digo que encuentra todos los vuelos que salieron en noviembre o diciembre:\n\nflights |&gt; \n   filter(month == 11 | month == 12)\n\nEs posible que tenga la tentaci√≥n de escribirlo como dir√≠a en ingl√©s: ‚ÄúBuscar todos los vuelos que partieron en noviembre o diciembre‚Äù.:\n\nflights |&gt; \n   filter(month == 11 | 12)\n#&gt; # A tibble: 336,776 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      544            545        -1     1004           1022\n#&gt; 5  2013     1     1      554            600        -6      812            837\n#&gt; 6  2013     1     1      554            558        -4      740            728\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nEste c√≥digo no da error, pero tampoco parece haber funcionado. ¬øQu√© est√° sucediendo? Aqu√≠, R primero eval√∫a month == 11 creando un vector l√≥gico, al que llamamos nov. Calcula nov | 12. Cuando usa un n√∫mero con un operador l√≥gico, convierte todo menos 0 en TRUE, por lo que esto es equivalente a nov | TRUE que siempre ser√° TRUE, por lo que se seleccionar√°n todas las filas:\n\nflights |&gt; \n  mutate(\n    nov = month == 11,\n    final = nov | 12,\n    .keep = \"used\"\n  )\n#&gt; # A tibble: 336,776 √ó 3\n#&gt;   month nov   final\n#&gt;   &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt;\n#&gt; 1     1 FALSE TRUE \n#&gt; 2     1 FALSE TRUE \n#&gt; 3     1 FALSE TRUE \n#&gt; 4     1 FALSE TRUE \n#&gt; 5     1 FALSE TRUE \n#&gt; 6     1 FALSE TRUE \n#&gt; # ‚Ñπ 336,770 more rows\n\n\n12.3.3 %in%\n\nUna manera f√°cil de evitar el problema de poner tus ==s y |s en el orden correcto es usar %in%. x %in% y devuelve un vector l√≥gico de la misma longitud que x que es TRUE cada vez que un valor en x est√° en cualquier parte de y.\n\n1:12 %in% c(1, 5, 11)\n#&gt;  [1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\nletters[1:10] %in% c(\"a\", \"e\", \"i\", \"o\", \"u\")\n#&gt;  [1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE\n\nEntonces, para encontrar todos los vuelos en noviembre y diciembre, podr√≠amos escribir:\n\nflights |&gt; \n  filter(month %in% c(11, 12))\n\nTenga en cuenta que %in% obedece reglas diferentes para NA y ==, ya que NA %in% NA es TRUE.\n\nc(1, 2, NA) == NA\n#&gt; [1] NA NA NA\nc(1, 2, NA) %in% NA\n#&gt; [1] FALSE FALSE  TRUE\n\nEsto puede ser un atajo √∫til:\n\nflights |&gt; \n  filter(dep_time %in% c(NA, 0800))\n#&gt; # A tibble: 8,803 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      800            800         0     1022           1014\n#&gt; 2  2013     1     1      800            810       -10      949            955\n#&gt; 3  2013     1     1       NA           1630        NA       NA           1815\n#&gt; 4  2013     1     1       NA           1935        NA       NA           2240\n#&gt; 5  2013     1     1       NA           1500        NA       NA           1825\n#&gt; 6  2013     1     1       NA            600        NA       NA            901\n#&gt; # ‚Ñπ 8,797 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\n\n12.3.4 Ejercicios\n\nEncuentre todos los vuelos en los que falte arr_delay pero no dep_delay. Encuentre todos los vuelos en los que no falten ni arr_time ni sched_arr_time, pero s√≠ arr_delay.\n¬øA cu√°ntos vuelos les falta dep_time? ¬øQu√© otras variables faltan en estas filas? ¬øQu√© podr√≠an representar estas filas?\nSuponiendo que la falta de dep_time implica que se cancel√≥ un vuelo, mire la cantidad de vuelos cancelados por d√≠a. ¬øHay un patr√≥n? ¬øExiste una conexi√≥n entre la proporci√≥n de vuelos cancelados y el retraso promedio de los vuelos no cancelados?",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Vectores l√≥gicos</span>"
    ]
  },
  {
    "objectID": "logicals.html#sec-logical-summaries",
    "href": "logicals.html#sec-logical-summaries",
    "title": "12¬† Vectores l√≥gicos",
    "section": "\n12.4 Res√∫menes",
    "text": "12.4 Res√∫menes\nLas siguientes secciones describen algunas t√©cnicas √∫tiles para resumir vectores l√≥gicos. Adem√°s de funciones que solo funcionan espec√≠ficamente con vectores l√≥gicos, tambi√©n puede usar funciones que funcionan con vectores num√©ricos.\n\n12.4.1 Res√∫menes l√≥gicos\nHay dos res√∫menes l√≥gicos principales: any() y all(). any(x) es el equivalente de |; devolver√° TRUE si hay alg√∫n TRUE en x. all(x) es equivalente a &; devolver√° TRUE solo si todos los valores de x son TRUE. Como casi todas las funciones de resumen, puede hacer que los valores faltantes desaparezcan con na.rm = TRUE.\nPor ejemplo, podr√≠amos usar all() y any() para averiguar si todos los vuelos se retrasaron a la salida como m√°ximo una hora o si alg√∫n vuelo se retras√≥ a la llegada cinco horas o m√°s. Y usar group_by() nos permite hacer eso por d√≠a:\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    all_delayed = all(dep_delay &lt;= 60, na.rm = TRUE),\n    any_long_delay = any(arr_delay &gt;= 300, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 √ó 5\n#&gt;    year month   day all_delayed any_long_delay\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt;       &lt;lgl&gt;         \n#&gt; 1  2013     1     1 FALSE       TRUE          \n#&gt; 2  2013     1     2 FALSE       TRUE          \n#&gt; 3  2013     1     3 FALSE       FALSE         \n#&gt; 4  2013     1     4 FALSE       FALSE         \n#&gt; 5  2013     1     5 FALSE       TRUE          \n#&gt; 6  2013     1     6 FALSE       FALSE         \n#&gt; # ‚Ñπ 359 more rows\n\nEn la mayor√≠a de los casos, sin embargo, any() y all() son un poco toscos, y ser√≠a bueno poder obtener un poco m√°s de detalles sobre cu√°ntos valores son TRUE o FALSE. Eso nos lleva a los res√∫menes num√©ricos.\n\n12.4.2 Res√∫menes num√©ricos de vectores l√≥gicos\nCuando usa un vector l√≥gico en un contexto num√©rico, TRUE se convierte en 1 y FALSE se convierte en 0. Esto hace que sum() y mean() sean muy √∫tiles con vectores l√≥gicos porque sum(x) da el n√∫mero de TRUEs y mean(x) da la proporci√≥n de TRUEs (porque mean() es simplemente sum() dividido por length()).\nEso, por ejemplo, nos permite ver la proporci√≥n de vuelos que se retrasaron a la salida como m√°ximo una hora y la cantidad de vuelos que se retrasaron a la llegada cinco horas o m√°s:\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    proportion_delayed = mean(dep_delay &lt;= 60, na.rm = TRUE),\n    count_long_delay = sum(arr_delay &gt;= 300, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 √ó 5\n#&gt;    year month   day proportion_delayed count_long_delay\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;              &lt;dbl&gt;            &lt;int&gt;\n#&gt; 1  2013     1     1              0.939                3\n#&gt; 2  2013     1     2              0.914                3\n#&gt; 3  2013     1     3              0.941                0\n#&gt; 4  2013     1     4              0.953                0\n#&gt; 5  2013     1     5              0.964                1\n#&gt; 6  2013     1     6              0.959                0\n#&gt; # ‚Ñπ 359 more rows\n\n\n12.4.3 Subconjunto l√≥gico\nHay un uso final para los vectores l√≥gicos en los res√∫menes: puede usar un vector l√≥gico para filtrar una sola variable a un subconjunto de inter√©s. Esto hace uso del operador base [ (subconjunto pronunciado), sobre el que obtendr√° m√°s informaci√≥n en Secci√≥n 27.2.\nImagine que quisi√©ramos ver el retraso promedio solo para los vuelos que realmente se retrasaron. Una forma de hacerlo ser√≠a filtrar primero los vuelos y luego calcular el retraso promedio:\n\nflights |&gt; \n  filter(arr_delay &gt; 0) |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    behind = mean(arr_delay),\n    n = n(),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 √ó 5\n#&gt;    year month   day behind     n\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt; &lt;int&gt;\n#&gt; 1  2013     1     1   32.5   461\n#&gt; 2  2013     1     2   32.0   535\n#&gt; 3  2013     1     3   27.7   460\n#&gt; 4  2013     1     4   28.3   297\n#&gt; 5  2013     1     5   22.6   238\n#&gt; 6  2013     1     6   24.4   381\n#&gt; # ‚Ñπ 359 more rows\n\nEsto funciona, pero ¬øy si tambi√©n quisi√©ramos calcular el retraso promedio de los vuelos que llegaron temprano? Tendr√≠amos que realizar un paso de filtro por separado y luego descubrir c√≥mo combinar los dos marcos de datos juntos [^ l√≥gicos-3]. En su lugar, podr√≠a usar [ para realizar un filtrado en l√≠nea: arr_delay[arr_delay &gt; 0] generar√° solo los retrasos de llegada positivos.\nEsto lleva a:\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    behind = mean(arr_delay[arr_delay &gt; 0], na.rm = TRUE),\n    ahead = mean(arr_delay[arr_delay &lt; 0], na.rm = TRUE),\n    n = n(),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 √ó 6\n#&gt;    year month   day behind ahead     n\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1  2013     1     1   32.5 -12.5   842\n#&gt; 2  2013     1     2   32.0 -14.3   943\n#&gt; 3  2013     1     3   27.7 -18.2   914\n#&gt; 4  2013     1     4   28.3 -17.0   915\n#&gt; 5  2013     1     5   22.6 -14.0   720\n#&gt; 6  2013     1     6   24.4 -13.6   832\n#&gt; # ‚Ñπ 359 more rows\n\nTambi√©n tenga en cuenta la diferencia en el tama√±o del grupo: en el primer fragmento n() da el n√∫mero de vuelos retrasados por d√≠a; en el segundo, n() da el n√∫mero total de vuelos.\n\n12.4.4 Ejercicios\n\n¬øQu√© te dir√° sum(is.na(x))? ¬øQu√© tal mean(is.na(x))?\n¬øQu√© devuelve prod() cuando se aplica a un vector l√≥gico? ¬øA qu√© funci√≥n de resumen l√≥gico es equivalente? ¬øQu√© devuelve min() cuando se aplica a un vector l√≥gico? ¬øA qu√© funci√≥n de resumen l√≥gico es equivalente? Lea la documentaci√≥n y realice algunos experimentos.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Vectores l√≥gicos</span>"
    ]
  },
  {
    "objectID": "logicals.html#transformaciones-condicionales",
    "href": "logicals.html#transformaciones-condicionales",
    "title": "12¬† Vectores l√≥gicos",
    "section": "\n12.5 Transformaciones condicionales",
    "text": "12.5 Transformaciones condicionales\nUna de las caracter√≠sticas m√°s poderosas de los vectores l√≥gicos es su uso para transformaciones condicionales, es decir, hacer una cosa para la condici√≥n x y algo diferente para la condici√≥n y. Hay dos herramientas importantes para esto: if_else() y case_when().\n\n12.5.1 if_else()\n\nSi quiere usar un valor cuando una condici√≥n es TRUE y otro valor cuando es FALSE, puede usar dplyr::if_else()3. Siempre usar√°s los tres primeros argumentos de if_else(). El primer argumento, condition, es un vector l√≥gico, el segundo, true, da la salida cuando la condici√≥n es verdadera, y el tercero, false, da la salida si la condici√≥n es falsa.\nComencemos con un ejemplo simple de etiquetar un vector num√©rico como ‚Äú+ve‚Äù (positivo) o ‚Äú-ve‚Äù (negativo):\n\nx &lt;- c(-3:3, NA)\nif_else(x &gt; 0, \"+ve\", \"-ve\")\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"-ve\" \"+ve\" \"+ve\" \"+ve\" NA\n\nHay un cuarto argumento opcional, missing que se usar√° si la entrada es NA:\n\nif_else(x &gt; 0, \"+ve\", \"-ve\", \"???\")\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"-ve\" \"+ve\" \"+ve\" \"+ve\" \"???\"\n\nTambi√©n puede usar vectores para los argumentos true y false. Por ejemplo, esto nos permite crear una implementaci√≥n m√≠nima de abs():\n\nif_else(x &lt; 0, -x, x)\n#&gt; [1]  3  2  1  0  1  2  3 NA\n\nHasta ahora, todos los argumentos han usado los mismos vectores, pero, por supuesto, puede mezclarlos y combinarlos. Por ejemplo, podr√≠a implementar una versi√≥n simple de coalesce() como esta:\n\nx1 &lt;- c(NA, 1, 2, NA)\ny1 &lt;- c(3, NA, 4, 6)\nif_else(is.na(x1), y1, x1)\n#&gt; [1] 3 1 2 6\n\nEs posible que haya notado una peque√±a infelicidad en nuestro ejemplo de etiquetado anterior: cero no es ni positivo ni negativo. Podr√≠amos resolver esto agregando un if_else() adicional:\n\nif_else(x == 0, \"0\", if_else(x &lt; 0, \"-ve\", \"+ve\"), \"???\")\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"0\"   \"+ve\" \"+ve\" \"+ve\" \"???\"\n\nEsto ya es un poco dif√≠cil de leer, y puedes imaginar que solo ser√≠a m√°s dif√≠cil si tuvieras m√°s condiciones. En su lugar, puede cambiar a dplyr::case_when().\n\n12.5.2 case_when()\n\ncase_when() de dplyr est√° inspirado en la declaraci√≥n CASE de SQL y proporciona una forma flexible de realizar diferentes c√°lculos para diferentes condiciones. Tiene una sintaxis especial que, lamentablemente, no se parece a nada que vayas a usar en tidyverse. Toma pares que parecen condition ~ output. condition debe ser un vector l√≥gico; cuando es TRUE, se usar√° output.\nEsto significa que podr√≠amos recrear nuestro anterior if_else() anidado de la siguiente manera:\n\nx &lt;- c(-3:3, NA)\ncase_when(\n  x == 0   ~ \"0\",\n  x &lt; 0    ~ \"-ve\", \n  x &gt; 0    ~ \"+ve\",\n  is.na(x) ~ \"???\"\n)\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"0\"   \"+ve\" \"+ve\" \"+ve\" \"???\"\n\nEsto es m√°s c√≥digo, pero tambi√©n es m√°s expl√≠cito.\nPara explicar c√≥mo funciona case_when(), exploremos algunos casos m√°s simples. Si ninguno de los casos coincide, la salida obtiene un NA:\n\ncase_when(\n  x &lt; 0 ~ \"-ve\",\n  x &gt; 0 ~ \"+ve\"\n)\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" NA    \"+ve\" \"+ve\" \"+ve\" NA\n\nUse .default si desea crear un valor catch all ‚Äúpredeterminado‚Äù:\n\ncase_when(\n  x &lt; 0 ~ \"-ve\",\n  x &gt; 0 ~ \"+ve\",\n  .default = \"???\"\n)\n#&gt; [1] \"-ve\" \"-ve\" \"-ve\" \"???\" \"+ve\" \"+ve\" \"+ve\" \"???\"\n\nY tenga en cuenta que si coinciden varias condiciones, solo se utilizar√° la primera:\n\ncase_when(\n  x &gt; 0 ~ \"+ve\",\n  x &gt; 2 ~ \"big\"\n)\n#&gt; [1] NA    NA    NA    NA    \"+ve\" \"+ve\" \"+ve\" NA\n\nAl igual que con if_else(), puede usar variables en ambos lados de ~ y puede mezclar y combinar variables seg√∫n sea necesario para su problema. Por ejemplo, podr√≠amos usar case_when() para proporcionar algunas etiquetas legibles por humanos para el retraso de llegada:\n\nflights |&gt; \n  mutate(\n    status = case_when(\n      is.na(arr_delay)      ~ \"cancelado\",\n      arr_delay &lt; -30       ~ \"muy temprano\",\n      arr_delay &lt; -15       ~ \"temprano\",\n      abs(arr_delay) &lt;= 15  ~ \"a tiempo\",\n      arr_delay &lt; 60        ~ \"tarde\",\n      arr_delay &lt; Inf       ~ \"muy tarde\",\n    ),\n    .keep = \"used\"\n  )\n#&gt; # A tibble: 336,776 √ó 2\n#&gt;   arr_delay status  \n#&gt;       &lt;dbl&gt; &lt;chr&gt;   \n#&gt; 1        11 a tiempo\n#&gt; 2        20 tarde   \n#&gt; 3        33 tarde   \n#&gt; 4       -18 temprano\n#&gt; 5       -25 temprano\n#&gt; 6        12 a tiempo\n#&gt; # ‚Ñπ 336,770 more rows\n\nTenga cuidado al escribir este tipo de declaraciones complejas case_when(); mis primeros dos intentos usaron una combinaci√≥n de &lt; y &gt; y segu√≠ creando accidentalmente condiciones superpuestas.\n\n12.5.3 Tipos compatibles\nTenga en cuenta que tanto if_else() como case_when() requieren tipos compatibles en la salida. Si no son compatibles, ver√° errores como este:\n\nif_else(TRUE, \"a\", 1)\n#&gt; Error in `if_else()`:\n#&gt; ! Can't combine `true` &lt;character&gt; and `false` &lt;double&gt;.\n\ncase_when(\n  x &lt; -1 ~ TRUE,  \n  x &gt; 0  ~ now()\n)\n#&gt; Error in `case_when()`:\n#&gt; ! Can't combine `..1 (right)` &lt;logical&gt; and `..2 (right)` &lt;datetime&lt;local&gt;&gt;.\n\nEn general, relativamente pocos tipos son compatibles, porque la conversi√≥n autom√°tica de un tipo de vector a otro es una fuente com√∫n de errores. Estos son los casos m√°s importantes que son compatibles:\n\nLos vectores num√©ricos y l√≥gicos son compatibles, como discutimos en Secci√≥n 12.4.2.\nLas cadenas y los factores (Cap√≠tulo 16) son compatibles, porque puede pensar en un factor como una cadena con un conjunto restringido de valores.\nLas fechas y las fechas y horas, de las que hablaremos en Cap√≠tulo 17, son compatibles porque puede pensar en una fecha como un caso especial de fecha y hora.\n\nNA, que t√©cnicamente es un vector l√≥gico, es compatible con todo porque cada vector tiene alguna forma de representar un valor faltante.\n\nNo esperamos que memorices estas reglas, pero deber√≠an convertirse en una segunda naturaleza con el tiempo porque se aplican de manera consistente en todo el tidyverse.\n\n12.5.4 Ejercicios\n\nUn n√∫mero es par si es divisible por dos, lo cual en R puedes averiguar con x %% 2 == 0. Usa este hecho y if_else() para determinar si cada n√∫mero entre 0 y 20 es par o impar.\nDado un vector de d√≠as como x &lt;- c(\"Lunes\", \"S√°bado\", \"Mi√©rcoles\"), use una instrucci√≥n if_else() para etiquetarlos como fines de semana o d√≠as de semana.\nUsa if_else() para calcular el valor absoluto de un vector num√©rico llamado x.\nEscriba una instrucci√≥n case_when() que use las columnas month y day de flights para etiquetar una selecci√≥n de d√≠as festivos importantes de EE. UU. (por ejemplo, A√±o Nuevo, 4 de julio, Acci√≥n de Gracias y Navidad). Primero cree una columna l√≥gica que sea TRUE o FALSE, y luego cree una columna de caracteres que d√© el nombre de la festividad o sea NA.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Vectores l√≥gicos</span>"
    ]
  },
  {
    "objectID": "logicals.html#resumen",
    "href": "logicals.html#resumen",
    "title": "12¬† Vectores l√≥gicos",
    "section": "\n12.6 Resumen",
    "text": "12.6 Resumen\nLa definici√≥n de un vector l√≥gico es simple porque cada valor debe ser TRUE, FALSE o NA. Pero los vectores l√≥gicos proporcionan una gran cantidad de posibilidades. En este cap√≠tulo, aprendi√≥ a crear vectores l√≥gicos con &gt;, &lt;, &lt;=, &gt;=, ==, != y is.na(), c√≥mo combinarlos con !, & y |, y c√≥mo resumirlos con any(), all(), sum() y mean(). Tambi√©n aprendiste las poderosas funciones if_else() y case_when() que te permiten devolver valores dependiendo del valor de un vector l√≥gico.\nVeremos vectores l√≥gicos una y otra vez en los siguientes cap√≠tulos. Por ejemplo, en Cap√≠tulo 14 aprender√° sobre str_detect(x, pattern) que devuelve un vector l√≥gico que es TRUE para los elementos de x que coinciden con el patr√≥n, pattern, y en Cap√≠tulo 17 crear√° vectores l√≥gicos a partir de la comparaci√≥n de fechas y horas. Pero por ahora, vamos a pasar al siguiente tipo de vector m√°s importante: los vectores num√©ricos.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Vectores l√≥gicos</span>"
    ]
  },
  {
    "objectID": "logicals.html#footnotes",
    "href": "logicals.html#footnotes",
    "title": "12¬† Vectores l√≥gicos",
    "section": "",
    "text": "R normalmente llama a print por usted (es decir, x es un atajo para print(x)), pero llamarlo expl√≠citamente es √∫til si desea proporcionar otros argumentos.‚Ü©Ô∏é\nEs decir, xor(x, y) es TRUE si x es TRUE, o y es TRUE, pero no ambos. As√≠ es como solemos usar ‚Äúo‚Äù en ingl√©s. ‚ÄúAmbos‚Äù no suele ser una respuesta aceptable a la pregunta ‚Äú¬øquieres un helado o un pastel?‚Äù.‚Ü©Ô∏é\nEl if_else() de dplyr es muy similar al ifelse() de base R. Hay dos ventajas principales de if_else() sobre ifelse(): puede elegir qu√© deber√≠a pasar con los valores faltantes, y es mucho m√°s probable que if_else() le d√© un error significativo si sus variables tienen tipos incompatibles.‚Ü©Ô∏é",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Vectores l√≥gicos</span>"
    ]
  },
  {
    "objectID": "numbers.html",
    "href": "numbers.html",
    "title": "13¬† N√∫meros",
    "section": "",
    "text": "13.1 Introducci√≥n\nLos vectores num√©ricos son la columna vertebral de la ciencia de datos y ya los ha usado varias veces anteriormente en el libro. Ahora es el momento de examinar sistem√°ticamente lo que puede hacer con ellos en R, asegur√°ndose de estar bien situado para abordar cualquier problema futuro que involucre vectores num√©ricos.\nComenzaremos brind√°ndole un par de herramientas para hacer n√∫meros si tiene cadenas, y luego entraremos en un poco m√°s de detalle de count(). Luego nos sumergiremos en varias transformaciones num√©ricas que combinan bien con mutate(), incluidas transformaciones m√°s generales que se pueden aplicar a otros tipos de vectores, pero que a menudo se usan con vectores num√©ricos. Terminaremos cubriendo las funciones de resumen que combinan bien con summarize() y le mostraremos c√≥mo tambi√©n se pueden usar con mutate().",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>N√∫meros</span>"
    ]
  },
  {
    "objectID": "numbers.html#introducci√≥n",
    "href": "numbers.html#introducci√≥n",
    "title": "13¬† N√∫meros",
    "section": "",
    "text": "13.1.1 Requisitos previos\nEste cap√≠tulo utiliza principalmente funciones de base R, que est√°n disponibles sin cargar ning√∫n paquete. Pero a√∫n necesitamos el tidyverse porque usaremos estas funciones b√°sicas de R dentro de las funciones de tidyverse como mutate() y filter(). Como en el √∫ltimo cap√≠tulo, usaremos ejemplos reales de nycflights13, as√≠ como ejemplos de juguetes hechos con c() y tribble().\n\nlibrary(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>N√∫meros</span>"
    ]
  },
  {
    "objectID": "numbers.html#haciendo-√∫meros",
    "href": "numbers.html#haciendo-√∫meros",
    "title": "13¬† N√∫meros",
    "section": "\n13.2 Haciendo √∫meros",
    "text": "13.2 Haciendo √∫meros\nEn la mayor√≠a de los casos, obtendr√° n√∫meros ya registrados en uno de los tipos num√©ricos de R: entero o doble. En algunos casos, sin embargo, los encontrar√° como cadenas, posiblemente porque los cre√≥ al girar desde los encabezados de columna o porque algo sali√≥ mal en su proceso de importaci√≥n de datos.\nreadr proporciona dos funciones √∫tiles para analizar cadenas en n√∫meros: parse_double() y parse_number(). Usa parse_double() cuando tengas n√∫meros escritos como cadenas:\n\nx &lt;- c(\"1.2\", \"5.6\", \"1e3\")\nparse_double(x)\n#&gt; [1]    1.2    5.6 1000.0\n\nUsa parse_number() cuando la cadena contenga texto no num√©rico que quieras ignorar. Esto es particularmente √∫til para datos de moneda y porcentajes:\n\nx &lt;- c(\"$1,234\", \"USD 3,513\", \"59%\")\nparse_number(x)\n#&gt; [1] 1234 3513   59",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>N√∫meros</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-counts",
    "href": "numbers.html#sec-counts",
    "title": "13¬† N√∫meros",
    "section": "\n13.3 Contar",
    "text": "13.3 Contar\nEs sorprendente la cantidad de ciencia de datos que puede hacer con solo conteos y un poco de aritm√©tica b√°sica, por lo que dplyr se esfuerza por hacer que contar sea lo m√°s f√°cil posible con count(). Esta funci√≥n es excelente para realizar exploraciones y comprobaciones r√°pidas durante el an√°lisis:\n\nflights |&gt; count(dest)\n#&gt; # A tibble: 105 √ó 2\n#&gt;   dest      n\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 ABQ     254\n#&gt; 2 ACK     265\n#&gt; 3 ALB     439\n#&gt; 4 ANC       8\n#&gt; 5 ATL   17215\n#&gt; 6 AUS    2439\n#&gt; # ‚Ñπ 99 more rows\n\n(A pesar de los consejos en Cap√≠tulo 4, generalmente colocamos count() en una sola l√≠nea porque generalmente se usa en la consola para verificar r√°pidamente que un c√°lculo funciona como se esperaba.)\nSi desea ver los valores m√°s comunes, agregue sort = TRUE:\n\nflights |&gt; count(dest, sort = TRUE)\n#&gt; # A tibble: 105 √ó 2\n#&gt;   dest      n\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 ORD   17283\n#&gt; 2 ATL   17215\n#&gt; 3 LAX   16174\n#&gt; 4 BOS   15508\n#&gt; 5 MCO   14082\n#&gt; 6 CLT   14064\n#&gt; # ‚Ñπ 99 more rows\n\nY recuerda que si quieres ver todos los valores, puedes usar |&gt; View() o |&gt; print(n = Inf).\nPuede realizar el mismo c√°lculo ‚Äúa mano‚Äù con group_by(), summarize() y n(). Esto es √∫til porque le permite calcular otros res√∫menes al mismo tiempo:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(\n    n = n(),\n    delay = mean(arr_delay, na.rm = TRUE)\n  )\n#&gt; # A tibble: 105 √ó 3\n#&gt;   dest      n delay\n#&gt;   &lt;chr&gt; &lt;int&gt; &lt;dbl&gt;\n#&gt; 1 ABQ     254  4.38\n#&gt; 2 ACK     265  4.85\n#&gt; 3 ALB     439 14.4 \n#&gt; 4 ANC       8 -2.5 \n#&gt; 5 ATL   17215 11.3 \n#&gt; 6 AUS    2439  6.02\n#&gt; # ‚Ñπ 99 more rows\n\nn() es una funci√≥n de resumen especial que no toma ning√∫n argumento y en su lugar accede a informaci√≥n sobre el grupo ‚Äúactual‚Äù. Esto significa que solo funciona dentro de los verbos dplyr:\n\nn()\n#&gt; Error in `n()`:\n#&gt; ! Must only be used inside data-masking verbs like `mutate()`,\n#&gt;   `filter()`, and `group_by()`.\n\nHay un par de variantes de n() y count() que pueden resultarle √∫tiles:\n\n\nn_distinct(x) cuenta el n√∫mero de valores distintos (√∫nicos) de una o m√°s variables. Por ejemplo, podr√≠amos averiguar qu√© destinos son atendidos por la mayor√≠a de los transportistas:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(carriers = n_distinct(carrier)) |&gt; \n  arrange(desc(carriers))\n#&gt; # A tibble: 105 √ó 2\n#&gt;   dest  carriers\n#&gt;   &lt;chr&gt;    &lt;int&gt;\n#&gt; 1 ATL          7\n#&gt; 2 BOS          7\n#&gt; 3 CLT          7\n#&gt; 4 ORD          7\n#&gt; 5 TPA          7\n#&gt; 6 AUS          6\n#&gt; # ‚Ñπ 99 more rows\n\n\n\nUna cuenta ponderada es una suma. Por ejemplo, podr√≠a ‚Äúcontar‚Äù el n√∫mero de millas que vol√≥ cada avi√≥n:\n\nflights |&gt; \n  group_by(tailnum) |&gt; \n  summarize(miles = sum(distance))\n#&gt; # A tibble: 4,044 √ó 2\n#&gt;   tailnum  miles\n#&gt;   &lt;chr&gt;    &lt;dbl&gt;\n#&gt; 1 D942DN    3418\n#&gt; 2 N0EGMQ  250866\n#&gt; 3 N10156  115966\n#&gt; 4 N102UW   25722\n#&gt; 5 N103US   24619\n#&gt; 6 N104UW   25157\n#&gt; # ‚Ñπ 4,038 more rows\n\nLos recuentos ponderados son un problema com√∫n, por lo que count() tiene un argumento wt que hace lo mismo:\n\nflights |&gt; count(tailnum, wt = distance)\n\n\n\nPuede contar los valores perdidos combinando sum() y is.na(). En el conjunto de datos de flights, esto representa los vuelos que se cancelan:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(n_cancelled = sum(is.na(dep_time))) \n#&gt; # A tibble: 105 √ó 2\n#&gt;   dest  n_cancelled\n#&gt;   &lt;chr&gt;       &lt;int&gt;\n#&gt; 1 ABQ             0\n#&gt; 2 ACK             0\n#&gt; 3 ALB            20\n#&gt; 4 ANC             0\n#&gt; 5 ATL           317\n#&gt; 6 AUS            21\n#&gt; # ‚Ñπ 99 more rows\n\n\n\n\n13.3.1 Ejercicios\n\n¬øC√≥mo puedes usar count() para contar las el n√∫mero de filas con un valor faltante para una variable dada?\nExpanda las siguientes llamadas a count() para usar en su lugar group_by(), summarize() y arrange():\n\nflights |&gt; count(dest, sort = TRUE)\nflights |&gt; count(tailnum, wt = distance)",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>N√∫meros</span>"
    ]
  },
  {
    "objectID": "numbers.html#transformaciones-num√©ricas",
    "href": "numbers.html#transformaciones-num√©ricas",
    "title": "13¬† N√∫meros",
    "section": "\n13.4 Transformaciones num√©ricas",
    "text": "13.4 Transformaciones num√©ricas\nLas funciones de transformaci√≥n funcionan bien con mutate() porque su salida tiene la misma longitud que la entrada. La gran mayor√≠a de las funciones de transformaci√≥n ya est√°n integradas en la base R. No es pr√°ctico enumerarlos todos, por lo que esta secci√≥n mostrar√° los m√°s √∫tiles. Como ejemplo, aunque R proporciona todas las funciones trigonom√©tricas con las que podr√≠a so√±ar, no las enumeramos aqu√≠ porque rara vez se necesitan para la ciencia de datos.\n\n13.4.1 Reglas aritm√©ticas y de reciclaje.\nIntrodujimos los conceptos b√°sicos de aritm√©tica (+, -, *, /, ^) en Cap√≠tulo 2 y los hemos usado mucho desde entonces. Estas funciones no necesitan una gran cantidad de explicaci√≥n porque hacen lo que aprendiste en la escuela primaria. Pero necesitamos hablar brevemente sobre las reglas de reciclaje que determinan lo que sucede cuando los lados izquierdo y derecho tienen diferentes longitudes. Esto es importante para operaciones como flights |&gt; mutate(air_time = air_time / 60) porque hay 336.776 n√∫meros a la izquierda de / pero solo uno a la derecha.\nR maneja las longitudes que no coinciden reciclando o repitiendo el vector corto. Podemos ver esto en funcionamiento m√°s f√°cilmente si creamos algunos vectores fuera de un data frame:\n\nx &lt;- c(1, 2, 10, 20)\nx / 5\n#&gt; [1] 0.2 0.4 2.0 4.0\n# is shorthand for\nx / c(5, 5, 5, 5)\n#&gt; [1] 0.2 0.4 2.0 4.0\n\nEn general, solo desea reciclar n√∫meros individuales (es decir, vectores de longitud 1), pero R reciclar√° cualquier vector de longitud m√°s corta. Por lo general (pero no siempre) le da una advertencia si el vector m√°s largo no es un m√∫ltiplo del m√°s corto:\n\nx * c(1, 2)\n#&gt; [1]  1  4 10 40\nx * c(1, 2, 3)\n#&gt; Warning in x * c(1, 2, 3): longer object length is not a multiple of shorter\n#&gt; object length\n#&gt; [1]  1  4 30 20\n\nEstas reglas de reciclaje tambi√©n se aplican a las comparaciones l√≥gicas (==, &lt;, &lt;=, &gt;, &gt;=, !=) y pueden conducir a un resultado sorprendente si accidentalmente usa == en lugar de %in% y el data frame tiene un n√∫mero desafortunado de filas. Por ejemplo, tome este c√≥digo que intenta encontrar todos los vuelos en enero y febrero:\n\nflights |&gt; \n  filter(month == c(1, 2))\n#&gt; # A tibble: 25,977 √ó 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      542            540         2      923            850\n#&gt; 3  2013     1     1      554            600        -6      812            837\n#&gt; 4  2013     1     1      555            600        -5      913            854\n#&gt; 5  2013     1     1      557            600        -3      838            846\n#&gt; 6  2013     1     1      558            600        -2      849            851\n#&gt; # ‚Ñπ 25,971 more rows\n#&gt; # ‚Ñπ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\nEl c√≥digo se ejecuta sin errores, pero no devuelve lo que desea. Debido a las reglas de reciclaje, encuentra vuelos en filas impares que partieron en enero y vuelos en filas pares que partieron en febrero. Y, lamentablemente, no hay ninguna advertencia porque flights tiene un n√∫mero par de filas.\nPara protegerlo de este tipo de fallas silenciosas, la mayor√≠a de las funciones de tidyverse utilizan una forma m√°s estricta de reciclaje que solo recicla valores √∫nicos. Desafortunadamente, eso no ayuda aqu√≠, ni en muchos otros casos, porque el c√°lculo clave lo realiza la funci√≥n base R ==, no filter().\n\n13.4.2 M√≠nimo y m√°ximo\nLas funciones aritm√©ticas trabajan con pares de variables. Dos funciones estrechamente relacionadas son pmin() y pmax(), que cuando se les dan dos o m√°s variables devolver√°n el valor m√°s peque√±o o m√°s grande en cada fila:\n\ndf &lt;- tribble(\n  ~x, ~y,\n  1,  3,\n  5,  2,\n  7, NA,\n)\n\ndf |&gt; \n  mutate(\n    min = pmin(x, y, na.rm = TRUE),\n    max = pmax(x, y, na.rm = TRUE)\n  )\n#&gt; # A tibble: 3 √ó 4\n#&gt;       x     y   min   max\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     3     1     3\n#&gt; 2     5     2     2     5\n#&gt; 3     7    NA     7     7\n\nTenga en cuenta que estas son diferentes a las funciones de resumen min() y max() que toman m√∫ltiples observaciones y devuelven un solo valor. Puedes darte cuenta de que has usado la forma incorrecta cuando todos los m√≠nimos y todos los m√°ximos tienen el mismo valor:\n\ndf |&gt; \n  mutate(\n    min = min(x, y, na.rm = TRUE),\n    max = max(x, y, na.rm = TRUE)\n  )\n#&gt; # A tibble: 3 √ó 4\n#&gt;       x     y   min   max\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     3     1     7\n#&gt; 2     5     2     1     7\n#&gt; 3     7    NA     1     7\n\n\n13.4.3 Aritm√©tica modular\nLa aritm√©tica modular es el nombre t√©cnico del tipo de matem√°tica que hac√≠as antes de aprender sobre los lugares decimales, es decir, la divisi√≥n que produce un n√∫mero entero y un resto. En R, %/% realiza la divisi√≥n de enteros y %% calcula el resto:\n\n1:10 %/% 3\n#&gt;  [1] 0 0 1 1 1 2 2 2 3 3\n1:10 %% 3\n#&gt;  [1] 1 2 0 1 2 0 1 2 0 1\n\nLa aritm√©tica modular es √∫til para el conjunto de datos flights, porque podemos usarla para desempaquetar la variable sched_dep_time en hour y minute:\n\nflights |&gt; \n  mutate(\n    hour = sched_dep_time %/% 100,\n    minute = sched_dep_time %% 100,\n    .keep = \"used\"\n  )\n#&gt; # A tibble: 336,776 √ó 3\n#&gt;   sched_dep_time  hour minute\n#&gt;            &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1            515     5     15\n#&gt; 2            529     5     29\n#&gt; 3            540     5     40\n#&gt; 4            545     5     45\n#&gt; 5            600     6      0\n#&gt; 6            558     5     58\n#&gt; # ‚Ñπ 336,770 more rows\n\nPodemos combinar eso con el truco mean(is.na(x)) de Secci√≥n 12.4 para ver c√≥mo var√≠a la proporci√≥n de vuelos cancelados a lo largo del d√≠a. Los resultados se muestran en Figura¬†13.1.\n\nflights |&gt; \n  group_by(hour = sched_dep_time %/% 100) |&gt; \n  summarize(prop_cancelled = mean(is.na(dep_time)), n = n()) |&gt; \n  filter(hour &gt; 1) |&gt; \n  ggplot(aes(x = hour, y = prop_cancelled)) +\n  geom_line(color = \"grey50\") + \n  geom_point(aes(size = n))\n\n\n\n\n\n\nFigura¬†13.1: Un gr√°fico de l√≠neas con la hora de salida programada en el eje x y la proporci√≥n de vuelos cancelados en el eje y. Las cancelaciones parecen acumularse en el transcurso del d√≠a hasta las 8:00 p.¬†m., los vuelos muy tard√≠os son mucho menos probables de ser cancelado.\n\n\n\n\n\n13.4.4 Logaritmos\nLos logaritmos son una transformaci√≥n incre√≠blemente √∫til para manejar datos que var√≠an en varios √≥rdenes de magnitud y convertir el crecimiento exponencial en crecimiento lineal. En R, puede elegir entre tres logaritmos: log() (el logaritmo natural, base e), log2() (base 2) y log10() (base 10). Recomendamos usar log2() o log10(). log2() es f√°cil de interpretar porque una diferencia de 1 en la escala logar√≠tmica corresponde a duplicar la escala original y una diferencia de -1 corresponde a reducir a la mitad; mientras que log10() es f√°cil de transformar porque (por ejemplo) 3 es 10^3 = 1000. El inverso de log() es exp(); para calcular el inverso de log2() o log10() necesitar√° usar 2^ o 10^.\n\n13.4.5 Redondeo\nUsa round(x) para redondear un n√∫mero al entero m√°s cercano:\n\nround(123.456)\n#&gt; [1] 123\n\nPuede controlar la precisi√≥n del redondeo con el segundo argumento d√≠gitos, digits. round(x, digits) se redondea al 10^-n m√°s cercano, por lo que digits = 2 se redondea al 0,01 m√°s cercano. Esta definici√≥n es √∫til porque implica que round(x, -3) se redondear√° al millar m√°s cercano, lo que de hecho sucede:\n\nround(123.456, 2)  # dos d√≠gitos\n#&gt; [1] 123.46\nround(123.456, 1)  # un d√≠gito\n#&gt; [1] 123.5\nround(123.456, -1) # redondear a la decena m√°s cercana\n#&gt; [1] 120\nround(123.456, -2) # redondear a la centena m√°s cercana\n#&gt; [1] 100\n\nHay una rareza con round() que parece sorprendente a primera vista:\n\nround(c(1.5, 2.5))\n#&gt; [1] 2 2\n\nround() utiliza lo que se conoce como ‚Äúredondear la mitad a par‚Äù o redondeo bancario: si un n√∫mero est√° a medio camino entre dos enteros, se redondear√° al entero par. Esta es una buena estrategia porque mantiene el redondeo imparcial: la mitad de todos los 0,5 se redondean hacia arriba y la otra mitad hacia abajo.\nround() se empareja con floor() que siempre redondea hacia abajo y ceiling() que siempre redondea hacia arriba:\n\nx &lt;- 123.456\n\nfloor(x)\n#&gt; [1] 123\nceiling(x)\n#&gt; [1] 124\n\nEstas funciones no tienen un argumento d√≠gitos, digits, por lo que puede reducir, redondear y luego volver a aumentar:\n\n# Redondear hacia abajo a los dos d√≠gitos m√°s cercanos\nfloor(x / 0.01) * 0.01\n#&gt; [1] 123.45\n# Redondea hacia arriba a los dos d√≠gitos m√°s cercanos\nceiling(x / 0.01) * 0.01\n#&gt; [1] 123.46\n\nPuedes usar la misma t√©cnica si quieres round() a un m√∫ltiplo de alg√∫n otro n√∫mero:\n\n# Redondea al m√∫ltiplo m√°s cercano de 4\nround(x / 4) * 4\n#&gt; [1] 124\n\n# Redondear al 0,25 m√°s cercano\nround(x / 0.25) * 0.25\n#&gt; [1] 123.5\n\n\n13.4.6 Cortar n√∫meros en rangos\nUse cut()1 para dividir (tambi√©n conocido como bin) un vector num√©rico en cubos discretos:\n\nx &lt;- c(1, 2, 5, 10, 15, 20)\ncut(x, breaks = c(0, 5, 10, 15, 20))\n#&gt; [1] (0,5]   (0,5]   (0,5]   (5,10]  (10,15] (15,20]\n#&gt; Levels: (0,5] (5,10] (10,15] (15,20]\n\nLos cortes no necesitan estar espaciados uniformemente:\n\ncut(x, breaks = c(0, 5, 10, 100))\n#&gt; [1] (0,5]    (0,5]    (0,5]    (5,10]   (10,100] (10,100]\n#&gt; Levels: (0,5] (5,10] (10,100]\n\nOpcionalmente, puede proporcionar sus propias etiquetas, labels. Tenga en cuenta que debe haber una etiqueta, labels, menos que rupturas, breaks.\n\ncut(x, \n  breaks = c(0, 5, 10, 15, 20), \n  labels = c(\"sm\", \"md\", \"lg\", \"xl\")\n)\n#&gt; [1] sm sm sm md lg xl\n#&gt; Levels: sm md lg xl\n\nCualquier valor fuera del rango de las rupturas se convertir√° en NA:\n\ny &lt;- c(NA, -10, 5, 10, 30)\ncut(y, breaks = c(0, 5, 10, 15, 20))\n#&gt; [1] &lt;NA&gt;   &lt;NA&gt;   (0,5]  (5,10] &lt;NA&gt;  \n#&gt; Levels: (0,5] (5,10] (10,15] (15,20]\n\nConsulte la documentaci√≥n para ver otros argumentos √∫tiles como right e include.lowest, que controlan si los intervalos son [a, b) o (a, b] y si el intervalo m√°s bajo debe ser [a, b].\n\n13.4.7 Agregados acumulativos y rodantes\nBase R proporciona cumsum(), cumprod(), cummin(), cummax() para ejecutar, o acumular, sumas, productos, m√≠nimos y m√°ximos. dplyr proporciona cummean() para medios acumulativos. Las sumas acumulativas tienden a ser las m√°s importantes en la pr√°ctica:\n\nx &lt;- 1:10\ncumsum(x)\n#&gt;  [1]  1  3  6 10 15 21 28 36 45 55\n\nSi necesita agregados rodantes o deslizantes m√°s complejos, pruebe el paquete slider.\n\n13.4.8 Ejercicios\n\nExplique con palabras qu√© hace cada l√≠nea del c√≥digo utilizado para generar Figura¬†13.1.\n¬øQu√© funciones trigonom√©tricas proporciona R? Adivina algunos nombres y busca la documentaci√≥n. ¬øUsan grados o radianes?\n\nActualmente, dep_time y sched_dep_time son convenientes de ver, pero dif√≠ciles de calcular porque en realidad no son n√∫meros continuos. Puede ver el problema b√°sico ejecutando el siguiente c√≥digo: hay un intervalo entre cada hora.\n\nflights |&gt; \n  filter(month == 1, day == 1) |&gt; \n  ggplot(aes(x = sched_dep_time, y = dep_delay)) +\n  geom_point()\n\nConvi√©rtalos a una representaci√≥n m√°s veraz del tiempo (ya sean horas fraccionarias o minutos desde la medianoche).\n\nRedondea dep_time y arr_time a los cinco minutos m√°s cercanos.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>N√∫meros</span>"
    ]
  },
  {
    "objectID": "numbers.html#transformaciones-generales",
    "href": "numbers.html#transformaciones-generales",
    "title": "13¬† N√∫meros",
    "section": "\n13.5 Transformaciones generales",
    "text": "13.5 Transformaciones generales\nLas siguientes secciones describen algunas transformaciones generales que se usan a menudo con vectores num√©ricos, pero que se pueden aplicar a todos los dem√°s tipos de columnas.\n\n13.5.1 Rangos\ndplyr proporciona una serie de funciones de clasificaci√≥n inspiradas en SQL, pero siempre debe comenzar con dplyr::min_rank(). Utiliza el m√©todo t√≠pico para tratar los empates, p.ej., 1¬∞, 2¬∞, 2¬∞, 4¬∞.\n\nx &lt;- c(1, 2, 2, 3, 4, NA)\nmin_rank(x)\n#&gt; [1]  1  2  2  4  5 NA\n\nTenga en cuenta que los valores m√°s peque√±os obtienen los rangos m√°s bajos; usa desc(x) para dar a los valores m√°s grandes los rangos m√°s peque√±os:\n\nmin_rank(desc(x))\n#&gt; [1]  5  3  3  2  1 NA\n\nSi min_rank() no hace lo que necesita, observe las variantes dplyr::row_number(), dplyr::dense_rank(), dplyr::percent_rank() y dplyr:: cume_dist(). Consulte la documentaci√≥n para obtener m√°s informaci√≥n.\n\ndf &lt;- tibble(x = x)\ndf |&gt; \n  mutate(\n    row_number = row_number(x),\n    dense_rank = dense_rank(x),\n    percent_rank = percent_rank(x),\n    cume_dist = cume_dist(x)\n  )\n#&gt; # A tibble: 6 √ó 5\n#&gt;       x row_number dense_rank percent_rank cume_dist\n#&gt;   &lt;dbl&gt;      &lt;int&gt;      &lt;int&gt;        &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1     1          1          1         0          0.2\n#&gt; 2     2          2          2         0.25       0.6\n#&gt; 3     2          3          2         0.25       0.6\n#&gt; 4     3          4          3         0.75       0.8\n#&gt; 5     4          5          4         1          1  \n#&gt; 6    NA         NA         NA        NA         NA\n\nPuede lograr muchos de los mismos resultados eligiendo el argumento ties.method adecuado para basar el rank() de R; probablemente tambi√©n querr√° configurar na.last = \"keep\" para mantener NAs como NA.\nrow_number() tambi√©n se puede usar sin ning√∫n argumento dentro de un verbo dplyr. En este caso, dar√° el n√∫mero de la fila ‚Äúcurrent‚Äù. Cuando se combina con %% o %/%, esta puede ser una herramienta √∫til para dividir datos en grupos de tama√±o similar:\n\ndf &lt;- tibble(id = 1:10)\n\ndf |&gt; \n  mutate(\n    row0 = row_number() - 1,\n    three_groups = row0 %% 3,\n    three_in_each_group = row0 %/% 3\n  )\n#&gt; # A tibble: 10 √ó 4\n#&gt;      id  row0 three_groups three_in_each_group\n#&gt;   &lt;int&gt; &lt;dbl&gt;        &lt;dbl&gt;               &lt;dbl&gt;\n#&gt; 1     1     0            0                   0\n#&gt; 2     2     1            1                   0\n#&gt; 3     3     2            2                   0\n#&gt; 4     4     3            0                   1\n#&gt; 5     5     4            1                   1\n#&gt; 6     6     5            2                   1\n#&gt; # ‚Ñπ 4 more rows\n\n\n13.5.2 Compensaciones\ndplyr::lead() y dplyr::lag() le permiten referirse a los valores justo antes o justo despu√©s del valor ‚Äúactual‚Äù. Devuelven un vector de la misma longitud que la entrada, rellenado con NA al principio o al final:\n\nx &lt;- c(2, 5, 11, 11, 19, 35)\nlag(x)\n#&gt; [1] NA  2  5 11 11 19\nlead(x)\n#&gt; [1]  5 11 11 19 35 NA\n\n\n\nx - lag(x) te da la diferencia entre el valor actual y el anterior.\n\nx - lag(x)\n#&gt; [1] NA  3  6  0  8 16\n\n\n\nx == lag(x) le indica cu√°ndo cambia el valor actual.\n\nx == lag(x)\n#&gt; [1]    NA FALSE FALSE  TRUE FALSE FALSE\n\n\n\nPuede adelantarse o retrasarse en m√°s de una posici√≥n utilizando el segundo argumento, n.\n\n13.5.3 Identificadores consecutivos\nA veces desea iniciar un nuevo grupo cada vez que ocurre alg√∫n evento. Por ejemplo, cuando est√° mirando los datos del sitio web, es com√∫n querer dividir los eventos en sesiones, donde comienza una nueva sesi√≥n despu√©s de un intervalo de m√°s de x minutos desde la √∫ltima actividad. Por ejemplo, imagina que tienes las veces que alguien visit√≥ un sitio web:\n\nevents &lt;- tibble(\n  time = c(0, 1, 2, 3, 5, 10, 12, 15, 17, 19, 20, 27, 28, 30)\n)\n\nY calcul√≥ el tiempo entre cada evento y descubri√≥ si hay una brecha lo suficientemente grande como para calificar:\n\nevents &lt;- events |&gt; \n  mutate(\n    diff = time - lag(time, default = first(time)),\n    has_gap = diff &gt;= 5\n  )\nevents\n#&gt; # A tibble: 14 √ó 3\n#&gt;    time  diff has_gap\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;  \n#&gt; 1     0     0 FALSE  \n#&gt; 2     1     1 FALSE  \n#&gt; 3     2     1 FALSE  \n#&gt; 4     3     1 FALSE  \n#&gt; 5     5     2 FALSE  \n#&gt; 6    10     5 TRUE   \n#&gt; # ‚Ñπ 8 more rows\n\nPero, ¬øc√≥mo pasamos de ese vector l√≥gico a algo que podamos group_by()? cumsum(), de Secci√≥n 13.4.7, viene al rescate como brecha, es decir, has_gap es TRUE, incrementar√° group en uno (Secci√≥n 12.4.2):\n\nevents |&gt; mutate(\n  group = cumsum(has_gap)\n)\n#&gt; # A tibble: 14 √ó 4\n#&gt;    time  diff has_gap group\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;   &lt;int&gt;\n#&gt; 1     0     0 FALSE       0\n#&gt; 2     1     1 FALSE       0\n#&gt; 3     2     1 FALSE       0\n#&gt; 4     3     1 FALSE       0\n#&gt; 5     5     2 FALSE       0\n#&gt; 6    10     5 TRUE        1\n#&gt; # ‚Ñπ 8 more rows\n\nOtro enfoque para crear variables de agrupaci√≥n es consecutive_id(), que inicia un nuevo grupo cada vez que cambia uno de sus argumentos. Por ejemplo, inspirado por esta pregunta de stackoverflow, imagine que tiene un data frame con un mont√≥n de valores repetidos:\n\ndf &lt;- tibble(\n  x = c(\"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"d\", \"e\", \"a\", \"a\", \"b\", \"b\"),\n  y = c(1, 2, 3, 2, 4, 1, 3, 9, 4, 8, 10, 199)\n)\n\nSi desea conservar la primera fila de cada x repetida, puede usar group_by(), consecutive_id() y slice_head():\n\ndf |&gt; \n  group_by(id = consecutive_id(x)) |&gt; \n  slice_head(n = 1)\n#&gt; # A tibble: 7 √ó 3\n#&gt; # Groups:   id [7]\n#&gt;   x         y    id\n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 a         1     1\n#&gt; 2 b         2     2\n#&gt; 3 c         4     3\n#&gt; 4 d         3     4\n#&gt; 5 e         9     5\n#&gt; 6 a         4     6\n#&gt; # ‚Ñπ 1 more row\n\n\n13.5.4 Ejercicios\n\nEncuentre los 10 vuelos m√°s retrasados usando una funci√≥n de clasificaci√≥n. ¬øC√≥mo quieres manejar los empates? Lea atentamente la documentaci√≥n de min_rank().\n¬øQu√© avi√≥n (tailnum) tiene el peor r√©cord de puntualidad?\n¬øA qu√© hora del d√≠a debes volar si quieres evitar los retrasos tanto como sea posible?\n¬øQu√© hace flights |&gt; group_by(dest) |&gt; filter(row_number() &lt; 4)? ¬øQu√© hace flights |&gt; group_by(dest) |&gt; filter(row_number(dep_delay) &lt; 4)?\nPara cada destino, calcule el total de minutos de retraso. Para cada vuelo, calcule la proporci√≥n de la demora total para su destino.\n\nLos retrasos suelen tener una correlaci√≥n temporal: incluso una vez que se ha resuelto el problema que caus√≥ el retraso inicial, los vuelos posteriores se retrasan para permitir que salgan los vuelos anteriores. Utilizando lag(), explore c√≥mo se relaciona el retraso promedio de un vuelo durante una hora con el retraso promedio de la hora anterior.\n\nflights |&gt; \n  mutate(hour = dep_time %/% 100) |&gt; \n  group_by(year, month, day, hour) |&gt; \n  summarize(\n    dep_delay = mean(dep_delay, na.rm = TRUE),\n    n = n(),\n    .groups = \"drop\"\n  ) |&gt; \n  filter(n &gt; 5)\n\n\nMira cada destino. ¬øPuedes encontrar vuelos que sean sospechosamente r√°pidos (es decir, vuelos que representen un posible error de ingreso de datos)? Calcule el tiempo de aire de un vuelo en relaci√≥n con el vuelo m√°s corto a ese destino. ¬øQu√© vuelos se retrasaron m√°s en el aire?\nEncuentre todos los destinos en los que vuelan al menos dos transportistas. Utilice esos destinos para obtener una clasificaci√≥n relativa de los transportistas en funci√≥n de su desempe√±o para el mismo destino.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>N√∫meros</span>"
    ]
  },
  {
    "objectID": "numbers.html#res√∫menes-num√©ricos",
    "href": "numbers.html#res√∫menes-num√©ricos",
    "title": "13¬† N√∫meros",
    "section": "\n13.6 Res√∫menes num√©ricos",
    "text": "13.6 Res√∫menes num√©ricos\nEl solo uso de los recuentos, medios y sumas que ya hemos presentado puede ayudarlo mucho, pero R proporciona muchas otras funciones de resumen √∫tiles. Aqu√≠ hay una selecci√≥n que puede resultarle √∫til.\n\n13.6.1 Centrar\nHasta ahora, hemos usado principalmente mean() para resumir el centro de un vector de valores. Como hemos visto en Secci√≥n 3.6, debido a que la media es la suma dividida por el recuento, es sensible incluso a unos pocos valores inusualmente altos o bajos. Una alternativa es usar median(), que encuentra un valor que se encuentra en el ‚Äúmedio‚Äù del vector, es decir, el 50 % de los valores est√° por encima y el 50 % por debajo. Dependiendo de la forma de la distribuci√≥n de la variable que le interese, la media o la mediana pueden ser una mejor medida del centro. Por ejemplo, para distribuciones sim√©tricas generalmente informamos la media, mientras que para distribuciones asim√©tricas generalmente informamos la mediana.\nFigura¬†13.2 compara la media con la mediana del retraso de salida (en minutos) para cada destino. El retraso mediano siempre es menor que el retraso medio porque los vuelos a veces salen varias horas tarde, pero nunca salen varias horas antes.\n\nflights |&gt;\n  group_by(year, month, day) |&gt;\n  summarize(\n    mean = mean(dep_delay, na.rm = TRUE),\n    median = median(dep_delay, na.rm = TRUE),\n    n = n(),\n    .groups = \"drop\"\n  ) |&gt; \n  ggplot(aes(x = mean, y = median)) + \n  geom_abline(slope = 1, intercept = 0, color = \"white\", linewidth = 2) +\n  geom_point()\n\n\n\n\n\n\nFigura¬†13.2: Un diagrama de dispersi√≥n que muestra las diferencias de resumir el retraso de salida por d√≠a con la mediana en lugar de la media.\n\n\n\n\nTambi√©n puede preguntarse sobre la moda o el valor m√°s com√∫n. Este es un resumen que solo funciona bien para casos muy simples (por eso es posible que lo hayas aprendido en la escuela secundaria), pero no funciona bien para muchos conjuntos de datos reales. Si los datos son discretos, puede haber varios valores m√°s comunes, y si los datos son continuos, es posible que no haya un valor m√°s com√∫n porque cada valor es ligeramente diferente. Por estas razones, la moda tiende a no ser utilizada por los estad√≠sticos y no hay una funci√≥n de moda incluida en la base R2.\n\n13.6.2 M√≠nimo, m√°ximo y cuantiles\n¬øQu√© pasa si est√°s interesado en lugares que no sean el centro? min() y max() le dar√°n los valores m√°s grandes y m√°s peque√±os. Otra herramienta poderosa es quantile(), que es una generalizaci√≥n de la mediana: quantile(x, 0.25) encontrar√° el valor de x que es mayor que el 25% de los valores, quantile(x, 0.5) es equivalente a la mediana, y quantile(x, 0.95) encontrar√° el valor que es mayor que el 95% de los valores.\nPara los datos de flights, es posible que desee observar el cuantil del 95 % de los retrasos en lugar del m√°ximo, ya que ignorar√° el 5 % de la mayor√≠a de los vuelos retrasados, lo que puede ser bastante extremo.\n\nflights |&gt;\n  group_by(year, month, day) |&gt;\n  summarize(\n    max = max(dep_delay, na.rm = TRUE),\n    q95 = quantile(dep_delay, 0.95, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n#&gt; # A tibble: 365 √ó 5\n#&gt;    year month   day   max   q95\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  2013     1     1   853  70.1\n#&gt; 2  2013     1     2   379  85  \n#&gt; 3  2013     1     3   291  68  \n#&gt; 4  2013     1     4   288  60  \n#&gt; 5  2013     1     5   327  41  \n#&gt; 6  2013     1     6   202  51  \n#&gt; # ‚Ñπ 359 more rows\n\n\n13.6.3 Dispersi√≥n\nA veces, no est√° tan interesado en d√≥nde se encuentra la mayor parte de los datos, sino en c√≥mo se distribuyen. Dos res√∫menes de uso com√∫n son la desviaci√≥n est√°ndar, sd(x), y el rango intercuart√≠lico, IQR(). No explicaremos sd() aqu√≠ porque probablemente ya est√©s familiarizado con √©l, pero IQR() podr√≠a ser nuevo ‚Äî es quantile(x, 0.75) - quantile(x, 0.25) y le da el rango que contiene el 50% medio de los datos.\nPodemos usar esto para revelar una peque√±a rareza en los datos de vuelos. Es de esperar que la dispersi√≥n de la distancia entre el origen y el destino sea cero, ya que los aeropuertos siempre est√°n en el mismo lugar. Pero el siguiente c√≥digo hace que parezca que un aeropuerto, EGE, podr√≠a haberse mudado.\n\nflights |&gt; \n  group_by(origin, dest) |&gt; \n  summarize(\n    distance_iqr = IQR(distance), \n    n = n(),\n    .groups = \"drop\"\n  ) |&gt; \n  filter(distance_iqr &gt; 0)\n#&gt; # A tibble: 2 √ó 4\n#&gt;   origin dest  distance_iqr     n\n#&gt;   &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 EWR    EGE              1   110\n#&gt; 2 JFK    EGE              1   103\n\n\n13.6.4 Distribuciones\nVale la pena recordar que todas las estad√≠sticas de resumen descritas anteriormente son una forma de reducir la distribuci√≥n a un solo n√∫mero. Esto significa que son fundamentalmente reductivos, y si elige el resumen incorrecto, f√°cilmente puede pasar por alto diferencias importantes entre los grupos. Es por eso que siempre es una buena idea visualizar la distribuci√≥n antes de comprometerse con sus estad√≠sticas de resumen.\nFigura¬†13.3 muestra la distribuci√≥n general de los retrasos en las salidas. La distribuci√≥n est√° tan sesgada que tenemos que acercarnos para ver la mayor parte de los datos. Esto sugiere que es poco probable que la media sea un buen resumen y que preferir√≠amos la mediana en su lugar.\n\n\n\n\n\n\n\nFigura¬†13.3: (Izquierda) El histograma de los datos completos est√° extremadamente sesgado, lo que lo hace dif√≠cil obtener alg√∫n detalle. (Derecha) Acercamiento a retrasos de menos de dos horas hace posible ver lo que sucede con la mayor parte de la observaciones.\n\n\n\n\nTambi√©n es una buena idea verificar que las distribuciones de los subgrupos se parezcan al todo. En el gr√°fico siguiente se superponen 365 pol√≠gonos de frecuencia de dep_delay, uno para cada d√≠a. Las distribuciones parecen seguir un patr√≥n com√∫n, lo que sugiere que est√° bien usar el mismo resumen para cada d√≠a.\n\nflights |&gt;\n  filter(dep_delay &lt; 120) |&gt; \n  ggplot(aes(x = dep_delay, group = interaction(day, month))) + \n  geom_freqpoly(binwidth = 5, alpha = 1/5)\n\n\n\n\n\n\n\nNo tenga miedo de explorar sus propios res√∫menes personalizados espec√≠ficamente dise√±ados para los datos con los que est√° trabajando. En este caso, eso podr√≠a significar resumir por separado los vuelos que salieron temprano frente a los vuelos que salieron tarde, o dado que los valores est√°n muy sesgados, puede intentar una transformaci√≥n logar√≠tmica. Finalmente, no olvide lo que aprendi√≥ en Secci√≥n 3.6: siempre que cree res√∫menes num√©ricos, es una buena idea incluir el n√∫mero de observaciones en cada grupo.\n\n13.6.5 Posiciones\nHay un √∫ltimo tipo de resumen que es √∫til para los vectores num√©ricos, pero tambi√©n funciona con cualquier otro tipo de valor: extraer un valor en una posici√≥n espec√≠fica: primero(x), √∫ltimo(x) y nth(x, n).\nPor ejemplo, podemos encontrar la primera, quinta y la √∫ltima salida de cada d√≠a:\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  summarize(\n    first_dep = first(dep_time, na_rm = TRUE), \n    fifth_dep = nth(dep_time, 5, na_rm = TRUE),\n    last_dep = last(dep_time, na_rm = TRUE)\n  )\n#&gt; `summarise()` has grouped output by 'year', 'month'. You can override using\n#&gt; the `.groups` argument.\n#&gt; # A tibble: 365 √ó 6\n#&gt; # Groups:   year, month [12]\n#&gt;    year month   day first_dep fifth_dep last_dep\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;    &lt;int&gt;\n#&gt; 1  2013     1     1       517       554     2356\n#&gt; 2  2013     1     2        42       535     2354\n#&gt; 3  2013     1     3        32       520     2349\n#&gt; 4  2013     1     4        25       531     2358\n#&gt; 5  2013     1     5        14       534     2357\n#&gt; 6  2013     1     6        16       555     2355\n#&gt; # ‚Ñπ 359 more rows\n\n(NB: Debido a que las funciones dplyr usan _ para separar los componentes de la funci√≥n y los nombres de los argumentos, estas funciones usan na_rm en lugar de na.rm.)\nSi est√° familiarizado con [, al que volveremos en Secci√≥n 27.2, es posible que se pregunte si alguna vez necesitar√° estas funciones. Hay tres razones: el argumento default le permite proporcionar un valor predeterminado si la posici√≥n especificada no existe, el argumento order_by le permite anular localmente el orden de las filas y el argumento na_rm le permite eliminar los valores perdidos.\nLa extracci√≥n de valores en posiciones es complementaria al filtrado en rangos. El filtrado le brinda todas las variables, con cada observaci√≥n en una fila separada:\n\nflights |&gt; \n  group_by(year, month, day) |&gt; \n  mutate(r = min_rank(sched_dep_time)) |&gt; \n  filter(r %in% c(1, max(r)))\n#&gt; # A tibble: 1,195 √ó 20\n#&gt; # Groups:   year, month, day [365]\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1     2353           2359        -6      425            445\n#&gt; 3  2013     1     1     2353           2359        -6      418            442\n#&gt; 4  2013     1     1     2356           2359        -3      425            437\n#&gt; 5  2013     1     2       42           2359        43      518            442\n#&gt; 6  2013     1     2      458            500        -2      703            650\n#&gt; # ‚Ñπ 1,189 more rows\n#&gt; # ‚Ñπ 12 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ‚Ä¶\n\n\n13.6.6 Con mutate()\n\nComo sugieren los nombres, las funciones de resumen normalmente se combinan con summarize(). Sin embargo, debido a las reglas de reciclaje que discutimos en Secci√≥n 13.4.1, tambi√©n se pueden combinar de manera √∫til con mutate(), particularmente cuando desea realizar alg√∫n tipo de estandarizaci√≥n de grupo. Por ejemplo:\n\n\nx / sum(x) calcula la proporci√≥n de un total.\n\n(x - mean(x)) / sd(x) calcula una puntuaci√≥n Z (estandarizada a media 0 y sd 1).\n\n(x - min(x)) / (max(x) - min(x)) se estandariza al rango [0, 1].\n\nx / first(x) calcula un √≠ndice basado en la primera observaci√≥n.\n\n13.6.7 Ejercicios\n\nHaga una lluvia de ideas sobre al menos 5 formas diferentes de evaluar las caracter√≠sticas t√≠picas de retraso de un grupo de vuelos. ¬øCu√°ndo es √∫til mean()? ¬øCu√°ndo es √∫til median()? ¬øCu√°ndo podr√≠a querer usar otra cosa? ¬øDebe utilizar el retraso de llegada o el retraso de salida? ¬øPor qu√© querr√≠as usar datos de aviones?\n¬øQu√© destinos muestran la mayor variaci√≥n en la velocidad del aire?\nCrea una gr√°fica para explorar m√°s a fondo las aventuras de EGE. ¬øPuedes encontrar alguna evidencia de que el aeropuerto cambi√≥ de ubicaci√≥n? ¬øPuedes encontrar otra variable que pueda explicar la diferencia?",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>N√∫meros</span>"
    ]
  },
  {
    "objectID": "numbers.html#resumen",
    "href": "numbers.html#resumen",
    "title": "13¬† N√∫meros",
    "section": "\n13.7 Resumen",
    "text": "13.7 Resumen\nYa est√° familiarizado con muchas herramientas para trabajar con n√∫meros y, despu√©s de leer este cap√≠tulo, ahora sabe c√≥mo usarlas en R. Tambi√©n aprendi√≥ un pu√±ado de transformaciones generales √∫tiles que se aplican com√∫nmente, pero no exclusivamente, a vectores num√©ricos como rangos y compensaciones. Finalmente, trabaj√≥ en una serie de res√∫menes num√©ricos y discuti√≥ algunos de los desaf√≠os estad√≠sticos que debe considerar.\nEn los pr√≥ximos dos cap√≠tulos, nos sumergiremos en el trabajo con cadenas con el paquete stringr. Las cadenas son un gran tema, por lo que tienen dos cap√≠tulos, uno sobre los fundamentos de las cadenas y otro sobre las expresiones regulares.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>N√∫meros</span>"
    ]
  },
  {
    "objectID": "numbers.html#footnotes",
    "href": "numbers.html#footnotes",
    "title": "13¬† N√∫meros",
    "section": "",
    "text": "ggplot2 proporciona algunos ayudantes para casos comunes en cut_interval(), cut_number() y cut_width(). ggplot2 es un lugar ciertamente extra√±o para que vivan estas funciones, pero son √∫tiles como parte del c√°lculo del histograma y se escribieron antes de que existieran otras partes del tidyverse.‚Ü©Ô∏é\n¬°La funci√≥n mode() hace algo muy diferente!‚Ü©Ô∏é",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>N√∫meros</span>"
    ]
  },
  {
    "objectID": "strings.html",
    "href": "strings.html",
    "title": "14¬† Caracteres",
    "section": "",
    "text": "14.1 Introducci√≥n\nHasta ahora, ha usado un mont√≥n de cadenas de caracteres sin aprender mucho sobre los detalles. Ahora es el momento de sumergirse en ellas, aprender qu√© hace que las cadenas de caracteres funcionen y dominar algunas de las poderosas herramientas de manipulaci√≥n de caracteres que tiene a su disposici√≥n.\nComenzaremos con los detalles de la creaci√≥n de cadenas y vectores de caracteres. Luego se sumergir√° en la creaci√≥n de cadenas a partir de datos, luego lo contrario; extraer cadenas de datos. Luego hablaremos de las herramientas que funcionan con letras individuales. El cap√≠tulo finaliza con funciones que funcionan con letras individuales y una breve discusi√≥n sobre d√≥nde podr√≠an equivocarse sus expectativas del ingl√©s al trabajar con otros idiomas.\nSeguiremos trabajando con cadenas en el pr√≥ximo cap√≠tulo, donde aprender√° m√°s sobre el poder de las expresiones regulares.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Caracteres</span>"
    ]
  },
  {
    "objectID": "strings.html#introducci√≥n",
    "href": "strings.html#introducci√≥n",
    "title": "14¬† Caracteres",
    "section": "",
    "text": "14.1.1 Requisitos previos\nEn este cap√≠tulo, usaremos funciones del paquete stringr, que forma parte del n√∫cleo tidyverse. Tambi√©n usaremos los datos de babynames ya que proporciona algunas cadenas divertidas para manipular.\n\nlibrary(tidyverse)\nlibrary(babynames)\n\nPuede saber r√°pidamente cu√°ndo est√° usando una funci√≥n stringr porque todas las funciones stringr comienzan con str_. Esto es particularmente √∫til si usa RStudio porque escribir str_ activar√° el autocompletado, lo que le permitir√° refrescar su memoria de las funciones disponibles.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Caracteres</span>"
    ]
  },
  {
    "objectID": "strings.html#creando-una-cadena-de-caracteres",
    "href": "strings.html#creando-una-cadena-de-caracteres",
    "title": "14¬† Caracteres",
    "section": "\n14.2 Creando una cadena de caracteres",
    "text": "14.2 Creando una cadena de caracteres\nHemos creado cadenas de pasada anteriormente en el libro, pero no discutimos los detalles. En primer lugar, puede crear una cadena usando comillas simples (') o comillas dobles (\"). No hay diferencia en el comportamiento entre los dos, as√≠ que en aras de la coherencia, la gu√≠a de estilo de tidyverse recomienda usar \", a menos que la cadena contiene m√∫ltiples \".\n\nstring1 &lt;- \"Esta es una cadena de caracteres\"\nstring2 &lt;- 'Si quiero incluir una \"comilla\" dentro de una cadena, uso comillas simples'\n\nSi olvida cerrar una comilla, ver√° +, el indicador de continuaci√≥n:\n&gt; \"Esta es una cadena sin comillas de cierre\n+ \n+ \n+ AYUDA ESTOY ATRAPADO EN UNA CADENA\nSi esto le sucede y no sabe qu√© comilla cerrar, presione Escape para cancelar y vuelva a intentarlo.\n\n14.2.1 Escapadas\nPara incluir una comilla simple o doble literal en una cadena, puede usar \\ para ‚Äúescaparla‚Äù:\n\ndouble_quote &lt;- \"\\\"\" # o '\"'\nsingle_quote &lt;- '\\'' # o \"'\"\n\nEntonces, si desea incluir una barra invertida literal en su cadena, deber√° escapar: \"\\\\\":\n\nbackslash &lt;- \"\\\\\"\n\nTenga en cuenta que la representaci√≥n impresa de una cadena no es la misma que la cadena misma porque la representaci√≥n impresa muestra los escapes (en otras palabras, cuando imprime una cadena, puede copiar y pegar la salida para recrear esa cadena). Para ver el contenido sin procesar de la cadena, use str_view()1:\n\nx &lt;- c(single_quote, double_quote, backslash)\nx\n#&gt; [1] \"'\"  \"\\\"\" \"\\\\\"\n\nstr_view(x)\n#&gt; [1] ‚îÇ '\n#&gt; [2] ‚îÇ \"\n#&gt; [3] ‚îÇ \\\n\n\n14.2.2 Cadenas de caracteres sin procesar\nCrear una cadena con m√∫ltiples comillas o barras invertidas se vuelve confuso r√°pidamente. Para ilustrar el problema, creemos una cadena que contenga el contenido del bloque de c√≥digo donde definimos las variables double_quote y single_quote:\n\ntricky &lt;- \"double_quote &lt;- \\\"\\\\\\\"\\\" # o '\\\"'\nsingle_quote &lt;- '\\\\'' # o \\\"'\\\"\"\nstr_view(tricky)\n#&gt; [1] ‚îÇ double_quote &lt;- \"\\\"\" # o '\"'\n#&gt;     ‚îÇ single_quote &lt;- '\\'' # o \"'\"\n\n¬°Eso es un mont√≥n de barras invertidas! (Esto a veces se llama [s√≠ndrome del palillo inclinado] (https://en.wikipedia.org/wiki/Leaning_toothpick_syndrome).) Para eliminar el escape, puede usar una cadena de caracteres sin procesar2:\n\ntricky &lt;- r\"(double_quote &lt;- \"\\\"\" # or '\"'\nsingle_quote &lt;- '\\'' # or \"'\")\"\nstr_view(tricky)\n#&gt; [1] ‚îÇ double_quote &lt;- \"\\\"\" # or '\"'\n#&gt;     ‚îÇ single_quote &lt;- '\\'' # or \"'\"\n\nUna cadena sin procesar generalmente comienza con r\"( y termina con )\". Pero si su cadena contiene )\", puede usar r\"[]\" o r\"{}\", y si eso a√∫n no es suficiente, puede insertar cualquier n√∫mero de guiones para hacer los pares de apertura y cierre √∫nico, por ejemplo, r\"--()--\", r\"---()---\", etc. Las cadenas sin procesar son lo suficientemente flexibles para manejar cualquier texto.\n\n14.2.3 Otros caracteres especiales\nAdem√°s de \\\", \\' y \\\\, hay otros caracteres especiales que pueden ser √∫tiles. Los m√°s comunes son \\n, una nueva l√≠nea y \\t, tabulador. A veces tambi√©n ver√° cadenas que contienen escapes Unicode que comienzan con \\u o \\U. Esta es una forma de escribir caracteres no ingleses que funcionan en todos los sistemas. Puede ver la lista completa de otros caracteres especiales en ?Quote.\n\nx &lt;- c(\"one\\ntwo\", \"one\\ttwo\", \"\\u00b5\", \"\\U0001f604\")\nx\n#&gt; [1] \"one\\ntwo\" \"one\\ttwo\" \"¬µ\"        \"üòÑ\"\nstr_view(x)\n#&gt; [1] ‚îÇ one\n#&gt;     ‚îÇ two\n#&gt; [2] ‚îÇ one{\\t}two\n#&gt; [3] ‚îÇ ¬µ\n#&gt; [4] ‚îÇ üòÑ\n\nTenga en cuenta que str_view() usa llaves para las pesta√±as para que sean m√°s f√°ciles de detectar 3. Uno de los desaf√≠os de trabajar con texto es que hay una variedad de formas en que los espacios en blanco pueden terminar en el texto, por lo que este fondo lo ayuda a reconocer que algo extra√±o est√° sucediendo.\n\n14.2.4 Ejercicios\n\n\nCree cadenas que contengan los siguientes valores:\n\n√âl dijo: \"¬°Eso es incre√≠ble!\"\n\\a\\b\\c\\d\n\\\\\\\\\\\\\n\n\n\nCree la cadena en su sesi√≥n R e impr√≠mala. ¬øQu√© sucede con el especial ‚Äú\\u00a0‚Äù? ¬øC√≥mo lo muestra str_view()? ¬øPuedes googlear un poco para averiguar qu√© es este car√°cter especial?\n\nx &lt;- \"Esto\\u00a0es\\u00a0complicado\"",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Caracteres</span>"
    ]
  },
  {
    "objectID": "strings.html#crear-muchas-cadenas-de-caracteres-a-partir-de-datos",
    "href": "strings.html#crear-muchas-cadenas-de-caracteres-a-partir-de-datos",
    "title": "14¬† Caracteres",
    "section": "\n14.3 Crear muchas cadenas de caracteres a partir de datos",
    "text": "14.3 Crear muchas cadenas de caracteres a partir de datos\nAhora que ha aprendido los conceptos b√°sicos para crear una o dos cadenas ‚Äúa mano‚Äù, entraremos en los detalles de la creaci√≥n de cadenas a partir de otras cadenas. Esto lo ayudar√° a resolver el problema com√∫n en el que tiene un texto que escribi√≥ que desea combinar con cadenas de un data frame. Por ejemplo, puede combinar ‚ÄúHola‚Äù con una variable name para crear un saludo. Le mostraremos c√≥mo hacer esto con str_c() y str_glue() y c√≥mo puede usarlos con mutate(). Naturalmente, eso plantea la pregunta de qu√© funciones de stringr podr√≠a usar con summarize(), por lo que terminaremos esta secci√≥n con una discusi√≥n de str_flatten(), que es una funci√≥n de resumen para cadenas.\n\n14.3.1 str_c()\n\nstr_c() toma cualquier n√∫mero de vectores como argumentos y devuelve un vector de caracteres:\n\nstr_c(\"x\", \"y\")\n#&gt; [1] \"xy\"\nstr_c(\"x\", \"y\", \"z\")\n#&gt; [1] \"xyz\"\nstr_c(\"Hola \", c(\"Juan\", \"Susana\"))\n#&gt; [1] \"Hola Juan\"   \"Hola Susana\"\n\nstr_c() es muy similar a la base paste0(), pero est√° dise√±ado para usarse con mutate() obedeciendo las reglas habituales de tidyverse para reciclar y propagar valores faltantes:\n\ndf &lt;- tibble(name = c(\"Flora\", \"David\", \"Terra\", NA))\ndf |&gt; mutate(greeting = str_c(\"Hi \", name, \"!\"))\n#&gt; # A tibble: 4 √ó 2\n#&gt;   name  greeting \n#&gt;   &lt;chr&gt; &lt;chr&gt;    \n#&gt; 1 Flora Hi Flora!\n#&gt; 2 David Hi David!\n#&gt; 3 Terra Hi Terra!\n#&gt; 4 &lt;NA&gt;  &lt;NA&gt;\n\nSi desea que los valores faltantes se muestren de otra manera, use coalesce() para reemplazarlos. Dependiendo de lo que quieras, puedes usarlo dentro o fuera de str_c():\n\ndf |&gt; \n  mutate(\n    greeting1 = str_c(\"Hi \", coalesce(name, \"you\"), \"!\"),\n    greeting2 = coalesce(str_c(\"Hi \", name, \"!\"), \"Hi!\")\n  )\n#&gt; # A tibble: 4 √ó 3\n#&gt;   name  greeting1 greeting2\n#&gt;   &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;    \n#&gt; 1 Flora Hi Flora! Hi Flora!\n#&gt; 2 David Hi David! Hi David!\n#&gt; 3 Terra Hi Terra! Hi Terra!\n#&gt; 4 &lt;NA&gt;  Hi you!   Hi!\n\n\n14.3.2 str_glue()\n\nSi est√° mezclando muchas cadenas fijas y variables con str_c(), notar√° que escribe muchas \"s, lo que dificulta ver el objetivo general del c√≥digo. Un enfoque alternativo es proporcionado por el paquete glue a trav√©s de str_glue()4. Le das una sola cadena que tiene una caracter√≠stica especial: cualquier cosa dentro de {} se evaluar√° como que est√° fuera de las comillas:\n\ndf |&gt; mutate(greeting = str_glue(\"Hola {name}!\"))\n#&gt; # A tibble: 4 √ó 2\n#&gt;   name  greeting   \n#&gt;   &lt;chr&gt; &lt;glue&gt;     \n#&gt; 1 Flora Hola Flora!\n#&gt; 2 David Hola David!\n#&gt; 3 Terra Hola Terra!\n#&gt; 4 &lt;NA&gt;  Hola NA!\n\nComo puede ver, str_glue() actualmente convierte los valores faltantes a la cadena \"NA\", desafortunadamente, lo que lo hace inconsistente con str_c().\nTambi√©n puede preguntarse qu√© sucede si necesita incluir un { o } regular en su cadena. Est√°s en el camino correcto si crees que necesitar√°s escapar de alguna manera. El truco es que el pegamento usa una t√©cnica de escape ligeramente diferente; en lugar de anteponer un car√°cter especial como \\, se duplican los caracteres especiales:\n\ndf |&gt; mutate(greeting = str_glue(\"{{Hola {name}!}}\"))\n#&gt; # A tibble: 4 √ó 2\n#&gt;   name  greeting     \n#&gt;   &lt;chr&gt; &lt;glue&gt;       \n#&gt; 1 Flora {Hola Flora!}\n#&gt; 2 David {Hola David!}\n#&gt; 3 Terra {Hola Terra!}\n#&gt; 4 &lt;NA&gt;  {Hola NA!}\n\n\n14.3.3 str_flatten()\n\nstr_c() y str_glue() funciona bien con mutate() porque su salida tiene la misma longitud que sus entradas. ¬øQu√© pasa si quieres una funci√≥n que funcione bien con summarize(), es decir, algo que siempre devuelva una sola cadena? Ese es el trabajo de str_flatten()5: toma un vector de caracteres y combina cada elemento del vector en una sola cadena:\n\nstr_flatten(c(\"x\", \"y\", \"z\"))\n#&gt; [1] \"xyz\"\nstr_flatten(c(\"x\", \"y\", \"z\"), \", \")\n#&gt; [1] \"x, y, z\"\nstr_flatten(c(\"x\", \"y\", \"z\"), \", \", last = \", and \")\n#&gt; [1] \"x, y, and z\"\n\nEsto hace que funcione bien con summarize():\n\ndf &lt;- tribble(\n  ~ name, ~ fruit,\n  \"Carmen\", \"banana\",\n  \"Carmen\", \"apple\",\n  \"Marvin\", \"nectarine\",\n  \"Terence\", \"cantaloupe\",\n  \"Terence\", \"papaya\",\n  \"Terence\", \"mandarin\"\n)\ndf |&gt;\n  group_by(name) |&gt; \n  summarize(fruits = str_flatten(fruit, \", \"))\n#&gt; # A tibble: 3 √ó 2\n#&gt;   name    fruits                      \n#&gt;   &lt;chr&gt;   &lt;chr&gt;                       \n#&gt; 1 Carmen  banana, apple               \n#&gt; 2 Marvin  nectarine                   \n#&gt; 3 Terence cantaloupe, papaya, mandarin\n\n\n14.3.4 Ejercicios\n\n\nCompare y contraste los resultados de paste0() con str_c() para las siguientes entradas:\n\nstr_c(\"hi \", NA)\nstr_c(letters[1:2], letters[1:3])\n\n\n¬øCu√°l es la diferencia entre paste() y paste0()? ¬øC√≥mo puedes recrear el equivalente de paste() con str_c()?\n\nConvierta las siguientes expresiones de str_c() a str_glue() o viceversa:\n\nstr_c(\"El precio de \", food, \" es \", price)\nstr_glue(\"Yo tengo {age} a√±os y vivo en {country}\")\nstr_c(\"\\\\section{\", title, \"}\")",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Caracteres</span>"
    ]
  },
  {
    "objectID": "strings.html#extraer-datos-de-cadenas-de-caracteres",
    "href": "strings.html#extraer-datos-de-cadenas-de-caracteres",
    "title": "14¬† Caracteres",
    "section": "\n14.4 Extraer datos de cadenas de caracteres",
    "text": "14.4 Extraer datos de cadenas de caracteres\nEs muy com√∫n que varias variables se amontonen en una sola cadena. En esta secci√≥n, aprender√° a utilizar cuatro funciones tidyr para extraerlas:\n\ndf |&gt; separate_longer_delim(col, delim)\ndf |&gt; separate_longer_position(col, width)\ndf |&gt; separate_wider_delim(col, delim, names)\ndf |&gt; separate_wider_position(col, widths)\n\nSi miras de cerca, puedes ver que hay un patr√≥n com√∫n aqu√≠: separate_, luego longer o wider, luego _, luego por delim o position. Eso es porque estas cuatro funciones se componen de dos primitivas m√°s simples: - Al igual que con pivot_longer() y pivot_wider(), las funciones _longer hacen que el data frame de entrada sea m√°s largo al crear nuevas filas y las funciones _wider hacen que el data frame de entrada sea m√°s ancho al generar nuevas columnas. - delim divide una cadena con un delimitador como \", \" o \" \"; position se divide en anchos espec√≠ficos, como c(3, 5, 2).\nVolveremos al √∫ltimo miembro de esta familia, separate_wider_regex(), en Cap√≠tulo 15. Es la m√°s flexible de las funciones wider, pero necesita saber algo acerca de las expresiones regulares antes de poder usarla.\nLas siguientes dos secciones le dar√°n la idea b√°sica detr√°s de estas funciones separadas, primero separ√°ndolas en filas (que es un poco m√°s simple) y luego separ√°ndolas en columnas. Terminaremos discutiendo las herramientas que le brindan las funciones wider para diagnosticar problemas.\n\n14.4.1 Separando en filas\nSeparar una cadena en filas tiende a ser m√°s √∫til cuando el n√∫mero de componentes var√≠a de una fila a otra. El caso m√°s com√∫n requiere que separate_longer_delim() se divida en funci√≥n de un delimitador:\n\ndf1 &lt;- tibble(x = c(\"a,b,c\", \"d,e\", \"f\"))\ndf1 |&gt; \n  separate_longer_delim(x, delim = \",\")\n#&gt; # A tibble: 6 √ó 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 a    \n#&gt; 2 b    \n#&gt; 3 c    \n#&gt; 4 d    \n#&gt; 5 e    \n#&gt; 6 f\n\nEs m√°s raro ver separate_longer_position() en la naturaleza, pero algunos conjuntos de datos m√°s antiguos usan un formato muy compacto donde cada car√°cter se usa para registrar un valor:\n\ndf2 &lt;- tibble(x = c(\"1211\", \"131\", \"21\"))\ndf2 |&gt; \n  separate_longer_position(x, width = 1)\n#&gt; # A tibble: 9 √ó 1\n#&gt;   x    \n#&gt;   &lt;chr&gt;\n#&gt; 1 1    \n#&gt; 2 2    \n#&gt; 3 1    \n#&gt; 4 1    \n#&gt; 5 1    \n#&gt; 6 3    \n#&gt; # ‚Ñπ 3 more rows\n\n\n14.4.2 Separando en columnas\nSeparar una cadena en columnas tiende a ser m√°s √∫til cuando hay un n√∫mero fijo de componentes en cada cadena y desea distribuirlos en columnas. Son un poco m√°s complicados que sus equivalentes longer porque necesitas nombrar las columnas. Por ejemplo, en el siguiente conjunto de datos, x se compone de un c√≥digo, un n√∫mero de edici√≥n y un a√±o, separados por \".\". Para usar separate_wider_delim(), proporcionamos el delimitador y los nombres en dos argumentos:\n\ndf3 &lt;- tibble(x = c(\"a10.1.2022\", \"b10.2.2011\", \"e15.1.2015\"))\ndf3 |&gt; \n  separate_wider_delim(\n    x,\n    delim = \".\",\n    names = c(\"code\", \"edition\", \"year\")\n  )\n#&gt; # A tibble: 3 √ó 3\n#&gt;   code  edition year \n#&gt;   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;\n#&gt; 1 a10   1       2022 \n#&gt; 2 b10   2       2011 \n#&gt; 3 e15   1       2015\n\nSi una pieza espec√≠fica no es √∫til, puede usar un nombre NA para omitirla de los resultados:\n\ndf3 |&gt; \n  separate_wider_delim(\n    x,\n    delim = \".\",\n    names = c(\"code\", NA, \"year\")\n  )\n#&gt; # A tibble: 3 √ó 2\n#&gt;   code  year \n#&gt;   &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 a10   2022 \n#&gt; 2 b10   2011 \n#&gt; 3 e15   2015\n\nseparate_wider_position() funciona un poco diferente porque normalmente desea especificar el ancho de cada columna. Entonces le das un vector entero con nombre, donde el nombre da el nombre de la nueva columna, y el valor es la cantidad de caracteres que ocupa. Puede omitir valores de la salida si no los nombra:\n\ndf4 &lt;- tibble(x = c(\"202215TX\", \"202122LA\", \"202325CA\")) \ndf4 |&gt; \n  separate_wider_position(\n    x,\n    widths = c(year = 4, age = 2, state = 2)\n  )\n#&gt; # A tibble: 3 √ó 3\n#&gt;   year  age   state\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 2022  15    TX   \n#&gt; 2 2021  22    LA   \n#&gt; 3 2023  25    CA\n\n\n14.4.3 Diagn√≥stico de problemas de ensanchamiento\nseparate_wider_delim()6 requiere un conjunto fijo y conocido de columnas. ¬øQu√© sucede si alguna de las filas no tiene el n√∫mero esperado de piezas? Hay dos posibles problemas, muy pocas o demasiadas piezas, por lo que separate_wider_delim() proporciona dos argumentos para ayudar: too_few y too_many. Primero veamos el caso too_few con el siguiente conjunto de datos de muestra:\n\ndf &lt;- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3\", \"1-3-2\", \"1\"))\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\")\n  )\n#&gt; Error in `separate_wider_delim()`:\n#&gt; ! Expected 3 pieces in each element of `x`.\n#&gt; ! 2 values were too short.\n#&gt; ‚Ñπ Use `too_few = \"debug\"` to diagnose the problem.\n#&gt; ‚Ñπ Use `too_few = \"align_start\"/\"align_end\"` to silence this message.\n\nNotar√° que recibimos un error, pero el error nos da algunas sugerencias sobre c√≥mo puede proceder. Comencemos por depurar el problema:\n\ndebug &lt;- df |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_few = \"debug\"\n  )\n#&gt; Warning: Debug mode activated: adding variables `x_ok`, `x_pieces`, and\n#&gt; `x_remainder`.\ndebug\n#&gt; # A tibble: 5 √ó 6\n#&gt;   x     y     z     x_ok  x_pieces x_remainder\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;      \n#&gt; 1 1-1-1 1     1     TRUE         3 \"\"         \n#&gt; 2 1-1-2 1     2     TRUE         3 \"\"         \n#&gt; 3 1-3   3     &lt;NA&gt;  FALSE        2 \"\"         \n#&gt; 4 1-3-2 3     2     TRUE         3 \"\"         \n#&gt; 5 1     &lt;NA&gt;  &lt;NA&gt;  FALSE        1 \"\"\n\nCuando usa el modo de depuraci√≥n, obtiene tres columnas adicionales agregadas a la salida: x_ok, x_pieces y x_remainder (si separa una variable con un nombre diferente, obtendr√° un prefijo diferente). Aqu√≠, x_ok te permite encontrar r√°pidamente las entradas que fallaron:\n\ndebug |&gt; filter(!x_ok)\n#&gt; # A tibble: 2 √ó 6\n#&gt;   x     y     z     x_ok  x_pieces x_remainder\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;      \n#&gt; 1 1-3   3     &lt;NA&gt;  FALSE        2 \"\"         \n#&gt; 2 1     &lt;NA&gt;  &lt;NA&gt;  FALSE        1 \"\"\n\nx_pieces nos dice cu√°ntas piezas se encontraron, en comparaci√≥n con las 3 esperadas (la longitud de names). x_remainder no es √∫til cuando hay muy pocas piezas, pero lo veremos de nuevo en breve.\nA veces, mirar esta informaci√≥n de depuraci√≥n revelar√° un problema con su estrategia de delimitaci√≥n o sugerir√° que necesita hacer m√°s preprocesamiento antes de separarse. En ese caso, solucione el problema aguas arriba y aseg√∫rese de eliminar too_few = \"debug\" para asegurarse de que los nuevos problemas se conviertan en errores.\nEn otros casos, es posible que desee completar las piezas que faltan con ‚ÄúNA‚Äù y seguir adelante. Ese es el trabajo de too_few = \"align_start\" y too_few = \"align_end\" que le permiten controlar d√≥nde deben ir los NA:\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_few = \"align_start\"\n  )\n#&gt; # A tibble: 5 √ó 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     1     1    \n#&gt; 2 1     1     2    \n#&gt; 3 1     3     &lt;NA&gt; \n#&gt; 4 1     3     2    \n#&gt; 5 1     &lt;NA&gt;  &lt;NA&gt;\n\nLos mismos principios se aplican si tiene demasiadas piezas:\n\ndf &lt;- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3-5-6\", \"1-3-2\", \"1-3-5-7-9\"))\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\")\n  )\n#&gt; Error in `separate_wider_delim()`:\n#&gt; ! Expected 3 pieces in each element of `x`.\n#&gt; ! 2 values were too long.\n#&gt; ‚Ñπ Use `too_many = \"debug\"` to diagnose the problem.\n#&gt; ‚Ñπ Use `too_many = \"drop\"/\"merge\"` to silence this message.\n\nPero ahora, cuando depuramos el resultado, puedes ver el prop√≥sito de x_remainder:\n\ndebug &lt;- df |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"debug\"\n  )\n#&gt; Warning: Debug mode activated: adding variables `x_ok`, `x_pieces`, and\n#&gt; `x_remainder`.\ndebug |&gt; filter(!x_ok)\n#&gt; # A tibble: 2 √ó 6\n#&gt;   x         y     z     x_ok  x_pieces x_remainder\n#&gt;   &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;      \n#&gt; 1 1-3-5-6   3     5     FALSE        4 -6         \n#&gt; 2 1-3-5-7-9 3     5     FALSE        5 -7-9\n\nTiene un conjunto ligeramente diferente de opciones para manejar demasiadas piezas: puede ‚Äúsoltar‚Äù silenciosamente cualquier pieza adicional o ‚Äúfusionarlas‚Äù todas en la columna final:\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"drop\"\n  )\n#&gt; # A tibble: 5 √ó 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     1     1    \n#&gt; 2 1     1     2    \n#&gt; 3 1     3     5    \n#&gt; 4 1     3     2    \n#&gt; 5 1     3     5\n\n\ndf |&gt; \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"merge\"\n  )\n#&gt; # A tibble: 5 √ó 3\n#&gt;   x     y     z    \n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     1     1    \n#&gt; 2 1     1     2    \n#&gt; 3 1     3     5-6  \n#&gt; 4 1     3     2    \n#&gt; 5 1     3     5-7-9",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Caracteres</span>"
    ]
  },
  {
    "objectID": "strings.html#letras",
    "href": "strings.html#letras",
    "title": "14¬† Caracteres",
    "section": "\n14.5 Letras",
    "text": "14.5 Letras\nEn esta secci√≥n, le presentaremos funciones que le permitir√°n trabajar con letras individuales dentro de una cadena. Aprender√° a encontrar la longitud de una cadena, extraer subcadenas y manejar cadenas largas en diagramas y tablas.\n\n14.5.1 Longitud\nstr_length() te dice el n√∫mero de letras en la cadena:\n\nstr_length(c(\"a\", \"R for data science\", NA))\n#&gt; [1]  1 18 NA\n\nPodr√≠a usar esto con count() para encontrar la distribuci√≥n de las longitudes de los nombres de beb√©s de EE. UU. y luego con filter() para ver los nombres m√°s largos, que tienen 15 letras 7:\n\nbabynames |&gt;\n  count(length = str_length(name), wt = n)\n#&gt; # A tibble: 14 √ó 2\n#&gt;   length        n\n#&gt;    &lt;int&gt;    &lt;int&gt;\n#&gt; 1      2   338150\n#&gt; 2      3  8589596\n#&gt; 3      4 48506739\n#&gt; 4      5 87011607\n#&gt; 5      6 90749404\n#&gt; 6      7 72120767\n#&gt; # ‚Ñπ 8 more rows\n\nbabynames |&gt; \n  filter(str_length(name) == 15) |&gt; \n  count(name, wt = n, sort = TRUE)\n#&gt; # A tibble: 34 √ó 2\n#&gt;   name                n\n#&gt;   &lt;chr&gt;           &lt;int&gt;\n#&gt; 1 Franciscojavier   123\n#&gt; 2 Christopherjohn   118\n#&gt; 3 Johnchristopher   118\n#&gt; 4 Christopherjame   108\n#&gt; 5 Christophermich    52\n#&gt; 6 Ryanchristopher    45\n#&gt; # ‚Ñπ 28 more rows\n\n\n14.5.2 Subconjunto\nPuedes extraer partes de una cadena usando str_sub(string, start, end), donde start y end son las posiciones donde la subcadena debe comenzar y terminar. Los argumentos start y end son inclusivos, por lo que la longitud de la cadena devuelta ser√° end - start + 1:\n\nx &lt;- c(\"Apple\", \"Banana\", \"Pear\")\nstr_sub(x, 1, 3)\n#&gt; [1] \"App\" \"Ban\" \"Pea\"\n\nPuede usar valores negativos para contar hacia atr√°s desde el final de la cadena: -1 es el √∫ltimo car√°cter, -2 es el pen√∫ltimo car√°cter, etc.\n\nstr_sub(x, -3, -1)\n#&gt; [1] \"ple\" \"ana\" \"ear\"\n\nTenga en cuenta que str_sub() no fallar√° si la cadena es demasiado corta: solo devolver√° tanto como sea posible:\n\nstr_sub(\"a\", 1, 5)\n#&gt; [1] \"a\"\n\nPodr√≠amos usar str_sub() con mutate() para encontrar la primera y √∫ltima letra de cada nombre:\n\nbabynames |&gt; \n  mutate(\n    first = str_sub(name, 1, 1),\n    last = str_sub(name, -1, -1)\n  )\n#&gt; # A tibble: 1,924,665 √ó 7\n#&gt;    year sex   name          n   prop first last \n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;int&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1  1880 F     Mary       7065 0.0724 M     y    \n#&gt; 2  1880 F     Anna       2604 0.0267 A     a    \n#&gt; 3  1880 F     Emma       2003 0.0205 E     a    \n#&gt; 4  1880 F     Elizabeth  1939 0.0199 E     h    \n#&gt; 5  1880 F     Minnie     1746 0.0179 M     e    \n#&gt; 6  1880 F     Margaret   1578 0.0162 M     t    \n#&gt; # ‚Ñπ 1,924,659 more rows\n\n\n14.5.3 Ejercicios\n\n¬øCuando calculamos la distribuci√≥n de la longitud de los nombres de los beb√©s, ¬øpor qu√© usamos wt = n?\nUse str_length() y str_sub() para extraer la letra del medio de cada nombre de beb√©. ¬øQu√© har√°s si la cadena tiene un n√∫mero par de caracteres?\n¬øExisten tendencias importantes en la longitud de los nombres de beb√©s a lo largo del tiempo? ¬øQu√© pasa con la popularidad de las primeras y √∫ltimas letras?",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Caracteres</span>"
    ]
  },
  {
    "objectID": "strings.html#sec-other-languages",
    "href": "strings.html#sec-other-languages",
    "title": "14¬† Caracteres",
    "section": "\n14.6 Texto no ingl√©s",
    "text": "14.6 Texto no ingl√©s\nHasta ahora, nos hemos centrado en el texto en ingl√©s, con el que es particularmente f√°cil trabajar por dos razones. En primer lugar, el alfabeto ingl√©s es relativamente simple: solo hay 26 letras. En segundo lugar (y quiz√°s m√°s importante), la infraestructura inform√°tica que usamos hoy en d√≠a fue dise√±ada predominantemente por angloparlantes. Desafortunadamente, no tenemos espacio para un tratamiento completo de los idiomas distintos del ingl√©s. A√∫n as√≠, quer√≠amos llamar su atenci√≥n sobre algunos de los mayores desaf√≠os que podr√≠a encontrar: codificaci√≥n, variaciones de letras y funciones dependientes de la configuraci√≥n regional.\n\n14.6.1 Codificaci√≥n\nCuando se trabaja con texto que no est√° en ingl√©s, el primer desaf√≠o suele ser la codificaci√≥n. Para entender lo que est√° pasando, necesitamos sumergirnos en c√≥mo las computadoras representan cadenas. En R, podemos llegar a la representaci√≥n subyacente de una cadena usando charToRaw():\n\ncharToRaw(\"Hadley\")\n#&gt; [1] 48 61 64 6c 65 79\n\nCada uno de estos seis n√∫meros hexadecimales representa una letra: 48 es H, 61 es a, y as√≠ sucesivamente. La asignaci√≥n de un n√∫mero hexadecimal a un car√°cter se denomina codificaci√≥n y, en este caso, la codificaci√≥n se denomina ASCII. ASCII hace un gran trabajo al representar los caracteres ingleses porque es el c√≥digo est√°ndar estadounidense para el intercambio de informaci√≥n.\nLas cosas no son tan f√°ciles para otros idiomas adem√°s del ingl√©s. En los primeros d√≠as de la inform√°tica, exist√≠an muchos est√°ndares en competencia para codificar caracteres no ingleses. Por ejemplo, hab√≠a dos codificaciones diferentes para Europa: Latin1 (tambi√©n conocido como ISO-8859-1) se usaba para los idiomas de Europa occidental, y Latin2 (tambi√©n conocido como ISO-8859-2) se usaba para los idiomas de Europa Central. En Latin1, el byte b1 es ‚Äú¬±‚Äù, pero en Latin2, ¬°es ‚Äú¬±‚Äù! Afortunadamente, hoy en d√≠a existe un est√°ndar que se admite en casi todas partes: UTF-8. UTF-8 puede codificar casi todos los caracteres utilizados por los humanos en la actualidad y muchos s√≠mbolos adicionales como emojis.\nreadr usa UTF-8 en todas partes. Este es un buen valor predeterminado, pero fallar√° para los datos producidos por sistemas m√°s antiguos que no usan UTF-8. Si esto sucede, sus cadenas se ver√°n raras cuando las imprima. A veces, solo uno o dos caracteres pueden estar en mal estado; otras veces, obtendr√°s un completo galimat√≠as. Por ejemplo, aqu√≠ hay dos CSV en l√≠nea con codificaciones inusuales 8:\n\nx1 &lt;- \"text\\nEl Ni\\xf1o fue particularmente malo este a√±o\"\nread_csv(x1)$text\n#&gt; [1] \"El Ni\\xf1o fue particularmente malo este a√±o\"\n\nx2 &lt;- \"text\\n\\x82\\xb1\\x82\\xf1\\x82\\xc9\\x82\\xbf\\x82\\xcd\"\nread_csv(x2)$text\n#&gt; [1] \"\\x82\\xb1\\x82\\xf1\\x82…Ç\\xbf\\x82\\xcd\"\n\nPara leerlos correctamente, especifica la codificaci√≥n a trav√©s del argumento locale:\n\nread_csv(x1, locale = locale(encoding = \"Latin1\"))$text\n#&gt; [1] \"El Ni\\xf1o fue particularmente malo este a√±o\"\n\nread_csv(x2, locale = locale(encoding = \"Shift-JIS\"))$text\n#&gt; [1] \"„Åì„Çì„Å´„Å°„ÅØ\"\n\n¬øC√≥mo encuentras la codificaci√≥n correcta? Si tiene suerte, se incluir√° en alg√∫n lugar de la documentaci√≥n de datos. Desafortunadamente, ese rara vez es el caso, por lo que readr proporciona guess_encoding() para ayudarlo a resolverlo. No es infalible y funciona mejor cuando tiene mucho texto (a diferencia de aqu√≠), pero es un lugar razonable para comenzar. Espere probar algunas codificaciones diferentes antes de encontrar la correcta.\nLas codificaciones son un tema rico y complejo; solo hemos ara√±ado la superficie aqu√≠. Si desea obtener m√°s informaci√≥n, le recomendamos leer la explicaci√≥n detallada en http://kunststube.net/encoding/.\n\n14.6.2 Variaciones de letras\nTrabajar en idiomas con acentos plantea un desaf√≠o significativo al determinar la posici√≥n de las letras (por ejemplo, con str_length() y str_sub()), ya que las letras acentuadas pueden codificarse como un solo car√°cter individual (por ejemplo, √º) o como dos caracteres por combinar una letra sin acento (por ejemplo, u) con un signo diacr√≠tico (por ejemplo, ¬®). Por ejemplo, este c√≥digo muestra dos formas de representar √º que parecen id√©nticas:\n\nu &lt;- c(\"\\u00fc\", \"u\\u0308\")\nstr_view(u)\n#&gt; [1] ‚îÇ √º\n#&gt; [2] ‚îÇ uÃà\n\nPero ambas cadenas difieren en longitud y sus primeros caracteres son diferentes:\n\nstr_length(u)\n#&gt; [1] 1 2\nstr_sub(u, 1, 1)\n#&gt; [1] \"√º\" \"u\"\n\nFinalmente, tenga en cuenta que una comparaci√≥n de estas cadenas con == interpreta estas cadenas como diferentes, mientras que la pr√°ctica funci√≥n str_equal() en stringr reconoce que ambas tienen la misma apariencia:\n\nu[[1]] == u[[2]]\n#&gt; [1] FALSE\n\nstr_equal(u[[1]], u[[2]])\n#&gt; [1] TRUE\n\n\n14.6.3 Funciones dependientes de la configuraci√≥n regional\nFinalmente, hay un pu√±ado de funciones stringr cuyo comportamiento depende de tu locale. Una configuraci√≥n regional es similar a un idioma, pero incluye un especificador de regi√≥n opcional para manejar las variaciones regionales dentro de un idioma. Una configuraci√≥n regional se especifica mediante una abreviatura de idioma en min√∫sculas, seguida opcionalmente por un _ y un identificador de regi√≥n en may√∫sculas. Por ejemplo, ‚Äúen‚Äù es ingl√©s, ‚Äúen_GB‚Äù es ingl√©s brit√°nico y ‚Äúen_US‚Äù es ingl√©s americano. Si a√∫n no conoce el c√≥digo de su idioma, Wikipedia tiene una buena lista, y puede ver cu√°les son compatibles con stringr mirando stringi::stri_locale_list().\nLas funciones de cadena base R utilizan autom√°ticamente la configuraci√≥n regional establecida por su sistema operativo. Esto significa que las funciones base de cadena R hacen lo que espera para su idioma, pero su c√≥digo podr√≠a funcionar de manera diferente si lo comparte con alguien que vive en un pa√≠s diferente. Para evitar este problema, stringr utiliza por defecto las reglas en ingl√©s utilizando la configuraci√≥n regional ‚Äúen‚Äù y requiere que especifique el argumento locale para anularlo. Afortunadamente, hay dos conjuntos de funciones donde la configuraci√≥n regional realmente importa: cambio de may√∫sculas y min√∫sculas y clasificaci√≥n.\nLas reglas para cambiar entre may√∫sculas y min√∫sculas difieren entre idiomas. Por ejemplo, el turco tiene dos i: con y sin punto. Como son dos letras distintas, se escriben en may√∫sculas de manera diferente:\n\nstr_to_upper(c(\"i\", \"ƒ±\"))\n#&gt; [1] \"I\" \"I\"\nstr_to_upper(c(\"i\", \"ƒ±\"), locale = \"tr\")\n#&gt; [1] \"ƒ∞\" \"I\"\n\n¬°La clasificaci√≥n de las cadenas depende del orden del alfabeto, y el orden del alfabeto no es el mismo en todos los idiomas 9! He aqu√≠ un ejemplo: en checo, ‚Äúch‚Äù es una letra compuesta que aparece despu√©s de la h en el alfabeto.\n\nstr_sort(c(\"a\", \"c\", \"ch\", \"h\", \"z\"))\n#&gt; [1] \"a\"  \"c\"  \"ch\" \"h\"  \"z\"\nstr_sort(c(\"a\", \"c\", \"ch\", \"h\", \"z\"), locale = \"cs\")\n#&gt; [1] \"a\"  \"c\"  \"h\"  \"ch\" \"z\"\n\nEsto tambi√©n surge al ordenar cadenas con dplyr::arrange(), por lo que tambi√©n tiene un argumento locale.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Caracteres</span>"
    ]
  },
  {
    "objectID": "strings.html#resumen",
    "href": "strings.html#resumen",
    "title": "14¬† Caracteres",
    "section": "\n14.7 Resumen",
    "text": "14.7 Resumen\nEn este cap√≠tulo, aprendi√≥ algo sobre el poder del paquete stringr: c√≥mo crear, combinar y extraer cadenas, y sobre algunos de los desaf√≠os que puede enfrentar con cadenas que no est√°n en ingl√©s. Ahora es el momento de aprender una de las herramientas m√°s importantes y poderosas para trabajar con cadenas: las expresiones regulares. Las expresiones regulares son un lenguaje muy conciso pero muy expresivo para describir patrones dentro de cadenas y son el tema del pr√≥ximo cap√≠tulo.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Caracteres</span>"
    ]
  },
  {
    "objectID": "strings.html#footnotes",
    "href": "strings.html#footnotes",
    "title": "14¬† Caracteres",
    "section": "",
    "text": "O usa la funci√≥n base R writeLines().‚Ü©Ô∏é\nDisponible en R 4.0.0 y superior.‚Ü©Ô∏é\nstr_view() tambi√©n usa colores para llamar su atenci√≥n sobre tabulaciones, espacios, coincidencias, etc. Los colores no aparecen actualmente en el libro, pero los notar√° cuando ejecute el c√≥digo de forma interactiva.‚Ü©Ô∏é\nSi no est√° usando stringr, tambi√©n puede acceder a √©l directamente con glue::glue().‚Ü©Ô∏é\nEl equivalente base de R es paste() usado con el argumento collapse.‚Ü©Ô∏é\nLos mismos principios se aplican a separate_wider_position() y separate_wider_regex().‚Ü©Ô∏é\nMirando estas entradas, supondr√≠amos que los datos de babynames eliminan espacios o guiones y se truncan despu√©s de 15 letras.‚Ü©Ô∏é\nAqu√≠ estoy usando el \\x especial para codificar datos binarios directamente en una cadena.‚Ü©Ô∏é\nClasificar en idiomas que no tienen alfabeto, como el chino, es a√∫n m√°s complicado.‚Ü©Ô∏é",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Caracteres</span>"
    ]
  },
  {
    "objectID": "regexps.html",
    "href": "regexps.html",
    "title": "15¬† Expresiones regulares",
    "section": "",
    "text": "15.1 Introducci√≥n\nEn Cap√≠tulo 14, aprendi√≥ un mont√≥n de funciones √∫tiles para trabajar con cadenas. Este cap√≠tulo se centrar√° en funciones que usan expresiones regulares, un lenguaje conciso y poderoso para describir patrones dentro de cadenas. El t√©rmino ‚Äúexpresi√≥n regular‚Äù es un poco complicado, por lo que la mayor√≠a de la gente lo abrevia como ‚Äúregex‚Äù1 (del ingl√©s, ‚Äúregular expressions‚Äù) o ‚Äúregexp‚Äù.\nEl cap√≠tulo comienza con los conceptos b√°sicos de las expresiones regulares y las funciones stringr m√°s √∫tiles para el an√°lisis de datos. Luego, ampliaremos su conocimiento de los patrones y cubriremos siete temas nuevos e importantes (escape, anclaje, clases de caracteres, clases de taquigraf√≠a, cuantificadores, precedencia y agrupaci√≥n). A continuaci√≥n, hablaremos sobre algunos de los otros tipos de patrones con los que pueden trabajar las funciones stringr y las diversas ‚Äúbanderas‚Äù que le permiten modificar el funcionamiento de las expresiones regulares. Terminaremos con una encuesta de otros lugares en el tidyverse y base R donde podr√≠a usar expresiones regulares.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Expresiones regulares</span>"
    ]
  },
  {
    "objectID": "regexps.html#introducci√≥n",
    "href": "regexps.html#introducci√≥n",
    "title": "15¬† Expresiones regulares",
    "section": "",
    "text": "15.1.1 Requisitos previos\nEn este cap√≠tulo, usaremos funciones de expresiones regulares de stringr y tidyr, ambos miembros centrales de tidyverse, as√≠ como datos del paquete babynames.\n\nlibrary(tidyverse)\nlibrary(babynames)\n\nA lo largo de este cap√≠tulo, usaremos una combinaci√≥n de ejemplos en l√≠nea muy simples para que pueda obtener la idea b√°sica, los datos de nombres de beb√©s y tres vectores de caracteres de stringr:\n\n\nfruit contiene los nombres de 80 frutas.\n\nwords contiene 980 palabras comunes del ideoma ingl√©s.\n\nsentences contiene 720 oraciones cortas.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Expresiones regulares</span>"
    ]
  },
  {
    "objectID": "regexps.html#sec-reg-basics",
    "href": "regexps.html#sec-reg-basics",
    "title": "15¬† Expresiones regulares",
    "section": "\n15.2 Conceptos b√°sicos de patrones",
    "text": "15.2 Conceptos b√°sicos de patrones\nUsaremos str_view() para aprender c√≥mo funcionan los patrones de expresiones regulares. Usamos str_view() en el √∫ltimo cap√≠tulo para comprender mejor una cadena en comparaci√≥n con su representaci√≥n impresa, y ahora la usaremos con su segundo argumento, una expresi√≥n regular. Cuando se proporciona, str_view() mostrar√° solo los elementos del vector de cadena que coincidan, rodeando cada coincidencia con &lt;&gt; y, donde sea posible, resaltando la coincidencia en azul.\nLos patrones m√°s simples consisten en letras y n√∫meros que coinciden exactamente con esos caracteres:\n\nstr_view(fruit, \"berry\")\n#&gt;  [6] ‚îÇ bil&lt;berry&gt;\n#&gt;  [7] ‚îÇ black&lt;berry&gt;\n#&gt; [10] ‚îÇ blue&lt;berry&gt;\n#&gt; [11] ‚îÇ boysen&lt;berry&gt;\n#&gt; [19] ‚îÇ cloud&lt;berry&gt;\n#&gt; [21] ‚îÇ cran&lt;berry&gt;\n#&gt; ... and 8 more\n\nLas letras y los n√∫meros coinciden exactamente y se denominan caracteres literales. La mayor√≠a de los caracteres de puntuaci√≥n, como ., +, *, [, ], y ?, tienen significados especiales2 y se denominan metacaracteres. Por ejemplo, . coincidir√° con cualquier car√°cter3, por lo que \"a.\" coincidir√° con cualquier cadena que contenga una ‚Äúa‚Äù seguida de otro car√°cter :\n\nstr_view(c(\"a\", \"ab\", \"ae\", \"bd\", \"ea\", \"eab\"), \"a.\")\n#&gt; [2] ‚îÇ &lt;ab&gt;\n#&gt; [3] ‚îÇ &lt;ae&gt;\n#&gt; [6] ‚îÇ e&lt;ab&gt;\n\nO podr√≠amos encontrar todas las frutas que contienen una ‚Äúa‚Äù, seguida de tres letras, seguidas de una ‚Äúe‚Äù:\n\nstr_view(fruit, \"a...e\")\n#&gt;  [1] ‚îÇ &lt;apple&gt;\n#&gt;  [7] ‚îÇ bl&lt;ackbe&gt;rry\n#&gt; [48] ‚îÇ mand&lt;arine&gt;\n#&gt; [51] ‚îÇ nect&lt;arine&gt;\n#&gt; [62] ‚îÇ pine&lt;apple&gt;\n#&gt; [64] ‚îÇ pomegr&lt;anate&gt;\n#&gt; ... and 2 more\n\nQuantifiers controla cu√°ntas veces puede coincidir un patr√≥n:\n\n\n? hace que un patr√≥n sea opcional (es decir, coincide 0 o 1 veces)\n\n+ permite que un patr√≥n se repita (es decir, coincide al menos una vez)\n\n* permite que un patr√≥n sea opcional o se repita (es decir, coincide con cualquier n√∫mero de veces, incluido 0).\n\n\n# ab? coincide con una \"a\", opcionalmente seguida de una \"b\".\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab?\")\n#&gt; [1] ‚îÇ &lt;a&gt;\n#&gt; [2] ‚îÇ &lt;ab&gt;\n#&gt; [3] ‚îÇ &lt;ab&gt;b\n\n# ab+ Coincide con una \"a\", seguida de al menos una \"b\".\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab+\")\n#&gt; [2] ‚îÇ &lt;ab&gt;\n#&gt; [3] ‚îÇ &lt;abb&gt;\n\n# ab* coincide con una \"a\", seguida de cualquier n√∫mero de \"b\".\nstr_view(c(\"a\", \"ab\", \"abb\"), \"ab*\")\n#&gt; [1] ‚îÇ &lt;a&gt;\n#&gt; [2] ‚îÇ &lt;ab&gt;\n#&gt; [3] ‚îÇ &lt;abb&gt;\n\nLas clases de caracteres est√°n definidas por [] y le permiten hacer coincidir un conjunto de caracteres, p.ej., [abcd] coincide con ‚Äúa‚Äù, ‚Äúb‚Äù, ‚Äúc‚Äù o ‚Äúd‚Äù. Tambi√©n puede invertir la coincidencia comenzando con ^: [^abcd] coincide con cualquier cosa excepto ‚Äúa‚Äù, ‚Äúb‚Äù, ‚Äúc‚Äù o ‚Äúd‚Äù. Podemos usar esta idea para encontrar las palabras que contienen una ‚Äúx‚Äù rodeada de vocales, o una ‚Äúy‚Äù rodeada de consonantes:\n\nstr_view(words, \"[aeiou]x[aeiou]\")\n#&gt; [284] ‚îÇ &lt;exa&gt;ct\n#&gt; [285] ‚îÇ &lt;exa&gt;mple\n#&gt; [288] ‚îÇ &lt;exe&gt;rcise\n#&gt; [289] ‚îÇ &lt;exi&gt;st\nstr_view(words, \"[^aeiou]y[^aeiou]\")\n#&gt; [836] ‚îÇ &lt;sys&gt;tem\n#&gt; [901] ‚îÇ &lt;typ&gt;e\n\nPuede usar alternancia, |, para elegir entre uno o m√°s patrones alternativos. Por ejemplo, los siguientes patrones buscan frutas que contengan ‚Äúmanzana‚Äù, ‚Äúmel√≥n‚Äù o ‚Äúnuez‚Äù, o una vocal repetida.\n\nstr_view(fruit, \"apple|melon|nut\")\n#&gt;  [1] ‚îÇ &lt;apple&gt;\n#&gt; [13] ‚îÇ canary &lt;melon&gt;\n#&gt; [20] ‚îÇ coco&lt;nut&gt;\n#&gt; [52] ‚îÇ &lt;nut&gt;\n#&gt; [62] ‚îÇ pine&lt;apple&gt;\n#&gt; [72] ‚îÇ rock &lt;melon&gt;\n#&gt; ... and 1 more\nstr_view(fruit, \"aa|ee|ii|oo|uu\")\n#&gt;  [9] ‚îÇ bl&lt;oo&gt;d orange\n#&gt; [33] ‚îÇ g&lt;oo&gt;seberry\n#&gt; [47] ‚îÇ lych&lt;ee&gt;\n#&gt; [66] ‚îÇ purple mangost&lt;ee&gt;n\n\nLas expresiones regulares son muy compactas y utilizan muchos caracteres de puntuaci√≥n, por lo que al principio pueden parecer abrumadoras y dif√≠ciles de leer. No te preocupes; mejorar√° con la pr√°ctica, y los patrones simples pronto se convertir√°n en una segunda naturaleza. Comencemos ese proceso practicando con algunas funciones √∫tiles de stringr.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Expresiones regulares</span>"
    ]
  },
  {
    "objectID": "regexps.html#sec-stringr-regex-funs",
    "href": "regexps.html#sec-stringr-regex-funs",
    "title": "15¬† Expresiones regulares",
    "section": "\n15.3 Funciones clave",
    "text": "15.3 Funciones clave\nAhora que tiene los conceptos b√°sicos de las expresiones regulares bajo su cintur√≥n, us√©moslos con algunas funciones stringr y tidyr. En la siguiente secci√≥n, aprender√° c√≥mo detectar la presencia o ausencia de una coincidencia, c√≥mo contar el n√∫mero de coincidencias, c√≥mo reemplazar una coincidencia con texto fijo y c√≥mo extraer texto usando un patr√≥n.\n\n15.3.1 Detectar coincidencias\nstr_detect() devuelve un vector l√≥gico que es TRUE si el patr√≥n coincide con un elemento del vector de caracteres y FALSE en caso contrario:\n\nstr_detect(c(\"a\", \"b\", \"c\"), \"[aeiou]\")\n#&gt; [1]  TRUE FALSE FALSE\n\nDado que str_detect() devuelve un vector l√≥gico de la misma longitud que el vector inicial, se empareja bien con filter(). Por ejemplo, este c√≥digo encuentra todos los nombres m√°s populares que contienen una ‚Äúx‚Äù min√∫scula:\n\nbabynames |&gt; \n  filter(str_detect(name, \"x\")) |&gt; \n  count(name, wt = n, sort = TRUE)\n#&gt; # A tibble: 974 √ó 2\n#&gt;   name           n\n#&gt;   &lt;chr&gt;      &lt;int&gt;\n#&gt; 1 Alexander 665492\n#&gt; 2 Alexis    399551\n#&gt; 3 Alex      278705\n#&gt; 4 Alexandra 232223\n#&gt; 5 Max       148787\n#&gt; 6 Alexa     123032\n#&gt; # ‚Ñπ 968 more rows\n\nTambi√©n podemos usar str_detect() con summarize() combin√°ndolo con sum() o mean(): sum(str_detect(x, pattern)) te dice el n√∫mero de observaciones que coinciden y mean(str_detect(x, pattern)) te dice la proporci√≥n que coincide. Por ejemplo, el siguiente fragmento calcula y visualiza la proporci√≥n de nombres de beb√©s4 que contienen ‚Äúx‚Äù, desglosados por a√±o. ¬°Parece que su popularidad ha aumentado radicalmente √∫ltimamente!\n\nbabynames |&gt; \n  group_by(year) |&gt; \n  summarize(prop_x = mean(str_detect(name, \"x\"))) |&gt; \n  ggplot(aes(x = year, y = prop_x)) + \n  geom_line()\n\n\n\n\n\n\n\nHay dos funciones que est√°n estrechamente relacionadas con str_detect(): str_subset() y str_which(). str_subset() devuelve solo las cadenas que contienen coincidencia. str_which() devuelve los √≠ndices de las cadenas que tienen coincidencia:\n\n15.3.2 Contar coincidencias\nEl siguiente paso en complejidad de str_detect() es str_count(): en lugar de verdadero o falso, le dice cu√°ntas coincidencias hay en cada cadena.\n\nx &lt;- c(\"apple\", \"banana\", \"pear\")\nstr_count(x, \"p\")\n#&gt; [1] 2 0 1\n\nTenga en cuenta que cada coincidencia comienza al final de la coincidencia anterior, es decir, las coincidencias de expresiones regulares nunca se superponen. Por ejemplo, en \"abababa\", ¬øcu√°ntas veces coincidir√° el patr√≥n \"aba\"? Las expresiones regulares dicen dos, no tres:\n\nstr_count(\"abababa\", \"aba\")\n#&gt; [1] 2\nstr_view(\"abababa\", \"aba\")\n#&gt; [1] ‚îÇ &lt;aba&gt;b&lt;aba&gt;\n\nEs natural usar str_count() con mutate(). El siguiente ejemplo usa str_count() con clases de caracteres para contar el n√∫mero de vocales y consonantes en cada nombre.\n\nbabynames |&gt; \n  count(name) |&gt; \n  mutate(\n    vowels = str_count(name, \"[aeiou]\"),\n    consonants = str_count(name, \"[^aeiou]\")\n  )\n#&gt; # A tibble: 97,310 √ó 4\n#&gt;   name          n vowels consonants\n#&gt;   &lt;chr&gt;     &lt;int&gt;  &lt;int&gt;      &lt;int&gt;\n#&gt; 1 Aaban        10      2          3\n#&gt; 2 Aabha         5      2          3\n#&gt; 3 Aabid         2      2          3\n#&gt; 4 Aabir         1      2          3\n#&gt; 5 Aabriella     5      4          5\n#&gt; 6 Aada          1      2          2\n#&gt; # ‚Ñπ 97,304 more rows\n\nSi miras de cerca, notar√°s que hay algo mal con nuestros c√°lculos: ‚ÄúAaban‚Äù contiene tres ‚Äúa‚Äù, pero nuestro resumen solo reporta dos vocales. Eso es porque las expresiones regulares distinguen entre may√∫sculas y min√∫sculas. Hay tres formas en las que podemos arreglar esto:\n\nAgregue las vocales may√∫sculas a la clase de car√°cter: str_count(name, \"[aeiouAEIOU]\").\nD√≠gale a la expresi√≥n regular que ignore el tama√±o: str_count(name, regex(\"[aeiou]\", ignore_case = TRUE)). Hablaremos de m√°s en Secci√≥n 15.5.1.\nUsa str_to_lower() para convertir los nombres a min√∫sculas: str_count(str_to_lower(name), \"[aeiou]\").\n\nEsta variedad de enfoques es bastante t√≠pica cuando se trabaja con cadenas; a menudo, hay varias formas de alcanzar su objetivo, ya sea haciendo que su patr√≥n sea m√°s complicado o haciendo un preprocesamiento en su cadena. Si se queda atascado intentando un enfoque, a menudo puede ser √∫til cambiar de marcha y abordar el problema desde una perspectiva diferente.\nEn este caso, dado que estamos aplicando dos funciones al nombre, creo que es m√°s f√°cil transformarlo primero:\n\nbabynames |&gt; \n  count(name) |&gt; \n  mutate(\n    name = str_to_lower(name),\n    vowels = str_count(name, \"[aeiou]\"),\n    consonants = str_count(name, \"[^aeiou]\")\n  )\n#&gt; # A tibble: 97,310 √ó 4\n#&gt;   name          n vowels consonants\n#&gt;   &lt;chr&gt;     &lt;int&gt;  &lt;int&gt;      &lt;int&gt;\n#&gt; 1 aaban        10      3          2\n#&gt; 2 aabha         5      3          2\n#&gt; 3 aabid         2      3          2\n#&gt; 4 aabir         1      3          2\n#&gt; 5 aabriella     5      5          4\n#&gt; 6 aada          1      3          1\n#&gt; # ‚Ñπ 97,304 more rows\n\n\n15.3.3 Reemplazar valores\nAdem√°s de detectar y contar coincidencias, tambi√©n podemos modificarlas con str_replace() y str_replace_all(). str_replace() reemplaza la primera coincidencia y, como sugiere el nombre, str_replace_all() reemplaza todas las coincidencias.\n\nx &lt;- c(\"apple\", \"pear\", \"banana\")\nstr_replace_all(x, \"[aeiou]\", \"-\")\n#&gt; [1] \"-ppl-\"  \"p--r\"   \"b-n-n-\"\n\nstr_remove() y str_remove_all() son atajos √∫tiles para str_replace(x, patr√≥n, \"\"):\n\nx &lt;- c(\"apple\", \"pear\", \"banana\")\nstr_remove_all(x, \"[aeiou]\")\n#&gt; [1] \"ppl\" \"pr\"  \"bnn\"\n\nEstas funciones se combinan de forma natural con mutate() al realizar la limpieza de datos y, a menudo, las aplicar√° repetidamente para quitar capas de formato inconsistente.\n\n15.3.4 Extraer variables\nLa √∫ltima funci√≥n que discutiremos usa expresiones regulares para extraer datos de una columna en una o m√°s columnas nuevas: separate_wider_regex(). Es un par de las funciones separate_wider_position() y separate_wider_delim() que aprendiste en Secci√≥n 14.4.2. Estas funciones viven en tidyr porque operan en (columnas de) data frames, en lugar de vectores individuales.\nVamos a crear un conjunto de datos simple para mostrar c√≥mo funciona. Aqu√≠ tenemos algunos datos derivados de babynames donde tenemos el nombre, el g√©nero y la edad de un grupo de personas en un formato bastante extra√±o 5:\n\ndf &lt;- tribble(\n  ~str,\n  \"&lt;Sheryl&gt;-F_34\",\n  \"&lt;Kisha&gt;-F_45\", \n  \"&lt;Brandon&gt;-N_33\",\n  \"&lt;Sharon&gt;-F_38\", \n  \"&lt;Penny&gt;-F_58\",\n  \"&lt;Justin&gt;-M_41\", \n  \"&lt;Patricia&gt;-F_84\", \n)\n\nPara extraer estos datos usando separate_wider_regex() solo necesitamos construir una secuencia de expresiones regulares que coincidan con cada pieza. Si queremos que el contenido de esa pieza aparezca en la salida, le damos un nombre:\n\ndf |&gt; \n  separate_wider_regex(\n    str,\n    patterns = c(\n      \"&lt;\", \n      name = \"[A-Za-z]+\", \n      \"&gt;-\", \n      gender = \".\",\n      \"_\", \n      age = \"[0-9]+\"\n    )\n  )\n#&gt; # A tibble: 7 √ó 3\n#&gt;   name    gender age  \n#&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;\n#&gt; 1 Sheryl  F      34   \n#&gt; 2 Kisha   F      45   \n#&gt; 3 Brandon N      33   \n#&gt; 4 Sharon  F      38   \n#&gt; 5 Penny   F      58   \n#&gt; 6 Justin  M      41   \n#&gt; # ‚Ñπ 1 more row\n\nSi la coincidencia falla, puede usar too_few = \"debug\" para descubrir qu√© sali√≥ mal, al igual que separate_wider_delim() y separate_wider_position().\n\n15.3.5 Ejercicios\n\n¬øQu√© nombre de beb√© tiene m√°s vocales? ¬øQu√© nombre tiene la mayor proporci√≥n de vocales? (Pista: ¬øcu√°l es el denominador?)\nReemplace todas las barras diagonales en \"a/b/c/d/e\" con barras invertidas. ¬øQu√© sucede si intenta deshacer la transformaci√≥n reemplazando todas las barras diagonales inversas con barras diagonales? (Discutiremos el problema muy pronto).\nImplemente una versi√≥n simple de str_to_lower() usando str_replace_all().\nCree una expresi√≥n regular que coincida con los n√∫meros de tel√©fono tal como se escriben com√∫nmente en su pa√≠s.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Expresiones regulares</span>"
    ]
  },
  {
    "objectID": "regexps.html#detalles-del-patr√≥n",
    "href": "regexps.html#detalles-del-patr√≥n",
    "title": "15¬† Expresiones regulares",
    "section": "\n15.4 Detalles del patr√≥n",
    "text": "15.4 Detalles del patr√≥n\nAhora que comprende los conceptos b√°sicos del lenguaje de patrones y c√≥mo usarlo con algunas funciones stringr y tidyr, es hora de profundizar en m√°s detalles. Primero, comenzaremos con escapar, lo que le permite unir metacaracteres que de otro modo ser√≠an tratados de manera especial. A continuaci√≥n, aprender√° sobre anclajes que le permiten hacer coincidir el inicio o el final de la cadena. Luego, aprender√° m√°s sobre las clases de caracteres y sus accesos directos que le permiten hacer coincidir cualquier car√°cter de un conjunto. A continuaci√≥n, conocer√° los detalles finales de los cuantificadores que controlan cu√°ntas veces puede coincidir un patr√≥n. Luego, tenemos que cubrir el tema importante (pero complejo) de precedencia de operadores y par√©ntesis. Y terminaremos con algunos detalles de agrupaci√≥n de componentes de patrones.\nLos t√©rminos que usamos aqu√≠ son los nombres t√©cnicos de cada componente. No siempre son los m√°s evocadores de su prop√≥sito, pero es muy √∫til conocer los t√©rminos correctos si luego desea buscar en Google para obtener m√°s detalles.\n\n15.4.1 Escapar\nPara hacer coincidir un . literal, necesita un escape que le indique a la expresi√≥n regular que coincida con los metacaracteres6 literalmente. Al igual que las cadenas, las expresiones regulares usan la barra invertida para escapar. Entonces, para hacer coincidir un ., necesita la expresi√≥n regular \\.. Desafortunadamente esto crea un problema. Usamos cadenas para representar expresiones regulares, y \\ tambi√©n se usa como s√≠mbolo de escape en cadenas. As√≠ que para crear la expresi√≥n regular \\. necesitamos la cadena \"\\\\.\", como muestra el siguiente ejemplo.\n\n# Para crear la expresi√≥n regular \\., necesitamos usar \\\\.\ndot &lt;- \"\\\\.\"\n\n# Pero la expresi√≥n en s√≠ solo contiene una \\\nstr_view(dot)\n#&gt; [1] ‚îÇ \\.\n\n# Y esto le dice a R que busque una explicita.\nstr_view(c(\"abc\", \"a.c\", \"bef\"), \"a\\\\.c\")\n#&gt; [2] ‚îÇ &lt;a.c&gt;\n\nEn este libro, normalmente escribiremos expresiones regulares sin comillas, como \\.. Si necesitamos enfatizar lo que realmente escribir√°, lo rodearemos con comillas y agregaremos escapes adicionales, como \"\\\\.\".\nSi \\ se usa como un car√°cter de escape en expresiones regulares, ¬øc√≥mo hace coincidir un literal \\? Bueno, necesitas escapar, creando la expresi√≥n regular \\\\. Para crear esa expresi√≥n regular, debe usar una cadena, que tambi√©n debe escapar de \\. Eso significa que para hacer coincidir un \\ literal, debe escribir \"\\\\\\\\\" ‚Äî ¬°necesita cuatro barras diagonales inversas para que coincida con uno!\n\nx &lt;- \"a\\\\b\"\nstr_view(x)\n#&gt; [1] ‚îÇ a\\b\nstr_view(x, \"\\\\\\\\\")\n#&gt; [1] ‚îÇ a&lt;\\&gt;b\n\nAlternativamente, puede que le resulte m√°s f√°cil usar las cadenas sin formato que aprendi√≥ en Secci√≥n 14.2.2). Eso le permite evitar una capa de escape:\n\nstr_view(x, r\"{\\\\}\")\n#&gt; [1] ‚îÇ a&lt;\\&gt;b\n\nSi est√° tratando de hacer coincidir un literal ., $, |, *, +, ?, {, }, (, ), hay una alternativa al uso de un escape de barra invertida: puede usar una clase de car√°cter: [.], [$], [|], ‚Ä¶ todos coinciden con los valores literales.\n\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \"a[.]c\")\n#&gt; [2] ‚îÇ &lt;a.c&gt;\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \".[*]c\")\n#&gt; [3] ‚îÇ &lt;a*c&gt;\n\n\n15.4.2 Anclajes\nDe forma predeterminada, las expresiones regulares coincidir√°n con cualquier parte de una cadena. Si desea hacer coincidir al principio del final, necesita anclar la expresi√≥n regular usando ^ para que coincida con el comienzo de la cadena o $ para que coincida con el final:\n\nstr_view(fruit, \"^a\")\n#&gt; [1] ‚îÇ &lt;a&gt;pple\n#&gt; [2] ‚îÇ &lt;a&gt;pricot\n#&gt; [3] ‚îÇ &lt;a&gt;vocado\nstr_view(fruit, \"a$\")\n#&gt;  [4] ‚îÇ banan&lt;a&gt;\n#&gt; [15] ‚îÇ cherimoy&lt;a&gt;\n#&gt; [30] ‚îÇ feijo&lt;a&gt;\n#&gt; [36] ‚îÇ guav&lt;a&gt;\n#&gt; [56] ‚îÇ papay&lt;a&gt;\n#&gt; [74] ‚îÇ satsum&lt;a&gt;\n\nEs tentador pensar que $ deber√≠a coincidir con el comienzo de una cadena, porque as√≠ es como escribimos cantidades en d√≥lares, pero no es lo que quieren las expresiones regulares.\nPara obligar a una expresi√≥n regular a coincidir solo con la cadena completa, aseg√∫rela con ^ y $:\n\nstr_view(fruit, \"apple\")\n#&gt;  [1] ‚îÇ &lt;apple&gt;\n#&gt; [62] ‚îÇ pine&lt;apple&gt;\nstr_view(fruit, \"^apple$\")\n#&gt; [1] ‚îÇ &lt;apple&gt;\n\nTambi√©n puede hacer coincidir el l√≠mite entre palabras (es decir, el comienzo o el final de una palabra) con \\b. Esto puede ser particularmente √∫til cuando se usa la herramienta de b√∫squeda y reemplazo de RStudio. Por ejemplo, si para encontrar todos los usos de sum(), puede buscar \\bsum\\b para evitar la coincidencia de summarize, summary, rowsum y as√≠ sucesivamente:\n\nx &lt;- c(\"summary(x)\", \"summarize(df)\", \"rowsum(x)\", \"sum(x)\")\nstr_view(x, \"sum\")\n#&gt; [1] ‚îÇ &lt;sum&gt;mary(x)\n#&gt; [2] ‚îÇ &lt;sum&gt;marize(df)\n#&gt; [3] ‚îÇ row&lt;sum&gt;(x)\n#&gt; [4] ‚îÇ &lt;sum&gt;(x)\nstr_view(x, \"\\\\bsum\\\\b\")\n#&gt; [4] ‚îÇ &lt;sum&gt;(x)\n\nCuando se usan solos, los anclajes producir√°n una coincidencia de ancho cero:\n\nstr_view(\"abc\", c(\"$\", \"^\", \"\\\\b\"))\n#&gt; [1] ‚îÇ abc&lt;&gt;\n#&gt; [2] ‚îÇ &lt;&gt;abc\n#&gt; [3] ‚îÇ &lt;&gt;abc&lt;&gt;\n\nEsto lo ayuda a comprender lo que sucede cuando reemplaza un ancla independiente:\n\nstr_replace_all(\"abc\", c(\"$\", \"^\", \"\\\\b\"), \"--\")\n#&gt; [1] \"abc--\"   \"--abc\"   \"--abc--\"\n\n\n15.4.3 Clases de caracteres\nUna clase de car√°cter, o un conjunto de caracteres, le permite hacer coincidir cualquier car√°cter en un conjunto. Como discutimos anteriormente, puede construir sus propios conjuntos con [], donde [abc] coincide con ‚Äúa‚Äù, ‚Äúb‚Äù o ‚Äúc‚Äù y [^abc] coincide con cualquier car√°cter excepto ‚Äúa‚Äù. , ‚Äúb‚Äù o ‚Äúc‚Äù. Adem√°s de ^, hay otros dos caracteres que tienen un significado especial dentro de []:\n\n\n- define un rango, p.ej., [a-z] coincide con cualquier letra min√∫scula y [0-9] coincide con cualquier n√∫mero.\n\n\\ eescapa a los caracteres especiales, por lo que [\\^\\-\\]] coincide ^, -, o ].\n\nAqu√≠ hay algunos ejemplos:\n\nx &lt;- \"abcd ABCD 12345 -!@#%.\"\nstr_view(x, \"[abc]+\")\n#&gt; [1] ‚îÇ &lt;abc&gt;d ABCD 12345 -!@#%.\nstr_view(x, \"[a-z]+\")\n#&gt; [1] ‚îÇ &lt;abcd&gt; ABCD 12345 -!@#%.\nstr_view(x, \"[^a-z0-9]+\")\n#&gt; [1] ‚îÇ abcd&lt; ABCD &gt;12345&lt; -!@#%.&gt;\n\n# Necesita un escape para hacer coincidir caracteres que de otro modo son\n# especial dentro de []\nstr_view(\"a-b-c\", \"[a-c]\")\n#&gt; [1] ‚îÇ &lt;a&gt;-&lt;b&gt;-&lt;c&gt;\nstr_view(\"a-b-c\", \"[a\\\\-c]\")\n#&gt; [1] ‚îÇ &lt;a&gt;&lt;-&gt;b&lt;-&gt;&lt;c&gt;\n\nAlgunas clases de caracteres se usan con tanta frecuencia que obtienen su propio atajo. Ya has visto ., que coincide con cualquier car√°cter excepto una nueva l√≠nea. Hay otros tres pares particularmente √∫tiles7:\n\n\n\\d coincide con cualquier d√≠gito;\\D coincide con cualquier cosa que no sea un d√≠gito.\n\n\\s coincide con cualquier espacio en blanco (por ejemplo, espacio, tabulador, nueva l√≠nea);\\S coincide con cualquier cosa que no sea un espacio en blanco.\n\n\\w coincide con cualquier car√°cter de ‚Äúpalabra‚Äù, es decir, letras y n√∫meros;\\W coincide con cualquier car√°cter ‚Äúno palabra‚Äù.\n\nEl siguiente c√≥digo muestra los seis atajos con una selecci√≥n de letras, n√∫meros y signos de puntuaci√≥n.\n\nx &lt;- \"abcd ABCD 12345 -!@#%.\"\nstr_view(x, \"\\\\d+\")\n#&gt; [1] ‚îÇ abcd ABCD &lt;12345&gt; -!@#%.\nstr_view(x, \"\\\\D+\")\n#&gt; [1] ‚îÇ &lt;abcd ABCD &gt;12345&lt; -!@#%.&gt;\nstr_view(x, \"\\\\s+\")\n#&gt; [1] ‚îÇ abcd&lt; &gt;ABCD&lt; &gt;12345&lt; &gt;-!@#%.\nstr_view(x, \"\\\\S+\")\n#&gt; [1] ‚îÇ &lt;abcd&gt; &lt;ABCD&gt; &lt;12345&gt; &lt;-!@#%.&gt;\nstr_view(x, \"\\\\w+\")\n#&gt; [1] ‚îÇ &lt;abcd&gt; &lt;ABCD&gt; &lt;12345&gt; -!@#%.\nstr_view(x, \"\\\\W+\")\n#&gt; [1] ‚îÇ abcd&lt; &gt;ABCD&lt; &gt;12345&lt; -!@#%.&gt;\n\n\n15.4.4 Cuantificadores\nLos cuantificadores controlan cu√°ntas veces coincide un patr√≥n. En Secci√≥n 15.2, aprendi√≥ sobre ? (0 o 1 coincidencias), + (1 o m√°s coincidencias) y * (0 o m√°s coincidencias). Por ejemplo, colou?r coincidir√° con la ortograf√≠a estadounidense o brit√°nica, \\d+ coincidir√° con uno o m√°s d√≠gitos y \\s? coincidir√° opcionalmente con un √∫nico elemento de espacio en blanco. Tambi√©n puede especificar el n√∫mero de coincidencias con precisi√≥n con {}:\n\n\n{n} coincide exactamente n veces.\n\n{n,} coincide al menos n veces.\n\n{n,m} coincide entre n y m veces.\n\n15.4.5 Precedencia de operadores y par√©ntesis\n¬øCon qu√© coincide ab+? ¬øCoincide con ‚Äúa‚Äù seguido de una o m√°s ‚Äúb‚Äù, o coincide con ‚Äúab‚Äù repetido cualquier n√∫mero de veces? ¬øCon qu√© coincide ^a|b$? ¬øCoincide con la cadena completa a o la cadena completa b, o coincide con una cadena que comienza con a o una cadena que termina con b?\nLa respuesta a estas preguntas est√° determinada por la precedencia de operadores, similar a las reglas PEMDAS o BEDMAS que quiz√°s haya aprendido en la escuela. Sabes que a + b * c es equivalente a a + (b * c) y no (a + b) * c porque * tiene mayor precedencia y + tiene menor precedencia: calculas * antes de +.\nDe manera similar, las expresiones regulares tienen sus propias reglas de precedencia: los cuantificadores tienen una precedencia alta y la alternancia tiene una precedencia baja, lo que significa que ab+ es equivalente a a(b+), y ^a|b$ es equivalente a (^a )|(b$). Al igual que con el √°lgebra, puede usar par√©ntesis para anular el orden habitual. Pero a diferencia del √°lgebra, es poco probable que recuerdes las reglas de precedencia para las expresiones regulares, as√≠ que si√©ntete libre de usar par√©ntesis libremente.\n\n15.4.6 Agrupaci√≥n y captura\nAdem√°s de anular la precedencia de los operadores, los par√©ntesis tienen otro efecto importante: crean grupos de captura que le permiten usar subcomponentes de la coincidencia.\nLa primera forma de usar un grupo de captura es hacer referencia a √©l dentro de una coincidencia con referencia posterior: \\1 se refiere a la coincidencia contenida en el primer par√©ntesis, \\2 en el segundo par√©ntesis, y as√≠ sucesivamente. Por ejemplo, el siguiente patr√≥n encuentra todas las frutas que tienen un par de letras repetido:\n\nstr_view(fruit, \"(..)\\\\1\")\n#&gt;  [4] ‚îÇ b&lt;anan&gt;a\n#&gt; [20] ‚îÇ &lt;coco&gt;nut\n#&gt; [22] ‚îÇ &lt;cucu&gt;mber\n#&gt; [41] ‚îÇ &lt;juju&gt;be\n#&gt; [56] ‚îÇ &lt;papa&gt;ya\n#&gt; [73] ‚îÇ s&lt;alal&gt; berry\n\nY este encuentra todas las palabras que comienzan y terminan con el mismo par de letras:\n\nstr_view(words, \"^(..).*\\\\1$\")\n#&gt; [152] ‚îÇ &lt;church&gt;\n#&gt; [217] ‚îÇ &lt;decide&gt;\n#&gt; [617] ‚îÇ &lt;photograph&gt;\n#&gt; [699] ‚îÇ &lt;require&gt;\n#&gt; [739] ‚îÇ &lt;sense&gt;\n\nTambi√©n puede usar referencias anteriores en str_replace(). Por ejemplo, este c√≥digo cambia el orden de la segunda y tercera palabra en sentences:\n\nsentences |&gt; \n  str_replace(\"(\\\\w+) (\\\\w+) (\\\\w+)\", \"\\\\1 \\\\3 \\\\2\") |&gt; \n  str_view()\n#&gt; [1] ‚îÇ The canoe birch slid on the smooth planks.\n#&gt; [2] ‚îÇ Glue sheet the to the dark blue background.\n#&gt; [3] ‚îÇ It's to easy tell the depth of a well.\n#&gt; [4] ‚îÇ These a days chicken leg is a rare dish.\n#&gt; [5] ‚îÇ Rice often is served in round bowls.\n#&gt; [6] ‚îÇ The of juice lemons makes fine punch.\n#&gt; ... and 714 more\n\nSi desea extraer las coincidencias para cada grupo, puede usar str_match(). Pero str_match() devuelve una matriz, por lo que no es particularmente f√°cil trabajar con 8:\n\nsentences |&gt; \n  str_match(\"the (\\\\w+) (\\\\w+)\") |&gt; \n  head()\n#&gt;      [,1]                [,2]     [,3]    \n#&gt; [1,] \"the smooth planks\" \"smooth\" \"planks\"\n#&gt; [2,] \"the sheet to\"      \"sheet\"  \"to\"    \n#&gt; [3,] \"the depth of\"      \"depth\"  \"of\"    \n#&gt; [4,] NA                  NA       NA      \n#&gt; [5,] NA                  NA       NA      \n#&gt; [6,] NA                  NA       NA\n\nPuede convertir a un tibble y nombrar las columnas:\n\nsentences |&gt; \n  str_match(\"the (\\\\w+) (\\\\w+)\") |&gt; \n  as_tibble(.name_repair = \"minimal\") |&gt; \n  set_names(\"match\", \"word1\", \"word2\")\n#&gt; # A tibble: 720 √ó 3\n#&gt;   match             word1  word2 \n#&gt;   &lt;chr&gt;             &lt;chr&gt;  &lt;chr&gt; \n#&gt; 1 the smooth planks smooth planks\n#&gt; 2 the sheet to      sheet  to    \n#&gt; 3 the depth of      depth  of    \n#&gt; 4 &lt;NA&gt;              &lt;NA&gt;   &lt;NA&gt;  \n#&gt; 5 &lt;NA&gt;              &lt;NA&gt;   &lt;NA&gt;  \n#&gt; 6 &lt;NA&gt;              &lt;NA&gt;   &lt;NA&gt;  \n#&gt; # ‚Ñπ 714 more rows\n\nPero luego b√°sicamente ha recreado su propia versi√≥n de separate_wider_regex(). De hecho, detr√°s de escena, separate_wider_regex() convierte su vector de patrones en una sola expresi√≥n regular que utiliza la agrupaci√≥n para capturar los componentes nombrados.\nOcasionalmente, querr√° usar par√©ntesis sin crear grupos coincidentes. Puede crear un grupo que no captura con (?:).\n\nx &lt;- c(\"a gray cat\", \"a grey dog\")\nstr_match(x, \"gr(e|a)y\")\n#&gt;      [,1]   [,2]\n#&gt; [1,] \"gray\" \"a\" \n#&gt; [2,] \"grey\" \"e\"\nstr_match(x, \"gr(?:e|a)y\")\n#&gt;      [,1]  \n#&gt; [1,] \"gray\"\n#&gt; [2,] \"grey\"\n\n\n15.4.7 Ejercicios\n\n¬øC√≥mo har√≠a coincidir la cadena literal \"'\\? ¬øQu√© tal \"$^$\"?\nExplique por qu√© cada uno de estos patrones no coincide con \\: \"\\\", \"\\\\\", \"\\\\\\\".\n\nDado el corpus de palabras comunes en stringr::words, cree expresiones regulares que encuentren todas las palabras que:\n\nEmpiezan con ‚Äúy‚Äù.\nNo empiezan con ‚Äúy‚Äù.\nTerminan con ‚Äúx‚Äù.\nTienen exactamente tres letras de largo. (¬°No hagas trampa usando str_length()!)\nTener siete letras o m√°s.\nContienen un par de vocales y consonantes.\nContener al menos dos pares de vocales y consonantes seguidos.\nS√≥lo consisten en pares repetidos de vocales y consonantes.\n\n\nCree 11 expresiones regulares que coincidan con la ortograf√≠a brit√°nica o estadounidense para cada una de las siguientes palabras: airplane/aeroplane, aluminum/aluminium, analog/analogue, ass/arse, center/centre, defense/defence, donut/doughnut, gray/grey, modeling/modelling, skeptic/sceptic, summarize/summarise. ¬°Intenta hacer la expresi√≥n regular m√°s corta posible!\nCambia la primera y la √∫ltima letra en palabras. ¬øCu√°les de esas cadenas siguen siendo palabras?\n\nDescriba con palabras con qu√© coinciden estas expresiones regulares: (lea atentamente para ver si cada entrada es una expresi√≥n regular o una cadena que define una expresi√≥n regular).\n\n^.*$\n\"\\\\{.+\\\\}\"\n\\d{4}-\\d{2}-\\d{2}\n\"\\\\\\\\{4}\"\n\\..\\..\\..\n(.)\\1\\1\n\"(..)\\\\1\"\n\n\nResuelva los crucigramas de expresiones regulares para principiantes en https://regexcrossword.com/challenges/beginner.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Expresiones regulares</span>"
    ]
  },
  {
    "objectID": "regexps.html#control-de-patrones",
    "href": "regexps.html#control-de-patrones",
    "title": "15¬† Expresiones regulares",
    "section": "\n15.5 Control de patrones",
    "text": "15.5 Control de patrones\nEs posible ejercer un control adicional sobre los detalles de la coincidencia mediante el uso de un objeto de patr√≥n en lugar de solo una cadena. Esto le permite controlar los llamados indicadores de expresiones regulares y hacer coincidir varios tipos de cadenas fijas, como se describe a continuaci√≥n.\n\n15.5.1 Banderas de expresiones regulares\nHay una serie de configuraciones que se pueden usar para controlar los detalles de la expresi√≥n regular. Estas configuraciones a menudo se denominan banderas en otros lenguajes de programaci√≥n. En stringr, puede usarlos envolviendo el patr√≥n en una llamada a regex(). La bandera m√°s √∫til es probablemente ignore_case = TRUE porque permite que los caracteres coincidan con sus formas may√∫sculas o min√∫sculas:\n\nbananas &lt;- c(\"banana\", \"Banana\", \"BANANA\")\nstr_view(bananas, \"banana\")\n#&gt; [1] ‚îÇ &lt;banana&gt;\nstr_view(bananas, regex(\"banana\", ignore_case = TRUE))\n#&gt; [1] ‚îÇ &lt;banana&gt;\n#&gt; [2] ‚îÇ &lt;Banana&gt;\n#&gt; [3] ‚îÇ &lt;BANANA&gt;\n\nSi est√° trabajando mucho con cadenas multil√≠nea (es decir, cadenas que contienen \\n), dotall y multiline tambi√©n pueden ser √∫tiles:\n\n\ndotall = TRUE permite que . coincida con todo, incluido \\n:\n\nx &lt;- \"Line 1\\nLine 2\\nLine 3\"\nstr_view(x, \".Line\")\nstr_view(x, regex(\".Line\", dotall = TRUE))\n#&gt; [1] ‚îÇ Line 1&lt;\n#&gt;     ‚îÇ Line&gt; 2&lt;\n#&gt;     ‚îÇ Line&gt; 3\n\n\n\nmultiline = TRUE hace que ^ y $ coincidan con el inicio y el final de cada l√≠nea en lugar del inicio y el final de la cadena completa:\n\nx &lt;- \"Line 1\\nLine 2\\nLine 3\"\nstr_view(x, \"^Line\")\n#&gt; [1] ‚îÇ &lt;Line&gt; 1\n#&gt;     ‚îÇ Line 2\n#&gt;     ‚îÇ Line 3\nstr_view(x, regex(\"^Line\", multiline = TRUE))\n#&gt; [1] ‚îÇ &lt;Line&gt; 1\n#&gt;     ‚îÇ &lt;Line&gt; 2\n#&gt;     ‚îÇ &lt;Line&gt; 3\n\n\n\nFinalmente, si est√° escribiendo una expresi√≥n regular complicada y le preocupa no entenderla en el futuro, puede probar comentarios = TRUE. Ajusta el lenguaje de patrones para ignorar los espacios y las l√≠neas nuevas, as√≠ como todo lo que se encuentra despu√©s de #. Esto le permite usar comentarios y espacios en blanco para hacer que las expresiones regulares complejas sean m√°s comprensibles9, como en el siguiente ejemplo:\n\nphone &lt;- regex(\n  r\"(\n    \\(?     # par√©ntesis de apertura opcionales\n    (\\d{3}) # √°rea de codigo\n    [)\\-]?  # par√©ntesis o gui√≥n de cierre opcionales\n    \\ ?     # spacio opcional\n    (\\d{3}) # otros tres n√∫meros\n    [\\ -]?  # espacio o gui√≥n opcional\n    (\\d{4}) # cuatro n√∫meros m√°s\n  )\", \n  comments = TRUE\n)\n\nstr_extract(c(\"514-791-8141\", \"(123) 456 7890\", \"123456\"), phone)\n#&gt; [1] \"514-791-8141\"   \"(123) 456 7890\" NA\n\nSi est√° utilizando comentarios y desea hacer coincidir un espacio, una nueva l√≠nea o #, deber√° escapar con \\.\n\n15.5.2 Coincidencias fijas\nPuede optar por no participar en las reglas de expresiones regulares utilizando fixed():\n\nstr_view(c(\"\", \"a\", \".\"), fixed(\".\"))\n#&gt; [3] ‚îÇ &lt;.&gt;\n\nfixed() tambi√©n le da la posibilidad de ignorar may√∫sculas y min√∫sculas:\n\nstr_view(\"x X\", \"X\")\n#&gt; [1] ‚îÇ x &lt;X&gt;\nstr_view(\"x X\", fixed(\"X\", ignore_case = TRUE))\n#&gt; [1] ‚îÇ &lt;x&gt; &lt;X&gt;\n\nSi est√° trabajando con texto que no est√° en ingl√©s, probablemente querr√° coll() en lugar de fixed(), ya que implementa las reglas completas para el uso de may√∫sculas tal como las usa el locale que especifique. Consulte Secci√≥n 14.6 para obtener m√°s detalles sobre las configuraciones regionales.\n\nstr_view(\"i ƒ∞ ƒ± I\", fixed(\"ƒ∞\", ignore_case = TRUE))\n#&gt; [1] ‚îÇ i &lt;ƒ∞&gt; ƒ± I\nstr_view(\"i ƒ∞ ƒ± I\", coll(\"ƒ∞\", ignore_case = TRUE, locale = \"tr\"))\n#&gt; [1] ‚îÇ &lt;i&gt; &lt;ƒ∞&gt; ƒ± I",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Expresiones regulares</span>"
    ]
  },
  {
    "objectID": "regexps.html#pr√°ctica",
    "href": "regexps.html#pr√°ctica",
    "title": "15¬† Expresiones regulares",
    "section": "\n15.6 Pr√°ctica",
    "text": "15.6 Pr√°ctica\nPara poner en pr√°ctica estas ideas, resolveremos a continuaci√≥n algunos problemas semiaut√©nticos. Discutiremos tres t√©cnicas generales:\n\nComprobar su trabajo mediante la creaci√≥n de controles positivos y negativos simples\nCombinar expresiones regulares con √°lgebra booleana\nCrear patrones complejos usando la manipulaci√≥n de cadenas\n\n\n15.6.1 Revisa tu trabajo\nPrimero, encontremos todas las oraciones que comienzan con The. Usar el ancla ^ solo no es suficiente:\n\nstr_view(sentences, \"^The\")\n#&gt;  [1] ‚îÇ &lt;The&gt; birch canoe slid on the smooth planks.\n#&gt;  [4] ‚îÇ &lt;The&gt;se days a chicken leg is a rare dish.\n#&gt;  [6] ‚îÇ &lt;The&gt; juice of lemons makes fine punch.\n#&gt;  [7] ‚îÇ &lt;The&gt; box was thrown beside the parked truck.\n#&gt;  [8] ‚îÇ &lt;The&gt; hogs were fed chopped corn and garbage.\n#&gt; [11] ‚îÇ &lt;The&gt; boy was there when the sun rose.\n#&gt; ... and 271 more\n\nPorque ese patr√≥n tambi√©n coincide con oraciones que comienzan con palabras como They o These. Necesitamos asegurarnos de que la ‚Äúe‚Äù sea la √∫ltima letra de la palabra, lo que podemos hacer agregando un l√≠mite de palabra:\n\nstr_view(sentences, \"^The\\\\b\")\n#&gt;  [1] ‚îÇ &lt;The&gt; birch canoe slid on the smooth planks.\n#&gt;  [6] ‚îÇ &lt;The&gt; juice of lemons makes fine punch.\n#&gt;  [7] ‚îÇ &lt;The&gt; box was thrown beside the parked truck.\n#&gt;  [8] ‚îÇ &lt;The&gt; hogs were fed chopped corn and garbage.\n#&gt; [11] ‚îÇ &lt;The&gt; boy was there when the sun rose.\n#&gt; [13] ‚îÇ &lt;The&gt; source of the huge river is the clear spring.\n#&gt; ... and 250 more\n\n¬øQu√© hay de encontrar todas las oraciones que comienzan con un pronombre?\n\nstr_view(sentences, \"^She|He|It|They\\\\b\")\n#&gt;  [3] ‚îÇ &lt;It&gt;'s easy to tell the depth of a well.\n#&gt; [15] ‚îÇ &lt;He&gt;lp the woman get back to her feet.\n#&gt; [27] ‚îÇ &lt;He&gt;r purse was full of useless trash.\n#&gt; [29] ‚îÇ &lt;It&gt; snowed, rained, and hailed the same morning.\n#&gt; [63] ‚îÇ &lt;He&gt; ran half way to the hardware store.\n#&gt; [90] ‚îÇ &lt;He&gt; lay prone and hardly moved a limb.\n#&gt; ... and 57 more\n\nUna inspecci√≥n r√°pida de los resultados muestra que estamos obteniendo algunas coincidencias falsas. Eso es porque nos hemos olvidado de usar par√©ntesis:\n\nstr_view(sentences, \"^(She|He|It|They)\\\\b\")\n#&gt;   [3] ‚îÇ &lt;It&gt;'s easy to tell the depth of a well.\n#&gt;  [29] ‚îÇ &lt;It&gt; snowed, rained, and hailed the same morning.\n#&gt;  [63] ‚îÇ &lt;He&gt; ran half way to the hardware store.\n#&gt;  [90] ‚îÇ &lt;He&gt; lay prone and hardly moved a limb.\n#&gt; [116] ‚îÇ &lt;He&gt; ordered peach pie with ice cream.\n#&gt; [127] ‚îÇ &lt;It&gt; caught its hind paw in a rusty trap.\n#&gt; ... and 51 more\n\nQuiz√°s se pregunte c√≥mo podr√≠a detectar tal error si no ocurri√≥ en las primeras coincidencias. Una buena t√©cnica es crear algunas coincidencias positivas y negativas y usarlas para probar que su patr√≥n funciona como se esperaba:\n\npos &lt;- c(\"He is a boy\", \"She had a good time\")\nneg &lt;- c(\"Shells come from the sea\", \"Hadley said 'It's a great day'\")\n\npattern &lt;- \"^(She|He|It|They)\\\\b\"\nstr_detect(pos, pattern)\n#&gt; [1] TRUE TRUE\nstr_detect(neg, pattern)\n#&gt; [1] FALSE FALSE\n\nPor lo general, es mucho m√°s f√°cil encontrar buenos ejemplos positivos que ejemplos negativos, porque toma un tiempo antes de que seas lo suficientemente bueno con las expresiones regulares para predecir d√≥nde est√°n tus debilidades. Sin embargo, siguen siendo √∫tiles: a medida que trabaja en el problema, puede acumular lentamente una colecci√≥n de sus errores, asegur√°ndose de que nunca cometer√° el mismo error dos veces.\n\n15.6.2 Operaciones booleanas\nImagina que queremos encontrar palabras que solo contengan consonantes. Una t√©cnica es crear una clase de car√°cter que contenga todas las letras excepto las vocales ([^aeiou]), luego permitir que coincida con cualquier n√∫mero de letras ([^aeiou]+), luego forzarlo a que coincida con el toda la cadena ancl√°ndola al principio y al final (^[^aeiou]+$):\n\nstr_view(words, \"^[^aeiou]+$\")\n#&gt; [123] ‚îÇ &lt;by&gt;\n#&gt; [249] ‚îÇ &lt;dry&gt;\n#&gt; [328] ‚îÇ &lt;fly&gt;\n#&gt; [538] ‚îÇ &lt;mrs&gt;\n#&gt; [895] ‚îÇ &lt;try&gt;\n#&gt; [952] ‚îÇ &lt;why&gt;\n\nPero puedes hacer que este problema sea un poco m√°s f√°cil d√°ndole la vuelta al problema. En lugar de buscar palabras que contengan solo consonantes, podr√≠amos buscar palabras que no contengan vocales:\n\nstr_view(words[!str_detect(words, \"[aeiou]\")])\n#&gt; [1] ‚îÇ by\n#&gt; [2] ‚îÇ dry\n#&gt; [3] ‚îÇ fly\n#&gt; [4] ‚îÇ mrs\n#&gt; [5] ‚îÇ try\n#&gt; [6] ‚îÇ why\n\nEsta es una t√©cnica √∫til siempre que se trate de combinaciones l√≥gicas, particularmente aquellas que involucran ‚Äúy‚Äù o ‚Äúno‚Äù. Por ejemplo, imagina si quieres encontrar todas las palabras que contienen ‚Äúa‚Äù y ‚Äúb‚Äù. No hay un operador ‚Äúy‚Äù integrado en las expresiones regulares, por lo que debemos abordarlo buscando todas las palabras que contengan una ‚Äúa‚Äù seguida de una ‚Äúb‚Äù o una ‚Äúb‚Äù seguida de una ‚Äúa‚Äù:\n\nstr_view(words, \"a.*b|b.*a\")\n#&gt;  [2] ‚îÇ &lt;ab&gt;le\n#&gt;  [3] ‚îÇ &lt;ab&gt;out\n#&gt;  [4] ‚îÇ &lt;ab&gt;solute\n#&gt; [62] ‚îÇ &lt;availab&gt;le\n#&gt; [66] ‚îÇ &lt;ba&gt;by\n#&gt; [67] ‚îÇ &lt;ba&gt;ck\n#&gt; ... and 24 more\n\nEs m√°s sencillo combinar los resultados de dos llamadas para str_detect():\n\nwords[str_detect(words, \"a\") & str_detect(words, \"b\")]\n#&gt;  [1] \"able\"      \"about\"     \"absolute\"  \"available\" \"baby\"      \"back\"     \n#&gt;  [7] \"bad\"       \"bag\"       \"balance\"   \"ball\"      \"bank\"      \"bar\"      \n#&gt; [13] \"base\"      \"basis\"     \"bear\"      \"beat\"      \"beauty\"    \"because\"  \n#&gt; [19] \"black\"     \"board\"     \"boat\"      \"break\"     \"brilliant\" \"britain\"  \n#&gt; [25] \"debate\"    \"husband\"   \"labour\"    \"maybe\"     \"probable\"  \"table\"\n\n¬øQu√© pasar√≠a si quisi√©ramos ver si hay una palabra que contiene todas las vocales? ¬°Si lo hici√©ramos con patrones, necesitar√≠amos generar 5! (120) patrones diferentes:\n\nwords[str_detect(words, \"a.*e.*i.*o.*u\")]\n# ...\nwords[str_detect(words, \"u.*o.*i.*e.*a\")]\n\nEs mucho m√°s sencillo combinar cinco llamadas para str_detect():\n\nwords[\n  str_detect(words, \"a\") &\n  str_detect(words, \"e\") &\n  str_detect(words, \"i\") &\n  str_detect(words, \"o\") &\n  str_detect(words, \"u\")\n]\n#&gt; character(0)\n\nEn general, si te quedas atascado tratando de crear una √∫nica expresi√≥n regular que resuelva tu problema, da un paso atr√°s y piensa si podr√≠as dividir el problema en partes m√°s peque√±as, resolviendo cada desaf√≠o antes de pasar al siguiente.\n\n15.6.3 Crear un patr√≥n con c√≥digo\n¬øQu√© pasar√≠a si quisi√©ramos encontrar todas las ‚Äòoraciones‚Äô que mencionan un color? La idea b√°sica es simple: simplemente combinamos alternancia con l√≠mites de palabras.\n\nstr_view(sentences, \"\\\\b(red|green|blue)\\\\b\")\n#&gt;   [2] ‚îÇ Glue the sheet to the dark &lt;blue&gt; background.\n#&gt;  [26] ‚îÇ Two &lt;blue&gt; fish swam in the tank.\n#&gt;  [92] ‚îÇ A wisp of cloud hung in the &lt;blue&gt; air.\n#&gt; [148] ‚îÇ The spot on the blotter was made by &lt;green&gt; ink.\n#&gt; [160] ‚îÇ The sofa cushion is &lt;red&gt; and of light weight.\n#&gt; [174] ‚îÇ The sky that morning was clear and bright &lt;blue&gt;.\n#&gt; ... and 20 more\n\nPero a medida que aumenta la cantidad de colores, r√°pidamente se vuelve tedioso construir este patr√≥n a mano. ¬øNo ser√≠a bueno si pudi√©ramos almacenar los colores en un vector?\n\nrgb &lt;- c(\"red\", \"green\", \"blue\")\n\nBueno, ¬°podemos! Solo necesitamos crear el patr√≥n a partir del vector usando str_c() y str_flatten():\n\nstr_c(\"\\\\b(\", str_flatten(rgb, \"|\"), \")\\\\b\")\n#&gt; [1] \"\\\\b(red|green|blue)\\\\b\"\n\nPodr√≠amos hacer este patr√≥n m√°s completo si tuvi√©ramos una buena lista de colores. Un lugar desde el que podr√≠amos comenzar es la lista de colores incorporados que R puede usar para los gr√°ficos:\n\nstr_view(colors())\n#&gt; [1] ‚îÇ white\n#&gt; [2] ‚îÇ aliceblue\n#&gt; [3] ‚îÇ antiquewhite\n#&gt; [4] ‚îÇ antiquewhite1\n#&gt; [5] ‚îÇ antiquewhite2\n#&gt; [6] ‚îÇ antiquewhite3\n#&gt; ... and 651 more\n\nPero primero eliminemos las variantes numeradas:\n\ncols &lt;- colors()\ncols &lt;- cols[!str_detect(cols, \"\\\\d\")]\nstr_view(cols)\n#&gt; [1] ‚îÇ white\n#&gt; [2] ‚îÇ aliceblue\n#&gt; [3] ‚îÇ antiquewhite\n#&gt; [4] ‚îÇ aquamarine\n#&gt; [5] ‚îÇ azure\n#&gt; [6] ‚îÇ beige\n#&gt; ... and 137 more\n\nEntonces podemos convertir esto en un patr√≥n gigante. No mostraremos el patr√≥n aqu√≠ porque es enorme, pero puedes verlo funcionar:\n\npattern &lt;- str_c(\"\\\\b(\", str_flatten(cols, \"|\"), \")\\\\b\")\nstr_view(sentences, pattern)\n#&gt;   [2] ‚îÇ Glue the sheet to the dark &lt;blue&gt; background.\n#&gt;  [12] ‚îÇ A rod is used to catch &lt;pink&gt; &lt;salmon&gt;.\n#&gt;  [26] ‚îÇ Two &lt;blue&gt; fish swam in the tank.\n#&gt;  [66] ‚îÇ Cars and busses stalled in &lt;snow&gt; drifts.\n#&gt;  [92] ‚îÇ A wisp of cloud hung in the &lt;blue&gt; air.\n#&gt; [112] ‚îÇ Leaves turn &lt;brown&gt; and &lt;yellow&gt; in the fall.\n#&gt; ... and 57 more\n\nEn este ejemplo, cols solo contiene n√∫meros y letras, por lo que no debe preocuparse por los metacaracteres. Pero, en general, siempre que cree patrones a partir de cadenas existentes, es aconsejable ejecutarlos a trav√©s de str_escape() para asegurarse de que coincidan literalmente.\n\n15.6.4 Ejercicios\n\n\nPara cada uno de los siguientes desaf√≠os, intente resolverlos usando una sola expresi√≥n regular y una combinaci√≥n de m√∫ltiples llamadas str_detect().\n\nEncuentra todas las palabras que comienzan o terminan con x.\nEncuentra todas las palabras que comienzan con una vocal y terminan con una consonante.\n¬øHay alguna palabra que contenga al menos una de cada vocal diferente?\n\n\n¬øConstruye patrones para encontrar evidencia a favor y en contra de la regla ‚Äúi antes de e excepto despu√©s de c‚Äù?\ncolors() contiene una serie de modificadores como ‚Äúlightgray‚Äù y ‚Äúdarkblue‚Äù. ¬øC√≥mo podr√≠a identificar autom√°ticamente estos modificadores? (Piense en c√≥mo podr√≠a detectar y luego eliminar los colores que se modifican).\nCree una expresi√≥n regular que encuentre cualquier conjunto de datos base de R. Puede obtener una lista de estos conjuntos de datos mediante un uso especial de la funci√≥n data(): data(package = \"datasets\")$results[, \"Item\"]. Tenga en cuenta que varios conjuntos de datos antiguos son vectores individuales; estos contienen el nombre del ‚Äúdata frame‚Äù de agrupaci√≥n entre par√©ntesis, por lo que deber√° eliminarlos.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Expresiones regulares</span>"
    ]
  },
  {
    "objectID": "regexps.html#expresiones-regulares-en-otros-lugares",
    "href": "regexps.html#expresiones-regulares-en-otros-lugares",
    "title": "15¬† Expresiones regulares",
    "section": "\n15.7 Expresiones regulares en otros lugares",
    "text": "15.7 Expresiones regulares en otros lugares\nAl igual que en las funciones stringr y tidyr, hay muchos otros lugares en R donde puede usar expresiones regulares. Las siguientes secciones describen algunas otras funciones √∫tiles en el tidyverse m√°s amplio y la base R.\n\n15.7.1 tidyverse\nHay otros tres lugares particularmente √∫tiles en los que es posible que desee utilizar expresiones regulares\n\nmatches(pattern) seleccionar√° todas las variables cuyo nombre coincida con el patr√≥n proporcionado. Es una funci√≥n ‚Äútidyselect‚Äù que puede usar en cualquier lugar en cualquier funci√≥n tidyverse que seleccione variables (p.ej., select(), rename_with() y across()).\npivot_longer()'s names_pattern aargumento toma un vector de expresiones regulares, al igual que separate_wider_regex(). Es √∫til cuando se extraen datos de nombres de variables con una estructura compleja.\nEl argumento delim en separate_longer_delim() y separate_wider_delim() generalmente coincide con una cadena fija, pero puede usar regex() para que coincida con un patr√≥n. Esto es √∫til, por ejemplo, si desea hacer coincidir una coma seguida opcionalmente por un espacio, es decir, regex(\", ?\").\n\n15.7.2 R base\napropos(pattern) busca todos los objetos disponibles del entorno global que coincidan con el patr√≥n dado. Esto es √∫til si no puede recordar el nombre de una funci√≥n:\n\napropos(\"replace\")\n#&gt; [1] \"%+replace%\"       \"replace\"          \"replace_na\"      \n#&gt; [4] \"setReplaceMethod\" \"str_replace\"      \"str_replace_all\" \n#&gt; [7] \"str_replace_na\"   \"theme_replace\"\n\nlist.files(path, pattern) enumera todos los archivos en path que coinciden con una expresi√≥n regular pattern. Por ejemplo, puede encontrar todos los archivos R Markdown en el directorio actual con:\n\nhead(list.files(pattern = \"\\\\.Rmd$\"))\n#&gt; character(0)\n\nVale la pena se√±alar que el lenguaje de patrones usado por base R es ligeramente diferente al usado por stringr. Esto se debe a que stringr est√° construido sobre el paquete stringi, que a su vez est√° construido sobre el motor ICU, mientras que las funciones b√°sicas de R usan el motor TRE o el motor PCRE, dependiendo de si ha establecido o no perl = TRUE. Afortunadamente, los conceptos b√°sicos de las expresiones regulares est√°n tan bien establecidos que encontrar√° pocas variaciones cuando trabaje con los patrones que aprender√° en este libro. Solo debe ser consciente de la diferencia cuando comience a confiar en funciones avanzadas como rangos de caracteres Unicode complejos o funciones especiales que usan la sintaxis (?‚Ä¶).",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Expresiones regulares</span>"
    ]
  },
  {
    "objectID": "regexps.html#resumen",
    "href": "regexps.html#resumen",
    "title": "15¬† Expresiones regulares",
    "section": "\n15.8 Resumen",
    "text": "15.8 Resumen\nCon cada car√°cter de puntuaci√≥n potencialmente sobrecargado de significado, las expresiones regulares son uno de los lenguajes m√°s compactos que existen. Definitivamente son confusos al principio, pero a medida que entrenas tus ojos para leerlos y tu cerebro para entenderlos, desbloqueas una habilidad poderosa que puedes usar en R y en muchos otros lugares.\nEn este cap√≠tulo, ha comenzado su viaje para convertirse en un maestro de las expresiones regulares aprendiendo las funciones m√°s √∫tiles de stringr y los componentes m√°s importantes del lenguaje de expresiones regulares. Y hay muchos recursos para aprender m√°s.\nUn buen lugar para comenzar es vignette(\"regular-expressions\", package = \"stringr\"): documenta el conjunto completo de sintaxis compatible con stringr. Otra referencia √∫til es https://www.regular-expressions.info/. No es espec√≠fico de R, pero puede usarlo para conocer las caracter√≠sticas m√°s avanzadas de las expresiones regulares y c√≥mo funcionan bajo el cap√≥.\nTambi√©n es bueno saber que stringr est√° implementado sobre el paquete stringi por Marek Gagolewski. Si tiene dificultades para encontrar una funci√≥n que haga lo que necesita en stringr, no tenga miedo de buscar en stringi. Encontrar√° que stringi es muy f√°cil de aprender porque sigue muchas de las mismas convenciones que stringr.\nEn el pr√≥ximo cap√≠tulo, hablaremos sobre una estructura de datos estrechamente relacionada con las cadenas: los factores. Los factores se utilizan para representar datos categ√≥ricos en R, es decir, datos con un conjunto fijo y conocido de valores posibles identificados por un vector de cadenas.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Expresiones regulares</span>"
    ]
  },
  {
    "objectID": "regexps.html#footnotes",
    "href": "regexps.html#footnotes",
    "title": "15¬† Expresiones regulares",
    "section": "",
    "text": "Puede pronunciarlo con una g dura (reg-x) o una g suave (rej-x).‚Ü©Ô∏é\nAprender√° c√≥mo escapar de estos significados especiales en Secci√≥n 15.4.1.‚Ü©Ô∏é\nBueno, cualquier car√°cter aparte de \\n.‚Ü©Ô∏é\nEsto nos da la proporci√≥n de nombres que contienen una ‚Äúx‚Äù; si quisiera la proporci√≥n de beb√©s con un nombre que contiene una x, necesitar√≠a realizar una media ponderada.‚Ü©Ô∏é\nDesear√≠amos poder asegurarle que nunca ver√° algo tan extra√±o en la vida real, pero desafortunadamente en el transcurso de su carrera es probable que vea cosas mucho m√°s extra√±as.‚Ü©Ô∏é\nEl conjunto completo de metacaracteres es .^$\\|*+?{}[]()‚Ü©Ô∏é\nRecuerde, para crear una expresi√≥n regular que contenga \\d o \\s, deber√° escapar del \\ para la cadena, por lo que escribir√° \"\\\\d\" o \"\\\\s \".‚Ü©Ô∏é\ncomments = TRUE es particularmente efectivo en combinaci√≥n con una cadena sin procesar, como la que usamos aqu√≠.‚Ü©Ô∏é\ncomments = TRUE es particularmente efectivo en combinaci√≥n con una cadena sin procesar, como la que usamos aqu√≠.‚Ü©Ô∏é",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Expresiones regulares</span>"
    ]
  },
  {
    "objectID": "factors.html",
    "href": "factors.html",
    "title": "16¬† Factores",
    "section": "",
    "text": "16.1 Introducci√≥n\nLos factores se utilizan para variables categ√≥ricas, variables que tienen un conjunto fijo y conocido de valores posibles. Tambi√©n son √∫tiles cuando desea mostrar vectores de caracteres en un orden no alfab√©tico.\nComenzaremos explicando por qu√© se necesitan factores para el an√°lisis de datos1 y c√≥mo puede crearlos con factor(). Luego le presentaremos el conjunto de datos gss_cat que contiene un mont√≥n de variables categ√≥ricas para experimentar. Luego usar√° ese conjunto de datos para practicar la modificaci√≥n del orden y los valores de los factores, antes de que terminemos con una discusi√≥n sobre los factores ordenados.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Factores</span>"
    ]
  },
  {
    "objectID": "factors.html#introducci√≥n",
    "href": "factors.html#introducci√≥n",
    "title": "16¬† Factores",
    "section": "",
    "text": "16.1.1 Requisitos previos\nBase R proporciona algunas herramientas b√°sicas para crear y manipular factores. Los complementaremos con el paquete forcats, que es parte del tidyverse principal. Proporciona herramientas para tratar con variables categ√≥ricas (¬°y es un anagrama de factores!) usando una amplia gama de ayudantes para trabajar con factores.\n\nlibrary(tidyverse)",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Factores</span>"
    ]
  },
  {
    "objectID": "factors.html#fundamentos-de-los-factores",
    "href": "factors.html#fundamentos-de-los-factores",
    "title": "16¬† Factores",
    "section": "\n16.2 Fundamentos de los factores",
    "text": "16.2 Fundamentos de los factores\nImagina que tienes una variable que registra el mes:\n\nx1 &lt;- c(\"Dic\", \"Abr\", \"Ene\", \"Mar\")\n\nUsar una cadena para registrar esta variable tiene dos problemas:\n\n\nSolo hay doce meses posibles, y no hay nada que lo salve de los errores tipogr√°ficos:\n\nx2 &lt;- c(\"Dic\", \"Abr\", \"Eme\", \"Mar\")\n\n\n\nNo ordena de una manera √∫til:\n\nsort(x1)\n#&gt; [1] \"Abr\" \"Dic\" \"Ene\" \"Mar\"\n\n\n\nPuede solucionar ambos problemas con un factor. Para crear un factor, debe comenzar creando una lista de los niveles (levels) v√°lidos:\n\nmeses_levels &lt;- c(\n  \"Ene\", \"Feb\", \"Mar\", \"Abr\", \"May\", \"Jun\", \n  \"Jul\", \"Ago\", \"Sep\", \"Oct\", \"Nov\", \"Dic\"\n)\n\nAhora puedes crear un factor:\n\ny1 &lt;- factor(x1, levels = meses_levels)\ny1\n#&gt; [1] Dic Abr Ene Mar\n#&gt; Levels: Ene Feb Mar Abr May Jun Jul Ago Sep Oct Nov Dic\n\nsort(y1)\n#&gt; [1] Ene Mar Abr Dic\n#&gt; Levels: Ene Feb Mar Abr May Jun Jul Ago Sep Oct Nov Dic\n\nY cualquier valor que no est√© en el nivel se convertir√° silenciosamente a NA:\n\ny2 &lt;- factor(x2, levels = meses_levels)\ny2\n#&gt; [1] Dic  Abr  &lt;NA&gt; Mar \n#&gt; Levels: Ene Feb Mar Abr May Jun Jul Ago Sep Oct Nov Dic\n\nEsto parece arriesgado, por lo que es posible que desee utilizar forcats::fct() en su lugar:\n\ny2 &lt;- fct(x2, levels = meses_levels)\n#&gt; Error in `fct()`:\n#&gt; ! All values of `x` must appear in `levels` or `na`\n#&gt; ‚Ñπ Missing level: \"Eme\"\n\nSi omite los niveles, se tomar√°n de los datos en orden alfab√©tico:\n\nfactor(x1)\n#&gt; [1] Dic Abr Ene Mar\n#&gt; Levels: Abr Dic Ene Mar\n\nOrdenar alfab√©ticamente es un poco arriesgado porque no todas las computadoras ordenar√°n las cadenas de la misma manera. Entonces forcats::fct() ordena por primera aparici√≥n:\n\nfct(x1)\n#&gt; [1] Dic Abr Ene Mar\n#&gt; Levels: Dic Abr Ene Mar\n\nSi alguna vez necesita acceder directamente al conjunto de niveles v√°lidos, puede hacerlo con levels():\n\nlevels(y2)\n#&gt;  [1] \"Ene\" \"Feb\" \"Mar\" \"Abr\" \"May\" \"Jun\" \"Jul\" \"Ago\" \"Sep\" \"Oct\" \"Nov\" \"Dic\"\n\nTambi√©n puedes crear un factor al leer tus datos con readr con col_factor():\n\ncsv &lt;- \"\nmonth,value\nJan,12\nFeb,56\nMar,12\"\n\ndf &lt;- read_csv(csv, col_types = cols(month = col_factor(meses_levels)))\n#&gt; Warning: One or more parsing issues, call `problems()` on your data frame for\n#&gt; details, e.g.:\n#&gt;   dat &lt;- vroom(...)\n#&gt;   problems(dat)\ndf$month\n#&gt; [1] &lt;NA&gt; Feb  Mar \n#&gt; Levels: Ene Feb Mar Abr May Jun Jul Ago Sep Oct Nov Dic",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Factores</span>"
    ]
  },
  {
    "objectID": "factors.html#encuesta-social-general",
    "href": "factors.html#encuesta-social-general",
    "title": "16¬† Factores",
    "section": "\n16.3 Encuesta Social General",
    "text": "16.3 Encuesta Social General\nPara el resto de este cap√≠tulo, usaremos forcats::gss_cat. Es una muestra de datos de la Encuesta Social General, una encuesta estadounidense de larga duraci√≥n realizada por la organizaci√≥n de investigaci√≥n independiente NORC en la Universidad de Chicago. La encuesta tiene miles de preguntas, por lo que en gss_cat Hadley seleccion√≥ algunas que ilustrar√°n algunos desaf√≠os comunes que encontrar√° al trabajar con factores.\n\ngss_cat\n#&gt; # A tibble: 21,483 √ó 9\n#&gt;    year marital         age race  rincome        partyid           \n#&gt;   &lt;int&gt; &lt;fct&gt;         &lt;int&gt; &lt;fct&gt; &lt;fct&gt;          &lt;fct&gt;             \n#&gt; 1  2000 Never married    26 White $8000 to 9999  Ind,near rep      \n#&gt; 2  2000 Divorced         48 White $8000 to 9999  Not str republican\n#&gt; 3  2000 Widowed          67 White Not applicable Independent       \n#&gt; 4  2000 Never married    39 White Not applicable Ind,near rep      \n#&gt; 5  2000 Divorced         25 White Not applicable Not str democrat  \n#&gt; 6  2000 Married          25 White $20000 - 24999 Strong democrat   \n#&gt; # ‚Ñπ 21,477 more rows\n#&gt; # ‚Ñπ 3 more variables: relig &lt;fct&gt;, denom &lt;fct&gt;, tvhours &lt;int&gt;\n\n(Recuerde, dado que este conjunto de datos lo proporciona un paquete, puede obtener m√°s informaci√≥n sobre las variables con ?gss_cat.)\nCuando los factores se almacenan en un tibble, no puede ver sus niveles tan f√°cilmente. Una forma de verlos es con count():\n\ngss_cat |&gt;\n  count(race)\n#&gt; # A tibble: 3 √ó 2\n#&gt;   race      n\n#&gt;   &lt;fct&gt; &lt;int&gt;\n#&gt; 1 Other  1959\n#&gt; 2 Black  3129\n#&gt; 3 White 16395\n\nCuando se trabaja con factores, las dos operaciones m√°s comunes son cambiar el orden de los niveles y cambiar los valores de los niveles. Esas operaciones se describen en las secciones siguientes.\n\n16.3.1 Ejercicios\n\nExplore la distribuci√≥n de rincome (ingresos declarados). ¬øQu√© hace que el gr√°fico de barras predeterminado sea dif√≠cil de entender? ¬øC√≥mo podr√≠as mejorar la gr√°fica?\n¬øCu√°l es la relig m√°s com√∫n en esta encuesta? ¬øCu√°l es el partyid m√°s com√∫n?\n¬øA qu√© relig se aplica denom (denominaci√≥n)? ¬øC√≥mo puedes averiguarlo con una tabla? ¬øC√≥mo puedes averiguarlo con una visualizaci√≥n?",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Factores</span>"
    ]
  },
  {
    "objectID": "factors.html#sec-modifying-factor-order",
    "href": "factors.html#sec-modifying-factor-order",
    "title": "16¬† Factores",
    "section": "\n16.4 Modificaci√≥n del orden de los factores",
    "text": "16.4 Modificaci√≥n del orden de los factores\nSuele ser √∫til cambiar el orden de los niveles de los factores en una visualizaci√≥n. Por ejemplo, imagine que desea explorar la cantidad promedio de horas que pasan viendo televisi√≥n por d√≠a en todas las religiones:\n\nrelig_summary &lt;- gss_cat |&gt;\n  group_by(relig) |&gt;\n  summarize(\n    tvhours = mean(tvhours, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(relig_summary, aes(x = tvhours, y = relig)) + \n  geom_point()\n\n\n\n\n\n\n\nEs dif√≠cil leer esta trama porque no hay un patr√≥n general. Podemos mejorarlo reordenando los niveles de relig usando fct_reorder(). fct_reorder() toma tres argumentos:\n\n\n.f, el factor cuyos niveles desea modificar.\n\n.x, un vector num√©rico que desea utilizar para reordenar los niveles.\nOpcionalmente, .fun, una funci√≥n que se usa si hay varios valores de .x para cada valor de .f. El valor predeterminado es median.\n\n\nggplot(relig_summary, aes(x = tvhours, y = fct_reorder(relig, tvhours))) +\n  geom_point()\n\n\n\n\n\n\n\nReordenar la religi√≥n hace que sea mucho m√°s f√°cil ver que las personas en la categor√≠a ‚ÄúNo s√©‚Äù ven mucha m√°s televisi√≥n, y el hinduismo y otras religiones orientales ven mucho menos.\nA medida que comience a realizar transformaciones m√°s complicadas, le recomendamos que las saque de aes() y las lleve a un paso separado de mutate(). Por ejemplo, podr√≠a reescribir el gr√°fico anterior como:\n\nrelig_summary |&gt;\n  mutate(\n    relig = fct_reorder(relig, tvhours)\n  ) |&gt;\n  ggplot(aes(x = tvhours, y = relig)) +\n  geom_point()\n\n¬øQu√© sucede si creamos una gr√°fica similar que observa c√≥mo var√≠a la edad promedio seg√∫n el nivel de ingresos informado?\n\nrincome_summary &lt;- gss_cat |&gt;\n  group_by(rincome) |&gt;\n  summarize(\n    age = mean(age, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(rincome_summary, aes(x = age, y = fct_reorder(rincome, age))) + \n  geom_point()\n\n\n\n\n\n\n\n¬°Aqu√≠, reordenar arbitrariamente los niveles no es una buena idea! Esto se debe a que rincome ya tiene un orden de principios con el que no debemos meternos. Reserve fct_reorder() para factores cuyos niveles est√©n ordenados arbitrariamente.\nSin embargo, tiene sentido poner ‚ÄúNo aplicable‚Äù al frente con los otros niveles especiales. Puedes usar fct_relevel(). Se necesita un factor, .f, y luego cualquier cantidad de niveles que desee mover al frente de la fila.\n\nggplot(rincome_summary, aes(x = age, y = fct_relevel(rincome, \"No aplicable\"))) +\n  geom_point()\n#&gt; Warning: 1 unknown level in `f`: No aplicable\n\n\n\n\n\n\n\n¬øPor qu√© cree que la edad promedio para ‚ÄúNo aplicable‚Äù es tan alta?\nOtro tipo de reordenaci√≥n es √∫til cuando colorea las l√≠neas de un gr√°fico. fct_reorder2(.f, .x, .y) reordena el factor .f por los valores .y asociados con los valores .x m√°s grandes. Esto hace que el gr√°fico sea m√°s f√°cil de leer porque los colores de la l√≠nea en el extremo derecho del gr√°fico se alinear√°n con la leyenda.\nby_age &lt;- gss_cat |&gt;\n  filter(!is.na(age)) |&gt; \n  count(age, marital) |&gt;\n  group_by(age) |&gt;\n  mutate(\n    prop = n / sum(n)\n  )\n\nggplot(by_age, aes(x = age, y = prop, color = marital)) +\n  geom_line(linewidth = 1) + \n  scale_color_brewer(palette = \"Set1\")\n\nggplot(by_age, aes(x = age, y = prop, color = fct_reorder2(marital, age, prop))) +\n  geom_line(linewidth = 1) +\n  scale_color_brewer(palette = \"Set1\") + \n  labs(color = \"marital\") \n\n\n\n\n\n\n\n\n\n\nFinalmente, para gr√°ficos de barras, puede usar fct_infreq() para ordenar niveles en frecuencia decreciente: este es el tipo m√°s simple de reordenamiento porque no necesita variables adicionales. Comb√≠nelo con fct_rev() si los quiere en frecuencia creciente para que en el gr√°fico de barras los valores m√°s grandes est√©n a la derecha, no a la izquierda.\n\ngss_cat |&gt;\n  mutate(marital = marital |&gt; fct_infreq() |&gt; fct_rev()) |&gt;\n  ggplot(aes(x = marital)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n16.4.1 Ejercicios\n\nHay algunos n√∫meros sospechosamente altos en tvhours. ¬øEs la media un buen resumen?\nPara cada factor en gss_cat, identifique si el orden de los niveles es arbitrario o basado en principios.\n¬øPor qu√© mover ‚ÄúNo aplicable‚Äù al frente de los niveles lo movi√≥ al final de la gr√°fica?",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Factores</span>"
    ]
  },
  {
    "objectID": "factors.html#modificar-los-niveles-de-los-factores",
    "href": "factors.html#modificar-los-niveles-de-los-factores",
    "title": "16¬† Factores",
    "section": "\n16.5 Modificar los niveles de los factores",
    "text": "16.5 Modificar los niveles de los factores\nM√°s poderoso que cambiar el orden de los niveles es cambiar sus valores. Esto le permite aclarar etiquetas para publicaci√≥n y contraer niveles para visualizaciones de alto nivel. La herramienta m√°s general y poderosa es fct_recode(). Le permite recodificar, o cambiar, el valor de cada nivel. Por ejemplo, tome la variable partyid del marco de datos gss_cat:\n\ngss_cat |&gt; count(partyid)\n#&gt; # A tibble: 10 √ó 2\n#&gt;   partyid                n\n#&gt;   &lt;fct&gt;              &lt;int&gt;\n#&gt; 1 No answer            154\n#&gt; 2 Don't know             1\n#&gt; 3 Other party          393\n#&gt; 4 Strong republican   2314\n#&gt; 5 Not str republican  3032\n#&gt; 6 Ind,near rep        1791\n#&gt; # ‚Ñπ 4 more rows\n\nLos niveles son breves e inconsistentes. Modifiqu√©moslos para que sean m√°s largos y usemos una construcci√≥n paralela. Como la mayor√≠a de las funciones de renombrar y recodificar en tidyverse, los valores nuevos van a la izquierda y los valores antiguos van a la derecha:\n\ngss_cat |&gt;\n  mutate(\n    partyid = fct_recode(partyid,\n      \"Republican, strong\"    = \"Strong republican\",\n      \"Republican, weak\"      = \"Not str republican\",\n      \"Independent, near rep\" = \"Ind,near rep\",\n      \"Independent, near dem\" = \"Ind,near dem\",\n      \"Democrat, weak\"        = \"Not str democrat\",\n      \"Democrat, strong\"      = \"Strong democrat\"\n    )\n  ) |&gt;\n  count(partyid)\n#&gt; # A tibble: 10 √ó 2\n#&gt;   partyid                   n\n#&gt;   &lt;fct&gt;                 &lt;int&gt;\n#&gt; 1 No answer               154\n#&gt; 2 Don't know                1\n#&gt; 3 Other party             393\n#&gt; 4 Republican, strong     2314\n#&gt; 5 Republican, weak       3032\n#&gt; 6 Independent, near rep  1791\n#&gt; # ‚Ñπ 4 more rows\n\nfct_recode() dejar√° los niveles que no se mencionan expl√≠citamente como est√°n y le avisar√° si accidentalmente hace referencia a un nivel que no existe.\nPara combinar grupos, puede asignar varios niveles antiguos al mismo nivel nuevo:\n\ngss_cat |&gt;\n  mutate(\n    partyid = fct_recode(partyid,\n      \"Republican, strong\"    = \"Strong republican\",\n      \"Republican, weak\"      = \"Not str republican\",\n      \"Independent, near rep\" = \"Ind,near rep\",\n      \"Independent, near dem\" = \"Ind,near dem\",\n      \"Democrat, weak\"        = \"Not str democrat\",\n      \"Democrat, strong\"      = \"Strong democrat\",\n      \"Other\"                 = \"No answer\",\n      \"Other\"                 = \"Don't know\",\n      \"Other\"                 = \"Other party\"\n    )\n  )\n\nUsa esta t√©cnica con cuidado: si agrupas categor√≠as que son realmente diferentes, terminar√°s con resultados enga√±osos.\nSi desea colapsar muchos niveles, fct_collapse() es una variante √∫til de fct_recode(). Para cada variable nueva, puede proporcionar un vector de niveles antiguos:\n\ngss_cat |&gt;\n  mutate(\n    partyid = fct_collapse(partyid,\n      \"other\" = c(\"No answer\", \"Don't know\", \"Other party\"),\n      \"rep\" = c(\"Strong republican\", \"Not str republican\"),\n      \"ind\" = c(\"Ind,near rep\", \"Independent\", \"Ind,near dem\"),\n      \"dem\" = c(\"Not str democrat\", \"Strong democrat\")\n    )\n  ) |&gt;\n  count(partyid)\n#&gt; # A tibble: 4 √ó 2\n#&gt;   partyid     n\n#&gt;   &lt;fct&gt;   &lt;int&gt;\n#&gt; 1 other     548\n#&gt; 2 rep      5346\n#&gt; 3 ind      8409\n#&gt; 4 dem      7180\n\nA veces, solo desea agrupar los grupos peque√±os para simplificar un diagrama o una tabla. Ese es el trabajo de la familia de funciones fct_lump_*(). fct_lump_lowfreq() es un punto de partida simple que agrupa progresivamente las categor√≠as de grupos m√°s peque√±os en ‚ÄúOtros‚Äù, manteniendo siempre ‚ÄúOtros‚Äù como la categor√≠a m√°s peque√±a.\n\ngss_cat |&gt;\n  mutate(relig = fct_lump_lowfreq(relig)) |&gt;\n  count(relig)\n#&gt; # A tibble: 2 √ó 2\n#&gt;   relig          n\n#&gt;   &lt;fct&gt;      &lt;int&gt;\n#&gt; 1 Protestant 10846\n#&gt; 2 Other      10637\n\nEn este caso, no es muy √∫til: es cierto que la mayor√≠a de los estadounidenses en esta encuesta son protestantes, ¬°pero probablemente nos gustar√≠a ver m√°s detalles! En cambio, podemos usar fct_lump_n() para especificar que queremos exactamente 10 grupos:\n\ngss_cat |&gt;\n  mutate(relig = fct_lump_n(relig, n = 10)) |&gt;\n  count(relig, sort = TRUE)\n#&gt; # A tibble: 10 √ó 2\n#&gt;   relig          n\n#&gt;   &lt;fct&gt;      &lt;int&gt;\n#&gt; 1 Protestant 10846\n#&gt; 2 Catholic    5124\n#&gt; 3 None        3523\n#&gt; 4 Christian    689\n#&gt; 5 Other        458\n#&gt; 6 Jewish       388\n#&gt; # ‚Ñπ 4 more rows\n\nLea la documentaci√≥n para conocer fct_lump_min() y fct_lump_prop(), que son √∫tiles en otros casos.\n\n16.5.1 Ejercicios\n\n¬øC√≥mo han cambiado con el tiempo las proporciones de personas que se identifican como dem√≥cratas, republicanas e independientes?\n¬øC√≥mo podr√≠a colapsar ‚Äòrincome‚Äô en un peque√±o conjunto de categor√≠as?\nObserve que hay 9 grupos (excluyendo otros) en el ejemplo fct_lump anterior. ¬øPor qu√© no 10? (Sugerencia: escriba ?fct_lump y encuentre que el valor predeterminado para el argumento other_level es ‚ÄúOther‚Äù.)",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Factores</span>"
    ]
  },
  {
    "objectID": "factors.html#sec-ordered-factors",
    "href": "factors.html#sec-ordered-factors",
    "title": "16¬† Factores",
    "section": "\n16.6 Factores ordenados",
    "text": "16.6 Factores ordenados\nAntes de continuar, es importante mencionar brevemente un tipo especial de factor: los factores ordenados. Creados con la funci√≥n ordered(), los factores ordenados implican un orden estricto entre niveles, pero no especifican nada sobre la magnitud de las diferencias entre los niveles. Utiliza factores ordenados cuando sabe que los niveles est√°n clasificados, pero no existe una clasificaci√≥n num√©rica precisa.\nPuede identificar un factor ordenado cuando se imprime porque utiliza s√≠mbolos &lt; entre los niveles de factor:\n\nordered(c(\"a\", \"b\", \"c\"))\n#&gt; [1] a b c\n#&gt; Levels: a &lt; b &lt; c\n\nTanto en la base R como en el tidyverse, los factores ordenados se comportan de manera muy similar a los factores regulares. Solo hay dos lugares donde puede notar un comportamiento diferente:\n\nSi asigna un factor ordenado a color o rellena ggplot2, se establecer√° de forma predeterminada en scale_color_viridis()/scale_fill_viridis(), una escala de color que implica una clasificaci√≥n.\nSi utiliza un predictor ordenado en un modelo lineal, utilizar√° ‚Äúcontrastes polin√≥micos‚Äù. Estos son ligeramente √∫tiles, pero es poco probable que haya o√≠do hablar de ellos a menos que tenga un doctorado en Estad√≠stica, y aun as√≠ probablemente no los interprete de forma rutinaria. Si desea obtener m√°s informaci√≥n, le recomendamos vignette(\"contrasts\", package = \"faux\") de Lisa DeBruine.\n\nA los efectos de este libro, no es particularmente importante distinguir correctamente entre factores regulares y ordenados. Sin embargo, en t√©rminos m√°s generales, ciertos campos (particularmente las ciencias sociales) utilizan ampliamente factores ordenados. En estos contextos, es importante identificarlos correctamente para que otros paquetes de an√°lisis puedan ofrecer el comportamiento adecuado.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Factores</span>"
    ]
  },
  {
    "objectID": "factors.html#resumen",
    "href": "factors.html#resumen",
    "title": "16¬† Factores",
    "section": "\n16.7 Resumen",
    "text": "16.7 Resumen\nEste cap√≠tulo le present√≥ el pr√°ctico paquete forcats para trabajar con factores, y le present√≥ las funciones m√°s utilizadas. forcats contiene una amplia gama de otros ayudantes que no tuvimos espacio para discutir aqu√≠, por lo que siempre que se enfrente a un desaf√≠o de an√°lisis factorial que no haya enfrentado antes, le recomiendo hojear el √≠ndice de referencia para ver si hay una funci√≥n enlatada que pueda ayudar a resolver su problema.\nSi desea obtener m√°s informaci√≥n sobre los factores despu√©s de leer este cap√≠tulo, le recomendamos que lea el art√≠culo de Amelia McNamara y Nicholas Horton, Wrangling categorical data in R. Este art√≠culo expone parte de la historia discutida en stringsAsFactors: An noauthorized biography y stringsAsFactors = &lt;sigh&gt;, y compara los enfoques ordenados de los datos categ√≥ricos descritos en este libro con los m√©todos base R. Una primera versi√≥n del documento ayud√≥ a motivar y definir el alcance del paquete forcats; ¬°Gracias Amelia y Nick!\nEn el pr√≥ximo cap√≠tulo, cambiaremos de marcha para comenzar a aprender sobre fechas y horas en R. Las fechas y las horas parecen enga√±osamente simples, pero como ver√° pronto, cuanto m√°s aprende sobre ellas, ¬°m√°s complejas parecen volverse!",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Factores</span>"
    ]
  },
  {
    "objectID": "factors.html#footnotes",
    "href": "factors.html#footnotes",
    "title": "16¬† Factores",
    "section": "",
    "text": "Tambi√©n son muy importantes para el modelado.‚Ü©Ô∏é",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Factores</span>"
    ]
  },
  {
    "objectID": "datetimes.html",
    "href": "datetimes.html",
    "title": "17¬† Fechas y horas",
    "section": "",
    "text": "17.1 Introducci√≥n\nEste cap√≠tulo le mostrar√° c√≥mo trabajar con fechas y horas en R. A primera vista, las fechas y horas parecen simples. Los usa todo el tiempo en su vida normal y no parecen causar mucha confusi√≥n. Sin embargo, cuanto m√°s aprendes sobre las fechas y las horas, ¬°m√°s complicadas parecen volverse!\nPara entrar en calor, piensa en cu√°ntos d√≠as hay en un a√±o y cu√°ntas horas hay en un d√≠a. Probablemente record√≥ que la mayor√≠a de los a√±os tienen 365 d√≠as, pero los a√±os bisiestos tienen 366. ¬øConoces la regla completa para determinar si un a√±o es bisiesto1? La cantidad de horas en un d√≠a es un poco menos obvia: la mayor√≠a de los d√≠as tienen 24 horas, pero en lugares que usan el horario de verano (DST), un d√≠a cada a√±o tiene 23 horas y otro tiene 25.\nLas fechas y las horas son dif√≠ciles porque tienen que conciliar dos fen√≥menos f√≠sicos (la rotaci√≥n de la Tierra y su √≥rbita alrededor del sol) con toda una serie de fen√≥menos geopol√≠ticos, incluidos los meses, las zonas horarias y el horario de verano. Este cap√≠tulo no le ense√±ar√° hasta el √∫ltimo detalle sobre fechas y horas, pero le brindar√° una base s√≥lida de habilidades pr√°cticas que lo ayudar√°n con los desaf√≠os comunes de an√°lisis de datos.\nComenzaremos mostr√°ndole c√≥mo crear fechas y horas a partir de varias entradas y luego, una vez que tenga una fecha y hora, c√≥mo puede extraer componentes como a√±o, mes y d√≠a. Luego nos sumergiremos en el tema complicado de trabajar con intervalos de tiempo, que vienen en una variedad de sabores dependiendo de lo que est√© tratando de hacer. Concluiremos con una breve discusi√≥n de los desaf√≠os adicionales que plantean las zonas horarias.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Fechas y horas</span>"
    ]
  },
  {
    "objectID": "datetimes.html#introducci√≥n",
    "href": "datetimes.html#introducci√≥n",
    "title": "17¬† Fechas y horas",
    "section": "",
    "text": "17.1.1 Requisitos previos\nEste cap√≠tulo se centrar√° en el paquete lubridate, que facilita el trabajo con fechas y horas en R. A partir de la √∫ltima versi√≥n de tidyverse, lubridate es parte del n√∫cleo de tidyverse. Tambi√©n necesitaremos nycflights13 para datos de pr√°ctica.\n\nlibrary(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Fechas y horas</span>"
    ]
  },
  {
    "objectID": "datetimes.html#sec-creating-datetimes",
    "href": "datetimes.html#sec-creating-datetimes",
    "title": "17¬† Fechas y horas",
    "section": "\n17.2 Creando fecha/horas",
    "text": "17.2 Creando fecha/horas\nHay tres tipos de datos de fecha/hora que se refieren a un instante en el tiempo:\n\nUna fecha. Tibbles imprime esto como &lt;date&gt;.\nUna hora en un d‚Äôia. Tibbles impreme esto como &lt;time&gt;.\nUna fecha-hora es una fecha m√°s una hora: identifica de manera √∫nica un instante en el tiempo (generalmente al segundo m√°s cercano). Tibbles imprime esto como &lt;dttm&gt;. Base R los llama POSIXct, pero no se sale de la lengua exactamente.\n\nEn este cap√≠tulo nos vamos a centrar en fechas y fechas y horas, ya que R no tiene una clase nativa para almacenar horas. Si necesita uno, puede usar el paquete hms.\nSiempre debe usar el tipo de datos m√°s simple posible que funcione para sus necesidades. Eso significa que si puede usar una fecha en lugar de una fecha y hora, deber√≠a hacerlo. Las fechas y horas son sustancialmente m√°s complicadas debido a la necesidad de manejar las zonas horarias, a lo que volveremos al final del cap√≠tulo.\nPara obtener la fecha actual o la fecha y hora, puede usar today() o now():\n\ntoday()\n#&gt; [1] \"2025-08-05\"\nnow()\n#&gt; [1] \"2025-08-05 21:49:39 UTC\"\n\nDe lo contrario, las siguientes secciones describen las cuatro formas en las que es probable que cree una fecha/hora:\n\nAl leer un archivo con readr.\nDe una cadena de caracteres.\nA partir de componentes individuales de fecha y hora.\nDe un objeto de fecha/hora existente.\n\n\n17.2.1 Durante la importaci√≥n\nSi su CSV contiene una fecha ISO8601 o una fecha y hora, no necesita hacer nada; readr lo reconocer√° autom√°ticamente:\n\ncsv &lt;- \"\n  date,datetime\n  2022-01-02,2022-01-02 05:12\n\"\nread_csv(csv)\n#&gt; # A tibble: 1 √ó 2\n#&gt;   date       datetime           \n#&gt;   &lt;date&gt;     &lt;dttm&gt;             \n#&gt; 1 2022-01-02 2022-01-02 05:12:00\n\nSi no ha o√≠do hablar de ISO8601 antes, es un est√°ndar internacional2 para escribir fechas donde los componentes de una fecha se organizan de mayor a menor separados por -. Por ejemplo, en ISO8601 el 3 de mayo de 2022 es 2022-05-03. Las fechas ISO8601 tambi√©n pueden incluir horas, donde la hora, el minuto y el segundo est√°n separados por :, y los componentes de fecha y hora est√°n separados por una T o un espacio. Por ejemplo, podr√≠a escribir 4:26 p.¬†m. el 3 de mayo de 2022 como 2022-05-03 16:26 o 2022-05-03T16:26.\nPara otros formatos de fecha y hora, necesitar√° usar col_types m√°s col_date() o col_datetime() junto con un formato de fecha y hora. El formato de fecha y hora utilizado por readr es un est√°ndar utilizado en muchos lenguajes de programaci√≥n, que describe un componente de fecha con un % seguido de un solo car√°cter. Por ejemplo, %Y-%m-%d especifica una fecha que es un a√±o, -, mes (como n√∫mero) -, d√≠a. La tabla Tabla¬†17.1 enumera todas las opciones.\n\n\nTabla¬†17.1: Todos los formatos de fecha entendidos por readr\n\n\n\n\n\n\n\n\n\nType\nCode\nMeaning\nExample\n\n\n\nA√±o\n%Y\na√±o de 4 digitos\n2021\n\n\n\n%y\na√±o de 2 digitos\n21\n\n\nMes\n%m\nN√∫mero\n2\n\n\n\n%b\nNombre abreviado\nFeb\n\n\n\n%B\nNombre completo\nFebruary\n\n\nD√≠a\n%d\nUno o dos digitos\n2\n\n\n\n%e\nDos digitos\n02\n\n\nHora\n%H\nHoras en 24-horas\n13\n\n\n\n%I\nHoras en 12-horas\n1\n\n\n\n%p\nAM/PM\npm\n\n\n\n%M\nMinutos\n35\n\n\n\n%S\nSegundos\n45\n\n\n\n%OS\nSegundos con componente decimal\n45.35\n\n\n\n%Z\nNombre de la zona horaria\nAmerica/Chicago\n\n\n\n%z\nDesplazamiento de UTC\n+0800\n\n\nOtros\n%.\nEvitar un no digito\n:\n\n\n\n%*\nEvitar cualquier n√∫mero de no digitos\n\n\n\n\n\n\n\nY este c√≥digo muestra algunas opciones aplicadas a una fecha muy ambigua:\n\ncsv &lt;- \"\n  date\n  01/02/15\n\"\n\nread_csv(csv, col_types = cols(date = col_date(\"%m/%d/%y\")))\n#&gt; # A tibble: 1 √ó 1\n#&gt;   date      \n#&gt;   &lt;date&gt;    \n#&gt; 1 2015-01-02\n\nread_csv(csv, col_types = cols(date = col_date(\"%d/%m/%y\")))\n#&gt; # A tibble: 1 √ó 1\n#&gt;   date      \n#&gt;   &lt;date&gt;    \n#&gt; 1 2015-02-01\n\nread_csv(csv, col_types = cols(date = col_date(\"%y/%m/%d\")))\n#&gt; # A tibble: 1 √ó 1\n#&gt;   date      \n#&gt;   &lt;date&gt;    \n#&gt; 1 2001-02-15\n\nTenga en cuenta que no importa c√≥mo especifique el formato de fecha, siempre se muestra de la misma manera una vez que lo ingresa en R.\nSi est√° utilizando %b o %B y trabaja con fechas que no est√°n en ingl√©s, tambi√©n deber√° proporcionar un locale(). Vea la lista de idiomas integrados en date_names_langs(), o cree el suyo propio con date_names().\n\n17.2.2 De una cadena de caracteres\nEl lenguaje de especificaci√≥n de fecha y hora es poderoso, pero requiere un an√°lisis cuidadoso del formato de fecha. Un enfoque alternativo es usar los ayudantes de lubridate que intentan determinar autom√°ticamente el formato una vez que especifica el orden del componente. Para usarlos, identifique el orden en que aparecen el a√±o, el mes y el d√≠a en sus fechas, luego organice ‚Äúy‚Äù, ‚Äúm‚Äù y ‚Äúd‚Äù en el mismo orden. Eso le da el nombre de la funci√≥n lubridate que analizar√° su fecha. Por ejemplo:\n\nymd(\"2017-01-31\")\n#&gt; [1] \"2017-01-31\"\nmdy(\"January 31st, 2017\")\n#&gt; [1] \"2017-01-31\"\ndmy(\"31-Jan-2017\")\n#&gt; [1] \"2017-01-31\"\n\nymd() y amigos crean fechas. Para crear una fecha y hora, agregue un gui√≥n bajo y uno o m√°s de ‚Äúh‚Äù, ‚Äúm‚Äù y ‚Äús‚Äù al nombre de la funci√≥n de an√°lisis:\n\nymd_hms(\"2017-01-31 20:11:59\")\n#&gt; [1] \"2017-01-31 20:11:59 UTC\"\nmdy_hm(\"01/31/2017 08:01\")\n#&gt; [1] \"2017-01-31 08:01:00 UTC\"\n\nTambi√©n puede forzar la creaci√≥n de una fecha y hora a partir de una fecha proporcionando una zona horaria:\n\nymd(\"2017-01-31\", tz = \"UTC\")\n#&gt; [1] \"2017-01-31 UTC\"\n\nAqu√≠ utilizo la zona horaria UTC3 que tambi√©n puede conocer como GMT, o Greenwich Mean Time, la hora en 0¬∞ de longitud4 . No utiliza el horario de verano, por lo que es un poco m√°s f√°cil de calcular .\n\n17.2.3 De componentes individuales\nEn lugar de una sola cadena, a veces tendr√° los componentes individuales de la fecha y hora distribuidos en varias columnas. Esto es lo que tenemos en los datos de flights:\n\nflights |&gt; \n  select(year, month, day, hour, minute)\n#&gt; # A tibble: 336,776 √ó 5\n#&gt;    year month   day  hour minute\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1  2013     1     1     5     15\n#&gt; 2  2013     1     1     5     29\n#&gt; 3  2013     1     1     5     40\n#&gt; 4  2013     1     1     5     45\n#&gt; 5  2013     1     1     6      0\n#&gt; 6  2013     1     1     5     58\n#&gt; # ‚Ñπ 336,770 more rows\n\nPara crear una fecha/hora a partir de este tipo de entrada, usa make_date() para fechas, o make_datetime() para fechas y horas:\n\nflights |&gt; \n  select(year, month, day, hour, minute) |&gt; \n  mutate(departure = make_datetime(year, month, day, hour, minute))\n#&gt; # A tibble: 336,776 √ó 6\n#&gt;    year month   day  hour minute departure          \n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dttm&gt;             \n#&gt; 1  2013     1     1     5     15 2013-01-01 05:15:00\n#&gt; 2  2013     1     1     5     29 2013-01-01 05:29:00\n#&gt; 3  2013     1     1     5     40 2013-01-01 05:40:00\n#&gt; 4  2013     1     1     5     45 2013-01-01 05:45:00\n#&gt; 5  2013     1     1     6      0 2013-01-01 06:00:00\n#&gt; 6  2013     1     1     5     58 2013-01-01 05:58:00\n#&gt; # ‚Ñπ 336,770 more rows\n\nHagamos lo mismo para cada una de las cuatro columnas de tiempo en flights. Los tiempos se representan en un formato ligeramente extra√±o, por lo que usamos aritm√©tica de m√≥dulo para extraer los componentes de hora y minuto. Una vez que hayamos creado las variables de fecha y hora, nos centraremos en las variables que exploraremos en el resto del cap√≠tulo.\n\nmake_datetime_100 &lt;- function(year, month, day, time) {\n  make_datetime(year, month, day, time %/% 100, time %% 100)\n}\n\nflights_dt &lt;- flights |&gt; \n  filter(!is.na(dep_time), !is.na(arr_time)) |&gt; \n  mutate(\n    dep_time = make_datetime_100(year, month, day, dep_time),\n    arr_time = make_datetime_100(year, month, day, arr_time),\n    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),\n    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)\n  ) |&gt; \n  select(origin, dest, ends_with(\"delay\"), ends_with(\"time\"))\n\nflights_dt\n#&gt; # A tibble: 328,063 √ó 9\n#&gt;   origin dest  dep_delay arr_delay dep_time            sched_dep_time     \n#&gt;   &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dttm&gt;              &lt;dttm&gt;             \n#&gt; 1 EWR    IAH           2        11 2013-01-01 05:17:00 2013-01-01 05:15:00\n#&gt; 2 LGA    IAH           4        20 2013-01-01 05:33:00 2013-01-01 05:29:00\n#&gt; 3 JFK    MIA           2        33 2013-01-01 05:42:00 2013-01-01 05:40:00\n#&gt; 4 JFK    BQN          -1       -18 2013-01-01 05:44:00 2013-01-01 05:45:00\n#&gt; 5 LGA    ATL          -6       -25 2013-01-01 05:54:00 2013-01-01 06:00:00\n#&gt; 6 EWR    ORD          -4        12 2013-01-01 05:54:00 2013-01-01 05:58:00\n#&gt; # ‚Ñπ 328,057 more rows\n#&gt; # ‚Ñπ 3 more variables: arr_time &lt;dttm&gt;, sched_arr_time &lt;dttm&gt;, ‚Ä¶\n\nCon estos datos, podemos visualizar la distribuci√≥n de los horarios de salida a lo largo del a√±o:\n\nflights_dt |&gt; \n  ggplot(aes(x = dep_time)) + \n  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day\n\n\n\n\n\n\n\nO dentro de un solo d√≠a:\n\nflights_dt |&gt; \n  filter(dep_time &lt; ymd(20130102)) |&gt; \n  ggplot(aes(x = dep_time)) + \n  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes\n\n\n\n\n\n\n\nTenga en cuenta que cuando usa fecha y hora en un contexto num√©rico (como en un histograma), 1 significa 1 segundo, por lo que un ancho de bin de 86400 significa un d√≠a. Para fechas, 1 significa 1 d√≠a.\n\n17.2.4 De otros tipos\nEs posible que desee cambiar entre una fecha y hora y una fecha. Ese es el trabajo de as_datetime() y as_date():\n\nas_datetime(today())\n#&gt; [1] \"2025-08-05 UTC\"\nas_date(now())\n#&gt; [1] \"2025-08-05\"\n\nA veces obtendr√° la fecha/hora como compensaciones num√©ricas de la ‚Äú√©poca de Unix‚Äù, 1970-01-01. Si el desplazamiento est√° en segundos, use as_datetime(); si es en d√≠as, usa as_date().\n\nas_datetime(60 * 60 * 10)\n#&gt; [1] \"1970-01-01 10:00:00 UTC\"\nas_date(365 * 10 + 2)\n#&gt; [1] \"1980-01-01\"\n\n\n17.2.5 Ejercicios\n\n\n¬øQu√© sucede si analiza una cadena que contiene fechas no v√°lidas?\n\nymd(c(\"2010-10-10\", \"bananas\"))\n\n\n¬øQu√© hace el argumento tzone para today()? ¬øPor qu√© es importante?\n\nPara cada una de las siguientes fechas y horas, muestre c√≥mo las analizar√≠a utilizando una especificaci√≥n de columna readr y una funci√≥n lubridate.\n\nd1 &lt;- \"January 1, 2010\"\nd2 &lt;- \"2015-Mar-07\"\nd3 &lt;- \"06-Jun-2017\"\nd4 &lt;- c(\"August 19 (2015)\", \"July 1 (2015)\")\nd5 &lt;- \"12/30/14\" # Dec 30, 2014\nt1 &lt;- \"1705\"\nt2 &lt;- \"11:15:10.12 PM\"",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Fechas y horas</span>"
    ]
  },
  {
    "objectID": "datetimes.html#componentes-de-fecha-y-hora",
    "href": "datetimes.html#componentes-de-fecha-y-hora",
    "title": "17¬† Fechas y horas",
    "section": "\n17.3 Componentes de fecha y hora",
    "text": "17.3 Componentes de fecha y hora\nAhora que sabe c√≥mo obtener datos de fecha y hora en las estructuras de datos de fecha y hora de R, exploremos qu√© puede hacer con ellos. Esta secci√≥n se centrar√° en las funciones de acceso que le permiten obtener y configurar componentes individuales. La siguiente secci√≥n ver√° c√≥mo funciona la aritm√©tica con fechas y horas.\n\n17.3.1 Obtener componentes\nPuede extraer partes individuales de la fecha con las funciones de acceso year(), month(), mday() (d√≠a del mes), yday() (d√≠a del a√±o), wday() (d√≠a de la semana), hour(), minute() y second(). Estos son efectivamente los opuestos de make_datetime().\n\ndatetime &lt;- ymd_hms(\"2026-07-08 12:34:56\")\n\nyear(datetime)\n#&gt; [1] 2026\nmonth(datetime)\n#&gt; [1] 7\nmday(datetime)\n#&gt; [1] 8\n\nyday(datetime)\n#&gt; [1] 189\nwday(datetime)\n#&gt; [1] 4\n\nPara month() y wday() puede configurar label = TRUE para devolver el nombre abreviado del mes o d√≠a de la semana. Establezca abbr = FALSE para devolver el nombre completo.\n\nmonth(datetime, label = TRUE)\n#&gt; [1] Jul\n#&gt; 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec\nwday(datetime, label = TRUE, abbr = FALSE)\n#&gt; [1] Wednesday\n#&gt; 7 Levels: Sunday &lt; Monday &lt; Tuesday &lt; Wednesday &lt; Thursday &lt; ... &lt; Saturday\n\nPodemos usar wday() para ver que salen m√°s vuelos durante la semana que el fin de semana:\n\nflights_dt |&gt; \n  mutate(wday = wday(dep_time, label = TRUE)) |&gt; \n  ggplot(aes(x = wday)) +\n  geom_bar()\n\n\n\n\n\n\n\nTambi√©n podemos ver el retraso de salida promedio por minuto dentro de la hora. Hay un patr√≥n interesante: ¬°los vuelos que salen en los minutos 20-30 y 50-60 tienen retrasos mucho menores que el resto de la hora!\n\nflights_dt |&gt; \n  mutate(minute = minute(dep_time)) |&gt; \n  group_by(minute) |&gt; \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE),\n    n = n()\n  ) |&gt; \n  ggplot(aes(x = minute, y = avg_delay)) +\n  geom_line()\n\n\n\n\n\n\n\nCuriosamente, si observamos la hora de salida programada, no vemos un patr√≥n tan fuerte:\n\nsched_dep &lt;- flights_dt |&gt; \n  mutate(minute = minute(sched_dep_time)) |&gt; \n  group_by(minute) |&gt; \n  summarize(\n    avg_delay = mean(arr_delay, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(sched_dep, aes(x = minute, y = avg_delay)) +\n  geom_line()\n\n\n\n\n\n\n\nEntonces, ¬øpor qu√© vemos ese patr√≥n con los horarios de salida reales? Bueno, como gran parte de los datos recopilados por humanos, hay un fuerte sesgo hacia los vuelos que salen en ‚Äúbuenos‚Äù horarios de salida, como muestra Figura¬†17.1. ¬°Est√© siempre alerta a este tipo de patr√≥n cada vez que trabaje con datos que involucran el juicio humano!\n\n\n\n\n\n\n\nFigura¬†17.1: Un pol√≠gono de frecuencia que muestra el n√∫mero de vuelos programados para salir cada hora. Puede ver una fuerte preferencia por los n√∫meros redondos como el 0 y el 30 y, en general, por los n√∫meros que son m√∫ltiplos de cinco.\n\n\n\n\n\n17.3.2 Redondeo\nUn enfoque alternativo para trazar componentes individuales es redondear la fecha a una unidad de tiempo cercana, con floor_date(), round_date() y ceiling_date(). Cada funci√≥n toma un vector de fechas para ajustar y luego el nombre de la unidad redondea hacia abajo (floor), redondea hacia arriba (ceiling) o redondea a. Esto, por ejemplo, nos permite graficar el n√∫mero de vuelos por semana:\n\nflights_dt |&gt; \n  count(week = floor_date(dep_time, \"week\")) |&gt; \n  ggplot(aes(x = week, y = n)) +\n  geom_line() + \n  geom_point()\n\n\n\n\n\n\n\nPuede usar el redondeo para mostrar la distribuci√≥n de vuelos a lo largo de un d√≠a calculando la diferencia entre dep_time y el primer instante de ese d√≠a:\n\nflights_dt |&gt; \n  mutate(dep_hour = dep_time - floor_date(dep_time, \"day\")) |&gt; \n  ggplot(aes(x = dep_hour)) +\n  geom_freqpoly(binwidth = 60 * 30)\n#&gt; Don't know how to automatically pick scale for object of type &lt;difftime&gt;.\n#&gt; Defaulting to continuous.\n\n\n\n\n\n\n\nCalcular la diferencia entre un par de fechas y horas produce un tiempo de diferencia (m√°s sobre eso en Secci√≥n 17.4.3). Podemos convertir eso en un objeto hms para obtener un eje x m√°s √∫til:\n\nflights_dt |&gt; \n  mutate(dep_hour = hms::as_hms(dep_time - floor_date(dep_time, \"day\"))) |&gt; \n  ggplot(aes(x = dep_hour)) +\n  geom_freqpoly(binwidth = 60 * 30)\n\n\n\n\n\n\n\n\n17.3.3 Modificaci√≥n de componentes\nTambi√©n puede utilizar cada funci√≥n de acceso para modificar los componentes de una fecha/hora. Esto no aparece mucho en el an√°lisis de datos, pero puede ser √∫til cuando se limpian datos que tienen fechas claramente incorrectas.\n\n(datetime &lt;- ymd_hms(\"2026-07-08 12:34:56\"))\n#&gt; [1] \"2026-07-08 12:34:56 UTC\"\n\nyear(datetime) &lt;- 2030\ndatetime\n#&gt; [1] \"2030-07-08 12:34:56 UTC\"\nmonth(datetime) &lt;- 01\ndatetime\n#&gt; [1] \"2030-01-08 12:34:56 UTC\"\nhour(datetime) &lt;- hour(datetime) + 1\ndatetime\n#&gt; [1] \"2030-01-08 13:34:56 UTC\"\n\nAlternativamente, en lugar de modificar una variable existente, puede crear una nueva fecha y hora con update(). Esto tambi√©n le permite establecer m√∫ltiples valores en un solo paso:\n\nupdate(datetime, year = 2030, month = 2, mday = 2, hour = 2)\n#&gt; [1] \"2030-02-02 02:34:56 UTC\"\n\nSi los valores son demasiado grandes, se transferir√°n:\n\nupdate(ymd(\"2023-02-01\"), mday = 30)\n#&gt; [1] \"2023-03-02\"\nupdate(ymd(\"2023-02-01\"), hour = 400)\n#&gt; [1] \"2023-02-17 16:00:00 UTC\"\n\n\n17.3.4 Ejercicios\n\n¬øC√≥mo cambia la distribuci√≥n de los tiempos de vuelo dentro de un d√≠a a lo largo del a√±o?\nCompara dep_time, sched_dep_time y dep_delay. ¬øSon consistentes? Explique sus hallazgos.\nCompara air_time con la duraci√≥n entre la salida y la llegada. Explique sus hallazgos. (Sugerencia: considere la ubicaci√≥n del aeropuerto).\n¬øC√≥mo cambia el tiempo de demora promedio en el transcurso de un d√≠a? ¬øDeber√≠as usar dep_time o sched_dep_time? ¬øPor qu√©?\n¬øQu√© d√≠a de la semana debe salir si quiere minimizar la posibilidad de un retraso?\n¬øQu√© hace que la distribuci√≥n de diamonds$carat y flights$sched_dep_time sea similar?\nConfirme nuestra hip√≥tesis de que las salidas anticipadas de vuelos en los minutos 20-30 y 50-60 son causadas por vuelos programados que salen temprano. Sugerencia: cree una variable binaria que le indique si un vuelo se retras√≥ o no.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Fechas y horas</span>"
    ]
  },
  {
    "objectID": "datetimes.html#intervalos-de-tiempo",
    "href": "datetimes.html#intervalos-de-tiempo",
    "title": "17¬† Fechas y horas",
    "section": "\n17.4 Intervalos de tiempo",
    "text": "17.4 Intervalos de tiempo\nA continuaci√≥n, aprender√° c√≥mo funciona la aritm√©tica con fechas, incluidas la resta, la suma y la divisi√≥n. En el camino, aprender√° acerca de tres clases importantes que representan per√≠odos de tiempo:\n\n\nDuraci√≥n, que representa un n√∫mero exacto de segundos.\n\nPer√≠odos, que representan unidades humanas como semanas y meses.\n\nIntervalos, que representan un punto inicial y final.\n\n¬øC√≥mo eliges entre duraci√≥n, per√≠odos e intervalos? Como siempre, elija la estructura de datos m√°s simple que resuelva su problema. Si solo te importa el tiempo f√≠sico, usa una duraci√≥n; si necesita agregar tiempos humanos, use un per√≠odo; si necesita averiguar cu√°nto mide un lapso en unidades humanas, use un intervalo.\n\n17.4.1 Duraciones\nEn R, cuando restas dos fechas, obtienes un objeto difftime:\n\n# How old is Hadley?\nh_age &lt;- today() - ymd(\"1979-10-14\")\nh_age\n#&gt; Time difference of 16732 days\n\nUn objeto de clase difftime registra un lapso de tiempo de segundos, minutos, horas, d√≠as o semanas. Esta ambig√ºedad puede hacer que trabajar con difftimes sea un poco doloroso, por lo que lubridate ofrece una alternativa que siempre usa segundos: la duraci√≥n.\n\nas.duration(h_age)\n#&gt; [1] \"1445644800s (~45.81 years)\"\n\nLas duraciones vienen con un mont√≥n de constructoras convenientes:\n\ndseconds(15)\n#&gt; [1] \"15s\"\ndminutes(10)\n#&gt; [1] \"600s (~10 minutes)\"\ndhours(c(12, 24))\n#&gt; [1] \"43200s (~12 hours)\" \"86400s (~1 days)\"\nddays(0:5)\n#&gt; [1] \"0s\"                \"86400s (~1 days)\"  \"172800s (~2 days)\"\n#&gt; [4] \"259200s (~3 days)\" \"345600s (~4 days)\" \"432000s (~5 days)\"\ndweeks(3)\n#&gt; [1] \"1814400s (~3 weeks)\"\ndyears(1)\n#&gt; [1] \"31557600s (~1 years)\"\n\nLas duraciones siempre registran el lapso de tiempo en segundos. Las unidades m√°s grandes se crean al convertir minutos, horas, d√≠as, semanas y a√±os en segundos: 60 segundos en un minuto, 60 minutos en una hora, 24 horas en un d√≠a y 7 d√≠as en una semana. Las unidades de tiempo m√°s grandes son m√°s problem√°ticas. Un a√±o utiliza el n√∫mero ‚Äúpromedio‚Äù de d√≠as en un a√±o, es decir, 365,25. No hay forma de convertir un mes en una duraci√≥n, porque hay demasiada variaci√≥n.\nPuedes sumar y multiplicar duraciones:\n\n2 * dyears(1)\n#&gt; [1] \"63115200s (~2 years)\"\ndyears(1) + dweeks(12) + dhours(15)\n#&gt; [1] \"38869200s (~1.23 years)\"\n\nPuede sumar y restar duraciones desde y hacia d√≠as:\n\ntomorrow &lt;- today() + ddays(1)\nlast_year &lt;- today() - dyears(1)\n\nSin embargo, debido a que las duraciones representan una cantidad exacta de segundos, a veces puede obtener un resultado inesperado:\n\none_am &lt;- ymd_hms(\"2026-03-08 01:00:00\", tz = \"America/New_York\")\n\none_am\n#&gt; [1] \"2026-03-08 01:00:00 EST\"\none_am + ddays(1)\n#&gt; [1] \"2026-03-09 02:00:00 EDT\"\n\n¬øPor qu√© un d√≠a despu√©s de la 1 a. m. es el 8 de marzo y a las 2 a. m. el 9 de marzo? Si observa detenidamente la fecha, tambi√©n puede notar que las zonas horarias han cambiado. El 8 de marzo solo tiene 23 horas porque es cuando comienza el horario de verano, por lo que si agregamos un d√≠a completo en segundos, terminamos con una hora diferente.\n\n17.4.2 Per√≠odos\nPara resolver este problema, lubridate proporciona per√≠odos. Los per√≠odos son lapsos de tiempo, pero no tienen una duraci√≥n fija en segundos, sino que funcionan con tiempos ‚Äúhumanos‚Äù, como d√≠as y meses. Eso les permite trabajar de una manera m√°s intuitiva:\n\none_am\n#&gt; [1] \"2026-03-08 01:00:00 EST\"\none_am + days(1)\n#&gt; [1] \"2026-03-09 01:00:00 EDT\"\n\nAl igual que las duraciones, los per√≠odos se pueden crear con una serie de funciones constructoras amigables.\n\nhours(c(12, 24))\n#&gt; [1] \"12H 0M 0S\" \"24H 0M 0S\"\ndays(7)\n#&gt; [1] \"7d 0H 0M 0S\"\nmonths(1:6)\n#&gt; [1] \"1m 0d 0H 0M 0S\" \"2m 0d 0H 0M 0S\" \"3m 0d 0H 0M 0S\" \"4m 0d 0H 0M 0S\"\n#&gt; [5] \"5m 0d 0H 0M 0S\" \"6m 0d 0H 0M 0S\"\n\nPuede sumar y multiplicar per√≠odos:\n\n10 * (months(6) + days(1))\n#&gt; [1] \"60m 10d 0H 0M 0S\"\ndays(50) + hours(25) + minutes(2)\n#&gt; [1] \"50d 25H 2M 0S\"\n\nY por supuesto, a√±√°delos a las fechas. En comparaci√≥n con las duraciones, es m√°s probable que los per√≠odos hagan lo que esperas:\n\n# Un a√±o bisiesto\nymd(\"2024-01-01\") + dyears(1)\n#&gt; [1] \"2024-12-31 06:00:00 UTC\"\nymd(\"2024-01-01\") + years(1)\n#&gt; [1] \"2025-01-01\"\n\n# El horario de verano\none_am + ddays(1)\n#&gt; [1] \"2026-03-09 02:00:00 EDT\"\none_am + days(1)\n#&gt; [1] \"2026-03-09 01:00:00 EDT\"\n\nUsemos per√≠odos para arreglar una rareza relacionada con nuestras fechas de vuelo. Algunos aviones parecen haber llegado a su destino antes de partir de la ciudad de Nueva York.\n\nflights_dt |&gt; \n  filter(arr_time &lt; dep_time) \n#&gt; # A tibble: 10,633 √ó 9\n#&gt;   origin dest  dep_delay arr_delay dep_time            sched_dep_time     \n#&gt;   &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dttm&gt;              &lt;dttm&gt;             \n#&gt; 1 EWR    BQN           9        -4 2013-01-01 19:29:00 2013-01-01 19:20:00\n#&gt; 2 JFK    DFW          59        NA 2013-01-01 19:39:00 2013-01-01 18:40:00\n#&gt; 3 EWR    TPA          -2         9 2013-01-01 20:58:00 2013-01-01 21:00:00\n#&gt; 4 EWR    SJU          -6       -12 2013-01-01 21:02:00 2013-01-01 21:08:00\n#&gt; 5 EWR    SFO          11       -14 2013-01-01 21:08:00 2013-01-01 20:57:00\n#&gt; 6 LGA    FLL         -10        -2 2013-01-01 21:20:00 2013-01-01 21:30:00\n#&gt; # ‚Ñπ 10,627 more rows\n#&gt; # ‚Ñπ 3 more variables: arr_time &lt;dttm&gt;, sched_arr_time &lt;dttm&gt;, ‚Ä¶\n\nEstos son vuelos nocturnos. Utilizamos la misma informaci√≥n de fecha tanto para la hora de salida como para la de llegada, pero estos vuelos llegaron al d√≠a siguiente. Podemos arreglar esto agregando d√≠as (1) a la hora de llegada de cada vuelo nocturno.\n\nflights_dt &lt;- flights_dt |&gt; \n  mutate(\n    overnight = arr_time &lt; dep_time,\n    arr_time = arr_time + days(overnight),\n    sched_arr_time = sched_arr_time + days(overnight)\n  )\n\nAhora todos nuestros vuelos obedecen las leyes de la f√≠sica.\n\nflights_dt |&gt; \n  filter(overnight, arr_time &lt; dep_time) \n#&gt; # A tibble: 0 √ó 10\n#&gt; # ‚Ñπ 10 variables: origin &lt;chr&gt;, dest &lt;chr&gt;, dep_delay &lt;dbl&gt;,\n#&gt; #   arr_delay &lt;dbl&gt;, dep_time &lt;dttm&gt;, sched_dep_time &lt;dttm&gt;, ‚Ä¶\n\n\n17.4.3 Intervalos\n¬øQu√© devuelve dyears(1) / ddays(365)? No es exactamente uno, porque dyear() se define como el n√∫mero de segundos por a√±o promedio, que son 365,25 d√≠as.\n¬øQu√© devuelve years(1) / days(1)? Bueno, si el a√±o fue 2015, deber√≠a devolver 365, pero si fue 2016, ¬°deber√≠a devolver 366! No hay suficiente informaci√≥n sobre lubridate para dar una sola respuesta clara. Lo que hace en cambio es dar una estimaci√≥n:\n\nyears(1) / days(1)\n#&gt; [1] 365.25\n\nSi desea una medici√≥n m√°s precisa, deber√° usar un intervalo. Un intervalo es un par de fechas de inicio y finalizaci√≥n, o puede considerarlo como una duraci√≥n con un punto de inicio.\nPuede crear un intervalo escribiendo start %--% end:\n\ny2023 &lt;- ymd(\"2023-01-01\") %--% ymd(\"2024-01-01\")\ny2024 &lt;- ymd(\"2024-01-01\") %--% ymd(\"2025-01-01\")\n\ny2023\n#&gt; [1] 2023-01-01 UTC--2024-01-01 UTC\ny2024\n#&gt; [1] 2024-01-01 UTC--2025-01-01 UTC\n\nLuego podr√≠as dividirlo por days() para averiguar cu√°ntos d√≠as caben en el a√±o:\n\ny2023 / days(1)\n#&gt; [1] 365\ny2024 / days(1)\n#&gt; [1] 366\n\n\n17.4.4 Ejercicios\n\nExplique days(!overnight) y days(overnight) a alguien que acaba de empezar a aprender R. ¬øCu√°l es el hecho clave que necesita saber?\nCree un vector de fechas que proporcione el primer d√≠a de cada mes en 2015. Cree un vector de fechas que proporcione el primer d√≠a de cada mes en el a√±o actual.\nEscribe una funci√≥n que, dado tu cumplea√±os (como una fecha), devuelva la edad que tienes en a√±os.\n¬øPor qu√© (today() %--% (today() + years(1))) / months(1) no puede funcionar?",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Fechas y horas</span>"
    ]
  },
  {
    "objectID": "datetimes.html#zonas-horarias",
    "href": "datetimes.html#zonas-horarias",
    "title": "17¬† Fechas y horas",
    "section": "\n17.5 Zonas horarias",
    "text": "17.5 Zonas horarias\nLas zonas horarias son un tema enormemente complicado debido a su interacci√≥n con las entidades geopol√≠ticas. Afortunadamente, no necesitamos profundizar en todos los detalles, ya que no todos son importantes para el an√°lisis de datos, pero hay algunos desaf√≠os que debemos abordar de frente.\n\nEl primer desaf√≠o es que los nombres cotidianos de las zonas horarias tienden a ser ambiguos. Por ejemplo, si es estadounidense, probablemente est√© familiarizado con EST u Hora est√°ndar del este. Sin embargo, ¬°tanto Australia como Canad√° tambi√©n tienen EST! Para evitar confusiones, R utiliza las zonas horarias est√°ndar internacionales de la IANA. Estos usan un esquema de nomenclatura consistente {√°rea}/{ubicaci√≥n}, normalmente en la forma {continente}/{ciudad} o {oc√©ano}/{ciudad}. Los ejemplos incluyen ‚ÄúAmerica/Nueva_York‚Äù, ‚ÄúEurope/Paris‚Äù y ‚ÄúPacific/Auckland‚Äù.\nQuiz√°s se pregunte por qu√© la zona horaria usa una ciudad, cuando normalmente piensa en las zonas horarias como asociadas con un pa√≠s o una regi√≥n dentro de un pa√≠s. Esto se debe a que la base de datos de la IANA tiene que registrar d√©cadas de reglas de zonas horarias. A lo largo de las d√©cadas, los pa√≠ses cambian de nombre (o se separan) con bastante frecuencia, pero los nombres de las ciudades tienden a permanecer igual. Otro problema es que el nombre debe reflejar no solo el comportamiento actual, sino tambi√©n el historial completo. Por ejemplo, hay zonas horarias tanto para ‚ÄúAmerica/Nueva_York‚Äù como para ‚ÄúAmerica/Detroit‚Äù. Ambas ciudades utilizan actualmente la hora est√°ndar del este, pero en 1969-1972 Michigan (el estado en el que se encuentra Detroit) no sigui√≥ el horario de verano, por lo que necesita un nombre diferente. ¬°Vale la pena leer la base de datos de zonas horarias sin procesar (disponible en https://www.iana.org/time-zones) solo para leer algunas de estas historias!\nPuedes averiguar cu√°l cree R que es tu zona horaria actual con Sys.timezone():\n\nSys.timezone()\n#&gt; [1] \"UTC\"\n\n(Si R no lo sabe, obtendr√° una NA.)\nY vea la lista completa de todos los nombres de zonas horarias con OlsonNames():\n\nlength(OlsonNames())\n#&gt; [1] 598\nhead(OlsonNames())\n#&gt; [1] \"Africa/Abidjan\"     \"Africa/Accra\"       \"Africa/Addis_Ababa\"\n#&gt; [4] \"Africa/Algiers\"     \"Africa/Asmara\"      \"Africa/Asmera\"\n\nEn R, la zona horaria es un atributo de la fecha-hora que solo controla la impresi√≥n. Por ejemplo, estos tres objetos representan el mismo instante en el tiempo:\n\nx1 &lt;- ymd_hms(\"2024-06-01 12:00:00\", tz = \"America/New_York\")\nx1\n#&gt; [1] \"2024-06-01 12:00:00 EDT\"\n\nx2 &lt;- ymd_hms(\"2024-06-01 18:00:00\", tz = \"Europe/Copenhagen\")\nx2\n#&gt; [1] \"2024-06-01 18:00:00 CEST\"\n\nx3 &lt;- ymd_hms(\"2024-06-02 04:00:00\", tz = \"Pacific/Auckland\")\nx3\n#&gt; [1] \"2024-06-02 04:00:00 NZST\"\n\nPuedes verificar que son la misma hora usando la resta:\n\nx1 - x2\n#&gt; Time difference of 0 secs\nx1 - x3\n#&gt; Time difference of 0 secs\n\nA menos que se especifique lo contrario, lubridate siempre usa UTC. UTC (Tiempo Universal Coordinado) es la zona horaria est√°ndar utilizada por la comunidad cient√≠fica y es aproximadamente equivalente a GMT (Greenwich Mean Time). No tiene DST, lo que hace una representaci√≥n conveniente para el c√°lculo. Las operaciones que combinan fechas y horas, como c(), a menudo eliminar√°n la zona horaria. En ese caso, las fechas y horas se mostrar√°n en la zona horaria del primer elemento:\n\nx4 &lt;- c(x1, x2, x3)\nx4\n#&gt; [1] \"2024-06-01 12:00:00 EDT\" \"2024-06-01 12:00:00 EDT\"\n#&gt; [3] \"2024-06-01 12:00:00 EDT\"\n\nPuede cambiar la zona horaria de dos maneras:\n\n\nMantenga el instante en el tiempo igual y cambie la forma en que se muestra. Use esto cuando el instante sea correcto, pero desee una visualizaci√≥n m√°s natural.\n\nx4a &lt;- with_tz(x4, tzone = \"Australia/Lord_Howe\")\nx4a\n#&gt; [1] \"2024-06-02 02:30:00 +1030\" \"2024-06-02 02:30:00 +1030\"\n#&gt; [3] \"2024-06-02 02:30:00 +1030\"\nx4a - x4\n#&gt; Time differences in secs\n#&gt; [1] 0 0 0\n\n(Esto tambi√©n ilustra otro desaf√≠o de las zonas horarias: ¬°no todas son compensaciones de horas enteras!)\n\n\nCambia el instante subyacente en el tiempo. Usa esto cuando tengas un instante que ha sido etiquetado con la zona horaria incorrecta y necesites corregirlo.\n\nx4b &lt;- force_tz(x4, tzone = \"Australia/Lord_Howe\")\nx4b\n#&gt; [1] \"2024-06-01 12:00:00 +1030\" \"2024-06-01 12:00:00 +1030\"\n#&gt; [3] \"2024-06-01 12:00:00 +1030\"\nx4b - x4\n#&gt; Time differences in hours\n#&gt; [1] -14.5 -14.5 -14.5",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Fechas y horas</span>"
    ]
  },
  {
    "objectID": "datetimes.html#resumen",
    "href": "datetimes.html#resumen",
    "title": "17¬† Fechas y horas",
    "section": "\n17.6 Resumen",
    "text": "17.6 Resumen\nEste cap√≠tulo le ha presentado las herramientas que proporciona lubridate para ayudarle a trabajar con datos de fecha y hora. Trabajar con fechas y horas puede parecer m√°s dif√≠cil de lo necesario, pero espero que este cap√≠tulo le haya ayudado a ver por qu√©: las fechas y horas son m√°s complejas de lo que parecen a primera vista, y el manejo de todas las situaciones posibles agrega complejidad. Incluso si sus datos nunca cruzan un l√≠mite de ahorro de luz diurna o involucran un a√±o bisiesto, las funciones deben poder manejarlo.\nEl siguiente cap√≠tulo ofrece un resumen de los valores perdidos. Los ha visto en algunos lugares y sin duda los ha encontrado en su propio an√°lisis, y ahora es el momento de proporcionar una bolsa de sorpresas con t√©cnicas √∫tiles para tratar con ellos.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Fechas y horas</span>"
    ]
  },
  {
    "objectID": "datetimes.html#footnotes",
    "href": "datetimes.html#footnotes",
    "title": "17¬† Fechas y horas",
    "section": "",
    "text": "Un a√±o es bisiesto si es divisible por 4, a menos que tambi√©n sea divisible por 100, excepto si tambi√©n es divisible por 400. En otras palabras, en cada conjunto de 400 a√±os, hay 97 a√±os bisiestos.‚Ü©Ô∏é\nhttps://xkcd.com/1179/‚Ü©Ô∏é\nQuiz√°s se pregunte qu√© significa UTC. Es un compromiso entre el ‚ÄúCoordinated Universal Time‚Äù ingl√©s y el ‚ÄúTemps Universel Coordonn√©‚Äù franc√©s.‚Ü©Ô∏é\nNo hay premios por adivinar a qu√© pa√≠s se le ocurri√≥ el sistema de longitud.‚Ü©Ô∏é",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Fechas y horas</span>"
    ]
  },
  {
    "objectID": "missing-values.html",
    "href": "missing-values.html",
    "title": "18¬† Valores faltanres",
    "section": "",
    "text": "18.1 Introducci√≥n\nYa aprendiste los conceptos b√°sicos de los valores faltantes anteriormente en el libro. Los vio por primera vez en Cap√≠tulo 1, donde resultaron en una advertencia al hacer un gr√°fico, as√≠ como en Secci√≥n 3.5.2, donde interfirieron con el c√°lculo de estad√≠sticas de resumen, y aprendi√≥ sobre su naturaleza infecciosa y c√≥mo verificar su presencia en Secci√≥n 12.2.2. Ahora volveremos a ellos con m√°s profundidad, para que pueda conocer m√°s detalles.\nComenzaremos discutiendo algunas herramientas generales para trabajar con valores faltantes registrados como NAs. Luego, exploraremos la idea de valores que faltan impl√≠citamente, los valores que simplemente est√°n ausentes de sus datos, y mostraremos algunas herramientas que puede usar para hacerlos expl√≠citos. Terminaremos con una discusi√≥n relacionada con los grupos vac√≠os, causados por niveles de factores que no aparecen en los datos.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Valores faltanres</span>"
    ]
  },
  {
    "objectID": "missing-values.html#introducci√≥n",
    "href": "missing-values.html#introducci√≥n",
    "title": "18¬† Valores faltanres",
    "section": "",
    "text": "18.1.1 Requisitos previos\nLas funciones para trabajar con datos faltantes provienen principalmente de dplyr y tidyr, que son miembros centrales de tidyverse.\n\nlibrary(tidyverse)",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Valores faltanres</span>"
    ]
  },
  {
    "objectID": "missing-values.html#valores-perdidos-expl√≠citos",
    "href": "missing-values.html#valores-perdidos-expl√≠citos",
    "title": "18¬† Valores faltanres",
    "section": "\n18.2 Valores perdidos expl√≠citos",
    "text": "18.2 Valores perdidos expl√≠citos\nPara comenzar, exploremos algunas herramientas √∫tiles para crear o eliminar valores expl√≠citos que faltan, es decir, celdas en las que ve un NA.\n\n18.2.1 √öltima observaci√≥n llevada adelante\nUn uso com√∫n para los valores faltantes es como una comodidad para la entrada de datos. Cuando los datos se ingresan a mano, los valores que faltan a veces indican que el valor en la fila anterior se ha repetido (o trasladado):\n\ntreatment &lt;- tribble(\n  ~person,           ~treatment, ~response,\n  \"Derrick Whitmore\", 1,         7,\n  NA,                 2,         10,\n  NA,                 3,         NA,\n  \"Katherine Burke\",  1,         4\n)\n\nPuede completar estos valores faltantes con tidyr::fill(). Funciona como select(), tomando un conjunto de columnas:\n\ntreatment |&gt;\n  fill(everything())\n#&gt; # A tibble: 4 √ó 3\n#&gt;   person           treatment response\n#&gt;   &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 Derrick Whitmore         1        7\n#&gt; 2 Derrick Whitmore         2       10\n#&gt; 3 Derrick Whitmore         3       10\n#&gt; 4 Katherine Burke          1        4\n\nEste tratamiento a veces se denomina ‚Äú√∫ltima observaci√≥n realizada‚Äù, o locf (del ingl√©s ‚Äúlast observation carried forward‚Äù) para abreviar. Puede usar el argumento .direction para completar los valores faltantes que se han generado de formas m√°s ex√≥ticas.\n\n18.2.2 Valores fijos\nAlgunas veces, los valores faltantes representan alg√∫n valor fijo y conocido, m√°s com√∫nmente 0. Puedes usar dplyr::coalesce() para reemplazarlos:\n\nx &lt;- c(1, 4, 5, 7, NA)\ncoalesce(x, 0)\n#&gt; [1] 1 4 5 7 0\n\nA veces te encontrar√°s con el problema opuesto en el que alg√∫n valor concreto en realidad representa un valor faltante. Por lo general, esto surge en los datos generados por un software antiguo que no tiene una forma adecuada de representar los valores faltantes, por lo que debe usar alg√∫n valor especial como 99 o -999.\nSi es posible, maneje esto cuando lea los datos, por ejemplo, usando el argumento na para readr::read_csv(), p.ej., read_csv(ruta, na = \"99\"). Si descubre el problema m√°s tarde, o su fuente de datos no proporciona una forma de manejarlo, puede usar dplyr::na_if():\n\nx &lt;- c(1, 4, 5, 7, -99)\nna_if(x, -99)\n#&gt; [1]  1  4  5  7 NA\n\n\n18.2.3 NaN\nAntes de continuar, hay un tipo especial de valor faltante que encontrar√° de vez en cuando: un NaN (pronunciado ‚Äúnan‚Äù), del ingl√©s not a nnumber. No es tan importante saberlo porque generalmente se comporta como NA:\n\nx &lt;- c(NA, NaN)\nx * 10\n#&gt; [1]  NA NaN\nx == 1\n#&gt; [1] NA NA\nis.na(x)\n#&gt; [1] TRUE TRUE\n\nEn el raro caso de que necesites distinguir un NA de un NaN, puedes usar is.nan(x).\nPor lo general, encontrar√° un NaN cuando realice una operaci√≥n matem√°tica que tenga un resultado indeterminado:\n\n0 / 0 \n#&gt; [1] NaN\n0 * Inf\n#&gt; [1] NaN\nInf - Inf\n#&gt; [1] NaN\nsqrt(-1)\n#&gt; Warning in sqrt(-1): NaNs produced\n#&gt; [1] NaN",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Valores faltanres</span>"
    ]
  },
  {
    "objectID": "missing-values.html#sec-missing-implicit",
    "href": "missing-values.html#sec-missing-implicit",
    "title": "18¬† Valores faltanres",
    "section": "\n18.3 Valores perdidos impl√≠citos",
    "text": "18.3 Valores perdidos impl√≠citos\nHasta ahora hemos hablado de los valores que faltan expl√≠citamente, es decir, puede ver un NA en sus datos. Pero los valores faltantes tambi√©n pueden faltar impl√≠citamente, si una fila completa de datos simplemente est√° ausente de los datos. Ilustremos la diferencia con un conjunto de datos simple que registra el precio de algunas acciones cada trimestre:\n\nstocks &lt;- tibble(\n  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),\n  qtr   = c(   1,    2,    3,    4,    2,    3,    4),\n  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)\n)\n\nEste conjunto de datos tiene dos observaciones faltantes:\n\nFalta expl√≠citamente el precio en el cuarto trimestre de 2020, porque su valor es NA.\nEl ‚Äòprecio‚Äô para el primer trimestre de 2021 falta impl√≠citamente, porque simplemente no aparece en el conjunto de datos.\n\nUna forma de pensar en la diferencia es con este koan de estilo zen:\n\nUn valor perdido expl√≠cito es la presencia de una ausencia.\nUn valor perdido impl√≠cito es la ausencia de una presencia.\n\nA veces, desea hacer expl√≠citos los faltantes impl√≠citos para tener algo f√≠sico con lo que trabajar. En otros casos, la estructura de los datos le impone faltas expl√≠citas y desea deshacerse de ellas. Las siguientes secciones discuten algunas herramientas para moverse entre faltantes impl√≠citos y expl√≠citos.\n\n18.3.1 Pivotar\nYa ha visto una herramienta que puede hacer expl√≠citas las faltas impl√≠citas y viceversa: pivotar. Ampliar los datos puede hacer que los valores faltantes impl√≠citos sean expl√≠citos porque cada combinaci√≥n de filas y columnas nuevas debe tener alg√∫n valor. Por ejemplo, si hacemos pivotar stocks para colocar el qtr en las columnas, ambos valores faltantes se vuelven expl√≠citos:\n\nstocks |&gt;\n  pivot_wider(\n    names_from = qtr, \n    values_from = price\n  )\n#&gt; # A tibble: 2 √ó 5\n#&gt;    year   `1`   `2`   `3`   `4`\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  2020  1.88  0.59  0.35 NA   \n#&gt; 2  2021 NA     0.92  0.17  2.66\n\nDe forma predeterminada, hacer que los datos duren m√°s tiempo conserva los valores faltantes expl√≠citos, pero si son valores faltantes estructuralmente que solo existen porque los datos no est√°n ordenados, puede descartarlos (hacerlos impl√≠citos) configurando values_drop_na = TRUE. Consulte los ejemplos en Secci√≥n 5.2 para obtener m√°s detalles.\n\n18.3.2 Completo\ntidyr::complete() te permite generar valores perdidos expl√≠citos proporcionando un conjunto de variables que definen la combinaci√≥n de filas que deber√≠an existir. Por ejemplo, sabemos que todas las combinaciones de year y qtr deben existir en los datos de stocks:\n\nstocks |&gt;\n  complete(year, qtr)\n#&gt; # A tibble: 8 √ó 3\n#&gt;    year   qtr price\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  2020     1  1.88\n#&gt; 2  2020     2  0.59\n#&gt; 3  2020     3  0.35\n#&gt; 4  2020     4 NA   \n#&gt; 5  2021     1 NA   \n#&gt; 6  2021     2  0.92\n#&gt; # ‚Ñπ 2 more rows\n\nPor lo general, llamar√° a complete() con los nombres de las variables existentes, completando las combinaciones que faltan. Sin embargo, a veces las variables individuales est√°n incompletas, por lo que puede proporcionar sus propios datos. Por ejemplo, es posible que sepa que se supone que el conjunto de datos de stocks se ejecutar√° desde 2019 hasta 2021, por lo que podr√≠a proporcionar expl√≠citamente esos valores para year:\n\nstocks |&gt;\n  complete(year = 2019:2021, qtr)\n#&gt; # A tibble: 12 √ó 3\n#&gt;    year   qtr price\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  2019     1 NA   \n#&gt; 2  2019     2 NA   \n#&gt; 3  2019     3 NA   \n#&gt; 4  2019     4 NA   \n#&gt; 5  2020     1  1.88\n#&gt; 6  2020     2  0.59\n#&gt; # ‚Ñπ 6 more rows\n\nSi el rango de una variable es correcto, pero no todos los valores est√°n presentes, puede usar full_seq(x, 1) para generar todos los valores desde min(x) hasta max(x) separados por 1.\nEn algunos casos, el conjunto completo de observaciones no puede generarse mediante una simple combinaci√≥n de variables. En ese caso, puede hacer manualmente lo que complete() hace por usted: crear un marco de datos que contenga todas las filas que deber√≠an existir (usando cualquier combinaci√≥n de t√©cnicas que necesite), luego comb√≠nelo con su conjunto de datos original con dplyr ::full_join().\n\n18.3.3 Uniones\nEsto nos lleva a otra forma importante de revelar observaciones que faltan impl√≠citamente: las uniones. Aprender√° m√°s sobre las uniones en Cap√≠tulo 19, pero quer√≠amos mencionarlas r√°pidamente aqu√≠, ya que a menudo solo puede saber que faltan valores en un conjunto de datos cuando lo compara con otro.\ndplyr::anti_join(x, y) es una herramienta particularmente √∫til aqu√≠ porque selecciona solo las filas en x que no tienen una coincidencia en y. Por ejemplo, podemos usar dos anti_join()s para revelar que nos falta informaci√≥n para cuatro aeropuertos y 722 aviones mencionados en flights:\n\nlibrary(nycflights13)\n\nflights |&gt; \n  distinct(faa = dest) |&gt; \n  anti_join(airports)\n#&gt; Joining with `by = join_by(faa)`\n#&gt; # A tibble: 4 √ó 1\n#&gt;   faa  \n#&gt;   &lt;chr&gt;\n#&gt; 1 BQN  \n#&gt; 2 SJU  \n#&gt; 3 STT  \n#&gt; 4 PSE\n\nflights |&gt; \n  distinct(tailnum) |&gt; \n  anti_join(planes)\n#&gt; Joining with `by = join_by(tailnum)`\n#&gt; # A tibble: 722 √ó 1\n#&gt;   tailnum\n#&gt;   &lt;chr&gt;  \n#&gt; 1 N3ALAA \n#&gt; 2 N3DUAA \n#&gt; 3 N542MQ \n#&gt; 4 N730MQ \n#&gt; 5 N9EAMQ \n#&gt; 6 N532UA \n#&gt; # ‚Ñπ 716 more rows\n\n\n18.3.4 Ejercicios\n\n¬øPuedes encontrar alguna relaci√≥n entre el portaaviones y las filas que parecen faltar en planes?",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Valores faltanres</span>"
    ]
  },
  {
    "objectID": "missing-values.html#factores-y-grupos-vac√≠os",
    "href": "missing-values.html#factores-y-grupos-vac√≠os",
    "title": "18¬† Valores faltanres",
    "section": "\n18.4 Factores y grupos vac√≠os",
    "text": "18.4 Factores y grupos vac√≠os\nUn √∫ltimo tipo de ausencia es el grupo vac√≠o, un grupo que no contiene ninguna observaci√≥n, que puede surgir cuando se trabaja con factores. Por ejemplo, imagina que tenemos un conjunto de datos que contiene informaci√≥n sobre la salud de las personas:\n\nhealth &lt;- tibble(\n  name   = c(\"Ikaia\", \"Oletta\", \"Leriah\", \"Dashay\", \"Tresaun\"),\n  smoker = factor(c(\"no\", \"no\", \"no\", \"no\", \"no\"), levels = c(\"yes\", \"no\")),\n  age    = c(34, 88, 75, 47, 56),\n)\n\nY queremos contar el n√∫mero de fumadores con dplyr::count():\n\nhealth |&gt; count(smoker)\n#&gt; # A tibble: 1 √ó 2\n#&gt;   smoker     n\n#&gt;   &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 no         5\n\nEste conjunto de datos solo contiene no fumadores, pero sabemos que existen fumadores; el grupo de no fumadores est√° vac√≠o. Podemos solicitar a count() que mantenga todos los grupos, incluso aquellos que no se ven en los datos usando .drop = FALSE:\n\nhealth |&gt; count(smoker, .drop = FALSE)\n#&gt; # A tibble: 2 √ó 2\n#&gt;   smoker     n\n#&gt;   &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 yes        0\n#&gt; 2 no         5\n\nEl mismo principio se aplica a los ejes discretos de ggplot2, que tambi√©n eliminar√°n los niveles que no tengan ning√∫n valor. Puede obligarlos a que se muestren proporcionando drop = FALSE en el eje discreto apropiado:\nggplot(health, aes(x = smoker)) +\n  geom_bar() +\n  scale_x_discrete()\n\nggplot(health, aes(x = smoker)) +\n  geom_bar() +\n  scale_x_discrete(drop = FALSE)\n\n\n\n\n\n\n\n\n\n\nEl mismo problema surge de manera m√°s general con dplyr::group_by(). Y de nuevo puedes usar .drop = FALSE para conservar todos los niveles de los factores:\n\nhealth |&gt; \n  group_by(smoker, .drop = FALSE) |&gt; \n  summarize(\n    n = n(),\n    mean_age = mean(age),\n    min_age = min(age),\n    max_age = max(age),\n    sd_age = sd(age)\n  )\n#&gt; # A tibble: 2 √ó 6\n#&gt;   smoker     n mean_age min_age max_age sd_age\n#&gt;   &lt;fct&gt;  &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 yes        0      NaN     Inf    -Inf   NA  \n#&gt; 2 no         5       60      34      88   21.6\n\nAqu√≠ obtenemos algunos resultados interesantes porque al resumir un grupo vac√≠o, las funciones de resumen se aplican a vectores de longitud cero. Hay una distinci√≥n importante entre los vectores vac√≠os, que tienen una longitud de 0, y los valores faltantes, cada uno de los cuales tiene una longitud de 1.\n\n# Un vector que contiene dos valores faltantes\nx1 &lt;- c(NA, NA)\nlength(x1)\n#&gt; [1] 2\n\n# Un vector que no contiene nada\nx2 &lt;- numeric()\nlength(x2)\n#&gt; [1] 0\n\nTodas las funciones de resumen funcionan con vectores de longitud cero, pero pueden devolver resultados sorprendentes a primera vista. Aqu√≠ vemos que mean(age) devuelve NaN porque mean(age) = sum(age)/length(age) que aqu√≠ es 0/0. max() y min() devuelven -Inf e Inf para vectores vac√≠os, por lo que si combina los resultados con un vector no vac√≠o de nuevos datos y vuelve a calcular, obtendr√° el m√≠nimo o el m√°ximo de los nuevos datos[^ valores perdidos-1].\nA veces, un enfoque m√°s simple es realizar el resumen y luego hacer expl√≠citas las faltas impl√≠citas con complete().\n\nhealth |&gt; \n  group_by(smoker) |&gt; \n  summarize(\n    n = n(),\n    mean_age = mean(age),\n    min_age = min(age),\n    max_age = max(age),\n    sd_age = sd(age)\n  ) |&gt; \n  complete(smoker)\n#&gt; # A tibble: 2 √ó 6\n#&gt;   smoker     n mean_age min_age max_age sd_age\n#&gt;   &lt;fct&gt;  &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 yes       NA       NA      NA      NA   NA  \n#&gt; 2 no         5       60      34      88   21.6\n\nEl principal inconveniente de este enfoque es que obtienes un NA para el conteo, aunque sabes que deber√≠a ser cero.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Valores faltanres</span>"
    ]
  },
  {
    "objectID": "missing-values.html#resumen",
    "href": "missing-values.html#resumen",
    "title": "18¬† Valores faltanres",
    "section": "\n18.5 Resumen",
    "text": "18.5 Resumen\n¬°Los valores perdidos son raros! A veces se registran como un ‚ÄòNA‚Äô expl√≠cito, pero otras veces solo se notan por su ausencia. Este cap√≠tulo le ha brindado algunas herramientas para trabajar con valores perdidos expl√≠citos, herramientas para descubrir valores perdidos impl√≠citos y discutido algunas de las formas en que lo impl√≠cito puede volverse expl√≠cito y viceversa.\nEn el siguiente cap√≠tulo, abordamos el √∫ltimo cap√≠tulo de esta parte del libro: las uniones. Este es un peque√±o cambio con respecto a los cap√≠tulos hasta ahora porque vamos a discutir las herramientas que funcionan con marcos de datos como un todo, no algo que se coloca dentro de un marco de datos.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Valores faltanres</span>"
    ]
  },
  {
    "objectID": "joins.html",
    "href": "joins.html",
    "title": "19¬† Uniones",
    "section": "",
    "text": "19.1 Introducci√≥n\nEs raro que un an√°lisis de datos involucre solo un √∫nico marco de datos. Por lo general, tiene muchos marcos de datos y debe unirlos para responder las preguntas que le interesan. Este cap√≠tulo le presentar√° dos tipos importantes de uniones:\nComenzaremos analizando las llaves, las variables que se utilizan para conectar un par de marcos de datos en una combinaci√≥n. Cimentamos la teor√≠a con un examen de las llaves en los conjuntos de datos del paquete nycflights13, luego usamos ese conocimiento para comenzar a unir marcos de datos. A continuaci√≥n, analizaremos c√≥mo funcionan las uniones, centr√°ndonos en su acci√≥n en las filas. Terminaremos con una discusi√≥n sobre las uniones no equitativas, una familia de uniones que proporcionan una forma m√°s flexible de hacer coincidir llaves que la relaci√≥n de igualdad predeterminada.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Uniones</span>"
    ]
  },
  {
    "objectID": "joins.html#introducci√≥n",
    "href": "joins.html#introducci√≥n",
    "title": "19¬† Uniones",
    "section": "",
    "text": "Combinaciones mutantes, que agregan nuevas variables a un marco de datos a partir de observaciones coincidentes en otro.\nCombinaciones de filtrado, que filtran las observaciones de un marco de datos en funci√≥n de si coinciden o no con una observaci√≥n en otro.\n\n\n\n19.1.1 Requisitos previos\nEn este cap√≠tulo, exploraremos los cinco conjuntos de datos relacionados de nycflights13 utilizando las funciones de combinaci√≥n de dplyr.\n\nlibrary(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Uniones</span>"
    ]
  },
  {
    "objectID": "joins.html#llaves",
    "href": "joins.html#llaves",
    "title": "19¬† Uniones",
    "section": "\n19.2 Llaves",
    "text": "19.2 Llaves\nPara comprender las uniones, primero debe comprender c√≥mo se pueden conectar dos tablas a trav√©s de un par de llaves, dentro de cada tabla. En esta secci√≥n, aprender√° sobre los dos tipos de llave y ver√° ejemplos de ambos en los conjuntos de datos del paquete nycflights13. Tambi√©n aprender√° c√≥mo verificar que sus llaves sean v√°lidas y qu√© hacer si su tabla no tiene una llave.\n\n19.2.1 Llaves primarias y for√°neas\nCada uni√≥n implica un par de llaves: una llave principal y una llave externa. Una Llave principal es una variable o un conjunto de variables que identifica de forma √∫nica cada observaci√≥n. Cuando se necesita m√°s de una variable, la llave se denomina Llave compuesta. Por ejemplo, en nycflights13:\n\n\nairlines registra dos datos sobre cada aerol√≠nea: su c√≥digo de aerol√≠nea y su nombre completo. Puede identificar una l√≠nea a√©rea con su c√≥digo de dos letras, haciendo que carrier sea la llave principal.\n\nairlines\n#&gt; # A tibble: 16 √ó 2\n#&gt;   carrier name                    \n#&gt;   &lt;chr&gt;   &lt;chr&gt;                   \n#&gt; 1 9E      Endeavor Air Inc.       \n#&gt; 2 AA      American Airlines Inc.  \n#&gt; 3 AS      Alaska Airlines Inc.    \n#&gt; 4 B6      JetBlue Airways         \n#&gt; 5 DL      Delta Air Lines Inc.    \n#&gt; 6 EV      ExpressJet Airlines Inc.\n#&gt; # ‚Ñπ 10 more rows\n\n\n\nairports registra datos sobre cada aeropuerto. Puede identificar cada aeropuerto por su c√≥digo de aeropuerto de tres letras, haciendo que faa sea la llave principal.\n\nairports\n#&gt; # A tibble: 1,458 √ó 8\n#&gt;   faa   name                            lat   lon   alt    tz dst  \n#&gt;   &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1 04G   Lansdowne Airport              41.1 -80.6  1044    -5 A    \n#&gt; 2 06A   Moton Field Municipal Airport  32.5 -85.7   264    -6 A    \n#&gt; 3 06C   Schaumburg Regional            42.0 -88.1   801    -6 A    \n#&gt; 4 06N   Randall Airport                41.4 -74.4   523    -5 A    \n#&gt; 5 09J   Jekyll Island Airport          31.1 -81.4    11    -5 A    \n#&gt; 6 0A9   Elizabethton Municipal Airpo‚Ä¶  36.4 -82.2  1593    -5 A    \n#&gt; # ‚Ñπ 1,452 more rows\n#&gt; # ‚Ñπ 1 more variable: tzone &lt;chr&gt;\n\n\n\nplanes registra datos sobre cada plano. Puede identificar un avi√≥n por su n√∫mero de cola, haciendo que tailnum sea la llave principal.\n\nplanes\n#&gt; # A tibble: 3,322 √ó 9\n#&gt;   tailnum  year type              manufacturer    model     engines\n#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;             &lt;chr&gt;           &lt;chr&gt;       &lt;int&gt;\n#&gt; 1 N10156   2004 Fixed wing multi‚Ä¶ EMBRAER         EMB-145XR       2\n#&gt; 2 N102UW   1998 Fixed wing multi‚Ä¶ AIRBUS INDUSTR‚Ä¶ A320-214        2\n#&gt; 3 N103US   1999 Fixed wing multi‚Ä¶ AIRBUS INDUSTR‚Ä¶ A320-214        2\n#&gt; 4 N104UW   1999 Fixed wing multi‚Ä¶ AIRBUS INDUSTR‚Ä¶ A320-214        2\n#&gt; 5 N10575   2002 Fixed wing multi‚Ä¶ EMBRAER         EMB-145LR       2\n#&gt; 6 N105UW   1999 Fixed wing multi‚Ä¶ AIRBUS INDUSTR‚Ä¶ A320-214        2\n#&gt; # ‚Ñπ 3,316 more rows\n#&gt; # ‚Ñπ 3 more variables: seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt;\n\n\n\nweather registra datos sobre el clima en los aeropuertos de origen. Puede identificar cada observaci√≥n por la combinaci√≥n de ubicaci√≥n y hora, haciendo que origin y time_hour sean la llave principal compuesta.\n\nweather\n#&gt; # A tibble: 26,115 √ó 15\n#&gt;   origin  year month   day  hour  temp  dewp humid wind_dir\n#&gt;   &lt;chr&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 EWR     2013     1     1     1  39.0  26.1  59.4      270\n#&gt; 2 EWR     2013     1     1     2  39.0  27.0  61.6      250\n#&gt; 3 EWR     2013     1     1     3  39.0  28.0  64.4      240\n#&gt; 4 EWR     2013     1     1     4  39.9  28.0  62.2      250\n#&gt; 5 EWR     2013     1     1     5  39.0  28.0  64.4      260\n#&gt; 6 EWR     2013     1     1     6  37.9  28.0  67.2      240\n#&gt; # ‚Ñπ 26,109 more rows\n#&gt; # ‚Ñπ 6 more variables: wind_speed &lt;dbl&gt;, wind_gust &lt;dbl&gt;, ‚Ä¶\n\n\n\nUna llave externa es una variable (o conjunto de variables) que corresponde a una llave principal en otra tabla. Por ejemplo:\n\n\nflights$tailnum es una llave for√°nea que corresponde a la llave primaria planes$tailnum.\n\nflights$carrier es una llave for√°nea que corresponde a la llave primaria airlines$carrier.\n\nflights$origin es una llave for√°nea que corresponde a la llave primaria airports$faa.\n\nflights$dest es una llave for√°nea que corresponde a la llave primaria airports$faa.\n\nflights$origin-flights$time_hour es una llave for√°nea compuesta que corresponde a la llave primaria compuesta weather$origin-weather$time_hour.\n\nEstas relaciones se resumen visualmente en Figura¬†19.1.\n\n\n\n\n\n\n\nFigura¬†19.1: Conexiones entre los cinco marcos de datos en el paquete nycflights13. Las variables que componen una llave primaria son de color gris y est√°n conectadas a sus correspondientes llaves for√°neas con flechas.\n\n\n\n\nNotar√° una buena caracter√≠stica en el dise√±o de estas claves: las claves principal y externa casi siempre tienen los mismos nombres, lo que, como ver√° en breve, har√° que su vida de uni√≥n sea mucho m√°s f√°cil. Tambi√©n vale la pena se√±alar la relaci√≥n opuesta: casi todos los nombres de variables utilizados en varias tablas tienen el mismo significado en cada lugar. S√≥lo hay una excepci√≥n: year significa a√±o de salida en flights y a√±o de fabricaci√≥n en planes. Esto se volver√° importante cuando empecemos a unir tablas.\n\n19.2.2 Comprobaci√≥n de llaves primarias\nAhora que hemos identificado las claves principales en cada tabla, es una buena pr√°ctica verificar que realmente identifiquen de manera √∫nica cada observaci√≥n. Una forma de hacerlo es contar, count(), las llaves primarias y buscar entradas donde n sea mayor que uno. Esto revela que planes y weather se ven bien:\n\nplanes |&gt; \n  count(tailnum) |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 0 √ó 2\n#&gt; # ‚Ñπ 2 variables: tailnum &lt;chr&gt;, n &lt;int&gt;\n\nweather |&gt; \n  count(time_hour, origin) |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 0 √ó 3\n#&gt; # ‚Ñπ 3 variables: time_hour &lt;dttm&gt;, origin &lt;chr&gt;, n &lt;int&gt;\n\nTambi√©n debe verificar si faltan valores en sus llaves principales ‚Äî si falta un valor, ¬°entonces no puede identificar una observaci√≥n!\n\nplanes |&gt; \n  filter(is.na(tailnum))\n#&gt; # A tibble: 0 √ó 9\n#&gt; # ‚Ñπ 9 variables: tailnum &lt;chr&gt;, year &lt;int&gt;, type &lt;chr&gt;, manufacturer &lt;chr&gt;,\n#&gt; #   model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt;\n\nweather |&gt; \n  filter(is.na(time_hour) | is.na(origin))\n#&gt; # A tibble: 0 √ó 15\n#&gt; # ‚Ñπ 15 variables: origin &lt;chr&gt;, year &lt;int&gt;, month &lt;int&gt;, day &lt;int&gt;,\n#&gt; #   hour &lt;int&gt;, temp &lt;dbl&gt;, dewp &lt;dbl&gt;, humid &lt;dbl&gt;, wind_dir &lt;dbl&gt;, ‚Ä¶\n\n\n19.2.3 Llaves sustitutas\nHasta ahora no hemos hablado de la llave principal para flights. No es muy importante aqu√≠, porque no hay marcos de datos que lo usen como clave externa, pero a√∫n as√≠ es √∫til considerarlo porque es m√°s f√°cil trabajar con observaciones si tenemos alguna forma de describirlas a otros.\nDespu√©s de pensar un poco y experimentar, determinamos que hay tres variables que juntas identifican de manera √∫nica cada vuelo:\n\nflights |&gt; \n  count(time_hour, carrier, flight) |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 0 √ó 4\n#&gt; # ‚Ñπ 4 variables: time_hour &lt;dttm&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, n &lt;int&gt;\n\n¬øLa ausencia de duplicados convierte autom√°ticamente a time_hour-carrier-flight en una llave principal? Sin duda es un buen comienzo, pero no lo garantiza. Por ejemplo, ¬øson la altitud y la latitud una buena clave principal para airports?\n\nairports |&gt;\n  count(alt, lat) |&gt; \n  filter(n &gt; 1)\n#&gt; # A tibble: 1 √ó 3\n#&gt;     alt   lat     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1    13  40.6     2\n\nIdentificar un aeropuerto por su altitud y latitud es claramente una mala idea y, en general, no es posible saber solo a partir de los datos si una combinaci√≥n de variables constituye o no una buena clave primaria. Pero para los vuelos, la combinaci√≥n de time_hour, carrier y flight parece razonable porque ser√≠a realmente confuso para una aerol√≠nea y sus clientes si hubiera varios vuelos con el mismo n√∫mero de vuelo en el aire al mismo tiempo.\nDicho esto, ser√≠a mejor que introduj√©ramos una clave sustituta num√©rica simple usando el n√∫mero de fila:\n\nflights2 &lt;- flights |&gt; \n  mutate(id = row_number(), .before = 1)\nflights2\n#&gt; # A tibble: 336,776 √ó 20\n#&gt;      id  year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1     1  2013     1     1      517            515         2      830\n#&gt; 2     2  2013     1     1      533            529         4      850\n#&gt; 3     3  2013     1     1      542            540         2      923\n#&gt; 4     4  2013     1     1      544            545        -1     1004\n#&gt; 5     5  2013     1     1      554            600        -6      812\n#&gt; 6     6  2013     1     1      554            558        -4      740\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, ‚Ä¶\n\nLas claves sustitutas pueden ser particularmente √∫tiles cuando se comunican con otros humanos: es mucho m√°s f√°cil decirle a alguien que mire el vuelo 2001 que decir que mire el UA430 que parti√≥ 9am 2013-01-03.\n\n19.2.4 Ejercicios\n\nNos olvidamos de dibujar la relaci√≥n entre weather y airports en Figura¬†19.1. ¬øCu√°l es la relaci√≥n y c√≥mo deber√≠a aparecer en el diagrama?\nweather solo contiene informaci√≥n de los tres aeropuertos de origen en NYC. Si contuviera registros meteorol√≥gicos de todos los aeropuertos de EE.UU. ¬øqu√© conexi√≥n adicional har√≠a con flights?\nLas variables year, month, day, hour y origin casi forman una clave compuesta para weather, pero hay una hora que tiene observaciones duplicadas. ¬øPuedes averiguar qu√© tiene de especial esa hora?\nSabemos que algunos d√≠as del a√±o son especiales y en ellos vuelan menos personas de lo habitual (por ejemplo, la v√≠spera de Navidad y el d√≠a de Navidad). ¬øC√≥mo podr√≠a representar esos datos como un marco de datos? ¬øCu√°l ser√≠a la llave principal? ¬øC√≥mo se conectar√≠a a los marcos de datos existentes?\nDibuje un diagrama que ilustre las conexiones entre los marcos de datos Batting, People y Salaries en el paquete Lahman. Dibuja otro diagrama que muestre la relaci√≥n entre People, Managers, AwardsManagers. ¬øC√≥mo caracterizar√≠a la relaci√≥n entre los data frames Batting, Pitching, y Fielding?",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Uniones</span>"
    ]
  },
  {
    "objectID": "joins.html#sec-mutating-joins",
    "href": "joins.html#sec-mutating-joins",
    "title": "19¬† Uniones",
    "section": "\n19.3 Uniones b√°sicas",
    "text": "19.3 Uniones b√°sicas\nAhora que comprende c√≥mo se conectan los marcos de datos a trav√©s de claves, podemos comenzar a usar uniones para comprender mejor el conjunto de datos de flights. dplyr proporciona seis funciones de uni√≥n: left_join(), inner_join(), right_join(), full_join(), semi_join() y anti_join(). Todas tienen la misma interfaz: toman un par de marcos de datos (x e y) y devuelven un marco de datos. El orden de las filas y columnas en la salida est√° determinado principalmente por x.\nEn esta secci√≥n, aprender√° a usar una uni√≥n mutante, left_join(), y dos uniones de filtrado, semi_join() y anti_join(). En la siguiente secci√≥n, aprender√° exactamente c√≥mo funcionan estas funciones y sobre las inner_join(), right_join() y full_join() restantes.\n\n19.3.1 Uniones mutantes\nUna uni√≥n mutante le permite combinar variables de dos marcos de datos: primero hace coincidir las observaciones por sus claves, luego copia las variables de un marco de datos al otro. Al igual que mutate(), las funciones de combinaci√≥n agregan variables a la derecha, por lo que si su conjunto de datos tiene muchas variables, no ver√° las nuevas. Para estos ejemplos, facilitaremos ver lo que sucede creando un conjunto de datos m√°s estrecho con solo seis variables1:\n\nflights2 &lt;- flights |&gt; \n  select(year, time_hour, origin, dest, tailnum, carrier)\nflights2\n#&gt; # A tibble: 336,776 √ó 6\n#&gt;    year time_hour           origin dest  tailnum carrier\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA     \n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA     \n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA     \n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6     \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL     \n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA     \n#&gt; # ‚Ñπ 336,770 more rows\n\nHay cuatro tipos de uni√≥n mutante, pero hay una que usar√° casi todo el tiempo: left_join(). Es especial porque la salida siempre tendr√° las mismas filas que x, el dataframe al que estas uniendo2. El uso principal de left_join() es agregar metadatos adicionales. Por ejemplo, podemos usar left_join() para agregar el nombre completo de la aerol√≠nea a los datos de flights2:\n\nflights2 |&gt;\n  left_join(airlines)\n#&gt; Joining with `by = join_by(carrier)`\n#&gt; # A tibble: 336,776 √ó 7\n#&gt;    year time_hour           origin dest  tailnum carrier name                \n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;               \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      United Air Lines In‚Ä¶\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      United Air Lines In‚Ä¶\n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      American Airlines I‚Ä¶\n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      JetBlue Airways     \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Delta Air Lines Inc.\n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      United Air Lines In‚Ä¶\n#&gt; # ‚Ñπ 336,770 more rows\n\nO podr√≠amos averiguar la temperatura y la velocidad del viento cuando parti√≥ cada avi√≥n:\n\nflights2 |&gt; \n  left_join(weather |&gt; select(origin, time_hour, temp, wind_speed))\n#&gt; Joining with `by = join_by(time_hour, origin)`\n#&gt; # A tibble: 336,776 √ó 8\n#&gt;    year time_hour           origin dest  tailnum carrier  temp wind_speed\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA       39.0       12.7\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA       39.9       15.0\n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA       39.0       15.0\n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6       39.0       15.0\n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL       39.9       16.1\n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA       39.0       12.7\n#&gt; # ‚Ñπ 336,770 more rows\n\nO qu√© tama√±o de avi√≥n estaba volando:\n\nflights2 |&gt; \n  left_join(planes |&gt; select(tailnum, type, engines, seats))\n#&gt; Joining with `by = join_by(tailnum)`\n#&gt; # A tibble: 336,776 √ó 9\n#&gt;    year time_hour           origin dest  tailnum carrier type                \n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;               \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Fixed wing multi en‚Ä¶\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      Fixed wing multi en‚Ä¶\n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Fixed wing multi en‚Ä¶\n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      Fixed wing multi en‚Ä¶\n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Fixed wing multi en‚Ä¶\n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Fixed wing multi en‚Ä¶\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 2 more variables: engines &lt;int&gt;, seats &lt;int&gt;\n\nCuando left_join() no encuentra una coincidencia para una fila en x, completa las nuevas variables con los valores que faltan. Por ejemplo, no hay informaci√≥n sobre el avi√≥n con el n√∫mero de cola N3ALAA, por lo que faltar√°n el type, los engines y los seats:\n\nflights2 |&gt; \n  filter(tailnum == \"N3ALAA\") |&gt; \n  left_join(planes |&gt; select(tailnum, type, engines, seats))\n#&gt; Joining with `by = join_by(tailnum)`\n#&gt; # A tibble: 63 √ó 9\n#&gt;    year time_hour           origin dest  tailnum carrier type  engines seats\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt; &lt;int&gt;\n#&gt; 1  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 2  2013 2013-01-02 18:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 3  2013 2013-01-03 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 4  2013 2013-01-07 19:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 5  2013 2013-01-08 17:00:00 JFK    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; 6  2013 2013-01-16 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA\n#&gt; # ‚Ñπ 57 more rows\n\nVolveremos a este problema unas cuantas veces en el resto del cap√≠tulo.\n\n19.3.2 Especificaci√≥n de llaves de combinaci√≥n\nPor defecto, left_join() usar√° todas las variables que aparecen en ambos marcos de datos como llave de uni√≥n, la llamada uni√≥n natural. Esta es una heur√≠stica √∫til, pero no siempre funciona. Por ejemplo, ¬øqu√© sucede si tratamos de unir flights2 con el conjunto de datos completo planes?\n\nflights2 |&gt; \n  left_join(planes)\n#&gt; Joining with `by = join_by(year, tailnum)`\n#&gt; # A tibble: 336,776 √ó 13\n#&gt;    year time_hour           origin dest  tailnum carrier type  manufacturer\n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;       \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      &lt;NA&gt;  &lt;NA&gt;        \n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 5 more variables: model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, ‚Ä¶\n\nNos faltan muchas coincidencias porque nuestra combinaci√≥n intenta usar tailnum y year como clave compuesta. Tanto flights como planes tienen una columna de year pero significan cosas diferentes: flights$year es el a√±o en que ocurri√≥ el vuelo y planes$year es el a√±o en que se construy√≥ el avi√≥n. Solo queremos unirnos en tailnum, por lo que debemos proporcionar una especificaci√≥n expl√≠cita con join_by ():\n\nflights2 |&gt; \n  left_join(planes, join_by(tailnum))\n#&gt; # A tibble: 336,776 √ó 14\n#&gt;   year.x time_hour           origin dest  tailnum carrier year.y\n#&gt;    &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;    &lt;int&gt;\n#&gt; 1   2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA        1999\n#&gt; 2   2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA        1998\n#&gt; 3   2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA        1990\n#&gt; 4   2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6        2012\n#&gt; 5   2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL        1991\n#&gt; 6   2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA        2012\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 7 more variables: type &lt;chr&gt;, manufacturer &lt;chr&gt;, model &lt;chr&gt;, ‚Ä¶\n\nTenga en cuenta que las variables year se eliminan de la ambig√ºedad en la salida con un sufijo (year.x y year.y), que le indica si la variable proviene del argumento x o y. Puede anular los sufijos predeterminados con el argumento suffix.\njoin_by(tailnum) es corto para join_by(tailnum == tailnum). Es importante saber acerca de esta forma m√°s completa por dos razones. En primer lugar, describe la relaci√≥n entre las dos tablas: las claves deben ser iguales. Es por eso que este tipo de uni√≥n a menudo se denomina equi-uni√≥n. Aprender√° acerca de las uniones no equitativas en Secci√≥n 19.5.\nEn segundo lugar, es c√≥mo especifica diferentes claves de combinaci√≥n en cada tabla. Por ejemplo, hay dos formas de unirs las tablas flight2 y airports: ya sea por dest o origin:\n\nflights2 |&gt; \n  left_join(airports, join_by(dest == faa))\n#&gt; # A tibble: 336,776 √ó 13\n#&gt;    year time_hour           origin dest  tailnum carrier name                \n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;               \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      George Bush Interco‚Ä¶\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      George Bush Interco‚Ä¶\n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Miami Intl          \n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      &lt;NA&gt;                \n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Hartsfield Jackson ‚Ä¶\n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Chicago Ohare Intl  \n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 6 more variables: lat &lt;dbl&gt;, lon &lt;dbl&gt;, alt &lt;dbl&gt;, tz &lt;dbl&gt;, ‚Ä¶\n\nflights2 |&gt; \n  left_join(airports, join_by(origin == faa))\n#&gt; # A tibble: 336,776 √ó 13\n#&gt;    year time_hour           origin dest  tailnum carrier name               \n#&gt;   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;              \n#&gt; 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Newark Liberty Intl\n#&gt; 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      La Guardia         \n#&gt; 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      John F Kennedy Intl\n#&gt; 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      John F Kennedy Intl\n#&gt; 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      La Guardia         \n#&gt; 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Newark Liberty Intl\n#&gt; # ‚Ñπ 336,770 more rows\n#&gt; # ‚Ñπ 6 more variables: lat &lt;dbl&gt;, lon &lt;dbl&gt;, alt &lt;dbl&gt;, tz &lt;dbl&gt;, ‚Ä¶\n\nEn el c√≥digo anterior, es posible que vea una forma diferente de especificar las claves de combinaci√≥n, utilizando un vector de caracteres:\n\n\nby = \"x\" corresponde a join_by(x).\n\nby = c(\"a\" = \"x\") corresponde a join_by(a == x).\n\nAhora que existe, preferimos join_by() ya que proporciona una especificaci√≥n m√°s clara y flexible.\ninner_join(), right_join(), full_join() tienen la misma que left_join(). La diferencia es qu√© filas conservan: la combinaci√≥n izquierda mantiene todas las filas en x, la combinaci√≥n derecha mantiene todas las filas en y, la combinaci√≥n completa mantiene todas las filas en x o y, y la combinaci√≥n interna solo mantiene las filas que aparecen tanto en x como en y. Volveremos a esto con m√°s detalle m√°s adelante.\n\n19.3.3 Filtrado de uniones\nComo puede suponer, la acci√≥n principal de una uni√≥n de filtrado es filtrar las filas. Hay dos tipos: semi-uniones y anti-uniones. Semi-uniones mantienen todas las filas en x que tienen una coincidencia en y. Por ejemplo, podr√≠amos usar una semi-uni√≥n para filtrar el conjunto de datos airports para mostrar solo los aeropuertos de origen:\n\nairports |&gt; \n  semi_join(flights2, join_by(faa == origin))\n#&gt; # A tibble: 3 √ó 8\n#&gt;   faa   name                  lat   lon   alt    tz dst   tzone           \n#&gt;   &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           \n#&gt; 1 EWR   Newark Liberty Intl  40.7 -74.2    18    -5 A     America/New_York\n#&gt; 2 JFK   John F Kennedy Intl  40.6 -73.8    13    -5 A     America/New_York\n#&gt; 3 LGA   La Guardia           40.8 -73.9    22    -5 A     America/New_York\n\nO solo los destinos:\n\nairports |&gt; \n  semi_join(flights2, join_by(faa == dest))\n#&gt; # A tibble: 101 √ó 8\n#&gt;   faa   name                     lat    lon   alt    tz dst   tzone          \n#&gt;   &lt;chr&gt; &lt;chr&gt;                  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;          \n#&gt; 1 ABQ   Albuquerque Internati‚Ä¶  35.0 -107.   5355    -7 A     America/Denver \n#&gt; 2 ACK   Nantucket Mem           41.3  -70.1    48    -5 A     America/New_Yo‚Ä¶\n#&gt; 3 ALB   Albany Intl             42.7  -73.8   285    -5 A     America/New_Yo‚Ä¶\n#&gt; 4 ANC   Ted Stevens Anchorage‚Ä¶  61.2 -150.    152    -9 A     America/Anchor‚Ä¶\n#&gt; 5 ATL   Hartsfield Jackson At‚Ä¶  33.6  -84.4  1026    -5 A     America/New_Yo‚Ä¶\n#&gt; 6 AUS   Austin Bergstrom Intl   30.2  -97.7   542    -6 A     America/Chicago\n#&gt; # ‚Ñπ 95 more rows\n\nAnti-joins son lo contrario: devuelven todas las filas en x que no tienen una coincidencia en y. Son √∫tiles para encontrar valores perdidos que est√°n impl√≠citos en los datos, el tema de Secci√≥n 18.3. Los valores faltantes impl√≠citos no se muestran como NA, sino que solo existen como una ausencia. Por ejemplo, podemos encontrar filas que faltan en airports buscando vuelos que no tengan un aeropuerto de destino coincidente:\n\nflights2 |&gt; \n  anti_join(airports, join_by(dest == faa)) |&gt; \n  distinct(dest)\n#&gt; # A tibble: 4 √ó 1\n#&gt;   dest \n#&gt;   &lt;chr&gt;\n#&gt; 1 BQN  \n#&gt; 2 SJU  \n#&gt; 3 STT  \n#&gt; 4 PSE\n\nO podemos encontrar qu√© tailnums faltan en planes:\n\nflights2 |&gt;\n  anti_join(planes, join_by(tailnum)) |&gt; \n  distinct(tailnum)\n#&gt; # A tibble: 722 √ó 1\n#&gt;   tailnum\n#&gt;   &lt;chr&gt;  \n#&gt; 1 N3ALAA \n#&gt; 2 N3DUAA \n#&gt; 3 N542MQ \n#&gt; 4 N730MQ \n#&gt; 5 N9EAMQ \n#&gt; 6 N532UA \n#&gt; # ‚Ñπ 716 more rows\n\n\n19.3.4 Ejercicios\n\nEncuentra las 48 horas (en el transcurso de todo el a√±o) que tienen los peores retrasos. Haga una referencia cruzada con los datos del weather. ¬øPuedes ver alg√∫n patr√≥n?\n\nImagina que has encontrado los 10 destinos m√°s populares usando este c√≥digo:\n\ntop_dest &lt;- flights2 |&gt;\n  count(dest, sort = TRUE) |&gt;\n  head(10)\n\n¬øC√≥mo puede encontrar todos los vuelos a esos destinos?\n\n¬øTodos los vuelos que salen tienen los datos meteorol√≥gicos correspondientes a esa hora?\n¬øQu√© tienen en com√∫n los n√∫meros de cola que no tienen un registro coincidente en planes? (Pista: una variable explica ~90% de los problemas.)\nAgregue una columna a planes que enumere cada carrier que ha volado ese avi√≥n. Es de esperar que haya una relaci√≥n impl√≠cita entre el avi√≥n y la l√≠nea a√©rea, porque cada avi√≥n lo pilota una sola l√≠nea a√©rea. Confirme o rechace esta hip√≥tesis utilizando las herramientas que ha aprendido en los cap√≠tulos anteriores.\nA√±ade la latitud y la longitud del aeropuerto de origen y de destino a flights. ¬øEs m√°s f√°cil cambiar el nombre de las columnas antes o despu√©s de la uni√≥n?\n\nCalcule el retraso promedio por destino, luego √∫nase al marco de datos airports para que pueda mostrar la distribuci√≥n espacial de los retrasos. Aqu√≠ hay una manera f√°cil de dibujar un mapa de los Estados Unidos.:\n\nairports |&gt;\n  semi_join(flights, join_by(faa == dest)) |&gt;\n  ggplot(aes(x = lon, y = lat)) +\n    borders(\"state\") +\n    geom_point() +\n    coord_quickmap()\n\nEs posible que desee utilizar el size o el color de los puntos para mostrar el retraso promedio de cada aeropuerto.\n\n¬øQu√© pas√≥ el 13 de junio de 2013? Dibuje un mapa de los retrasos y luego use Google para hacer una referencia cruzada con el clima.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Uniones</span>"
    ]
  },
  {
    "objectID": "joins.html#c√≥mo-funcionan-las-uniones",
    "href": "joins.html#c√≥mo-funcionan-las-uniones",
    "title": "19¬† Uniones",
    "section": "\n19.4 ¬øC√≥mo funcionan las uniones?",
    "text": "19.4 ¬øC√≥mo funcionan las uniones?\nAhora que ha usado combinaciones varias veces, es hora de aprender m√°s sobre c√≥mo funcionan, enfoc√°ndose en c√≥mo cada fila en x coincide con las filas en y. Comenzaremos presentando una representaci√≥n visual de las uniones, usando los simples tibbles definidos a continuaci√≥n y que se muestran en Figura¬†19.2. En estos ejemplos, usaremos una sola llave llamada key y una sola columna de valor (val_x y val_y), pero todas las ideas se generalizan a m√∫ltiples llaves y m√∫ltiples valores.\n\nx &lt;- tribble(\n  ~key, ~val_x,\n     1, \"x1\",\n     2, \"x2\",\n     3, \"x3\"\n)\ny &lt;- tribble(\n  ~key, ~val_y,\n     1, \"y1\",\n     2, \"y2\",\n     4, \"y3\"\n)\n\n\n\n\n\n\n\n\nFigura¬†19.2: Representaci√≥n gr√°fica de dos tablas simples. Las columnas key coloreadas asignan el color de fondo al valor clave. Las columnas grises representan las columnas de ‚Äúvalue‚Äù que se llevan durante el viaje.\n\n\n\n\nFigura¬†19.3 introduce la base para nuestra representaci√≥n visual. Muestra todas las posibles coincidencias entre x e y como la intersecci√≥n entre las l√≠neas dibujadas desde cada fila de x y cada fila de y. Las filas y columnas en la salida est√°n determinadas principalmente por x, por lo que la tabla x es horizontal y se alinea con la salida.\n\n\n\n\n\n\n\nFigura¬†19.3: Para comprender c√≥mo funcionan las uniones, es √∫til pensar en todas las coincidencias posibles. Aqu√≠ lo mostramos con una cuadr√≠cula de l√≠neas de conexi√≥n.\n\n\n\n\nPara describir un tipo espec√≠fico de combinaci√≥n, indicamos coincidencias con puntos. Las coincidencias determinan las filas en la salida, un nuevo marco de datos que contiene la clave, los valores x y los valores y. Por ejemplo, Figura¬†19.4 muestra una combinaci√≥n interna, donde las filas se retienen si y solo si las claves son iguales.\n\n\n\n\n\n\n\nFigura¬†19.4: Una uni√≥n interna hace coincidir cada fila en x con la fila en y que tiene el mismo valor de key. Cada coincidencia se convierte en una fila en la salida.\n\n\n\n\nPodemos aplicar los mismos principios para explicar las uniones externas, que mantienen las observaciones que aparecen en al menos uno de los marcos de datos. Estas uniones funcionan agregando una observaci√≥n ‚Äúvirtual‚Äù adicional a cada marco de datos. Esta observaci√≥n tiene una clave que coincide si ninguna otra clave coincide, y los valores se completan con NA. Hay tres tipos de uniones externas:\n\n\nUna uni√≥n izquierda mantiene todas las observaciones en x, Figura¬†19.5. Cada fila de x se conserva en la salida porque puede volver a coincidir con una fila de NAs en y.\n\n\n\n\n\n\n\nFigura¬†19.5: Una representaci√≥n visual de la combinaci√≥n izquierda donde cada fila en x aparece en la salida.\n\n\n\n\n\n\nUna uni√≥n derecha mantiene todas las observaciones en y, Figura¬†19.6. Cada fila de y se conserva en la salida porque puede volver a hacer coincidir una fila de NAs en x. La salida a√∫n coincide con x tanto como sea posible; cualquier fila adicional de y se agrega al final.\n\n\n\n\n\n\n\nFigura¬†19.6: Una representaci√≥n visual de la combinaci√≥n correcta donde cada fila de y aparece en la salida.\n\n\n\n\n\n\nUna combinaci√≥n completa mantiene todas las observaciones que aparecen en x o y, Figura¬†19.7. Cada fila de x e y se incluye en la salida porque tanto x como y tienen una fila de reserva de NA. Una vez m√°s, la salida comienza con todas las filas desde x, seguidas de las filas restantes y no coincidentes.\n\n\n\n\n\n\n\nFigura¬†19.7: Una representaci√≥n visual de la combinaci√≥n completa donde cada fila en x e y aparece en la salida.\n\n\n\n\n\n\nOtra forma de mostrar c√≥mo difieren los tipos de uni√≥n externa es con un diagrama de Venn, como en Figura¬†19.8. Sin embargo, esta no es una gran representaci√≥n porque, si bien puede refrescar su memoria sobre qu√© filas se conservan, no ilustra lo que sucede con las columnas.\n\n\n\n\n\n\n\nFigura¬†19.8: Diagramas de Venn que muestran la diferencia entre uniones internas, izquierdas, derechas y completas.\n\n\n\n\nLas uniones que se muestran aqu√≠ son las denominadas equi uniones, donde las filas coinciden si las claves son iguales. Las uniones equitativas son el tipo de uni√≥n m√°s com√∫n, por lo que normalmente omitiremos el prefijo equi y solo diremos ‚Äúuni√≥n interna‚Äù en lugar de ‚Äúuni√≥n interna equi‚Äù. Volveremos a las uniones no equitativas en Secci√≥n 19.5.\n\n19.4.1 Coincidencia de filas\nHasta ahora hemos explorado lo que sucede si una fila en x coincide con cero o una fila en y. ¬øQu√© sucede si coincide con m√°s de una fila? Para comprender lo que sucede, primero limitemos nuestro enfoque a inner_join() y luego dibujemos una imagen, Figura¬†19.9.\n\n\n\n\n\n\n\nFigura¬†19.9: Las tres formas en que una fila en x puede coincidir. x1 coincide con una fila en y, x2 coincide con dos filas en y, x3 coincide con cero filas en y. Tenga en cuenta que si bien hay tres filas en x y tres filas en la salida, no hay una correspondencia directa entre las filas.\n\n\n\n\nHay tres resultados posibles para una fila en x:\n\nSi no coincide con nada, se descarta.\nSi coincide con 1 fila en y, se conserva.\nSi coincide con m√°s de 1 fila en y, se duplica una vez para cada coincidencia.\n\nEn principio, esto significa que no hay una correspondencia garantizada entre las filas de la salida y las filas de x, pero en la pr√°ctica, esto rara vez causa problemas. Hay, sin embargo, un caso particularmente peligroso que puede provocar una explosi√≥n combinatoria de filas. Imagina unir las siguientes dos tablas:\n\ndf1 &lt;- tibble(key = c(1, 2, 2), val_x = c(\"x1\", \"x2\", \"x3\"))\ndf2 &lt;- tibble(key = c(1, 2, 2), val_y = c(\"y1\", \"y2\", \"y3\"))\n\nMientras que la primera fila en df1 solo coincide con una fila en df2, la segunda y la tercera fila coinciden con dos filas. Esto a veces se denomina uni√≥n de muchos a muchos y har√° que dplyr emita una advertencia:\n\ndf1 |&gt; \n  inner_join(df2, join_by(key))\n#&gt; Warning in inner_join(df1, df2, join_by(key)): Detected an unexpected many-to-many relationship between `x` and `y`.\n#&gt; ‚Ñπ Row 2 of `x` matches multiple rows in `y`.\n#&gt; ‚Ñπ Row 2 of `y` matches multiple rows in `x`.\n#&gt; ‚Ñπ If a many-to-many relationship is expected, set `relationship =\n#&gt;   \"many-to-many\"` to silence this warning.\n#&gt; # A tibble: 5 √ó 3\n#&gt;     key val_x val_y\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1     1 x1    y1   \n#&gt; 2     2 x2    y2   \n#&gt; 3     2 x2    y3   \n#&gt; 4     2 x3    y2   \n#&gt; 5     2 x3    y3\n\nSi est√° haciendo esto deliberadamente, puede configurar relationship = \"many-to-many\", como sugiere la advertencia.\n\n19.4.2 Filtrado de uniones\nEl n√∫mero de coincidencias tambi√©n determina el comportamiento de las uniones de filtrado. El semi-join mantiene filas en x que tienen una o m√°s coincidencias en y, como en Figura¬†19.10. El anti-join mantiene filas en x que coinciden con cero filas en y, como en Figura¬†19.11. En ambos casos, solo es importante la existencia de una coincidencia; no importa cuantas veces coincida. Esto significa que las uniones de filtrado nunca duplican filas como lo hacen las uniones mutantes.\n\n\n\n\n\n\n\nFigura¬†19.10: En un semi-join solo importa que haya coincidencia; de lo contrario, los valores en y no afectan la salida.\n\n\n\n\n\n\n\n\n\n\n\nFigura¬†19.11: Un anti-join es lo contrario de un semi-join, eliminando filas de x que tienen una coincidencia en y.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Uniones</span>"
    ]
  },
  {
    "objectID": "joins.html#sec-non-equi-joins",
    "href": "joins.html#sec-non-equi-joins",
    "title": "19¬† Uniones",
    "section": "\n19.5 Non-equi joins",
    "text": "19.5 Non-equi joins\nHasta ahora solo has visto uniones de igualdad, uniones donde las filas coinciden si la tecla x es igual a la tecla y. Ahora relajaremos esa restricci√≥n y analizaremos otras formas de determinar si un par de filas coinciden.\nPero antes de que podamos hacer eso, debemos revisar una simplificaci√≥n que hicimos anteriormente. En equi-joins, las teclas x e y son siempre iguales, por lo que solo necesitamos mostrar una en la salida. Podemos solicitar que dplyr mantenga ambas claves con keep = TRUE, lo que lleva al siguiente c√≥digo y inner_join() redibujado en Figura¬†19.12.\n\nx |&gt; inner_join(y, join_by(key == key), keep = TRUE)\n#&gt; # A tibble: 2 √ó 4\n#&gt;   key.x val_x key.y val_y\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1     1 x1        1 y1   \n#&gt; 2     2 x2        2 y2\n\n\n\n\n\n\n\n\nFigura¬†19.12: Una combinaci√≥n interna que muestra x e y en la salida.\n\n\n\n\nCuando nos alejamos de las combinaciones de igualdad, siempre mostraremos las claves, porque los valores de las claves a menudo ser√°n diferentes. Por ejemplo, en lugar de hacer coincidir solo cuando la x$key y la y$key son iguales, podr√≠amos hacer coincidir siempre que la x$key sea mayor o igual que la y$key, lo que lleva a Figura¬†19.13. Las funciones de combinaci√≥n de dplyr entienden esta distinci√≥n entre combinaciones equi y no equi, por lo que siempre mostrar√° ambas teclas cuando realice una combinaci√≥n no equi.\n\n\n\n\n\n\n\nFigura¬†19.13: Una combinaci√≥n no equitativa en la que la tecla x debe ser mayor o igual que la tecla y. Muchas filas generan m√∫ltiples coincidencias.\n\n\n\n\nUni√≥n no equitativa no es un t√©rmino particularmente √∫til porque solo le dice qu√© no es la uni√≥n, no qu√© es. dplyr ayuda identificando cuatro tipos particularmente √∫tiles de uni√≥n no equitativa:\n\n\nUniones cruzadas coinciden con cada par de filas.\n\nUniones de desigualdad use &lt;, &lt;=, &gt; y &gt;= en lugar de ==.\n\nLas uniones continuas son similares a las uniones de desigualdad, pero solo encuentran la coincidencia m√°s cercana.\n\nLas uniones superpuestas son un tipo especial de uni√≥n de desigualdades dise√±adas para trabajar con rangos.\n\nCada uno de estos se describe con m√°s detalle en las siguientes secciones.\n\n19.5.1 Uniones cruzadas\nUna uni√≥n cruzada coincide con todo, como en Figura¬†19.14, generando el producto cartesiano de filas. Esto significa que la salida tendr√° filas nrow(x) * nrow(y).\n\n\n\n\n\n\n\nFigura¬†19.14: Una combinaci√≥n cruzada hace coincidir cada fila en x con cada fila en y.\n\n\n\n\nLas uniones cruzadas son √∫tiles cuando se generan permutaciones. Por ejemplo, el siguiente c√≥digo genera todos los pares de nombres posibles. Dado que estamos uniendo df a s√≠ mismo, esto a veces se denomina autouni√≥n. Las uniones cruzadas usan una funci√≥n de uni√≥n diferente porque no hay distinci√≥n entre inner/left/right/full cuando est√°s haciendo coincidir cada fila.\n\ndf &lt;- tibble(name = c(\"John\", \"Simon\", \"Tracy\", \"Max\"))\ndf |&gt; cross_join(df)\n#&gt; # A tibble: 16 √ó 2\n#&gt;   name.x name.y\n#&gt;   &lt;chr&gt;  &lt;chr&gt; \n#&gt; 1 John   John  \n#&gt; 2 John   Simon \n#&gt; 3 John   Tracy \n#&gt; 4 John   Max   \n#&gt; 5 Simon  John  \n#&gt; 6 Simon  Simon \n#&gt; # ‚Ñπ 10 more rows\n\n\n19.5.2 Uniones de desigualdad\nLas uniones de desigualdad usan &lt;, &lt;=, &gt;= o &gt; para restringir el conjunto de posibles coincidencias, como en Figura¬†19.13 y Figura¬†19.15.\n\n\n\n\n\n\n\nFigura¬†19.15: Una uni√≥n de desigualdad donde ‚Äòx‚Äô se une a ‚Äòy‚Äô en filas donde la clave de ‚Äòx‚Äô es menor que la clave de ‚Äòy‚Äô. Esto crea una forma triangular en la esquina superior izquierda. fig-alt: | Un diagrama que representa una uni√≥n de desigualdad donde un marco de datos x se une a un marco de datos y donde la clave de x es menor que la clave de y, lo que da como resultado una forma triangular en la esquina superior izquierda.\n\n\n\n\nLas uniones de desigualdad son extremadamente generales, tan generales que es dif√≠cil encontrar casos de uso espec√≠ficos significativos. Una peque√±a t√©cnica √∫til es usarlos para restringir la uni√≥n cruzada de modo que, en lugar de generar todas las permutaciones, generemos todas las combinaciones:\n\ndf &lt;- tibble(id = 1:4, name = c(\"John\", \"Simon\", \"Tracy\", \"Max\"))\n\ndf |&gt; inner_join(df, join_by(id &lt; id))\n#&gt; # A tibble: 6 √ó 4\n#&gt;    id.x name.x  id.y name.y\n#&gt;   &lt;int&gt; &lt;chr&gt;  &lt;int&gt; &lt;chr&gt; \n#&gt; 1     1 John       2 Simon \n#&gt; 2     1 John       3 Tracy \n#&gt; 3     1 John       4 Max   \n#&gt; 4     2 Simon      3 Tracy \n#&gt; 5     2 Simon      4 Max   \n#&gt; 6     3 Tracy      4 Max\n\n\n19.5.3 Uniones rodantes\nLas combinaciones rotativas son un tipo especial de combinaci√≥n de desigualdad donde en lugar de obtener todas las filas que satisfacen la desigualdad, obtienes solo la fila m√°s cercana, como en Figura¬†19.16. Puede convertir cualquier combinaci√≥n de desigualdad en una combinaci√≥n continua agregando closest(). Por ejemplo, join_by(closest(x &lt;= y)) coincide con la y m√°s peque√±a que es mayor o igual que x, y join_by(closest(x &gt; y)) coincide con la y m√°s grande que es menor que x.\n\n\n\n\n\n\n\nFigura¬†19.16: Una uni√≥n continua es similar a una uni√≥n de desigualdad mayor o igual, pero solo coincide con el primer valor.\n\n\n\n\nLas uniones rotativas son particularmente √∫tiles cuando tiene dos tablas de fechas que no se alinean perfectamente y desea encontrar (por ejemplo) la fecha m√°s cercana en la tabla 1 que viene antes (o despu√©s) de alguna fecha en la tabla 2.\nPor ejemplo, imagina que est√°s a cargo de la comisi√≥n de planificaci√≥n de fiestas de tu oficina. Su empresa es bastante barata, por lo que en lugar de tener fiestas individuales, solo tiene una fiesta una vez cada trimestre. Las reglas para determinar cu√°ndo se realizar√° una fiesta son un poco complejas: las fiestas siempre son los lunes, te saltas la primera semana de enero porque mucha gente est√° de vacaciones y el primer lunes del tercer trimestre de 2022 es el 4 de julio, por lo que eso tiene que ser retrasado una semana. Eso lleva a los siguientes d√≠as de fiesta:\n\nparties &lt;- tibble(\n  q = 1:4,\n  party = ymd(c(\"2022-01-10\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\"))\n)\n\nAhora imagina que tienes una tabla de cumplea√±os de los empleados:\n\nset.seed(123)\nemployees &lt;- tibble(\n  name = sample(babynames::babynames$name, 100),\n  birthday = ymd(\"2022-01-01\") + (sample(365, 100, replace = TRUE) - 1)\n)\nemployees\n#&gt; # A tibble: 100 √ó 2\n#&gt;   name     birthday  \n#&gt;   &lt;chr&gt;    &lt;date&gt;    \n#&gt; 1 Kemba    2022-01-22\n#&gt; 2 Orean    2022-06-26\n#&gt; 3 Kirstyn  2022-02-11\n#&gt; 4 Amparo   2022-11-11\n#&gt; 5 Belen    2022-03-25\n#&gt; 6 Rayshaun 2022-01-11\n#&gt; # ‚Ñπ 94 more rows\n\nY para cada empleado queremos encontrar la fecha de la √∫ltima fiesta que viene antes (o en) su cumplea√±os. Podemos expresar eso con una uni√≥n rodante:\n\nemployees |&gt; \n  left_join(parties, join_by(closest(birthday &gt;= party)))\n#&gt; # A tibble: 100 √ó 4\n#&gt;   name     birthday       q party     \n#&gt;   &lt;chr&gt;    &lt;date&gt;     &lt;int&gt; &lt;date&gt;    \n#&gt; 1 Kemba    2022-01-22     1 2022-01-10\n#&gt; 2 Orean    2022-06-26     2 2022-04-04\n#&gt; 3 Kirstyn  2022-02-11     1 2022-01-10\n#&gt; 4 Amparo   2022-11-11     4 2022-10-03\n#&gt; 5 Belen    2022-03-25     1 2022-01-10\n#&gt; 6 Rayshaun 2022-01-11     1 2022-01-10\n#&gt; # ‚Ñπ 94 more rows\n\nSin embargo, hay un problema con este enfoque: las personas que cumplen a√±os antes del 10 de enero no organizan una fiesta:\n\nemployees |&gt; \n  anti_join(parties, join_by(closest(birthday &gt;= party)))\n#&gt; # A tibble: 2 √ó 2\n#&gt;   name   birthday  \n#&gt;   &lt;chr&gt;  &lt;date&gt;    \n#&gt; 1 Maks   2022-01-07\n#&gt; 2 Nalani 2022-01-04\n\nPara resolver ese problema, necesitaremos abordar el problema de una manera diferente, con uniones superpuestas.\n\n19.5.4 Uniones superpuestas\nLas uniones superpuestas proporcionan tres ayudantes que usan uniones de desigualdad para facilitar el trabajo con intervalos:\n\n\nbetween(x, y_lower, y_upper) es abreviatura para x &gt;= y_lower, x &lt;= y_upper.\n\nwithin(x_lower, x_upper, y_lower, y_upper) es abreviatura para x_lower &gt;= y_lower, x_upper &lt;= y_upper.\n\noverlaps(x_lower, x_upper, y_lower, y_upper) es abreviatura para x_lower &lt;= y_upper, x_upper &gt;= y_lower.\n\nSigamos con el ejemplo del cumplea√±os para ver c√≥mo podr√≠a usarlos. Hay un problema con la estrategia que usamos anteriormente: no hay fiesta antes de los cumplea√±os del 1 al 9 de enero. Por lo tanto, ser√≠a mejor ser expl√≠cito sobre los rangos de fechas que abarca cada fiesta y hacer un caso especial para esos cumplea√±os anticipados:\n\nparties &lt;- tibble(\n  q = 1:4,\n  party = ymd(c(\"2022-01-10\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  start = ymd(c(\"2022-01-01\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  end = ymd(c(\"2022-04-03\", \"2022-07-11\", \"2022-10-02\", \"2022-12-31\"))\n)\nparties\n#&gt; # A tibble: 4 √ó 4\n#&gt;       q party      start      end       \n#&gt;   &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    \n#&gt; 1     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; 2     2 2022-04-04 2022-04-04 2022-07-11\n#&gt; 3     3 2022-07-11 2022-07-11 2022-10-02\n#&gt; 4     4 2022-10-03 2022-10-03 2022-12-31\n\nHadley es terriblemente malo ingresando datos, por lo que tambi√©n quer√≠a verificar que los per√≠odos de las fiestas no se superpusieran. Una forma de hacer esto es usar una autouni√≥n para verificar si alg√∫n intervalo de inicio-fin se superpone con otro:\n\nparties |&gt; \n  inner_join(parties, join_by(overlaps(start, end, start, end), q &lt; q)) |&gt; \n  select(start.x, end.x, start.y, end.y)\n#&gt; # A tibble: 1 √ó 4\n#&gt;   start.x    end.x      start.y    end.y     \n#&gt;   &lt;date&gt;     &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    \n#&gt; 1 2022-04-04 2022-07-11 2022-07-11 2022-10-02\n\nVaya, hay una superposici√≥n, as√≠ que solucionemos ese problema y continuemos:\n\nparties &lt;- tibble(\n  q = 1:4,\n  party = ymd(c(\"2022-01-10\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  start = ymd(c(\"2022-01-01\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  end = ymd(c(\"2022-04-03\", \"2022-07-10\", \"2022-10-02\", \"2022-12-31\"))\n)\n\nAhora podemos emparejar a cada empleado con su partido. Este es un buen lugar para usar unmatched = \"error\" porque queremos averiguar r√°pidamente si a alg√∫n empleado no se le asign√≥ una fiesta.\n\nemployees |&gt; \n  inner_join(parties, join_by(between(birthday, start, end)), unmatched = \"error\")\n#&gt; # A tibble: 100 √ó 6\n#&gt;   name     birthday       q party      start      end       \n#&gt;   &lt;chr&gt;    &lt;date&gt;     &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    \n#&gt; 1 Kemba    2022-01-22     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; 2 Orean    2022-06-26     2 2022-04-04 2022-04-04 2022-07-10\n#&gt; 3 Kirstyn  2022-02-11     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; 4 Amparo   2022-11-11     4 2022-10-03 2022-10-03 2022-12-31\n#&gt; 5 Belen    2022-03-25     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; 6 Rayshaun 2022-01-11     1 2022-01-10 2022-01-01 2022-04-03\n#&gt; # ‚Ñπ 94 more rows\n\n\n19.5.5 Ejercicios\n\n\n¬øPuedes explicar qu√© est√° pasando con las claves en esta uni√≥n equitativa? ¬øPor qu√© son diferentes?\n\nx |&gt; full_join(y, join_by(key == key))\n#&gt; # A tibble: 4 √ó 3\n#&gt;     key val_x val_y\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1     1 x1    y1   \n#&gt; 2     2 x2    y2   \n#&gt; 3     3 x3    &lt;NA&gt; \n#&gt; 4     4 &lt;NA&gt;  y3\n\nx |&gt; full_join(y, join_by(key == key), keep = TRUE)\n#&gt; # A tibble: 4 √ó 4\n#&gt;   key.x val_x key.y val_y\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1     1 x1        1 y1   \n#&gt; 2     2 x2        2 y2   \n#&gt; 3     3 x3       NA &lt;NA&gt; \n#&gt; 4    NA &lt;NA&gt;      4 y3\n\n\nAl encontrar si alg√∫n per√≠odo de fiesta se superpon√≠a con otro per√≠odo de fiesta, usamos q &lt; q en join_by () ¬øPor qu√©? ¬øQu√© pasa si eliminas esta desigualdad?",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Uniones</span>"
    ]
  },
  {
    "objectID": "joins.html#resumen",
    "href": "joins.html#resumen",
    "title": "19¬† Uniones",
    "section": "\n19.6 Resumen",
    "text": "19.6 Resumen\nEn este cap√≠tulo, aprendi√≥ a usar combinaciones de mutaci√≥n y filtrado para combinar datos de un par de marcos de datos. En el camino, aprendi√≥ c√≥mo identificar claves y la diferencia entre claves primarias y externas. Tambi√©n comprende c√≥mo funcionan las uniones y c√≥mo averiguar cu√°ntas filas tendr√° la salida. Finalmente, ha logrado vislumbrar el poder de las uniones no equitativas y ha visto algunos casos de uso interesantes.\nEste cap√≠tulo concluye la parte ‚ÄúTransformar‚Äù del libro, donde la atenci√≥n se centr√≥ en las herramientas que podr√≠a usar con columnas y tibbles individuales. Aprendi√≥ sobre las funciones dplyr y base para trabajar con vectores l√≥gicos, n√∫meros y tablas completas, funciones stringr para trabajar con cadenas, funciones lubridate para trabajar con fechas y horas y funciones forcats para trabajar con factores.\nEn la siguiente parte del libro, aprender√° m√°s sobre c√≥mo obtener varios tipos de datos en R de forma ordenada.",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Uniones</span>"
    ]
  },
  {
    "objectID": "joins.html#footnotes",
    "href": "joins.html#footnotes",
    "title": "19¬† Uniones",
    "section": "",
    "text": "Recuerda que en RStudio tambi√©n puedes usar View() para evitar este problema.‚Ü©Ô∏é\nEso no es 100% cierto, pero recibir√°s una advertencia cuando no lo sea.‚Ü©Ô∏é",
    "crumbs": [
      "Transformar",
      "<span class='chapter-number'>19</span>¬† <span class='chapter-title'>Uniones</span>"
    ]
  },
  {
    "objectID": "import.html",
    "href": "import.html",
    "title": "Importar",
    "section": "",
    "text": "En esta parte del libro, aprender√° a importar una gama m√°s amplia de datos en R, as√≠ como a convertirlos en una forma √∫til para el an√°lisis. A veces, esto es solo una cuesti√≥n de llamar a una funci√≥n desde el paquete de importaci√≥n de datos apropiado. Pero en casos m√°s complejos, puede ser necesario ordenar y transformar para llegar al rect√°ngulo ordenado con el que preferir√≠a trabajar.\n\n\n\n\n\n\n\nFigura¬†1: La importaci√≥n de datos es el comienzo del proceso de ciencia de datos; ¬°Sin datos no se puede hacer ciencia de datos!\n\n\n\n\nEn esta parte del libro, aprender√° c√≥mo acceder a los datos almacenados de las siguientes maneras:\n\nEn 20¬† Hojas de calculo, aprender√° a importar datos de hojas de c√°lculo de Excel y Google Sheets.\nEn 21¬† Bases de datos, aprender√° a sacar datos de una base de datos y llevarlos a R (y tambi√©n aprender√° un poco acerca de c√≥mo sacar datos de R a una base de datos).\nEn 22¬† Arrow, aprender√° sobre Arrow, una poderosa herramienta para trabajar con datos sin memoria, especialmente cuando se almacenan en formato parquet.\nEn 23¬† Datos jer√°rquicos, aprender√° a trabajar con datos jer√°rquicos, incluidas las listas profundamente anidadas producidas por datos almacenados en formato JSON.\nEn 24¬† Web scraping, aprender√° ‚Äúscraping‚Äù web, el arte y la ciencia de extraer datos de p√°ginas web.\n\nHay dos paquetes importantes de tidyverse que no discutiremos aqu√≠: haven y xml2. Si trabaja con datos de archivos SPSS, Stata y SAS, consulte el paquete haven, https://haven.tidyverse.org. Si est√° trabajando con datos XML, consulte el paquete xml2, https://xml2.r-lib.org. De lo contrario, deber√° investigar un poco para determinar qu√© paquete necesitar√° usar; Google es tu amigo aqu√≠ üòÉ.",
    "crumbs": [
      "Importar"
    ]
  },
  {
    "objectID": "spreadsheets.html",
    "href": "spreadsheets.html",
    "title": "20¬† Hojas de calculo",
    "section": "",
    "text": "20.1 Introducci√≥n\nEn Cap√≠tulo 7, aprendi√≥ a importar datos de archivos de texto sin formato como .csv y .tsv. Ahora es el momento de aprender c√≥mo obtener datos de una hoja de c√°lculo, ya sea una hoja de c√°lculo de Excel o una hoja de c√°lculo de Google. Esto se basar√° en gran parte de lo que ha aprendido en Cap√≠tulo 7, pero tambi√©n analizaremos consideraciones y complejidades adicionales al trabajar con datos de hojas de c√°lculo.\nSi usted o sus colaboradores utilizan hojas de c√°lculo para organizar datos, le recomendamos leer el documento ‚ÄúOrganizaci√≥n de datos en hojas de c√°lculo‚Äù de Karl Broman y Kara Woo: https://doi.org/10.1080/00031305.2017.1375989. Las mejores pr√°cticas presentadas en este documento le ahorrar√°n muchos dolores de cabeza cuando importe datos de una hoja de c√°lculo a R para analizarlos y visualizarlos.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Hojas de calculo</span>"
    ]
  },
  {
    "objectID": "spreadsheets.html#excel",
    "href": "spreadsheets.html#excel",
    "title": "20¬† Hojas de calculo",
    "section": "\n20.2 Excel",
    "text": "20.2 Excel\nMicrosoft Excel es un programa de software de hojas de c√°lculo ampliamente utilizado donde los datos se organizan en hojas de trabajo dentro de archivos de hojas de c√°lculo.\n\n20.2.1 Requisitos previos\nEn esta secci√≥n, aprender√° a cargar datos de hojas de c√°lculo de Excel en R con el paquete readxl. Este paquete es tidyverse no central, por lo que debe cargarlo expl√≠citamente, pero se instala autom√°ticamente cuando instala el paquete tidyverse. M√°s tarde, tambi√©n usaremos el paquete writexl, que nos permite crear hojas de c√°lculo de Excel.\n\nlibrary(readxl)\nlibrary(tidyverse)\nlibrary(writexl)\n\n\n20.2.2 Empezando\nLa mayor√≠a de las funciones de readxl le permiten cargar hojas de c√°lculo de Excel en R:\n\n\nread_xls() lee archivos de Excel con formato xls.\n\nread_xlsx() leer archivos de Excel con formato xlsx.\n\nread_excel() puede leer archivos con formato xls y xlsx. Adivina el tipo de archivo en funci√≥n de la entrada.\n\nTodas estas funciones tienen una sintaxis similar al igual que otras funciones que hemos introducido anteriormente para leer otros tipos de archivos, p.ej., read_csv(), read_table(), etc. Para el resto del cap√≠tulo nos enfocaremos en usar read_excel().\n\n20.2.3 Lectura de hojas de c√°lculo de Excel\nFigura¬†20.1 muestra c√≥mo se ve la hoja de c√°lculo que vamos a leer en R en Excel. Esta hoja de c√°lculo se puede descargar en un archivo Excel desde https://docs.google.com/spreadsheets/d/1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w/.\n\n\n\n\n\n\n\nFigura¬†20.1: Hoja de c√°lculo llamada students.xlsx en Excel.\n\n\n\n\nEl primer argumento de read_excel() es la ruta al archivo a leer.\n\nstudents &lt;- read_excel(\"data/students.xlsx\")\n\nread_excel() leer√° el archivo como un tibble.\n\nstudents\n#&gt; # A tibble: 6 √ó 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6            6 G√ºven√ß Attila    Ice cream          Lunch only          6\n\nTenemos seis estudiantes en los datos y cinco variables en cada estudiante. Sin embargo, hay algunas cosas que podr√≠amos querer abordar en este conjunto de datos:\n\n\nLos nombres de las columnas est√°n por todas partes. Puede proporcionar nombres de columna que sigan un formato coherente; recomendamos snake_case usando el argumento col_names.\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\")\n)\n#&gt; # A tibble: 7 √ó 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;   &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1 Student ID Full Name        favourite.food     mealPlan            AGE  \n#&gt; 2 1          Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 3 2          Barclay Lynn     French fries       Lunch only          5    \n#&gt; 4 3          Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 5 4          Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 6 5          Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 7 6          G√ºven√ß Attila    Ice cream          Lunch only          6\n\nDesafortunadamente, esto no funcion√≥ del todo. Ahora tenemos los nombres de las variables que queremos, pero lo que antes era la fila del encabezado ahora aparece como la primera observaci√≥n en los datos. Puede omitir expl√≠citamente esa fila usando el argumento skip.\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1\n)\n#&gt; # A tibble: 6 √ó 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 G√ºven√ß Attila    Ice cream          Lunch only          6\n\n\n\nEn la columna favourite_food, una de las observaciones es N/A, que significa ‚Äúno disponible‚Äù, pero actualmente no se reconoce como NA (tenga en cuenta el contraste entre este N/A y la edad de el cuarto estudiante de la lista). Puede especificar qu√© cadenas de caracteres deben reconocerse como NAs con el argumento na. De forma predeterminada, solo \"\" (cadena vac√≠a o, en el caso de leer desde una hoja de c√°lculo, una celda vac√≠a o una celda con la f√≥rmula =NA()) se reconoce como NA.\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1,\n  na = c(\"\", \"N/A\")\n)\n#&gt; # A tibble: 6 √ó 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 G√ºven√ß Attila    Ice cream          Lunch only          6\n\n\n\nOtro problema pendiente es que age se lee como una variable de car√°cter, pero en realidad deber√≠a ser num√©rico. Al igual que con read_csv() y amigos para leer datos de archivos planos, puede proporcionar un argumento col_types a read_excel() y especificar los tipos de columna para las variables que lee. Sin embargo, la sintaxis es un poco diferente. Sus opciones son \"skip\", \"guess\", \"logical\", \"numeric\", \"date\", \"text\" o \"list\".\n\nread_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1,\n  na = c(\"\", \"N/A\"),\n  col_types = c(\"numeric\", \"text\", \"text\", \"text\", \"numeric\")\n)\n#&gt; Warning: Expecting numeric in E6 / R6C5: got 'five'\n#&gt; # A tibble: 6 √ó 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch    NA\n#&gt; 6          6 G√ºven√ß Attila    Ice cream          Lunch only              6\n\nSin embargo, esto tampoco produjo el resultado deseado. Al especificar que la edad, age, debe ser num√©rica, hemos convertido la √∫nica celda con la entrada no num√©rica (que ten√≠a el valor five) en NA. En este caso, deber√≠amos leer la edad como \"texto\" y luego hacer el cambio una vez que los datos est√©n cargados en R.\n\nstudents &lt;- read_excel(\n  \"data/students.xlsx\",\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1,\n  na = c(\"\", \"N/A\"),\n  col_types = c(\"numeric\", \"text\", \"text\", \"text\", \"text\")\n)\n\nstudents &lt;- students |&gt;\n  mutate(\n    age = if_else(age == \"five\", \"5\", age),\n    age = parse_number(age)\n  )\n\nstudents\n#&gt; # A tibble: 6 √ó 5\n#&gt;   student_id full_name        favourite_food     meal_plan             age\n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;dbl&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n#&gt; 2          2 Barclay Lynn     French fries       Lunch only              5\n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only             NA\n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5\n#&gt; 6          6 G√ºven√ß Attila    Ice cream          Lunch only              6\n\n\n\nNos tom√≥ varios pasos y prueba y error para cargar los datos exactamente en el formato que quer√≠amos, y esto no es inesperado. La ciencia de datos es un proceso iterativo, y el proceso de iteraci√≥n puede ser a√∫n m√°s tedioso cuando se leen datos de hojas de c√°lculo en comparaci√≥n con otros archivos de datos rectangulares de texto sin formato porque los humanos tienden a ingresar datos en hojas de c√°lculo y los usan no solo para el almacenamiento de datos sino tambi√©n para compartir y comunicar.\nNo hay forma de saber exactamente c√≥mo se ver√°n los datos hasta que los cargue y los mire. Bueno, hay una manera, en realidad. Puede abrir el archivo en Excel y echar un vistazo. Si va a hacerlo, le recomendamos que haga una copia del archivo de Excel para abrirlo y navegar de forma interactiva mientras deja intacto el archivo de datos original y lee en R desde el archivo intacto. Esto asegurar√° que no sobrescriba accidentalmente nada en la hoja de c√°lculo mientras la inspecciona. Tampoco debe tener miedo de hacer lo que hicimos aqu√≠: cargue los datos, eche un vistazo, realice ajustes en su c√≥digo, c√°rguelo nuevamente y repita hasta que est√© satisfecho con el resultado.\n\n20.2.4 Hojas de trabajo de lectura\nUna caracter√≠stica importante que distingue a las hojas de c√°lculo de los archivos planos es la noci√≥n de hojas m√∫ltiples, llamadas hojas de trabajo. Figura¬†20.2 muestra una hoja de c√°lculo de Excel con varias hojas de trabajo. Los datos provienen del paquete palmerpenguins. Cada hoja de trabajo contiene informaci√≥n sobre ping√ºinos de una isla diferente donde se recopilaron datos.\n\n\n\n\n\n\n\nFigura¬†20.2: Hoja de c√°lculo llamada penguins.xlsx en Excel que contiene tres hojas de c√°lculo.\n\n\n\n\nPuede leer una sola hoja de trabajo desde una hoja de c√°lculo con el argumento sheet en read_excel(). El valor predeterminado, en el que nos hemos basado hasta ahora, es la primera hoja.\n\nread_excel(\"data/penguins.xlsx\", sheet = \"Torgersen Island\")\n#&gt; # A tibble: 52 √ó 8\n#&gt;   species island    bill_length_mm     bill_depth_mm      flipper_length_mm\n#&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;              &lt;chr&gt;              &lt;chr&gt;            \n#&gt; 1 Adelie  Torgersen 39.1               18.7               181              \n#&gt; 2 Adelie  Torgersen 39.5               17.399999999999999 186              \n#&gt; 3 Adelie  Torgersen 40.299999999999997 18                 195              \n#&gt; 4 Adelie  Torgersen NA                 NA                 NA               \n#&gt; 5 Adelie  Torgersen 36.700000000000003 19.3               193              \n#&gt; 6 Adelie  Torgersen 39.299999999999997 20.6               190              \n#&gt; # ‚Ñπ 46 more rows\n#&gt; # ‚Ñπ 3 more variables: body_mass_g &lt;chr&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\nAlgunas variables que parecen contener datos num√©ricos se leen como caracteres debido a que la cadena de caracteres \"NA\" no se reconoce como verdadera NA.\n\npenguins_torgersen &lt;- read_excel(\"data/penguins.xlsx\", sheet = \"Torgersen Island\", na = \"NA\")\n\npenguins_torgersen\n#&gt; # A tibble: 52 √ó 8\n#&gt;   species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1 Adelie  Torgersen           39.1          18.7               181\n#&gt; 2 Adelie  Torgersen           39.5          17.4               186\n#&gt; 3 Adelie  Torgersen           40.3          18                 195\n#&gt; 4 Adelie  Torgersen           NA            NA                  NA\n#&gt; 5 Adelie  Torgersen           36.7          19.3               193\n#&gt; 6 Adelie  Torgersen           39.3          20.6               190\n#&gt; # ‚Ñπ 46 more rows\n#&gt; # ‚Ñπ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\nAlternativamente, puede usar excel_sheets() para obtener informaci√≥n sobre todas las hojas de trabajo en una hoja de c√°lculo de Excel y luego leer las que le interesan.\n\nexcel_sheets(\"data/penguins.xlsx\")\n#&gt; [1] \"Torgersen Island\" \"Biscoe Island\"    \"Dream Island\"\n\nUna vez que sepa los nombres de las hojas de trabajo, puede leerlas individualmente con read_excel().\n\npenguins_biscoe &lt;- read_excel(\"data/penguins.xlsx\", sheet = \"Biscoe Island\", na = \"NA\")\npenguins_dream  &lt;- read_excel(\"data/penguins.xlsx\", sheet = \"Dream Island\", na = \"NA\")\n\nEn este caso, el conjunto de datos completo de ping√ºinos se distribuye en tres hojas de trabajo en la hoja de c√°lculo. Cada hoja de c√°lculo tiene el mismo n√∫mero de columnas pero diferente n√∫mero de filas.\n\ndim(penguins_torgersen)\n#&gt; [1] 52  8\ndim(penguins_biscoe)\n#&gt; [1] 168   8\ndim(penguins_dream)\n#&gt; [1] 124   8\n\nPodemos juntarlos con bind_rows().\n\npenguins &lt;- bind_rows(penguins_torgersen, penguins_biscoe, penguins_dream)\npenguins\n#&gt; # A tibble: 344 √ó 8\n#&gt;   species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1 Adelie  Torgersen           39.1          18.7               181\n#&gt; 2 Adelie  Torgersen           39.5          17.4               186\n#&gt; 3 Adelie  Torgersen           40.3          18                 195\n#&gt; 4 Adelie  Torgersen           NA            NA                  NA\n#&gt; 5 Adelie  Torgersen           36.7          19.3               193\n#&gt; 6 Adelie  Torgersen           39.3          20.6               190\n#&gt; # ‚Ñπ 338 more rows\n#&gt; # ‚Ñπ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\nEn Cap√≠tulo 26 hablaremos sobre formas de realizar este tipo de tareas sin c√≥digo repetitivo.\n\n20.2.5 Leer parte de una hoja\nDado que muchos usan hojas de c√°lculo de Excel para la presentaci√≥n, as√≠ como para el almacenamiento de datos, es bastante com√∫n encontrar entradas de celdas en una hoja de c√°lculo que no forman parte de los datos que desea leer en R. Figura¬†20.3 muestra una hoja de c√°lculo de este tipo: en el medio de la hoja hay lo que parece un marco de datos, pero hay texto superfluo en las celdas por encima y por debajo de los datos.\n\n\n\n\n\n\n\nFigura¬†20.3: Hoja de c√°lculo llamada death.xlsx en Excel.\n\n\n\n\nEsta hoja de c√°lculo es una de las hojas de c√°lculo de ejemplo proporcionadas en el paquete readxl. Puede usar la funci√≥n readxl_example() para ubicar la hoja de c√°lculo en su sistema en el directorio donde est√° instalado el paquete. Esta funci√≥n devuelve la ruta a la hoja de c√°lculo, que puede usar en read_excel() como de costumbre.\n\ndeaths_path &lt;- readxl_example(\"deaths.xlsx\")\ndeaths &lt;- read_excel(deaths_path)\n#&gt; New names:\n#&gt; ‚Ä¢ `` -&gt; `...2`\n#&gt; ‚Ä¢ `` -&gt; `...3`\n#&gt; ‚Ä¢ `` -&gt; `...4`\n#&gt; ‚Ä¢ `` -&gt; `...5`\n#&gt; ‚Ä¢ `` -&gt; `...6`\ndeaths\n#&gt; # A tibble: 18 √ó 6\n#&gt;   `Lots of people`    ...2       ...3  ...4     ...5          ...6           \n#&gt;   &lt;chr&gt;               &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;         &lt;chr&gt;          \n#&gt; 1 simply cannot resi‚Ä¶ &lt;NA&gt;       &lt;NA&gt;  &lt;NA&gt;     &lt;NA&gt;          some notes     \n#&gt; 2 at                  the        top   &lt;NA&gt;     of            their spreadsh‚Ä¶\n#&gt; 3 or                  merging    &lt;NA&gt;  &lt;NA&gt;     &lt;NA&gt;          cells          \n#&gt; 4 Name                Profession Age   Has kids Date of birth Date of death  \n#&gt; 5 David Bowie         musician   69    TRUE     17175         42379          \n#&gt; 6 Carrie Fisher       actor      60    TRUE     20749         42731          \n#&gt; # ‚Ñπ 12 more rows\n\nLas tres filas superiores y las cuatro filas inferiores no forman parte del marco de datos. Es posible eliminar estas filas superfluas usando los argumentos skip y n_max, pero recomendamos usar rangos de celdas. En Excel, la celda superior izquierda es A1. A medida que se mueve por las columnas hacia la derecha, la etiqueta de la celda se mueve hacia abajo en el alfabeto, es decir, B1, C1, etc. Y a medida que se mueve hacia abajo en una columna, el n√∫mero en la etiqueta de la celda aumenta, es decir, A2, A3, etc.\nAqu√≠, los datos que queremos leer comienzan en la celda A5 y terminan en la celda F15. En notaci√≥n de hoja de c√°lculo, esto es A5:F15, que proporcionamos al argumento range:\n\nread_excel(deaths_path, range = \"A5:F15\")\n#&gt; # A tibble: 10 √ó 6\n#&gt;   Name          Profession   Age `Has kids` `Date of birth`    \n#&gt;   &lt;chr&gt;         &lt;chr&gt;      &lt;dbl&gt; &lt;lgl&gt;      &lt;dttm&gt;             \n#&gt; 1 David Bowie   musician      69 TRUE       1947-01-08 00:00:00\n#&gt; 2 Carrie Fisher actor         60 TRUE       1956-10-21 00:00:00\n#&gt; 3 Chuck Berry   musician      90 TRUE       1926-10-18 00:00:00\n#&gt; 4 Bill Paxton   actor         61 TRUE       1955-05-17 00:00:00\n#&gt; 5 Prince        musician      57 TRUE       1958-06-07 00:00:00\n#&gt; 6 Alan Rickman  actor         69 FALSE      1946-02-21 00:00:00\n#&gt; # ‚Ñπ 4 more rows\n#&gt; # ‚Ñπ 1 more variable: `Date of death` &lt;dttm&gt;\n\n\n20.2.6 Tipos de datos\nEn los archivos CSV, todos los valores son cadenas. Esto no es particularmente cierto para los datos, pero es simple: todo es una cadena.\nLos datos subyacentes en las hojas de c√°lculo de Excel son m√°s complejos. Una c√©lula puede ser una de cuatro cosas:\n\nUn valor booleano, como TRUE, FALSE o NA.\nUn n√∫mero, como ‚Äú10‚Äù o ‚Äú10.5‚Äù.\nUna fecha y hora, que tambi√©n puede incluir una hora como ‚Äú1/11/21‚Äù o ‚Äú1/11/21 3:00 PM‚Äù.\nUna cadena de texto, como ‚Äúdiez‚Äù.\n\nAl trabajar con datos de hojas de c√°lculo, es importante tener en cuenta que los datos subyacentes pueden ser muy diferentes de lo que ve en la celda. Por ejemplo, Excel no tiene noci√≥n de un n√∫mero entero. Todos los n√∫meros se almacenan como puntos flotantes, pero puede optar por mostrar los datos con un n√∫mero personalizable de puntos decimales. De manera similar, las fechas en realidad se almacenan como n√∫meros, espec√≠ficamente la cantidad de segundos desde el 1 de enero de 1970. Puede personalizar c√≥mo muestra la fecha aplicando formato en Excel. De manera confusa, tambi√©n es posible tener algo que parezca un n√∫mero pero que en realidad sea una cadena (por ejemplo, escriba '10 en una celda de Excel).\nEstas diferencias entre c√≥mo se almacenan los datos subyacentes y c√≥mo se muestran pueden causar sorpresas cuando los datos se cargan en R. Por defecto, readxl adivinar√° el tipo de datos en una columna determinada. Un flujo de trabajo recomendado es dejar que readxl adivine los tipos de columna, confirme que est√° satisfecho con los tipos de columna adivinados y, si no, regrese y vuelva a importar especificando col_types como se muestra en Secci√≥n 20.2.3.\nOtro desaf√≠o es cuando tiene una columna en su hoja de c√°lculo de Excel que tiene una combinaci√≥n de estos tipos, p.ej., algunas celdas son num√©ricas, otras de texto, otras de fechas. Al importar los datos a R, readxl tiene que tomar algunas decisiones. En estos casos, puede establecer el tipo de esta columna en \"list\", lo que cargar√° la columna como una lista de vectores de longitud 1, donde se adivina el tipo de cada elemento del vector.\n\n\n\n\n\n\nA veces, los datos se almacenan de formas m√°s ex√≥ticas, como el color del fondo de la celda o si el texto est√° en negrita o no. En tales casos, puede encontrar √∫til el paquete tidyxl. Consulte https://nacnudus.github.io/spreadsheet-munging-strategies/ para obtener m√°s informaci√≥n sobre estrategias para trabajar con datos no tabulares de Excel.\n\n\n\n\n20.2.7 Escribir en Excel\nVamos a crear un peque√±o marco de datos que luego podamos escribir. Tenga en cuenta que item es un factor y quantity es un n√∫mero entero.\n\nbake_sale &lt;- tibble(\n  item     = factor(c(\"brownie\", \"cupcake\", \"cookie\")),\n  quantity = c(10, 5, 8)\n)\n\nbake_sale\n#&gt; # A tibble: 3 √ó 2\n#&gt;   item    quantity\n#&gt;   &lt;fct&gt;      &lt;dbl&gt;\n#&gt; 1 brownie       10\n#&gt; 2 cupcake        5\n#&gt; 3 cookie         8\n\nPuede volver a escribir datos en el disco como un archivo de Excel usando write_xlsx() del paquete writexl:\n\nwrite_xlsx(bake_sale, path = \"data/bake-sale.xlsx\")\n\nFigura¬†20.4 muestra c√≥mo se ven los datos en Excel. Tenga en cuenta que los nombres de las columnas est√°n incluidos y en negrita. Estos se pueden desactivar configurando los argumentos col_names y format_headers en FALSE.\n\n\n\n\n\n\n\nFigura¬†20.4: Hoja de c√°lculo llamada bake_sale.xlsx en Excel.\n\n\n\n\nAl igual que la lectura de un CSV, la informaci√≥n sobre el tipo de datos se pierde cuando volvemos a leer los datos. Esto hace que los archivos de Excel no sean confiables para almacenar en cach√© los resultados intermedios. Para ver alternativas, consulte Secci√≥n 7.5.\n\nread_excel(\"data/bake-sale.xlsx\")\n#&gt; # A tibble: 3 √ó 2\n#&gt;   item    quantity\n#&gt;   &lt;chr&gt;      &lt;dbl&gt;\n#&gt; 1 brownie       10\n#&gt; 2 cupcake        5\n#&gt; 3 cookie         8\n\n\n20.2.8 Salida formateada\nEl paquete writexl es una soluci√≥n liviana para escribir una hoja de c√°lculo de Excel simple, pero si est√° interesado en funciones adicionales como escribir en hojas dentro de una hoja de c√°lculo y dise√±ar, querr√° usar el paquete openxlsx. No entraremos en los detalles del uso de este paquete aqu√≠, pero recomendamos leer https://ycphs.github.io/openxlsx/articles/Formatting.html para una discusi√≥n extensa sobre la funcionalidad de formato adicional para los datos escritos desde R a Excel con openxlsx.\nTenga en cuenta que este paquete no forma parte de tidyverse, por lo que las funciones y los flujos de trabajo pueden parecerle desconocidos. Por ejemplo, los nombres de las funciones son camelCase, varias funciones no se pueden componer en canalizaciones y los argumentos est√°n en un orden diferente al que suelen tener en el tidyverse. Sin embargo, esto est√° bien. A medida que su aprendizaje y uso de R se expanda fuera de este libro, encontrar√° muchos estilos diferentes utilizados en varios paquetes de R que puede usar para lograr objetivos espec√≠ficos en R. Una buena manera de familiarizarse con el estilo de codificaci√≥n utilizado en un nuevo paquete es ejecutar los ejemplos proporcionados en la documentaci√≥n de la funci√≥n para tener una idea de la sintaxis y los formatos de salida, as√≠ como leer cualquier vi√±eta que pueda venir con el paquete.\n\n20.2.9 Ejercicios\n\n\nEn un archivo de Excel, cree el siguiente conjunto de datos y gu√°rdelo como survey.xlsx. Como alternativa, puede descargarlo como un archivo de Excel desde aqu√≠.\n\n\n\n\n\n\n\n\nLuego, l√©alo en R, con survey_id como variable de car√°cter y n_pets como variable num√©rica.\n\n#&gt; # A tibble: 6 √ó 2\n#&gt;   survey_id n_pets\n#&gt;   &lt;chr&gt;      &lt;dbl&gt;\n#&gt; 1 1              0\n#&gt; 2 2              1\n#&gt; 3 3             NA\n#&gt; 4 4              2\n#&gt; 5 5              2\n#&gt; 6 6             NA\n\n\n\nEn otro archivo de Excel, cree el siguiente conjunto de datos y gu√°rdelo como roster.xlsx. Como alternativa, puede descargarlo como un archivo de Excel desde aqu√≠.\n\n\n\n\n\n\n\n\nLuego, l√©alo en R. El marco de datos resultante debe llamarse roster y debe tener el siguiente aspecto.\n\n#&gt; # A tibble: 12 √ó 3\n#&gt;    group subgroup    id\n#&gt;    &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n#&gt;  1     1 A            1\n#&gt;  2     1 A            2\n#&gt;  3     1 A            3\n#&gt;  4     1 B            4\n#&gt;  5     1 B            5\n#&gt;  6     1 B            6\n#&gt;  7     1 B            7\n#&gt;  8     2 A            8\n#&gt;  9     2 A            9\n#&gt; 10     2 B           10\n#&gt; 11     2 B           11\n#&gt; 12     2 B           12\n\n\n\nEn un nuevo archivo de Excel, cree el siguiente conjunto de datos y gu√°rdelo como sales.xlsx. Como alternativa, puede descargarlo como un archivo de Excel desde aqu√≠.\n\n\n\n\n\n\n\n\na. Lea sales.xlsx y gu√°rdelo como sales. El marco de datos deber√≠a verse como el siguiente, con id y n como nombres de columna y con 9 filas.\n\n#&gt; # A tibble: 9 √ó 2\n#&gt;   id      n    \n#&gt;   &lt;chr&gt;   &lt;chr&gt;\n#&gt; 1 Brand 1 n    \n#&gt; 2 1234    8    \n#&gt; 3 8721    2    \n#&gt; 4 1822    3    \n#&gt; 5 Brand 2 n    \n#&gt; 6 3333    1    \n#&gt; 7 2156    3    \n#&gt; 8 3987    6    \n#&gt; 9 3216    5\n\nb. Modifique sales a√∫n m√°s para obtener el siguiente formato ordenado con tres columnas (brand, id y n) y 7 filas de datos. Tenga en cuenta que id y n son num√©ricos, brand es una variable de car√°cter.\n\n#&gt; # A tibble: 7 √ó 3\n#&gt;   brand      id     n\n#&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Brand 1  1234     8\n#&gt; 2 Brand 1  8721     2\n#&gt; 3 Brand 1  1822     3\n#&gt; 4 Brand 2  3333     1\n#&gt; 5 Brand 2  2156     3\n#&gt; 6 Brand 2  3987     6\n#&gt; 7 Brand 2  3216     5\n\n\nVuelva a crear el marco de datos bake_sale, escr√≠balo en un archivo de Excel usando la funci√≥n write.xlsx() del paquete openxlsx.\nEn Cap√≠tulo 7, aprendi√≥ sobre la funci√≥n janitor::clean_names() para convertir los nombres de las columnas en may√∫sculas y min√∫sculas. Lea el archivo students.xlsx que presentamos anteriormente en esta secci√≥n y use esta funci√≥n para ‚Äúlimpiar‚Äù los nombres de las columnas.\n¬øQu√© sucede si intentas leer un archivo con la extensi√≥n .xlsx con read_xls()?",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Hojas de calculo</span>"
    ]
  },
  {
    "objectID": "spreadsheets.html#hojas-de-c√°lculo-de-google",
    "href": "spreadsheets.html#hojas-de-c√°lculo-de-google",
    "title": "20¬† Hojas de calculo",
    "section": "\n20.3 Hojas de c√°lculo de Google",
    "text": "20.3 Hojas de c√°lculo de Google\nGoogle Sheets es otro programa de hoja de c√°lculo ampliamente utilizado. Es gratis y est√° basado en la web. Al igual que con Excel, en Hojas de c√°lculo de Google, los datos se organizan en hojas de trabajo (tambi√©n llamadas hojas) dentro de archivos de hojas de c√°lculo.\n\n20.3.1 Requisitos previos\nEsta secci√≥n tambi√©n se centrar√° en las hojas de c√°lculo, pero esta vez cargar√° datos de una hoja de c√°lculo de Google con el paquete googlesheets4. Este paquete tambi√©n es tidyverse no central, debe cargarlo expl√≠citamente.\n\nlibrary(googlesheets4)\nlibrary(tidyverse)\n\nUna nota r√°pida sobre el nombre del paquete: googlesheets4 usa v4 de Sheets API v4 para proporcionar una interfaz R a Google Sheets, de ah√≠ el nombre.\n\n20.3.2 Empezando\nLa funci√≥n principal del paquete googlesheets4 es read_sheet(), que lee una hoja de c√°lculo de Google desde una URL o una identificaci√≥n de archivo. Esta funci√≥n tambi√©n se conoce con el nombre range_read().\nTambi√©n puede crear una hoja nueva con gs4_create() o escribir en una hoja existente con sheet_write() y amigos.\nEn esta secci√≥n, trabajaremos con los mismos conjuntos de datos que los de la secci√≥n de Excel para resaltar las similitudes y diferencias entre los flujos de trabajo para leer datos de Excel y Hojas de c√°lculo de Google. Los paquetes readxl y googlesheets4 est√°n dise√±ados para imitar la funcionalidad del paquete readr, que proporciona la funci√≥n read_csv() que ha visto en Cap√≠tulo 7. Por lo tanto, muchas de las tareas se pueden realizar simplemente cambiando read_excel() por read_sheet(). Sin embargo, tambi√©n ver√° que Excel y Google Sheets no se comportan exactamente de la misma manera, por lo tanto, otras tareas pueden requerir m√°s actualizaciones en las llamadas a funciones.\n\n20.3.3 Leer Hojas de c√°lculo de Google\nFigura¬†20.5 muestra c√≥mo se ve la hoja de c√°lculo que vamos a leer en R en Hojas de c√°lculo de Google. Este es el mismo conjunto de datos que en Figura¬†20.1, excepto que est√° almacenado en una hoja de Google en lugar de Excel.\n\n\n\n\n\n\n\nFigura¬†20.5: Google Sheet llam√≥ a los estudiantes en una ventana del navegador.\n\n\n\n\nEl primer argumento de read_sheet() es la URL del archivo a leer, y devuelve un tibble:&lt;https://docs.google.com/spreadsheets/d/1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w&gt;. No es agradable trabajar con estas URL, por lo que a menudo querr√° identificar una hoja por su ID.\n\ngs4_deauth()\n\n\nstudents_sheet_id &lt;- \"1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w\"\nstudents &lt;- read_sheet(students_sheet_id)\n#&gt; ‚úî Reading from students.\n#&gt; ‚úî Range Sheet1.\nstudents\n#&gt; # A tibble: 6 √ó 5\n#&gt;   `Student ID` `Full Name`      favourite.food     mealPlan            AGE   \n#&gt;          &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;list&gt;\n#&gt; 1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          &lt;dbl&gt; \n#&gt; 2            2 Barclay Lynn     French fries       Lunch only          &lt;dbl&gt; \n#&gt; 3            3 Jayendra Lyne    N/A                Breakfast and lunch &lt;dbl&gt; \n#&gt; 4            4 Leon Rossini     Anchovies          Lunch only          &lt;NULL&gt;\n#&gt; 5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch &lt;chr&gt; \n#&gt; 6            6 G√ºven√ß Attila    Ice cream          Lunch only          &lt;dbl&gt;\n\nAl igual que hicimos con read_excel(), podemos proporcionar nombres de columnas, cadenas NA y tipos de columnas a read_sheet().\n\nstudents &lt;- read_sheet(\n  students_sheet_id,\n  col_names = c(\"student_id\", \"full_name\", \"favourite_food\", \"meal_plan\", \"age\"),\n  skip = 1,\n  na = c(\"\", \"N/A\"),\n  col_types = \"dcccc\"\n)\n#&gt; ‚úî Reading from students.\n#&gt; ‚úî Range 2:10000000.\n\nstudents\n#&gt; # A tibble: 6 √ó 5\n#&gt;   student_id full_name        favourite_food     meal_plan           age  \n#&gt;        &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n#&gt; 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n#&gt; 2          2 Barclay Lynn     French fries       Lunch only          5    \n#&gt; 3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch 7    \n#&gt; 4          4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n#&gt; 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n#&gt; 6          6 G√ºven√ß Attila    Ice cream          Lunch only          6\n\nTenga en cuenta que aqu√≠ definimos los tipos de columna de manera un poco diferente, usando c√≥digos cortos. Por ejemplo, ‚Äúdcccc‚Äù significa ‚Äúdoble, car√°cter, car√°cter, car√°cter, car√°cter‚Äù.\nTambi√©n es posible leer hojas individuales de Google Sheets. Leamos la hoja ‚ÄúIsla Torgersen‚Äù de la Hoja de Google de ping√ºinos:\n\npenguins_sheet_id &lt;- \"1aFu8lnD_g0yjF5O-K6SFgSEWiHPpgvFCF0NY9D6LXnY\"\nread_sheet(penguins_sheet_id, sheet = \"Torgersen Island\")\n#&gt; ‚úî Reading from penguins.\n#&gt; ‚úî Range ''Torgersen Island''.\n#&gt; # A tibble: 52 √ó 8\n#&gt;   species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;list&gt;         &lt;list&gt;        &lt;list&gt;           \n#&gt; 1 Adelie  Torgersen &lt;dbl [1]&gt;      &lt;dbl [1]&gt;     &lt;dbl [1]&gt;        \n#&gt; 2 Adelie  Torgersen &lt;dbl [1]&gt;      &lt;dbl [1]&gt;     &lt;dbl [1]&gt;        \n#&gt; 3 Adelie  Torgersen &lt;dbl [1]&gt;      &lt;dbl [1]&gt;     &lt;dbl [1]&gt;        \n#&gt; 4 Adelie  Torgersen &lt;chr [1]&gt;      &lt;chr [1]&gt;     &lt;chr [1]&gt;        \n#&gt; 5 Adelie  Torgersen &lt;dbl [1]&gt;      &lt;dbl [1]&gt;     &lt;dbl [1]&gt;        \n#&gt; 6 Adelie  Torgersen &lt;dbl [1]&gt;      &lt;dbl [1]&gt;     &lt;dbl [1]&gt;        \n#&gt; # ‚Ñπ 46 more rows\n#&gt; # ‚Ñπ 3 more variables: body_mass_g &lt;list&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\nPuede obtener una lista de todas las hojas dentro de una Hoja de Google con sheet_names():\n\nsheet_names(penguins_sheet_id)\n#&gt; [1] \"Torgersen Island\" \"Biscoe Island\"    \"Dream Island\"\n\nFinalmente, al igual que con read_excel(), podemos leer una parte de una hoja de c√°lculo de Google definiendo un range en read_sheet(). Tenga en cuenta que tambi√©n estamos usando la funci√≥n gs4_example() a continuaci√≥n para ubicar una hoja de c√°lculo de Google de ejemplo que viene con el paquete googlesheets4.\n\ndeaths_url &lt;- gs4_example(\"deaths\")\ndeaths &lt;- read_sheet(deaths_url, range = \"A5:F15\")\n#&gt; ‚úî Reading from deaths.\n#&gt; ‚úî Range A5:F15.\ndeaths\n#&gt; # A tibble: 10 √ó 6\n#&gt;   Name          Profession   Age `Has kids` `Date of birth`    \n#&gt;   &lt;chr&gt;         &lt;chr&gt;      &lt;dbl&gt; &lt;lgl&gt;      &lt;dttm&gt;             \n#&gt; 1 David Bowie   musician      69 TRUE       1947-01-08 00:00:00\n#&gt; 2 Carrie Fisher actor         60 TRUE       1956-10-21 00:00:00\n#&gt; 3 Chuck Berry   musician      90 TRUE       1926-10-18 00:00:00\n#&gt; 4 Bill Paxton   actor         61 TRUE       1955-05-17 00:00:00\n#&gt; 5 Prince        musician      57 TRUE       1958-06-07 00:00:00\n#&gt; 6 Alan Rickman  actor         69 FALSE      1946-02-21 00:00:00\n#&gt; # ‚Ñπ 4 more rows\n#&gt; # ‚Ñπ 1 more variable: `Date of death` &lt;dttm&gt;\n\n\n20.3.4 Escribir en Hojas de c√°lculo de Google\nPuede escribir desde R a Hojas de c√°lculo de Google con write_sheet(). El primer argumento es el marco de datos para escribir, y el segundo argumento es el nombre (u otro identificador) de la Hoja de Google para escribir:\n\nwrite_sheet(bake_sale, ss = \"bake-sale\")\n\nSi desea escribir sus datos en una hoja (de trabajo) espec√≠fica dentro de una hoja de c√°lculo de Google, tambi√©n puede especificarlo con el argumento sheet.\n\nwrite_sheet(bake_sale, ss = \"bake-sale\", sheet = \"Sales\")\n\n\n20.3.5 Autenticaci√≥n\nSi bien puede leer una hoja de Google p√∫blica sin autenticarse con su cuenta de Google y con gs4_deauth(), leer una hoja privada o escribir en una hoja requiere autenticaci√≥n para que googlesheets4 pueda ver y administrar sus hojas de Google.\nCuando intenta leer una hoja que requiere autenticaci√≥n, googlesheets4 lo dirigir√° a un navegador web con un mensaje para iniciar sesi√≥n en su cuenta de Google y otorgar permiso para operar en su nombre con Hojas de c√°lculo de Google. Sin embargo, si desea especificar una cuenta de Google espec√≠fica, el alcance de la autenticaci√≥n, etc., puede hacerlo con gs4_auth(), p.ej., gs4_auth(email = \"mine@example.com\"), que forzar√° el uso de un token asociado con un correo electr√≥nico espec√≠fico. Para obtener m√°s detalles de autenticaci√≥n, recomendamos leer la documentaci√≥n googlesheets4 auth vi√±eta: https://googlesheets4.tidyverse.org/articles/auth.html.\n\n20.3.6 Ejercicios\n\nLea el conjunto de datos de students anterior en el cap√≠tulo de Excel y tambi√©n de Hojas de c√°lculo de Google, sin proporcionar argumentos adicionales a las funciones read_excel() y read_sheet(). ¬øLos marcos de datos resultantes en R son exactamente iguales? Si no, ¬øen qu√© se diferencian?\nLea la encuesta titulada Google Sheet de https://pos.it/r4ds-survey, con survey_id como variable de car√°cter y n_pets como variable num√©rica.\n\nLea la lista de Google Sheet titulada de https://pos.it/r4ds-roster. El marco de datos resultante debe llamarse roster y debe tener el siguiente aspecto.\n\n#&gt; # A tibble: 12 √ó 3\n#&gt;    group subgroup    id\n#&gt;    &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n#&gt;  1     1 A            1\n#&gt;  2     1 A            2\n#&gt;  3     1 A            3\n#&gt;  4     1 B            4\n#&gt;  5     1 B            5\n#&gt;  6     1 B            6\n#&gt;  7     1 B            7\n#&gt;  8     2 A            8\n#&gt;  9     2 A            9\n#&gt; 10     2 B           10\n#&gt; 11     2 B           11\n#&gt; 12     2 B           12",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Hojas de calculo</span>"
    ]
  },
  {
    "objectID": "spreadsheets.html#resumen",
    "href": "spreadsheets.html#resumen",
    "title": "20¬† Hojas de calculo",
    "section": "\n20.4 Resumen",
    "text": "20.4 Resumen\nMicrosoft Excel y Google Sheets son dos de los sistemas de hojas de c√°lculo m√°s populares. ¬°Poder interactuar con datos almacenados en archivos de Excel y Google Sheets directamente desde R es un superpoder! En este cap√≠tulo, aprendi√≥ a leer datos en R desde hojas de c√°lculo de Excel con read_excel() del paquete readxl y de Google Sheets con read_sheet() del paquete googlesheets4. Estas funciones funcionan de manera muy similar entre s√≠ y tienen argumentos similares para especificar nombres de columnas, cadenas NA, filas para omitir en la parte superior del archivo que est√° leyendo, etc. Adem√°s, ambas funciones tambi√©n permiten leer una sola hoja de una hoja de c√°lculo.\nPor otro lado, escribir en un archivo de Excel requiere un paquete y una funci√≥n diferentes (writexl::write_xlsx()), mientras que puede escribir en una hoja de c√°lculo de Google con el paquete googlesheets4, con write_sheet().\nEn el pr√≥ximo cap√≠tulo, aprender√° sobre una fuente de datos diferente y c√≥mo leer datos de esa fuente en R: bases de datos.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>20</span>¬† <span class='chapter-title'>Hojas de calculo</span>"
    ]
  },
  {
    "objectID": "databases.html",
    "href": "databases.html",
    "title": "21¬† Bases de datos",
    "section": "",
    "text": "21.1 Introducci√≥n\nUna gran cantidad de datos reside en las bases de datos, por lo que es esencial que sepa c√≥mo acceder a ellos. A veces, puede pedirle a alguien que descargue una instant√°nea en un .csv para usted, pero esto se vuelve doloroso r√°pidamente: cada vez que necesite hacer un cambio, tendr√° que comunicarse con otro ser humano. Desea poder acceder directamente a la base de datos para obtener los datos que necesita, cuando los necesita.\nEn este cap√≠tulo, primero aprender√° los conceptos b√°sicos del paquete DBI: c√≥mo usarlo para conectarse a una base de datos y luego recuperar datos con una consulta SQL1. SQL, abreviatura de structured query llanguage, es la lingua franca de las bases de datos y es un lenguaje importante que deben aprender todos los cient√≠ficos de datos. Dicho esto, no vamos a comenzar con SQL, sino que le ense√±aremos dbplyr, que puede traducir su c√≥digo dplyr a SQL. Usaremos eso como una forma de ense√±arle algunas de las caracter√≠sticas m√°s importantes de SQL. No se convertir√° en un maestro de SQL al final del cap√≠tulo, pero podr√° identificar los componentes m√°s importantes y entender lo que hacen.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Bases de datos</span>"
    ]
  },
  {
    "objectID": "databases.html#introducci√≥n",
    "href": "databases.html#introducci√≥n",
    "title": "21¬† Bases de datos",
    "section": "",
    "text": "21.1.1 Requisitos previos\nEn este cap√≠tulo, presentaremos DBI y dbplyr. DBI es una interfaz de bajo nivel que se conecta a bases de datos y ejecuta SQL; dbplyr es una interfaz de alto nivel que traduce su c√≥digo dplyr a consultas SQL y luego las ejecuta con DBI.\n\nlibrary(DBI)\nlibrary(dbplyr)\nlibrary(tidyverse)",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Bases de datos</span>"
    ]
  },
  {
    "objectID": "databases.html#bases-de-datos-b√°sicos",
    "href": "databases.html#bases-de-datos-b√°sicos",
    "title": "21¬† Bases de datos",
    "section": "\n21.2 Bases de datos b√°sicos",
    "text": "21.2 Bases de datos b√°sicos\nEn el nivel m√°s simple, puede pensar en una base de datos como una colecci√≥n de marcos de datos, llamados tablas en la terminolog√≠a de la base de datos. Al igual que un marco de datos, una tabla de base de datos es una colecci√≥n de columnas con nombre, donde cada valor en la columna es del mismo tipo. Hay tres diferencias de alto nivel entre los marcos de datos y las tablas de la base de datos:\n\nLas tablas de la base de datos se almacenan en el disco y pueden tener un tama√±o arbitrario. Los marcos de datos se almacenan en la memoria y est√°n fundamentalmente limitados (aunque ese l√≠mite sigue siendo bastante grande para muchos problemas).\nLas tablas de bases de datos casi siempre tienen √≠ndices. Al igual que el √≠ndice de un libro, el √≠ndice de una base de datos permite encontrar r√°pidamente filas de inter√©s sin tener que mirar cada una de ellas. Los marcos de datos y los tibbles no tienen √≠ndices, pero las tablas de datos s√≠, que es una de las razones por las que son tan r√°pidos.\nLa mayor√≠a de las bases de datos cl√°sicas est√°n optimizadas para recopilar datos r√°pidamente, no para analizar los datos existentes. Estas bases de datos se denominan orientadas a filas porque los datos se almacenan fila por fila, en lugar de columna por columna como R. M√°s recientemente, ha habido mucho desarrollo de bases de datos orientadas a columnas que hacen que el an√°lisis de los datos existentes sea mucho m√°s r√°pido.\n\nLas bases de datos se ejecutan mediante sistemas de administraci√≥n de bases de datos (DBMS para abreviar), que vienen en tres formas b√°sicas:\n\n\nCliente-servidor Los DBMS se ejecutan en un poderoso servidor central, que usted conecta desde su computadora (el cliente). Son excelentes para compartir datos con varias personas en una organizaci√≥n. Los DBMS cliente-servidor populares incluyen PostgreSQL, MariaDB, SQL Server y Oracle.\nLos DBMS de Cloud, como Snowflake, RedShift de Amazon y BigQuery de Google, son similares a los DBMS del servidor del cliente, pero se ejecutan en la nube. Esto significa que pueden manejar f√°cilmente conjuntos de datos extremadamente grandes y pueden proporcionar autom√°ticamente m√°s recursos inform√°ticos seg√∫n sea necesario.\nLos DBMS en proceso, como SQLite o duckdb, se ejecutan completamente en su computadora. Son excelentes para trabajar con grandes conjuntos de datos en los que usted es el usuario principal.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Bases de datos</span>"
    ]
  },
  {
    "objectID": "databases.html#conexi√≥n-a-una-base-de-datos",
    "href": "databases.html#conexi√≥n-a-una-base-de-datos",
    "title": "21¬† Bases de datos",
    "section": "\n21.3 Conexi√≥n a una base de datos",
    "text": "21.3 Conexi√≥n a una base de datos\nPara conectarse a la base de datos desde R, utilizar√° un par de paquetes:\n\nSiempre usar√° DBI (database interface) porque proporciona un conjunto de funciones gen√©ricas que se conectan a la base de datos, cargan datos, ejecutan consultas SQL, etc.\nTambi√©n utilizar√° un paquete dise√±ado para el DBMS al que se est√° conectando. Este paquete traduce los comandos DBI gen√©ricos a los espec√≠ficos necesarios para un DBMS dado. Por lo general, hay un paquete para cada DBMS, p. RPostgres para PostgresSQL y RMariaDB para MySQL.\n\nSi no puede encontrar un paquete espec√≠fico para su DBMS, generalmente puede usar el paquete odbc en su lugar. Esto usa el protocolo ODBC soportado por muchos DBMS. odbc requiere un poco m√°s de configuraci√≥n porque tambi√©n necesitar√° instalar un controlador ODBC e indicarle al paquete odbc d√≥nde encontrarlo.\nConcretamente, crea una conexi√≥n a la base de datos usando DBI::dbConnect(). El primer argumento selecciona DBMS2, luego el segundo argumento y los subsiguientes describen c√≥mo conectarse a √©l (es decir, d√≥nde reside y las credenciales que necesita para acceder a √©l). El siguiente c√≥digo muestra un par de ejemplos t√≠picos:\n\ncon &lt;- DBI::dbConnect(\n  RMariaDB::MariaDB(), \n  username = \"foo\"\n)\ncon &lt;- DBI::dbConnect(\n  RPostgres::Postgres(), \n  hostname = \"databases.mycompany.com\", \n  port = 1234\n)\n\nLos detalles precisos de la conexi√≥n var√≠an mucho de DBMS a DBMS, por lo que lamentablemente no podemos cubrir todos los detalles aqu√≠. Esto significa que tendr√°s que investigar un poco por tu cuenta. Por lo general, puede preguntar a los otros cient√≠ficos de datos de su equipo o hablar con su DBA (database aadministrador). La configuraci√≥n inicial a menudo requerir√° un poco de manipulaci√≥n (y tal vez un poco de google) para hacerlo bien, pero generalmente solo necesitar√° hacerlo una vez.\n\n21.3.1 En este libro\nConfigurar un DBMS cliente-servidor o en la nube ser√≠a una molestia para este libro, por lo que en su lugar usaremos un DBMS en proceso que vive completamente en un paquete R: duckdb. Gracias a la magia de DBI, la √∫nica diferencia entre usar duckdb y cualquier otro DBMS es c√≥mo te conectar√°s a la base de datos. Esto hace que sea excelente para ense√±ar porque puede ejecutar f√°cilmente este c√≥digo y tomar f√°cilmente lo que aprende y aplicarlo en otro lugar.\nConectarse a duckdb es particularmente simple porque los valores predeterminados crean una base de datos temporal que se elimina cuando sale de R. Eso es excelente para aprender porque garantiza que comenzar√° desde cero cada vez que reinicie R:\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb())\n\nduckdb es una base de datos de alto rendimiento dise√±ada en gran medida para las necesidades de un cient√≠fico de datos. Lo usamos aqu√≠ porque es muy f√°cil de usar, pero tambi√©n es capaz de manejar gigabytes de datos a gran velocidad. Si desea utilizar duckdb para un proyecto de an√°lisis de datos real, tambi√©n deber√° proporcionar el argumento dbdir para crear una base de datos persistente y decirle a duckdb d√≥nde guardarla. Asumiendo que est√°s usando un proyecto (Cap√≠tulo 6), es razonable guardarlo en el directorio duckdb del proyecto actual:\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = \"duckdb\")\n\n\n21.3.2 Cargar algunos datos\nDado que esta es una base de datos nueva, debemos comenzar agregando algunos datos. Aqu√≠ agregaremos conjuntos de datos mpg y diamonds de ggplot2 usando DBI::dbWriteTable(). El uso m√°s simple de dbWriteTable() necesita tres argumentos: una conexi√≥n de base de datos, el nombre de la tabla para crear en la base de datos y un marco de datos de datos.\n\ndbWriteTable(con, \"mpg\", ggplot2::mpg)\ndbWriteTable(con, \"diamonds\", ggplot2::diamonds)\n\nSi est√° utilizando duckdb en un proyecto real, le recomendamos que aprenda sobre duckdb_read_csv() y duckdb_register_arrow(). Estos le brindan formas potentes y eficaces de cargar r√°pidamente datos directamente en duckdb, sin tener que cargarlos primero en R. Tambi√©n mostraremos una t√©cnica √∫til para cargar varios archivos en una base de datos en Secci√≥n 26.4.1.\n\n21.3.3 DBI b√°sico\nPuede comprobar que los datos se cargan correctamente utilizando un par de otras funciones de DBI: dbListTables() enumera todas las tablas de la base de datos3 y dbReadTable() recupera el contenido de una tabla.\n\ndbListTables(con)\n#&gt; [1] \"diamonds\" \"mpg\"\n\ncon |&gt; \n  dbReadTable(\"diamonds\") |&gt; \n  as_tibble()\n#&gt; # A tibble: 53,940 √ó 10\n#&gt;   carat cut       color clarity depth table price     x     y     z\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#&gt; 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#&gt; 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#&gt; 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#&gt; 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#&gt; 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#&gt; # ‚Ñπ 53,934 more rows\n\ndbReadTable() devuelve un data.frame por lo que usamos as_tibble() para convertirlo en un tibble para que se imprima bien.\nSi ya conoce SQL, puede usar dbGetQuery() para obtener los resultados de ejecutar una consulta en la base de datos:\n\nsql &lt;- \"\n  SELECT carat, cut, clarity, color, price \n  FROM diamonds \n  WHERE price &gt; 15000\n\"\nas_tibble(dbGetQuery(con, sql))\n#&gt; # A tibble: 1,655 √ó 5\n#&gt;   carat cut       clarity color price\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt;   &lt;fct&gt; &lt;int&gt;\n#&gt; 1  1.54 Premium   VS2     E     15002\n#&gt; 2  1.19 Ideal     VVS1    F     15005\n#&gt; 3  2.1  Premium   SI1     I     15007\n#&gt; 4  1.69 Ideal     SI1     D     15011\n#&gt; 5  1.5  Very Good VVS2    G     15013\n#&gt; 6  1.73 Very Good VS1     G     15014\n#&gt; # ‚Ñπ 1,649 more rows\n\nSi nunca ha visto SQL antes, ¬°no se preocupe! En breve aprender√°s m√°s al respecto. Pero si lo lee detenidamente, puede adivinar que selecciona cinco columnas del conjunto de datos de diamantes y todas las filas donde el precio es mayor que 15,000.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Bases de datos</span>"
    ]
  },
  {
    "objectID": "databases.html#dbplyr-b√°sico",
    "href": "databases.html#dbplyr-b√°sico",
    "title": "21¬† Bases de datos",
    "section": "\n21.4 dbplyr b√°sico",
    "text": "21.4 dbplyr b√°sico\nAhora que nos conectamos a una base de datos y cargamos algunos datos, podemos comenzar a aprender sobre dbplyr. dbplyr es un backend de dplyr, lo que significa que sigues escribiendo c√≥digo dplyr pero el backend lo ejecuta de manera diferente. En esto, dbplyr se traduce a SQL; otros backends incluyen dtplyr que se traduce en data.table, y multidplyr que ejecuta su c√≥digo en m√∫ltiples n√∫cleos.\nPara usar dbplyr, primero debe usar tbl() para crear un objeto que represente una tabla de base de datos:\n\ndiamonds_db &lt;- tbl(con, \"diamonds\")\ndiamonds_db\n#&gt; # Source:   table&lt;diamonds&gt; [?? x 10]\n#&gt; # Database: DuckDB v0.10.2 [unknown@Linux 6.11.0-1018-azure:R 4.4.0/:memory:]\n#&gt;   carat cut       color clarity depth table price     x     y     z\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#&gt; 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#&gt; 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#&gt; 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#&gt; 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#&gt; 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#&gt; # ‚Ñπ more rows\n\n\n\n\n\n\n\nHay otras dos formas comunes de interactuar con una base de datos. Primero, muchas bases de datos corporativas son muy grandes, por lo que necesita cierta jerarqu√≠a para mantener todas las tablas organizadas. En ese caso, es posible que deba proporcionar un esquema, o un cat√°logo y un esquema, para elegir la tabla que le interesa.:\n\ndiamonds_db &lt;- tbl(con, in_schema(\"sales\", \"diamonds\"))\ndiamonds_db &lt;- tbl(con, in_catalog(\"north_america\", \"sales\", \"diamonds\"))\n\nOtras veces, es posible que desee utilizar su propia consulta SQL como punto de partida:\n\ndiamonds_db &lt;- tbl(con, sql(\"SELECT * FROM diamonds\"))\n\n\n\n\nEste objeto es perezoso; cuando usa verbos dplyr en √©l, dplyr no hace ning√∫n trabajo: solo registra la secuencia de operaciones que desea realizar y solo las realiza cuando es necesario. Por ejemplo, tome la siguiente canalizaci√≥n:\n\nbig_diamonds_db &lt;- diamonds_db |&gt; \n  filter(price &gt; 15000) |&gt; \n  select(carat:clarity, price)\n\nbig_diamonds_db\n#&gt; # Source:   SQL [?? x 5]\n#&gt; # Database: DuckDB v0.10.2 [unknown@Linux 6.11.0-1018-azure:R 4.4.0/:memory:]\n#&gt;   carat cut       color clarity price\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n#&gt; 1  1.54 Premium   E     VS2     15002\n#&gt; 2  1.19 Ideal     F     VVS1    15005\n#&gt; 3  2.1  Premium   I     SI1     15007\n#&gt; 4  1.69 Ideal     D     SI1     15011\n#&gt; 5  1.5  Very Good G     VVS2    15013\n#&gt; 6  1.73 Very Good G     VS1     15014\n#&gt; # ‚Ñπ more rows\n\nPuede decir que este objeto representa una consulta de base de datos porque imprime el nombre de DBMS en la parte superior y, aunque le dice el n√∫mero de columnas, normalmente no sabe el n√∫mero de filas. Esto se debe a que encontrar el n√∫mero total de filas generalmente requiere ejecutar la consulta completa, algo que estamos tratando de evitar.\nPuede ver el c√≥digo SQL generado por la funci√≥n dbplyr show_query(). Si conoce dplyr, ¬°esta es una excelente manera de aprender SQL! Escriba algo de c√≥digo dplyr, obtenga dbplyr para traducirlo a SQL y luego intente averiguar c√≥mo coinciden los dos idiomas.\n\nbig_diamonds_db |&gt;\n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT carat, cut, color, clarity, price\n#&gt; FROM diamonds\n#&gt; WHERE (price &gt; 15000.0)\n\nPara recuperar todos los datos en R, llama a collect(). Detr√°s de escena, esto genera el SQL, llama a dbGetQuery() para obtener los datos, luego convierte el resultado en un tibble:\n\nbig_diamonds &lt;- big_diamonds_db |&gt; \n  collect()\nbig_diamonds\n#&gt; # A tibble: 1,655 √ó 5\n#&gt;   carat cut       color clarity price\n#&gt;   &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n#&gt; 1  1.54 Premium   E     VS2     15002\n#&gt; 2  1.19 Ideal     F     VVS1    15005\n#&gt; 3  2.1  Premium   I     SI1     15007\n#&gt; 4  1.69 Ideal     D     SI1     15011\n#&gt; 5  1.5  Very Good G     VVS2    15013\n#&gt; 6  1.73 Very Good G     VS1     15014\n#&gt; # ‚Ñπ 1,649 more rows\n\nPor lo general, usar√° dbplyr para seleccionar los datos que desea de la base de datos, realizando filtrado y agregaci√≥n b√°sicos utilizando las traducciones que se describen a continuaci√≥n. Luego, una vez que est√© listo para analizar los datos con funciones que son exclusivas de R, collect() los datos para obtener un tibble en memoria y continuar su trabajo con c√≥digo R puro.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Bases de datos</span>"
    ]
  },
  {
    "objectID": "databases.html#sql",
    "href": "databases.html#sql",
    "title": "21¬† Bases de datos",
    "section": "\n21.5 SQL",
    "text": "21.5 SQL\nEl resto del cap√≠tulo le ense√±ar√° un poco de SQL a trav√©s de la lente de dbplyr. Es una introducci√≥n bastante no tradicional a SQL, pero esperamos que lo ponga r√°pidamente al d√≠a con los conceptos b√°sicos. Afortunadamente, si entiende dplyr, est√° en un buen lugar para aprender SQL r√°pidamente porque muchos de los conceptos son los mismos.\nExploraremos la relaci√≥n entre dplyr y SQL usando un par de viejos amigos del paquete nycflights13: flights y planes. Estos conjuntos de datos son f√°ciles de ingresar a nuestra base de datos de aprendizaje porque dbplyr viene con una funci√≥n que copia las tablas de nycflights13 a nuestra base de datos:\n\ndbplyr::copy_nycflights13(con)\n#&gt; Creating table: airlines\n#&gt; Creating table: airports\n#&gt; Creating table: flights\n#&gt; Creating table: planes\n#&gt; Creating table: weather\nflights &lt;- tbl(con, \"flights\")\nplanes &lt;- tbl(con, \"planes\")\n\n\n21.5.1 SQL b√°sico\nLos componentes de nivel superior de SQL se denominan declaraciones. Las declaraciones comunes incluyen CREATE para definir nuevas tablas, INSERT para agregar datos y SELECT para recuperar datos. Nos centraremos en las declaraciones SELECT, tambi√©n llamadas consultas, porque son casi exclusivamente lo que usar√° como cient√≠fico de datos.\nUna consulta se compone de cl√°usulas. Hay cinco cl√°usulas importantes: SELECT, FROM, WHERE, ORDER BY y GROUP BY. Cada consulta debe tener las cl√°usulas SELECT4 y FROM5 y la consulta m√°s simple es SELECT * FROM table, que selecciona todas las columnas de la tabla especificada . Esto es lo que genera dbplyr para una tabla sin adulterar :\n\nflights |&gt; show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT *\n#&gt; FROM flights\nplanes |&gt; show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT *\n#&gt; FROM planes\n\nWHERE y ORDER BY controlan qu√© filas se incluyen y c√≥mo se ordenan:\n\nflights |&gt; \n  filter(dest == \"IAH\") |&gt; \n  arrange(dep_delay) |&gt;\n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (dest = 'IAH')\n#&gt; ORDER BY dep_delay\n\nGROUP BY convierte la consulta en un resumen, lo que hace que se produzca la agregaci√≥n:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(dep_delay = mean(dep_delay, na.rm = TRUE)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT dest, AVG(dep_delay) AS dep_delay\n#&gt; FROM flights\n#&gt; GROUP BY dest\n\nHay dos diferencias importantes entre los verbos dplyr y las cl√°usulas SELECT:\n\nEn SQL, el caso no importa: puede escribir select, SELECT o incluso SeLeCt. En este libro nos apegaremos a la convenci√≥n com√∫n de escribir palabras clave de SQL en may√∫sculas para distinguirlas de los nombres de tablas o variables.\nEn SQL, el orden importa: siempre debe escribir las cl√°usulas en el orden SELECT, FROM, WHERE, GROUP BY, ORDER BY. De manera confusa, este orden no coincide con la evaluaci√≥n real de las cl√°usulas, que es primero FROM, luego WHERE, GROUP BY, SELECT y ORDER BY.\n\nLas siguientes secciones exploran cada cl√°usula con m√°s detalle.\n\n\n\n\n\n\nTenga en cuenta que, si bien SQL es un est√°ndar, es extremadamente complejo y ninguna base de datos lo sigue exactamente. Si bien los componentes principales en los que nos centraremos en este libro son muy similares entre los DBMS, existen muchas variaciones menores. Afortunadamente, dbplyr est√° dise√±ado para manejar este problema y genera diferentes traducciones para diferentes bases de datos. No es perfecto, pero est√° mejorando continuamente, y si encuentra un problema, puede presentar un problema en GitHub para ayudarnos a hacerlo mejor.\n\n\n\n\n21.5.2 SELECT\nLa cl√°usula SELECT es el caballo de batalla de las consultas y realiza el mismo trabajo que select(), mutate(), rename(), relocate() y, como aprender√° en la pr√≥xima secci√≥n, summarize().\nselect(), rename() y relocate() tienen traducciones muy directas a SELECT ya que solo afectan el lugar donde aparece una columna (si es que aparece) junto con su nombre:\n\nplanes |&gt; \n  select(tailnum, type, manufacturer, model, year) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT tailnum, \"type\", manufacturer, model, \"year\"\n#&gt; FROM planes\n\nplanes |&gt; \n  select(tailnum, type, manufacturer, model, year) |&gt; \n  rename(year_built = year) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT tailnum, \"type\", manufacturer, model, \"year\" AS year_built\n#&gt; FROM planes\n\nplanes |&gt; \n  select(tailnum, type, manufacturer, model, year) |&gt; \n  relocate(manufacturer, model, .before = type) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT tailnum, manufacturer, model, \"type\", \"year\"\n#&gt; FROM planes\n\nEste ejemplo tambi√©n muestra c√≥mo SQL cambia el nombre. En la terminolog√≠a SQL, el cambio de nombre se denomina aliasing y se realiza con AS. Tenga en cuenta que, a diferencia de mutate(), el nombre anterior est√° a la izquierda y el nuevo nombre est√° a la derecha.\n\n\n\n\n\n\nEn los ejemplos anteriores, tenga en cuenta que \"year\" y \"type\" est√°n entre comillas dobles. Esto se debe a que estas son palabras reservadas en duckdb, por lo que dbplyr las cita para evitar cualquier posible confusi√≥n entre los nombres de columnas/tablas y los operadores de SQL.\nCuando trabaje con otras bases de datos, es probable que vea todos los nombres de variables entre comillas porque solo un pu√±ado de paquetes de clientes, como duckdb, saben cu√°les son todas las palabras reservadas, por lo que citan todo para estar seguros.\nSELECT \"tailnum\", \"type\", \"manufacturer\", \"model\", \"year\"\nFROM \"planes\"\nAlgunos otros sistemas de bases de datos usan acentos graves en lugar de comillas:\nSELECT `tailnum`, `type`, `manufacturer`, `model`, `year`\nFROM `planes`\n\n\n\nLas traducciones de mutate() son igualmente sencillas: cada variable se convierte en una nueva expresi√≥n en SELECT:\n\nflights |&gt; \n  mutate(\n    speed = distance / (air_time / 60)\n  ) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*, distance / (air_time / 60.0) AS speed\n#&gt; FROM flights\n\nVolveremos a la traducci√≥n de componentes individuales (como /) en Secci√≥n 21.6.\n\n21.5.3 FROM\nLa cl√°usula FROM define la fuente de datos. Va a ser poco interesante por un tiempo, porque solo estamos usando tablas individuales. Ver√° ejemplos m√°s complejos una vez que lleguemos a las funciones de uni√≥n.\n\n21.5.4 GROUP BY\ngroup_by() se traduce a la cl√°usula GROUP BY6 y summarize() se traduce a la cl√°usula SELECT:\n\ndiamonds_db |&gt; \n  group_by(cut) |&gt; \n  summarize(\n    n = n(),\n    avg_price = mean(price, na.rm = TRUE)\n  ) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT cut, COUNT(*) AS n, AVG(price) AS avg_price\n#&gt; FROM diamonds\n#&gt; GROUP BY cut\n\nVolveremos a lo que sucede con la traducci√≥n n() y mean() en Secci√≥n 21.6.\n\n21.5.5 WHERE\nfilter() se traduce a la cl√°usula WHERE:\n\nflights |&gt; \n  filter(dest == \"IAH\" | dest == \"HOU\") |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (dest = 'IAH' OR dest = 'HOU')\n\nflights |&gt; \n  filter(arr_delay &gt; 0 & arr_delay &lt; 20) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (arr_delay &gt; 0.0 AND arr_delay &lt; 20.0)\n\nHay algunos detalles importantes a tener en cuenta aqu√≠:\n\n\n| se convierte en OR y & se convierte en AND.\nSQL usa = para comparar, no ==. SQL no tiene asignaci√≥n, por lo que no hay posibilidad de confusi√≥n all√≠.\nSQL usa solo '' para cadenas, no \"\". En SQL, \"\" se usa para identificar variables, como `` de R.\n\nOtro operador SQL √∫til es IN, que est√° muy cerca del %in% de R:\n\nflights |&gt; \n  filter(dest %in% c(\"IAH\", \"HOU\")) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (dest IN ('IAH', 'HOU'))\n\nSQL usa NULL en lugar de NA. NULLs se comportan de manera similar a NAs. La principal diferencia es que, si bien son ‚Äúinfecciosos‚Äù en las comparaciones y la aritm√©tica, se descartan silenciosamente al resumir. dbplyr le recordar√° este comportamiento la primera vez que lo presione:\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarize(delay = mean(arr_delay))\n#&gt; Warning: Missing values are always removed in SQL aggregation functions.\n#&gt; Use `na.rm = TRUE` to silence this warning\n#&gt; This warning is displayed once every 8 hours.\n#&gt; # Source:   SQL [?? x 2]\n#&gt; # Database: DuckDB v0.10.2 [unknown@Linux 6.11.0-1018-azure:R 4.4.0/:memory:]\n#&gt;   dest  delay\n#&gt;   &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 ATL   11.3 \n#&gt; 2 CLT    7.36\n#&gt; 3 MCO    5.45\n#&gt; 4 MDW   12.4 \n#&gt; 5 HOU    7.18\n#&gt; 6 SDF   12.7 \n#&gt; # ‚Ñπ more rows\n\nSi desea obtener m√°s informaci√≥n sobre c√≥mo funcionan los valores NULL, puede disfrutar de ‚ÄúLa l√≥gica de tres valores de SQL‚Äù de Markus Winand.\nEn general, puedes trabajar con NULLs usando las funciones que usar√≠as para NAs en R:\n\nflights |&gt; \n  filter(!is.na(dep_delay)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; WHERE (NOT((dep_delay IS NULL)))\n\nEsta consulta SQL ilustra uno de los inconvenientes de dbplyr: si bien el SQL es correcto, no es tan simple como podr√≠a escribirse a mano. En este caso, podr√≠a quitar los par√©ntesis y usar un operador especial que sea m√°s f√°cil de leer:\nWHERE \"dep_delay\" IS NOT NULL\nTenga en cuenta que si filtra, filter(), una variable que cre√≥ utilizando un resumen, dbplyr generar√° una cl√°usula ‚ÄòHAVING‚Äô, en lugar de una cl√°usula ‚ÄòWHERE‚Äô. Esta es una de las idiosincrasias de SQL: WHERE se eval√∫a antes que SELECT y GROUP BY, por lo que SQL necesita otra cl√°usula que se eval√∫a despu√©s.\n\ndiamonds_db |&gt; \n  group_by(cut) |&gt; \n  summarize(n = n()) |&gt; \n  filter(n &gt; 100) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT cut, COUNT(*) AS n\n#&gt; FROM diamonds\n#&gt; GROUP BY cut\n#&gt; HAVING (COUNT(*) &gt; 100.0)\n\n\n21.5.6 ORDER BY\nOrdenar filas implica una traducci√≥n directa de arrange() a la cl√°usula ORDER BY:\n\nflights |&gt; \n  arrange(year, month, day, desc(dep_delay)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT flights.*\n#&gt; FROM flights\n#&gt; ORDER BY \"year\", \"month\", \"day\", dep_delay DESC\n\nObserve c√≥mo desc() se traduce a DESC: esta es una de las muchas funciones dplyr cuyo nombre se inspir√≥ directamente en SQL.\n\n21.5.7 Subconsultas\nA veces, no es posible traducir una canalizaci√≥n dplyr en una sola declaraci√≥n SELECT y necesita usar una subconsulta. Una subconsulta es solo una consulta utilizada como fuente de datos en la cl√°usula FROM, en lugar de la tabla habitual.\ndbplyr normalmente usa subconsultas para sortear las limitaciones de SQL. Por ejemplo, las expresiones en la cl√°usula SELECT no pueden hacer referencia a columnas que se acaban de crear. Eso significa que la siguiente canalizaci√≥n (tonta) de dplyr debe ocurrir en dos pasos: la primera consulta (interna) calcula year1 y luego la segunda consulta (externa) puede calcular year2.\n\nflights |&gt; \n  mutate(\n    year1 = year + 1,\n    year2 = year1 + 1\n  ) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT q01.*, year1 + 1.0 AS year2\n#&gt; FROM (\n#&gt;   SELECT flights.*, \"year\" + 1.0 AS year1\n#&gt;   FROM flights\n#&gt; ) q01\n\nTambi√©n ver√° esto si intent√≥ filtrar, filter(), una variable que acaba de crear. Recuerda, aunque WHERE se escribe despu√©s de SELECT, se eval√∫a antes, por lo que necesitamos una subconsulta en este (tonto) ejemplo:\n\nflights |&gt; \n  mutate(year1 = year + 1) |&gt; \n  filter(year1 == 2014) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT q01.*\n#&gt; FROM (\n#&gt;   SELECT flights.*, \"year\" + 1.0 AS year1\n#&gt;   FROM flights\n#&gt; ) q01\n#&gt; WHERE (year1 = 2014.0)\n\nA veces, dbplyr crear√° una subconsulta donde no es necesaria porque a√∫n no sabe c√≥mo optimizar esa traducci√≥n. A medida que dbplyr mejore con el tiempo, estos casos se volver√°n m√°s raros pero probablemente nunca desaparezcan.\n\n21.5.8 Uniones\nSi est√° familiarizado con las uniones de dplyr, las uniones de SQL son muy similares. Aqu√≠ hay un ejemplo simple:\n\nflights |&gt; \n  left_join(planes |&gt; rename(year_built = year), join_by(tailnum)) |&gt; \n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   flights.*,\n#&gt;   planes.\"year\" AS year_built,\n#&gt;   \"type\",\n#&gt;   manufacturer,\n#&gt;   model,\n#&gt;   engines,\n#&gt;   seats,\n#&gt;   speed,\n#&gt;   engine\n#&gt; FROM flights\n#&gt; LEFT JOIN planes\n#&gt;   ON (flights.tailnum = planes.tailnum)\n\nLo principal a notar aqu√≠ es la sintaxis: las uniones SQL usan subcl√°usulas de la cl√°usula FROM para traer tablas adicionales, usando ON para definir c√≥mo se relacionan las tablas.\nLos nombres de dplyr para estas funciones est√°n tan estrechamente relacionados con SQL que puede adivinar f√°cilmente el SQL equivalente para inner_join(), right_join() y full_join():\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nINNER JOIN planes ON (flights.tailnum = planes.tailnum)\n\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nRIGHT JOIN planes ON (flights.tailnum = planes.tailnum)\n\nSELECT flights.*, \"type\", manufacturer, model, engines, seats, speed\nFROM flights\nFULL JOIN planes ON (flights.tailnum = planes.tailnum)\nEs probable que necesite muchas uniones cuando trabaje con datos de una base de datos. Esto se debe a que las tablas de la base de datos a menudo se almacenan en una forma altamente normalizada, donde cada ‚Äúhecho‚Äù se almacena en un solo lugar y para mantener un conjunto de datos completo para el an√°lisis, debe navegar por una red compleja de tablas conectadas por claves primarias y externas. Si te encuentras en este escenario, el paquete dm, de Tobias Schieferdecker, Kirill M√ºller y Darko Bergant, es un salvavidas. Puede determinar autom√°ticamente las conexiones entre tablas usando las restricciones que los administradores de bases de datos suelen proporcionar, visualizar las conexiones para que pueda ver lo que est√° pasando y generar las uniones que necesita para conectar una tabla con otra.\n\n21.5.9 Otros verbos\ndbplyr tambi√©n traduce otros verbos como distinct(), slice_*() e intersect(), y una creciente selecci√≥n de funciones tidyr como pivot_longer() y pivot_wider(). La forma m√°s f√°cil de ver el conjunto completo de lo que est√° disponible actualmente es visitar el sitio web de dbplyr: https://dbplyr.tidyverse.org/reference/.\n\n21.5.10 Ejercicios\n\n¬øA qu√© se traduce distinct()? ¬øQu√© tal head()?\n\nExplique qu√© hace cada una de las siguientes consultas SQL e intente recrearlas usando dbplyr.\nSELECT * \nFROM flights\nWHERE dep_delay &lt; arr_delay\n\nSELECT *, distance / (air_time / 60) AS speed\nFROM flights",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Bases de datos</span>"
    ]
  },
  {
    "objectID": "databases.html#sec-sql-expressions",
    "href": "databases.html#sec-sql-expressions",
    "title": "21¬† Bases de datos",
    "section": "\n21.6 Traducciones de funciones",
    "text": "21.6 Traducciones de funciones\nHasta ahora nos hemos centrado en el panorama general de c√≥mo se traducen los verbos dplyr a las cl√°usulas de una consulta. Ahora vamos a acercarnos un poco y hablar sobre la traducci√≥n de las funciones R que funcionan con columnas individuales, p.ej., ¬øQu√© pasa cuando usas mean(x) en summarize()?\nPara ayudar a ver lo que est√° pasando, usaremos un par de peque√±as funciones auxiliares que ejecutan summarize() o mutate() y muestran el SQL generado. Eso har√° que sea un poco m√°s f√°cil explorar algunas variaciones y ver c√≥mo los res√∫menes y las transformaciones pueden diferir.\n\nsummarize_query &lt;- function(df, ...) {\n  df |&gt; \n    summarize(...) |&gt; \n    show_query()\n}\nmutate_query &lt;- function(df, ...) {\n  df |&gt; \n    mutate(..., .keep = \"none\") |&gt; \n    show_query()\n}\n\n¬°Vamos a sumergirnos con algunos res√∫menes! Si observa el c√≥digo siguiente, notar√° que algunas funciones de resumen, como mean(), tienen una traducci√≥n relativamente simple, mientras que otras, como median(), son mucho m√°s complejas. La complejidad suele ser mayor para las operaciones que son comunes en las estad√≠sticas pero menos comunes en las bases de datos.\n\nflights |&gt; \n  group_by(year, month, day) |&gt;  \n  summarize_query(\n    mean = mean(arr_delay, na.rm = TRUE),\n    median = median(arr_delay, na.rm = TRUE)\n  )\n#&gt; `summarise()` has grouped output by \"year\" and \"month\". You can override\n#&gt; using the `.groups` argument.\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   \"year\",\n#&gt;   \"month\",\n#&gt;   \"day\",\n#&gt;   AVG(arr_delay) AS mean,\n#&gt;   PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY arr_delay) AS median\n#&gt; FROM flights\n#&gt; GROUP BY \"year\", \"month\", \"day\"\n\nLa traducci√≥n de las funciones de resumen se vuelve m√°s complicada cuando las usa dentro de un mutate() porque tienen que convertirse en las llamadas funciones de ventana. En SQL, convierte una funci√≥n de agregaci√≥n ordinaria en una funci√≥n de ventana agregando OVER despu√©s de ella:\n\nflights |&gt; \n  group_by(year, month, day) |&gt;  \n  mutate_query(\n    mean = mean(arr_delay, na.rm = TRUE),\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   \"year\",\n#&gt;   \"month\",\n#&gt;   \"day\",\n#&gt;   AVG(arr_delay) OVER (PARTITION BY \"year\", \"month\", \"day\") AS mean\n#&gt; FROM flights\n\nEn SQL, la cl√°usula GROUP BY se usa exclusivamente para res√∫menes, por lo que aqu√≠ puede ver que la agrupaci√≥n se ha movido desde la cl√°usula GROUP BY a OVER.\nLas funciones de ventana incluyen todas las funciones que miran hacia adelante o hacia atr√°s, como lead() y lag() que miran el valor ‚Äúanterior‚Äù o ‚Äúsiguiente‚Äù respectivamente:\n\nflights |&gt; \n  group_by(dest) |&gt;  \n  arrange(time_hour) |&gt; \n  mutate_query(\n    lead = lead(arr_delay),\n    lag = lag(arr_delay)\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT\n#&gt;   dest,\n#&gt;   LEAD(arr_delay, 1, NULL) OVER (PARTITION BY dest ORDER BY time_hour) AS lead,\n#&gt;   LAG(arr_delay, 1, NULL) OVER (PARTITION BY dest ORDER BY time_hour) AS lag\n#&gt; FROM flights\n#&gt; ORDER BY time_hour\n\nAqu√≠ es importante arreglar, arrange(), los datos, porque las tablas SQL no tienen un orden intr√≠nseco. De hecho, si no usa arrange(), ¬°podr√≠a recuperar las filas en un orden diferente cada vez! Aviso para las funciones de ventana, la informaci√≥n de pedido se repite: la cl√°usula ORDER BY de la consulta principal no se aplica autom√°ticamente a las funciones de ventana.\nOtra funci√≥n SQL importante es CASE WHEN. Se usa como la traducci√≥n de if_else() y case_when(), la funci√≥n dplyr que inspir√≥ directamente. Aqu√≠ hay un par de ejemplos simples:\n\nflights |&gt; \n  mutate_query(\n    description = if_else(arr_delay &gt; 0, \"delayed\", \"on-time\")\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT CASE WHEN (arr_delay &gt; 0.0) THEN 'delayed' WHEN NOT (arr_delay &gt; 0.0) THEN 'on-time' END AS description\n#&gt; FROM flights\nflights |&gt; \n  mutate_query(\n    description = \n      case_when(\n        arr_delay &lt; -5 ~ \"early\", \n        arr_delay &lt; 5 ~ \"on-time\",\n        arr_delay &gt;= 5 ~ \"late\"\n      )\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT CASE\n#&gt; WHEN (arr_delay &lt; -5.0) THEN 'early'\n#&gt; WHEN (arr_delay &lt; 5.0) THEN 'on-time'\n#&gt; WHEN (arr_delay &gt;= 5.0) THEN 'late'\n#&gt; END AS description\n#&gt; FROM flights\n\nCASE WHEN tambi√©n se usa para algunas otras funciones que no tienen una traducci√≥n directa de R a SQL. Un buen ejemplo de esto es cut():\n\nflights |&gt; \n  mutate_query(\n    description =  cut(\n      arr_delay, \n      breaks = c(-Inf, -5, 5, Inf), \n      labels = c(\"early\", \"on-time\", \"late\")\n    )\n  )\n#&gt; &lt;SQL&gt;\n#&gt; SELECT CASE\n#&gt; WHEN (arr_delay &lt;= -5.0) THEN 'early'\n#&gt; WHEN (arr_delay &lt;= 5.0) THEN 'on-time'\n#&gt; WHEN (arr_delay &gt; 5.0) THEN 'late'\n#&gt; END AS description\n#&gt; FROM flights\n\ndbplyr tambi√©n traduce funciones comunes de manipulaci√≥n de cadenas y fecha y hora, sobre las que puede obtener informaci√≥n en vignette(\"funcion-de-traduccion\", package = \"dbplyr\"). Las traducciones de dbplyr ciertamente no son perfectas, y hay muchas funciones de R que a√∫n no est√°n traducidas, pero dbplyr hace un trabajo sorprendentemente bueno al cubrir las funciones que usar√° la mayor parte del tiempo..",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Bases de datos</span>"
    ]
  },
  {
    "objectID": "databases.html#resumen",
    "href": "databases.html#resumen",
    "title": "21¬† Bases de datos",
    "section": "\n21.7 Resumen",
    "text": "21.7 Resumen\nEn este cap√≠tulo aprendi√≥ c√≥mo acceder a los datos de las bases de datos. Nos enfocamos en dbplyr, un ‚Äúbackend‚Äù de dplyr que le permite escribir el c√≥digo dplyr con el que est√° familiarizado y hacer que se traduzca autom√°ticamente a SQL. Usamos esa traducci√≥n para ense√±arle un poco de SQL; es importante aprender algo de SQL porque es el lenguaje m√°s utilizado para trabajar con datos y conocer algunos le facilitar√° la comunicaci√≥n con otras personas de datos que no usan R. Si ha terminado este cap√≠tulo y desea obtener m√°s informaci√≥n sobre SQL. Tenemos dos recomendaciones:\n\n\nSQL for Data Scientists de Ren√©e M. P. Teate es una introducci√≥n a SQL dise√±ada espec√≠ficamente para las necesidades de los cient√≠ficos de datos e incluye ejemplos del tipo de datos altamente interconectados que es probable que encuentre en organizaciones reales.\n\nPractical SQL de Anthony DeBarros est√° escrito desde la perspectiva de un periodista de datos (un cient√≠fico de datos especializado en contar historias convincentes) y entra en m√°s detalles sobre c√≥mo obtener sus datos en una base de datos y ejecutar su propio DBMS.\n\nEn el pr√≥ximo cap√≠tulo, aprenderemos sobre otro backend de dplyr para trabajar con datos de gran tama√±o: arrow. Arrow est√° dise√±ado para trabajar con archivos grandes en disco y es un complemento natural para las bases de datos.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Bases de datos</span>"
    ]
  },
  {
    "objectID": "databases.html#footnotes",
    "href": "databases.html#footnotes",
    "title": "21¬† Bases de datos",
    "section": "",
    "text": "SQL es pronunciado ‚Äús‚Äù-‚Äúq‚Äù-‚Äúl‚Äù o ‚Äúsequel‚Äù.‚Ü©Ô∏é\nPor lo general, esta es la √∫nica funci√≥n que usar√° del paquete del cliente, por lo que recomendamos usar :: para extraer esa funci√≥n, en lugar de cargar el paquete completo con library().‚Ü©Ô∏é\nAl menos, todas las tablas que tiene permiso para ver.‚Ü©Ô∏é\nDe manera confusa, seg√∫n el contexto, SELECT es una declaraci√≥n o una cl√°usula. Para evitar esta confusi√≥n, generalmente usaremos la consulta SELECT en lugar de la instrucci√≥n SELECT.‚Ü©Ô∏é\nOk, t√©cnicamente, solo se requiere SELECT, ya que puedes escribir consultas como SELECT 1+1 para realizar c√°lculos b√°sicos. Pero si quieres trabajar con datos (¬°como siempre lo haces!) tambi√©n necesitar√°s una cl√°usula FROM.‚Ü©Ô∏é\nEsto no es coincidencia: el nombre de la funci√≥n dplyr se inspir√≥ en la cl√°usula SQL.‚Ü©Ô∏é",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>21</span>¬† <span class='chapter-title'>Bases de datos</span>"
    ]
  },
  {
    "objectID": "arrow.html",
    "href": "arrow.html",
    "title": "22¬† Arrow",
    "section": "",
    "text": "22.1 Introducci√≥n\nLos archivos CSV est√°n dise√±ados para que los humanos los lean f√°cilmente. Son un buen formato de intercambio porque son muy simples y pueden ser le√≠dos por todas las herramientas bajo el sol. Pero los archivos CSV no son muy eficientes: hay que trabajar mucho para leer los datos en R. En este cap√≠tulo, aprender√° sobre una poderosa alternativa: el formato parquet, un formato basado en est√°ndares abiertos ampliamente utilizado por los sistemas de big data.\nCombinaremos los archivos de parquet con Apache Arrow, una caja de herramientas multiling√ºe dise√±ada para el an√°lisis y el transporte eficientes de grandes conjuntos de datos. Usaremos Apache Arrow a trav√©s del paquete arrow, que proporciona un backend de dplyr que le permite analizar conjuntos de datos m√°s grandes que la memoria usando la sintaxis familiar de dplyr. Como beneficio adicional, arrow es extremadamente r√°pida: ver√° algunos ejemplos m√°s adelante en el cap√≠tulo.\nTanto arrow como dbplyr proporcionan backends de dplyr, por lo que es posible que se pregunte cu√°ndo usar cada uno. En muchos casos, la elecci√≥n est√° hecha por usted, ya que los datos ya est√°n en una base de datos o en archivos de parquet, y desear√° trabajar con ellos tal como est√°n. Pero si est√° comenzando con sus propios datos (quiz√°s archivos CSV), puede cargarlos en una base de datos o convertirlos en parquet. En general, es dif√≠cil saber qu√© funcionar√° mejor, por lo que en las primeras etapas de su an√°lisis lo alentamos a que pruebe ambos y elija el que funcione mejor para usted.\n(Muchas gracias a Danielle Navarro que contribuy√≥ con la versi√≥n inicial de este cap√≠tulo.)",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>22</span>¬† <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#introducci√≥n",
    "href": "arrow.html#introducci√≥n",
    "title": "22¬† Arrow",
    "section": "",
    "text": "22.1.1 Requisitos previos\nEn este cap√≠tulo, continuaremos usando tidyverse, particularmente dplyr, pero lo emparejaremos con el paquete arrow, que est√° dise√±ado espec√≠ficamente para trabajar con grandes datos.\n\nlibrary(tidyverse)\nlibrary(arrow)\n\nM√°s adelante en el cap√≠tulo, tambi√©n veremos algunas conexiones entre arrow y duckdb, por lo que tambi√©n necesitaremos dbplyr y duckdb.\n\nlibrary(dbplyr, warn.conflicts = FALSE)\nlibrary(duckdb)\n#&gt; Loading required package: DBI",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>22</span>¬† <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#obtener-los-datos",
    "href": "arrow.html#obtener-los-datos",
    "title": "22¬† Arrow",
    "section": "\n22.2 Obtener los datos",
    "text": "22.2 Obtener los datos\nComenzamos obteniendo un conjunto de datos digno de estas herramientas: un conjunto de datos de pr√©stamo de art√≠culos de las bibliotecas p√∫blicas de Seattle, disponible en l√≠nea en data.seattle.gov/Community/Checkouts-by-Title/tmmm-ytt6. Este conjunto de datos contiene 41 389 465 filas que le indican cu√°ntas veces cada libro fue prestado cada mes desde abril de 2005 hasta octubre de 2022.\nEl siguiente c√≥digo le dar√° una copia en cach√© de los datos. Los datos son un archivo CSV de 9 GB, por lo que llevar√° alg√∫n tiempo descargarlos. Recomiendo encarecidamente usar curl::multidownload() para obtener archivos muy grandes, ya que est√° dise√±ado exactamente para este prop√≥sito: le brinda una barra de progreso y puede reanudar la descarga si se interrumpe.\n\ndir.create(\"data\", showWarnings = FALSE)\n\ncurl::multi_download(\n  \"https://r4ds.s3.us-west-2.amazonaws.com/seattle-library-checkouts.csv\",\n  \"data/seattle-library-checkouts.csv\",\n  resume = TRUE\n)\n#&gt; # A tibble: 1 √ó 10\n#&gt;   success status_code resumefrom url                    destfile        error\n#&gt;   &lt;lgl&gt;         &lt;int&gt;      &lt;dbl&gt; &lt;chr&gt;                  &lt;chr&gt;           &lt;chr&gt;\n#&gt; 1 TRUE            200          0 https://r4ds.s3.us-we‚Ä¶ data/seattle-l‚Ä¶ &lt;NA&gt; \n#&gt; # ‚Ñπ 4 more variables: type &lt;chr&gt;, modified &lt;dttm&gt;, time &lt;dbl&gt;,\n#&gt; #   headers &lt;list&gt;",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>22</span>¬† <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#abrir-un-conjunto-de-datos",
    "href": "arrow.html#abrir-un-conjunto-de-datos",
    "title": "22¬† Arrow",
    "section": "\n22.3 Abrir un conjunto de datos",
    "text": "22.3 Abrir un conjunto de datos\nComencemos echando un vistazo a los datos. Con 9 GB, este archivo es lo suficientemente grande como para que probablemente no queramos cargarlo todo en la memoria. Una buena regla general es que, por lo general, desea al menos el doble de memoria que el tama√±o de los datos, y muchas computadoras port√°tiles no superan los 16 Gb. Esto significa que queremos evitar read_csv() y en su lugar usar arrow::open_dataset():\n\nseattle_csv &lt;- open_dataset(\n  sources = \"data/seattle-library-checkouts.csv\", \n  col_types = schema(ISBN = string()),\n  format = \"csv\"\n)\n\n¬øQu√© sucede cuando se ejecuta este c√≥digo? open_dataset() escanear√° unas pocas miles de filas para descubrir la estructura del conjunto de datos. La columna ISBN contiene valores en blanco para las primeras 80 000 filas, por lo que debemos especificar el tipo de columna para ayudar a arrow a calcular la estructura de datos. Una vez que los datos han sido escaneados por open_dataset(), registra lo que se encuentra y se detiene; solo leer√° filas adicionales a medida que las solicite espec√≠ficamente. Estos metadatos son los que vemos si imprimimos seattle_csv:\n\nseattle_csv\n#&gt; FileSystemDataset with 1 csv file\n#&gt; UsageClass: string\n#&gt; CheckoutType: string\n#&gt; MaterialType: string\n#&gt; CheckoutYear: int64\n#&gt; CheckoutMonth: int64\n#&gt; Checkouts: int64\n#&gt; Title: string\n#&gt; ISBN: string\n#&gt; Creator: string\n#&gt; Subjects: string\n#&gt; Publisher: string\n#&gt; PublicationYear: string\n\nLa primera l√≠nea de la salida le dice que seattle_csv se almacena localmente en el disco como un √∫nico archivo CSV; solo se cargar√° en la memoria seg√∫n sea necesario. El resto de la salida le indica el tipo de columna que arrow ha imputado para cada columna.\nPodemos ver qu√© hay realmente con glimpse(). Esto revela que hay ~41 millones de filas y 12 columnas, y nos muestra algunos valores.\n\nseattle_csv |&gt; glimpse()\n#&gt; FileSystemDataset with 1 csv file\n#&gt; 41,389,465 rows x 12 columns\n#&gt; $ UsageClass      &lt;string&gt; \"Physical\", \"Physical\", \"Digital\", \"Physical\", \"Ph‚Ä¶\n#&gt; $ CheckoutType    &lt;string&gt; \"Horizon\", \"Horizon\", \"OverDrive\", \"Horizon\", \"Hor‚Ä¶\n#&gt; $ MaterialType    &lt;string&gt; \"BOOK\", \"BOOK\", \"EBOOK\", \"BOOK\", \"SOUNDDISC\", \"BOO‚Ä¶\n#&gt; $ CheckoutYear     &lt;int64&gt; 2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016, 20‚Ä¶\n#&gt; $ CheckoutMonth    &lt;int64&gt; 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,‚Ä¶\n#&gt; $ Checkouts        &lt;int64&gt; 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 2, 3, 2, 1, 3, 2,‚Ä¶\n#&gt; $ Title           &lt;string&gt; \"Super rich : a guide to having it all / Russell S‚Ä¶\n#&gt; $ ISBN            &lt;string&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"‚Ä¶\n#&gt; $ Creator         &lt;string&gt; \"Simmons, Russell\", \"Barclay, James, 1965-\", \"Tim ‚Ä¶\n#&gt; $ Subjects        &lt;string&gt; \"Self realization, Conduct of life, Attitude Psych‚Ä¶\n#&gt; $ Publisher       &lt;string&gt; \"Gotham Books,\", \"Pyr,\", \"Random House, Inc.\", \"Di‚Ä¶\n#&gt; $ PublicationYear &lt;string&gt; \"c2011.\", \"2010.\", \"2015\", \"2005.\", \"c2004.\", \"c20‚Ä¶\n\nPodemos comenzar a usar este conjunto de datos con verbos dplyr, usando collect() para forzar a arrow a realizar el c√°lculo y devolver algunos datos. Por ejemplo, este c√≥digo nos dice el n√∫mero total de pagos por a√±o:\n\nseattle_csv |&gt; \n  group_by(CheckoutYear) |&gt; \n  summarise(Checkouts = sum(Checkouts)) |&gt; \n  arrange(CheckoutYear) |&gt; \n  collect()\n#&gt; # A tibble: 18 √ó 2\n#&gt;   CheckoutYear Checkouts\n#&gt;          &lt;int&gt;     &lt;int&gt;\n#&gt; 1         2005   3798685\n#&gt; 2         2006   6599318\n#&gt; 3         2007   7126627\n#&gt; 4         2008   8438486\n#&gt; 5         2009   9135167\n#&gt; 6         2010   8608966\n#&gt; # ‚Ñπ 12 more rows\n\nGracias a arrow, este c√≥digo funcionar√° independientemente del tama√±o del conjunto de datos subyacente. Pero actualmente es bastante lento: en la computadora de Hadley, tard√≥ ~ 10 segundos en ejecutarse. Eso no es terrible dada la cantidad de datos que tenemos, pero podemos hacerlo mucho m√°s r√°pido si cambiamos a un mejor formato.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>22</span>¬† <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#sec-parquet",
    "href": "arrow.html#sec-parquet",
    "title": "22¬† Arrow",
    "section": "\n22.4 El formato parquet",
    "text": "22.4 El formato parquet\nPara facilitar el trabajo con estos datos, cambiemos al formato de archivo parquet y divid√°moslo en varios archivos. Las siguientes secciones le presentar√°n primero el parquet y las particiones, y luego aplicar√°n lo que aprendimos a los datos de la biblioteca de Seattle.\n\n22.4.1 Ventajas del parquet\nAl igual que CSV, el parquet se usa para datos rectangulares, pero en lugar de ser un formato de texto que puede leer con cualquier editor de archivos, es un formato binario personalizado dise√±ado espec√≠ficamente para las necesidades de big data. Esto significa que:\n\nLos archivos de parquet suelen ser m√°s peque√±os que el archivo CSV equivalente. Parquet se basa en codificaciones eficientes para reducir el tama√±o del archivo y admite la compresi√≥n de archivos. Esto ayuda a que los archivos de parquet sean m√°s r√°pidos porque hay menos datos para mover del disco a la memoria.\nLos archivos de parquet tienen un sistema de tipo rico. Como comentamos en Secci√≥n 7.3, un archivo CSV no proporciona ninguna informaci√≥n sobre los tipos de columna. Por ejemplo, un lector de CSV tiene que adivinar si \"08-10-2022\" debe analizarse como una cadena o una fecha. Por el contrario, los archivos de parquet almacenan datos de una manera que registra el tipo junto con los datos.\nLos archivos de parquet est√°n ‚Äúorientados a columnas‚Äù. Esto significa que est√°n organizados columna por columna, como el marco de datos de R. Esto generalmente conduce a un mejor rendimiento para las tareas de an√°lisis de datos en comparaci√≥n con los archivos CSV, que se organizan fila por fila.\nLos archivos de parquet est√°n ‚Äúfragmentados‚Äù, lo que hace posible trabajar en diferentes partes del archivo al mismo tiempo y, si tiene suerte, saltarse algunos fragmentos por completo.\n\nHay una desventaja principal en los archivos de parquet: ya no son ‚Äúlegibles por humanos‚Äù, es decir, si miras un archivo de parquet usando readr::read_file(), solo ver√°s un mont√≥n de galimat√≠as.\n\n22.4.2 Fraccionamiento\nA medida que los conjuntos de datos se hacen cada vez m√°s grandes, almacenar todos los datos en un solo archivo se vuelve cada vez m√°s complicado y, a menudo, es √∫til dividir grandes conjuntos de datos en varios archivos. Cuando esta estructuraci√≥n se realiza de manera inteligente, esta estrategia puede conducir a mejoras significativas en el rendimiento porque muchos an√°lisis solo requerir√°n un subconjunto de los archivos.\nNo existen reglas estrictas sobre c√≥mo particionar su conjunto de datos: los resultados depender√°n de sus datos, patrones de acceso y los sistemas que leen los datos. Es probable que necesite experimentar un poco antes de encontrar la partici√≥n ideal para su situaci√≥n. Como gu√≠a aproximada, arrow sugiere que evite los archivos de menos de 20 MB y m√°s de 2 GB y evite las particiones que producen m√°s de 10,000 archivos. Tambi√©n debe intentar particionar por variables por las que filtra; como ver√° en breve, eso permite que arrow se salte una gran cantidad de trabajo al leer solo los archivos relevantes.\n\n22.4.3 Reescribiendo los datos de la biblioteca de Seattle\nApliquemos estas ideas a los datos de la biblioteca de Seattle para ver c√≥mo se desarrollan en la pr√°ctica. Vamos a particionar por CheckoutYear, ya que es probable que algunos an√°lisis solo quieran ver datos recientes y la partici√≥n por a√±o produce 18 fragmentos de un tama√±o razonable.\nPara reescribir los datos definimos la partici√≥n usando dplyr::group_by() y luego guardamos las particiones en un directorio con arrow::write_dataset(). write_dataset() tiene dos argumentos importantes: un directorio donde crearemos los archivos y el formato que usaremos.\n\npq_path &lt;- \"data/seattle-library-checkouts\"\n\n\nseattle_csv |&gt;\n  group_by(CheckoutYear) |&gt;\n  write_dataset(path = pq_path, format = \"parquet\")\n\nEsto tarda aproximadamente un minuto en ejecutarse; como veremos en breve, esta es una inversi√≥n inicial que vale la pena al hacer que las operaciones futuras sean mucho m√°s r√°pidas.\nEchemos un vistazo a lo que acabamos de producir:\n\ntibble(\n  files = list.files(pq_path, recursive = TRUE),\n  size_MB = file.size(file.path(pq_path, files)) / 1024^2\n)\n#&gt; # A tibble: 18 √ó 2\n#&gt;   files                            size_MB\n#&gt;   &lt;chr&gt;                              &lt;dbl&gt;\n#&gt; 1 CheckoutYear=2005/part-0.parquet    109.\n#&gt; 2 CheckoutYear=2006/part-0.parquet    164.\n#&gt; 3 CheckoutYear=2007/part-0.parquet    178.\n#&gt; 4 CheckoutYear=2008/part-0.parquet    195.\n#&gt; 5 CheckoutYear=2009/part-0.parquet    214.\n#&gt; 6 CheckoutYear=2010/part-0.parquet    222.\n#&gt; # ‚Ñπ 12 more rows\n\nNuestro √∫nico archivo CSV de 9 GB se ha reescrito en 18 archivos de parquet. Los nombres de archivo utilizan una convenci√≥n de ‚Äúautodescripci√≥n‚Äù utilizada por el proyecto Apache Hive. Las particiones de estilo Hive nombran carpetas con una convenci√≥n ‚Äúclave=valor‚Äù, por lo que, como puede suponer, el directorio CheckoutYear=2005 contiene todos los datos donde CheckoutYear es 2005. Cada archivo tiene entre 100 y 300 MB y el tama√±o total ahora es de alrededor de 4 GB, un poco m√°s de la mitad del tama√±o del archivo CSV original. Esto es lo que esperamos ya que el parquet es un formato mucho m√°s eficiente.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>22</span>¬† <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#usando-dplyr-con-arrow",
    "href": "arrow.html#usando-dplyr-con-arrow",
    "title": "22¬† Arrow",
    "section": "\n22.5 Usando dplyr con arrow",
    "text": "22.5 Usando dplyr con arrow\nAhora que hemos creado estos archivos de parquet, necesitaremos volver a leerlos. Usamos open_dataset() nuevamente, pero esta vez le damos un directorio:\n\nseattle_pq &lt;- open_dataset(pq_path)\n\nAhora podemos escribir nuestra canalizaci√≥n dplyr. Por ejemplo, podr√≠amos contar el n√∫mero total de libros prestados cada mes durante los √∫ltimos cinco a√±os:\n\nquery &lt;- seattle_pq |&gt; \n  filter(CheckoutYear &gt;= 2018, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutYear, CheckoutMonth) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(CheckoutYear, CheckoutMonth)\n\nEscribir c√≥digo dplyr para datos de arrow es conceptualmente similar a dbplyr, Cap√≠tulo 21: usted escribe c√≥digo dplyr, que se transforma autom√°ticamente en una consulta que entiende la biblioteca Apache Arrow C++, que luego se ejecuta cuando llama a collect(). Si imprimimos el objeto query, podemos ver un poco de informaci√≥n sobre lo que esperamos que devuelva Arrow cuando tenga lugar la ejecuci√≥n:\n\nquery\n#&gt; FileSystemDataset (query)\n#&gt; CheckoutYear: int32\n#&gt; CheckoutMonth: int64\n#&gt; TotalCheckouts: int64\n#&gt; \n#&gt; * Grouped by CheckoutYear\n#&gt; * Sorted by CheckoutYear [asc], CheckoutMonth [asc]\n#&gt; See $.data for the source Arrow object\n\nY podemos obtener los resultados llamando collect():\n\nquery |&gt; collect()\n#&gt; # A tibble: 58 √ó 3\n#&gt; # Groups:   CheckoutYear [5]\n#&gt;   CheckoutYear CheckoutMonth TotalCheckouts\n#&gt;          &lt;int&gt;         &lt;int&gt;          &lt;int&gt;\n#&gt; 1         2018             1         355101\n#&gt; 2         2018             2         309813\n#&gt; 3         2018             3         344487\n#&gt; 4         2018             4         330988\n#&gt; 5         2018             5         318049\n#&gt; 6         2018             6         341825\n#&gt; # ‚Ñπ 52 more rows\n\nAl igual que dbplyr, arrow solo comprende algunas expresiones R, por lo que es posible que no pueda escribir exactamente el mismo c√≥digo que normalmente har√≠a. Sin embargo, la lista de operaciones y funciones admitidas es bastante extensa y sigue creciendo; encuentra una lista completa de las funciones soportadas actualmente en ?acero.\n\n22.5.1 Rendimiento\nEchemos un vistazo r√°pido al impacto en el rendimiento de cambiar de CSV a parquet. Primero, cronometremos cu√°nto tiempo lleva calcular la cantidad de libros prestados en cada mes de 2021, cuando los datos se almacenan como un solo archivo csv grande:\n\nseattle_csv |&gt; \n  filter(CheckoutYear == 2021, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutMonth) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(desc(CheckoutMonth)) |&gt;\n  collect() |&gt; \n  system.time()\n#&gt;    user  system elapsed \n#&gt;  17.578   3.017  17.020\n\nAhora usemos nuestra nueva versi√≥n del conjunto de datos en el que los datos de pr√©stamo de la biblioteca de Seattle se han dividido en 18 archivos de parquet m√°s peque√±os:\n\nseattle_pq |&gt; \n  filter(CheckoutYear == 2021, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutMonth) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(desc(CheckoutMonth)) |&gt;\n  collect() |&gt; \n  system.time()\n#&gt;    user  system elapsed \n#&gt;   0.280   0.044   0.114\n\nLa aceleraci√≥n de ~100x en el rendimiento se atribuye a dos factores: la partici√≥n de varios archivos y el formato de los archivos individuales:\n\nLa partici√≥n mejora el rendimiento porque esta consulta usa CheckoutYear == 2021 para filtrar los datos, y arrow es lo suficientemente inteligente como para reconocer que solo necesita leer 1 de los 18 archivos de parquet.\nEl formato parquet mejora el rendimiento al almacenar datos en un formato binario que se puede leer m√°s directamente en la memoria. El formato por columnas y los metadatos enriquecidos significan que arrow solo necesita leer las cuatro columnas realmente utilizadas en la consulta (CheckoutYear, MaterialType, CheckoutMonth y Checkouts).\n\n¬°Esta gran diferencia en el rendimiento es la raz√≥n por la que vale la pena convertir grandes CSV en parquet!\n\n22.5.2 Usando duckdb con arrow\nHay una √∫ltima ventaja de parquet y arrow: es muy f√°cil convertir un conjunto de datos de arrow en una base de datos DuckDB (Cap√≠tulo 21) llamando a arrow::to_duckdb():\n\nseattle_pq |&gt; \n  to_duckdb() |&gt;\n  filter(CheckoutYear &gt;= 2018, MaterialType == \"BOOK\") |&gt;\n  group_by(CheckoutYear) |&gt;\n  summarize(TotalCheckouts = sum(Checkouts)) |&gt;\n  arrange(desc(CheckoutYear)) |&gt;\n  collect()\n#&gt; Warning: Missing values are always removed in SQL aggregation functions.\n#&gt; Use `na.rm = TRUE` to silence this warning\n#&gt; This warning is displayed once every 8 hours.\n#&gt; # A tibble: 5 √ó 2\n#&gt;   CheckoutYear TotalCheckouts\n#&gt;          &lt;int&gt;          &lt;dbl&gt;\n#&gt; 1         2022        2431502\n#&gt; 2         2021        2266438\n#&gt; 3         2020        1241999\n#&gt; 4         2019        3931688\n#&gt; 5         2018        3987569\n\nLo bueno de to_duckdb() es que la transferencia no implica ninguna copia de memoria y habla de los objetivos del ecosistema de arrow: permitir transiciones sin problemas de un entorno inform√°tico a otro.\n\n22.5.3 Exercises\n\nAverigua cu√°l es el libro m√°s popular de cada a√±o.\n¬øQu√© autor tiene la mayor cantidad de libros en el sistema de bibliotecas de Seattle?\n¬øC√≥mo ha cambiado el pago de libros frente a los libros electr√≥nicos en los √∫ltimos 10 a√±os?",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>22</span>¬† <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "arrow.html#resumen",
    "href": "arrow.html#resumen",
    "title": "22¬† Arrow",
    "section": "\n22.6 Resumen",
    "text": "22.6 Resumen\nEn este cap√≠tulo, se le ha dado una idea del paquete arrow, que proporciona un backend dplyr para trabajar con grandes conjuntos de datos en disco. Puede funcionar con archivos CSV, y es mucho m√°s r√°pido si convierte sus datos a parquet. Parquet es un formato de datos binarios que est√° dise√±ado espec√≠ficamente para el an√°lisis de datos en computadoras modernas. Muchas menos herramientas pueden trabajar con archivos de parquet en comparaci√≥n con CSV, pero su estructura dividida, comprimida y en columnas hace que sea mucho m√°s eficiente de analizar.\nA continuaci√≥n, aprender√° sobre su primera fuente de datos no rectangular, que manejar√° con las herramientas proporcionadas por el paquete tidyr. Nos centraremos en los datos que provienen de archivos JSON, pero los principios generales se aplican a los datos en forma de √°rbol, independientemente de su origen.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>22</span>¬† <span class='chapter-title'>Arrow</span>"
    ]
  },
  {
    "objectID": "rectangling.html",
    "href": "rectangling.html",
    "title": "23¬† Datos jer√°rquicos",
    "section": "",
    "text": "23.1 Introducci√≥n\nEn este cap√≠tulo, aprender√° el arte de rectangular datos: tomando datos que son fundamentalmente jer√°rquicos, o en forma de √°rbol, y convirti√©ndolos en un marco de datos rectangular formado por filas y columnas. Esto es importante porque los datos jer√°rquicos son sorprendentemente comunes, especialmente cuando se trabaja con datos que provienen de la web.\nPara obtener informaci√≥n sobre el rect√°ngulo, primero deber√° aprender sobre las listas, la estructura de datos que hace posible los datos jer√°rquicos. Luego aprender√° sobre dos funciones cruciales de tidyr: tidyr::unnest_longer() y tidyr::unnest_wider(). Luego le mostraremos algunos casos de estudio, aplicando estas funciones simples una y otra vez para resolver problemas reales. Terminaremos hablando de JSON, la fuente m√°s frecuente de conjuntos de datos jer√°rquicos y un formato com√∫n para el intercambio de datos en la web.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>23</span>¬† <span class='chapter-title'>Datos jer√°rquicos</span>"
    ]
  },
  {
    "objectID": "rectangling.html#introducci√≥n",
    "href": "rectangling.html#introducci√≥n",
    "title": "23¬† Datos jer√°rquicos",
    "section": "",
    "text": "23.1.1 Requisitos previos\nEn este cap√≠tulo, usaremos muchas funciones de tidyr, un miembro central de tidyverse. Tambi√©n usaremos repurrrsive para proporcionar algunos conjuntos de datos interesantes para la pr√°ctica de rect√°ngulos, y terminaremos usando jsonlite para leer archivos JSON en listas R.\n\nlibrary(tidyverse)\nlibrary(repurrrsive)\nlibrary(jsonlite)",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>23</span>¬† <span class='chapter-title'>Datos jer√°rquicos</span>"
    ]
  },
  {
    "objectID": "rectangling.html#listas",
    "href": "rectangling.html#listas",
    "title": "23¬† Datos jer√°rquicos",
    "section": "\n23.2 Listas",
    "text": "23.2 Listas\nHasta ahora, ha trabajado con marcos de datos que contienen vectores simples como enteros, n√∫meros, caracteres, fechas y horas y factores. Estos vectores son simples porque son homog√©neos: cada elemento es del mismo tipo de datos. Si quieres almacenar elementos de diferentes tipos en el mismo vector, necesitar√°s una lista, que creas con list():\n\nx1 &lt;- list(1:4, \"a\", TRUE)\nx1\n#&gt; [[1]]\n#&gt; [1] 1 2 3 4\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"a\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] TRUE\n\nA menudo es conveniente nombrar los componentes, o hijos, de una lista, lo que puede hacer de la misma manera que se nombran las columnas de un tibble:\n\nx2 &lt;- list(a = 1:2, b = 1:3, c = 1:4)\nx2\n#&gt; $a\n#&gt; [1] 1 2\n#&gt; \n#&gt; $b\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $c\n#&gt; [1] 1 2 3 4\n\nIncluso para estas listas tan simples, la impresi√≥n ocupa bastante espacio. Una alternativa √∫til es str(), que genera una visualizaci√≥n compacta de la estructura, restando √©nfasis al contenido:\n\nstr(x1)\n#&gt; List of 3\n#&gt;  $ : int [1:4] 1 2 3 4\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi TRUE\nstr(x2)\n#&gt; List of 3\n#&gt;  $ a: int [1:2] 1 2\n#&gt;  $ b: int [1:3] 1 2 3\n#&gt;  $ c: int [1:4] 1 2 3 4\n\nComo puede ver, str() muestra cada hijo de la lista en su propia l√≠nea. Muestra el nombre, si est√° presente, luego una abreviatura del tipo, luego los primeros valores.\n\n23.2.1 Jerarqu√≠a\nLas listas pueden contener cualquier tipo de objeto, incluidas otras listas. Esto los hace adecuados para representar estructuras jer√°rquicas (en forma de √°rbol):\n\nx3 &lt;- list(list(1, 2), list(3, 4))\nstr(x3)\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 3\n#&gt;   ..$ : num 4\n\nEsto es notablemente diferente a c(), que genera un vector plano:\n\nc(c(1, 2), c(3, 4))\n#&gt; [1] 1 2 3 4\n\nx4 &lt;- c(list(1, 2), list(3, 4))\nstr(x4)\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\nA medida que las listas se vuelven m√°s complejas, str() se vuelve m√°s √∫til, ya que le permite ver la jerarqu√≠a de un vistazo:\n\nx5 &lt;- list(1, list(2, list(3, list(4, list(5)))))\nstr(x5)\n#&gt; List of 2\n#&gt;  $ : num 1\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 2\n#&gt;   ..$ :List of 2\n#&gt;   .. ..$ : num 3\n#&gt;   .. ..$ :List of 2\n#&gt;   .. .. ..$ : num 4\n#&gt;   .. .. ..$ :List of 1\n#&gt;   .. .. .. ..$ : num 5\n\nA medida que las listas se vuelven a√∫n m√°s grandes y complejas, str() eventualmente comienza a fallar, y deber√° cambiar a View()1. Figura¬†23.1 muestra el resultado de llamar a View(x5). El visor comienza mostrando solo el nivel superior de la lista, pero puede expandir interactivamente cualquiera de los componentes para ver m√°s, como en Figura¬†23.2. RStudio tambi√©n le mostrar√° el c√≥digo que necesita para acceder a ese elemento, como en Figura¬†23.3. Volveremos sobre c√≥mo funciona este c√≥digo en Secci√≥n 27.3.\n\n\n\n\n\n\n\nFigura¬†23.1: La vista de RStudio le permite explorar de forma interactiva una lista compleja. El visor se abre mostrando solo el nivel superior de la lista.\n\n\n\n\n\n\n\n\n\n\n\nFigura¬†23.2: Al hacer clic en el tri√°ngulo que mira hacia la derecha, se expande ese componente de la lista para que tambi√©n puedas ver sus hijos.\n\n\n\n\n\n\n\n\n\n\n\nFigura¬†23.3: Puede repetir esta operaci√≥n tantas veces como sea necesario para llegar a los datos que le interesan. Tenga en cuenta la esquina inferior izquierda: si hace clic en un elemento de la lista, RStudio le dar√° el c√≥digo de subconjunto necesario para acceder a √©l, en este caso x4[[2]][[2]][[2]].\n\n\n\n\n\n23.2.2 Lista-columnas\nLas listas tambi√©n pueden vivir dentro de un tibble, donde las llamamos columnas de lista. Las columnas de lista son √∫tiles porque le permiten colocar objetos en un tibble que normalmente no pertenecer√≠an all√≠. En particular, las columnas de lista se usan mucho en el ecosistema tidymodels, porque le permiten almacenar cosas como resultados de modelos o remuestreos en un marco de datos.\nAqu√≠ hay un ejemplo simple de una columna de lista:\n\ndf &lt;- tibble(\n  x = 1:2, \n  y = c(\"a\", \"b\"),\n  z = list(list(1, 2), list(3, 4, 5))\n)\ndf\n#&gt; # A tibble: 2 √ó 3\n#&gt;       x y     z         \n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;list&gt;    \n#&gt; 1     1 a     &lt;list [2]&gt;\n#&gt; 2     2 b     &lt;list [3]&gt;\n\nNo hay nada especial acerca de las listas en un tibble; se comportan como cualquier otra columna:\n\ndf |&gt; \n  filter(x == 1)\n#&gt; # A tibble: 1 √ó 3\n#&gt;       x y     z         \n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;list&gt;    \n#&gt; 1     1 a     &lt;list [2]&gt;\n\nComputar con columnas de lista es m√°s dif√≠cil, pero eso se debe a que computar con listas es m√°s dif√≠cil en general; volveremos a eso en Cap√≠tulo 26. En este cap√≠tulo, nos centraremos en convertir columnas de lista en variables regulares para que pueda usar sus herramientas existentes en ellas.\nEl m√©todo de impresi√≥n predeterminado solo muestra un resumen aproximado del contenido. La columna de la lista podr√≠a ser arbitrariamente compleja, por lo que no hay una buena manera de imprimirla. Si desea verlo, deber√° extraer solo una columna de la lista y aplicar una de las t√©cnicas que aprendi√≥ anteriormente, como df |&gt; pull(z) |&gt; str() o df |&gt; pull(z) |&gt; Ver().\n\n\n\n\n\n\nR base\n\n\n\nEs posible poner una lista en una columna de un data.frame, pero es mucho m√°s complicado porque data.frame() trata una lista como una lista de columnas:\n\ndata.frame(x = list(1:3, 3:5))\n#&gt;   x.1.3 x.3.5\n#&gt; 1     1     3\n#&gt; 2     2     4\n#&gt; 3     3     5\n\nPuede obligar a data.frame() a tratar una lista como una lista de filas envolvi√©ndola en la lista I(), pero el resultado no se imprime particularmente bien:\n\ndata.frame(\n  x = I(list(1:2, 3:5)), \n  y = c(\"1, 2\", \"3, 4, 5\")\n)\n#&gt;         x       y\n#&gt; 1    1, 2    1, 2\n#&gt; 2 3, 4, 5 3, 4, 5\n\nEs m√°s f√°cil usar columnas de lista con tibbles porque tibble() trata las listas como vectores y el m√©todo de impresi√≥n ha sido dise√±ado teniendo en cuenta las listas.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>23</span>¬† <span class='chapter-title'>Datos jer√°rquicos</span>"
    ]
  },
  {
    "objectID": "rectangling.html#anidando",
    "href": "rectangling.html#anidando",
    "title": "23¬† Datos jer√°rquicos",
    "section": "\n23.3 Anidando",
    "text": "23.3 Anidando\nAhora que ha aprendido los conceptos b√°sicos de las listas y las columnas de lista, exploremos c√≥mo puede volver a convertirlas en filas y columnas regulares. Aqu√≠ usaremos datos de muestra muy simples para que puedas tener una idea b√°sica; en la siguiente secci√≥n cambiaremos a datos reales.\nLas columnas de lista tienden a presentarse en dos formas b√°sicas: con nombre y sin nombre. Cuando los ni√±os tienen nombre, tienden a tener los mismos nombres en todas las filas. Por ejemplo, en df1, cada elemento de la columna de lista y tiene dos elementos llamados a y b. Las columnas de lista con nombre se separan naturalmente en columnas: cada elemento con nombre se convierte en una nueva columna con nombre.\n\ndf1 &lt;- tribble(\n  ~x, ~y,\n  1, list(a = 11, b = 12),\n  2, list(a = 21, b = 22),\n  3, list(a = 31, b = 32),\n)\n\nCuando los elementos secundarios no tienen nombre, la cantidad de elementos tiende a variar de una fila a otra. Por ejemplo, en df2, los elementos de la columna de lista y no tienen nombre y var√≠an en longitud de uno a tres. Las columnas de lista sin nombre se anulan naturalmente en filas: obtendr√° una fila para cada ni√±o.\n\n\ndf2 &lt;- tribble(\n  ~x, ~y,\n  1, list(11, 12, 13),\n  2, list(21),\n  3, list(31, 32),\n)\n\ntidyr proporciona dos funciones para estos dos casos: unnest_wider() y unnest_longer(). Las siguientes secciones explican c√≥mo funcionan.\n\n23.3.1 unnest_wider()\n\nCuando cada fila tiene la misma cantidad de elementos con los mismos nombres, como df1, es natural poner cada componente en su propia columna con unnest_wider():\n\ndf1 |&gt; \n  unnest_wider(y)\n#&gt; # A tibble: 3 √ó 3\n#&gt;       x     a     b\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    11    12\n#&gt; 2     2    21    22\n#&gt; 3     3    31    32\n\nPor defecto, los nombres de las nuevas columnas provienen exclusivamente de los nombres de los elementos de la lista, pero puedes usar el argumento names_sep para solicitar que combinen el nombre de la columna y el nombre del elemento. Esto es √∫til para eliminar la ambig√ºedad de los nombres repetidos.\n\ndf1 |&gt; \n  unnest_wider(y, names_sep = \"_\")\n#&gt; # A tibble: 3 √ó 3\n#&gt;       x   y_a   y_b\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    11    12\n#&gt; 2     2    21    22\n#&gt; 3     3    31    32\n\n\n23.3.2 unnest_longer()\n\nCuando cada fila contiene una lista sin nombre, lo m√°s natural es poner cada elemento en su propia fila con unnest_longer():\n\ndf2 |&gt; \n  unnest_longer(y)\n#&gt; # A tibble: 6 √ó 2\n#&gt;       x     y\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    11\n#&gt; 2     1    12\n#&gt; 3     1    13\n#&gt; 4     2    21\n#&gt; 5     3    31\n#&gt; 6     3    32\n\nObserve c√≥mo x se duplica para cada elemento dentro de y: obtenemos una fila de salida para cada elemento dentro de la columna de lista. Pero, ¬øqu√© sucede si uno de los elementos est√° vac√≠o, como en el siguiente ejemplo?\n\ndf6 &lt;- tribble(\n  ~x, ~y,\n  \"a\", list(1, 2),\n  \"b\", list(3),\n  \"c\", list()\n)\ndf6 |&gt; unnest_longer(y)\n#&gt; # A tibble: 3 √ó 2\n#&gt;   x         y\n#&gt;   &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 a         1\n#&gt; 2 a         2\n#&gt; 3 b         3\n\nObtenemos cero filas en la salida, por lo que la fila desaparece efectivamente. Si desea conservar esa fila, agrega NA en y, configure keep_empty = TRUE.\n\n23.3.3 Tipos inconsistentes\n¬øQu√© sucede si anulas una columna de lista que contiene diferentes tipos de vectores? Por ejemplo, tome el siguiente conjunto de datos donde la columna de lista y contiene dos n√∫meros, un caracter y un l√≥gico, que normalmente no se pueden mezclar en una sola columna.\n\ndf4 &lt;- tribble(\n  ~x, ~y,\n  \"a\", list(1),\n  \"b\", list(\"a\", TRUE, 5)\n)\n\nunnest_longer() siempre mantiene el conjunto de columnas sin cambios, mientras cambia el n√∫mero de filas. ¬øQu√© es lo que ocurre? ¬øC√≥mo unnest_longer() produce cinco filas mientras mantiene todo en y?\n\ndf4 |&gt; \n  unnest_longer(y)\n#&gt; # A tibble: 4 √ó 2\n#&gt;   x     y        \n#&gt;   &lt;chr&gt; &lt;list&gt;   \n#&gt; 1 a     &lt;dbl [1]&gt;\n#&gt; 2 b     &lt;chr [1]&gt;\n#&gt; 3 b     &lt;lgl [1]&gt;\n#&gt; 4 b     &lt;dbl [1]&gt;\n\nComo puede ver, la salida contiene una columna de lista, pero cada elemento de la columna de lista contiene un solo elemento. Debido a que unnest_longer() no puede encontrar un tipo com√∫n de vector, mantiene los tipos originales en una columna de lista. Quiz√°s se pregunte si esto rompe el mandamiento de que todos los elementos de una columna deben ser del mismo tipo. No lo hace: cada elemento es una lista, aunque los contenidos sean de diferentes tipos.\nTratar con tipos inconsistentes es un desaf√≠o y los detalles dependen de la naturaleza precisa del problema y sus objetivos, pero lo m√°s probable es que necesite herramientas de Cap√≠tulo 26.\n\n23.3.4 Otras funciones\ntidyr tiene algunas otras funciones √∫tiles de rect√°ngulos que no vamos a cubrir en este libro:\n\n\nunnest_auto() elige autom√°ticamente entre unnest_longer() y unnest_wider() seg√∫n la estructura de la columna de la lista. Es excelente para una exploraci√≥n r√°pida, pero en √∫ltima instancia es una mala idea porque no lo obliga a comprender c√≥mo est√°n estructurados sus datos y hace que su c√≥digo sea m√°s dif√≠cil de entender.\n\nunnest() expande filas y columnas. Es √∫til cuando tiene una columna de lista que contiene una estructura 2d como un marco de datos, que no ve en este libro, pero que puede encontrar si usa el ecosistema tidymodels.\n\nEs bueno conocer estas funciones, ya que puede encontrarlas al leer el c√≥digo de otras personas o al abordar desaf√≠os de rect√°ngulos m√°s raros.\n\n23.3.5 Ejercicios\n\n¬øQu√© sucede cuando usa unnest_wider() con columnas de lista sin nombre como df2? ¬øQu√© argumento es ahora necesario? ¬øQu√© sucede con los valores perdidos?\n¬øQu√© sucede cuando usa unnest_longer() con columnas de lista con nombre como df1? ¬øQu√© informaci√≥n adicional obtienes en la salida? ¬øC√≥mo puedes suprimir ese detalle extra?\n\nDe vez en cuando se encuentra con marcos de datos con varias columnas de lista con valores alineados. Por ejemplo, en el siguiente marco de datos, los valores de y y z est√°n alineados (es decir, y y z siempre tendr√°n la misma longitud dentro de una fila, y el primer valor de y corresponde a el primer valor de z). ¬øQu√© sucede si aplica dos llamadas unnest_longer() a este marco de datos? ¬øC√≥mo puedes preservar la relaci√≥n entre x e y? (Sugerencia: lea atentamente la documentaci√≥n).\n\ndf4 &lt;- tribble(\n  ~x, ~y, ~z,\n  \"a\", list(\"y-a-1\", \"y-a-2\"), list(\"z-a-1\", \"z-a-2\"),\n  \"b\", list(\"y-b-1\", \"y-b-2\", \"y-b-3\"), list(\"z-b-1\", \"z-b-2\", \"z-b-3\")\n)",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>23</span>¬† <span class='chapter-title'>Datos jer√°rquicos</span>"
    ]
  },
  {
    "objectID": "rectangling.html#casos-de-estudio",
    "href": "rectangling.html#casos-de-estudio",
    "title": "23¬† Datos jer√°rquicos",
    "section": "\n23.4 Casos de estudio",
    "text": "23.4 Casos de estudio\nLa principal diferencia entre los ejemplos simples que usamos anteriormente y los datos reales es que los datos reales generalmente contienen m√∫ltiples niveles de anidamiento que requieren m√∫ltiples llamadas a unnest_longer() y/o unnest_wider(). Para mostrar eso en acci√≥n, esta secci√≥n trabaja a trav√©s de tres desaf√≠os reales de rect√°ngulos utilizando conjuntos de datos del paquete repurrrsive.\n\n23.4.1 Datos muy amplios\nEmpezaremos con gh_repos. Esta es una lista que contiene datos sobre una colecci√≥n de repositorios de GitHub recuperados mediante la API de GitHub. Es una lista muy anidada, por lo que es dif√≠cil mostrar la estructura en este libro; recomendamos explorar un poco por su cuenta con View(gh_repos) antes de continuar.\ngh_repos es una lista, pero nuestras herramientas funcionan con columnas de lista, por lo que comenzaremos poni√©ndola en un tibble. Llamamos a esta columna json por razones que veremos m√°s adelante.\n\nrepos &lt;- tibble(json = gh_repos)\nrepos\n#&gt; # A tibble: 6 √ó 1\n#&gt;   json       \n#&gt;   &lt;list&gt;     \n#&gt; 1 &lt;list [30]&gt;\n#&gt; 2 &lt;list [30]&gt;\n#&gt; 3 &lt;list [30]&gt;\n#&gt; 4 &lt;list [26]&gt;\n#&gt; 5 &lt;list [30]&gt;\n#&gt; 6 &lt;list [30]&gt;\n\nEste tibble contiene 6 filas, una fila para cada hijo de gh_repos. Cada fila contiene una lista sin nombre con 26 o 30 filas. Como estos no tienen nombre, comenzaremos con unnest_longer() para poner a cada ni√±o en su propia fila:\n\nrepos |&gt; \n  unnest_longer(json)\n#&gt; # A tibble: 176 √ó 1\n#&gt;   json             \n#&gt;   &lt;list&gt;           \n#&gt; 1 &lt;named list [68]&gt;\n#&gt; 2 &lt;named list [68]&gt;\n#&gt; 3 &lt;named list [68]&gt;\n#&gt; 4 &lt;named list [68]&gt;\n#&gt; 5 &lt;named list [68]&gt;\n#&gt; 6 &lt;named list [68]&gt;\n#&gt; # ‚Ñπ 170 more rows\n\nA primera vista, puede parecer que no hemos mejorado la situaci√≥n: aunque tenemos m√°s filas (176 en lugar de 6), cada elemento de json sigue siendo una lista. Sin embargo, hay una diferencia importante: ahora cada elemento es una lista nombrada, por lo que podemos usar unnest_wider() para poner cada elemento en su propia columna:\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) \n#&gt; # A tibble: 176 √ó 68\n#&gt;         id name        full_name         owner        private html_url       \n#&gt;      &lt;int&gt; &lt;chr&gt;       &lt;chr&gt;             &lt;list&gt;       &lt;lgl&gt;   &lt;chr&gt;          \n#&gt; 1 61160198 after       gaborcsardi/after &lt;named list&gt; FALSE   https://github‚Ä¶\n#&gt; 2 40500181 argufy      gaborcsardi/argu‚Ä¶ &lt;named list&gt; FALSE   https://github‚Ä¶\n#&gt; 3 36442442 ask         gaborcsardi/ask   &lt;named list&gt; FALSE   https://github‚Ä¶\n#&gt; 4 34924886 baseimports gaborcsardi/base‚Ä¶ &lt;named list&gt; FALSE   https://github‚Ä¶\n#&gt; 5 61620661 citest      gaborcsardi/cite‚Ä¶ &lt;named list&gt; FALSE   https://github‚Ä¶\n#&gt; 6 33907457 clisymbols  gaborcsardi/clis‚Ä¶ &lt;named list&gt; FALSE   https://github‚Ä¶\n#&gt; # ‚Ñπ 170 more rows\n#&gt; # ‚Ñπ 62 more variables: description &lt;chr&gt;, fork &lt;lgl&gt;, url &lt;chr&gt;, ‚Ä¶\n\nEsto ha funcionado, pero el resultado es un poco abrumador: ¬°hay tantas columnas que tibble ni siquiera las imprime todas! Podemos verlos todos con names(); y aqu√≠ nos fijamos en los 10 primeros:\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) |&gt; \n  names() |&gt; \n  head(10)\n#&gt;  [1] \"id\"          \"name\"        \"full_name\"   \"owner\"       \"private\"    \n#&gt;  [6] \"html_url\"    \"description\" \"fork\"        \"url\"         \"forks_url\"\n\nVamos a sacar algunos que parecen interesantes:\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) |&gt; \n  select(id, full_name, owner, description)\n#&gt; # A tibble: 176 √ó 4\n#&gt;         id full_name               owner             description             \n#&gt;      &lt;int&gt; &lt;chr&gt;                   &lt;list&gt;            &lt;chr&gt;                   \n#&gt; 1 61160198 gaborcsardi/after       &lt;named list [17]&gt; Run Code in the Backgro‚Ä¶\n#&gt; 2 40500181 gaborcsardi/argufy      &lt;named list [17]&gt; Declarative function ar‚Ä¶\n#&gt; 3 36442442 gaborcsardi/ask         &lt;named list [17]&gt; Friendly CLI interactio‚Ä¶\n#&gt; 4 34924886 gaborcsardi/baseimports &lt;named list [17]&gt; Do we get warnings for ‚Ä¶\n#&gt; 5 61620661 gaborcsardi/citest      &lt;named list [17]&gt; Test R package and repo‚Ä¶\n#&gt; 6 33907457 gaborcsardi/clisymbols  &lt;named list [17]&gt; Unicode symbols for CLI‚Ä¶\n#&gt; # ‚Ñπ 170 more rows\n\nPuede usar esto para volver a comprender c√≥mo se estructur√≥ gh_repos: cada ni√±o era un usuario de GitHub que conten√≠a una lista de hasta 30 repositorios de GitHub que crearon.\nowner es otra columna de lista, y dado que contiene una lista con nombre, podemos usar unnest_wider() para obtener los valores:\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) |&gt; \n  select(id, full_name, owner, description) |&gt; \n  unnest_wider(owner)\n#&gt; Error in `unnest_wider()`:\n#&gt; ! Can't duplicate names between the affected columns and the original\n#&gt;   data.\n#&gt; ‚úñ These names are duplicated:\n#&gt;   ‚Ñπ `id`, from `owner`.\n#&gt; ‚Ñπ Use `names_sep` to disambiguate using the column name.\n#&gt; ‚Ñπ Or use `names_repair` to specify a repair strategy.\n\nOh, oh, esta columna de lista tambi√©n contiene una columna id y no podemos tener dos columnas id en el mismo marco de datos. Como se sugiere, usemos names_sep para resolver el problema:\n\nrepos |&gt; \n  unnest_longer(json) |&gt; \n  unnest_wider(json) |&gt; \n  select(id, full_name, owner, description) |&gt; \n  unnest_wider(owner, names_sep = \"_\")\n#&gt; # A tibble: 176 √ó 20\n#&gt;         id full_name               owner_login owner_id owner_avatar_url     \n#&gt;      &lt;int&gt; &lt;chr&gt;                   &lt;chr&gt;          &lt;int&gt; &lt;chr&gt;                \n#&gt; 1 61160198 gaborcsardi/after       gaborcsardi   660288 https://avatars.gith‚Ä¶\n#&gt; 2 40500181 gaborcsardi/argufy      gaborcsardi   660288 https://avatars.gith‚Ä¶\n#&gt; 3 36442442 gaborcsardi/ask         gaborcsardi   660288 https://avatars.gith‚Ä¶\n#&gt; 4 34924886 gaborcsardi/baseimports gaborcsardi   660288 https://avatars.gith‚Ä¶\n#&gt; 5 61620661 gaborcsardi/citest      gaborcsardi   660288 https://avatars.gith‚Ä¶\n#&gt; 6 33907457 gaborcsardi/clisymbols  gaborcsardi   660288 https://avatars.gith‚Ä¶\n#&gt; # ‚Ñπ 170 more rows\n#&gt; # ‚Ñπ 15 more variables: owner_gravatar_id &lt;chr&gt;, owner_url &lt;chr&gt;, ‚Ä¶\n\nEsto proporciona otro amplio conjunto de datos, pero puede tener la sensaci√≥n de que owner parece contener una gran cantidad de datos adicionales sobre la persona que ‚Äúposee‚Äù el repositorio.\n\n23.4.2 Datos relacionales\nLos datos anidados a veces se usan para representar datos que normalmente distribuir√≠amos en varios marcos de datos. Por ejemplo, tome got_chars que contiene datos sobre los personajes que aparecen en los libros y series de televisi√≥n de Game of Thrones. Al igual que gh_repos, es una lista, por lo que comenzamos convirti√©ndola en una columna de lista de un tibble:\n\nchars &lt;- tibble(json = got_chars)\nchars\n#&gt; # A tibble: 30 √ó 1\n#&gt;   json             \n#&gt;   &lt;list&gt;           \n#&gt; 1 &lt;named list [18]&gt;\n#&gt; 2 &lt;named list [18]&gt;\n#&gt; 3 &lt;named list [18]&gt;\n#&gt; 4 &lt;named list [18]&gt;\n#&gt; 5 &lt;named list [18]&gt;\n#&gt; 6 &lt;named list [18]&gt;\n#&gt; # ‚Ñπ 24 more rows\n\nLa columna json contiene elementos con nombre, por lo que comenzaremos ampli√°ndola:\n\nchars |&gt; \n  unnest_wider(json)\n#&gt; # A tibble: 30 √ó 18\n#&gt;   url                    id name            gender culture    born           \n#&gt;   &lt;chr&gt;               &lt;int&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;          \n#&gt; 1 https://www.anapio‚Ä¶  1022 Theon Greyjoy   Male   \"Ironborn\" \"In 278 AC or ‚Ä¶\n#&gt; 2 https://www.anapio‚Ä¶  1052 Tyrion Lannist‚Ä¶ Male   \"\"         \"In 273 AC, at‚Ä¶\n#&gt; 3 https://www.anapio‚Ä¶  1074 Victarion Grey‚Ä¶ Male   \"Ironborn\" \"In 268 AC or ‚Ä¶\n#&gt; 4 https://www.anapio‚Ä¶  1109 Will            Male   \"\"         \"\"             \n#&gt; 5 https://www.anapio‚Ä¶  1166 Areo Hotah      Male   \"Norvoshi\" \"In 257 AC or ‚Ä¶\n#&gt; 6 https://www.anapio‚Ä¶  1267 Chett           Male   \"\"         \"At Hag's Mire\"\n#&gt; # ‚Ñπ 24 more rows\n#&gt; # ‚Ñπ 12 more variables: died &lt;chr&gt;, alive &lt;lgl&gt;, titles &lt;list&gt;, ‚Ä¶\n\nY seleccionando algunas columnas para que sea m√°s f√°cil de leer:\n\ncharacters &lt;- chars |&gt; \n  unnest_wider(json) |&gt; \n  select(id, name, gender, culture, born, died, alive)\ncharacters\n#&gt; # A tibble: 30 √ó 7\n#&gt;      id name              gender culture    born              died           \n#&gt;   &lt;int&gt; &lt;chr&gt;             &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;             &lt;chr&gt;          \n#&gt; 1  1022 Theon Greyjoy     Male   \"Ironborn\" \"In 278 AC or 27‚Ä¶ \"\"             \n#&gt; 2  1052 Tyrion Lannister  Male   \"\"         \"In 273 AC, at C‚Ä¶ \"\"             \n#&gt; 3  1074 Victarion Greyjoy Male   \"Ironborn\" \"In 268 AC or be‚Ä¶ \"\"             \n#&gt; 4  1109 Will              Male   \"\"         \"\"                \"In 297 AC, at‚Ä¶\n#&gt; 5  1166 Areo Hotah        Male   \"Norvoshi\" \"In 257 AC or be‚Ä¶ \"\"             \n#&gt; 6  1267 Chett             Male   \"\"         \"At Hag's Mire\"   \"In 299 AC, at‚Ä¶\n#&gt; # ‚Ñπ 24 more rows\n#&gt; # ‚Ñπ 1 more variable: alive &lt;lgl&gt;\n\nEste conjunto de datos tambi√©n contiene muchas columnas de lista:\n\nchars |&gt; \n  unnest_wider(json) |&gt; \n  select(id, where(is.list))\n#&gt; # A tibble: 30 √ó 8\n#&gt;      id titles    aliases    allegiances books     povBooks tvSeries playedBy\n#&gt;   &lt;int&gt; &lt;list&gt;    &lt;list&gt;     &lt;list&gt;      &lt;list&gt;    &lt;list&gt;   &lt;list&gt;   &lt;list&gt;  \n#&gt; 1  1022 &lt;chr [2]&gt; &lt;chr [4]&gt;  &lt;chr [1]&gt;   &lt;chr [3]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 2  1052 &lt;chr [2]&gt; &lt;chr [11]&gt; &lt;chr [1]&gt;   &lt;chr [2]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 3  1074 &lt;chr [2]&gt; &lt;chr [1]&gt;  &lt;chr [1]&gt;   &lt;chr [3]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 4  1109 &lt;chr [1]&gt; &lt;chr [1]&gt;  &lt;NULL&gt;      &lt;chr [1]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 5  1166 &lt;chr [1]&gt; &lt;chr [1]&gt;  &lt;chr [1]&gt;   &lt;chr [3]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 6  1267 &lt;chr [1]&gt; &lt;chr [1]&gt;  &lt;NULL&gt;      &lt;chr [2]&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n#&gt; # ‚Ñπ 24 more rows\n\nExploremos la columna t√≠tulos. Es una columna de lista sin nombre, por lo que la dividiremos en filas:\n\nchars |&gt; \n  unnest_wider(json) |&gt; \n  select(id, titles) |&gt; \n  unnest_longer(titles)\n#&gt; # A tibble: 59 √ó 2\n#&gt;      id titles                                              \n#&gt;   &lt;int&gt; &lt;chr&gt;                                               \n#&gt; 1  1022 Prince of Winterfell                                \n#&gt; 2  1022 Lord of the Iron Islands (by law of the green lands)\n#&gt; 3  1052 Acting Hand of the King (former)                    \n#&gt; 4  1052 Master of Coin (former)                             \n#&gt; 5  1074 Lord Captain of the Iron Fleet                      \n#&gt; 6  1074 Master of the Iron Victory                          \n#&gt; # ‚Ñπ 53 more rows\n\nEs posible que espere ver estos datos en su propia tabla porque ser√≠a f√°cil unirlos a los datos de los caracteres seg√∫n sea necesario. Hag√°moslo, lo que requiere poca limpieza: eliminar las filas que contienen cadenas vac√≠as y cambiar el nombre de titles a title ya que cada fila ahora solo contiene un solo t√≠tulo.\n\ntitles &lt;- chars |&gt; \n  unnest_wider(json) |&gt; \n  select(id, titles) |&gt; \n  unnest_longer(titles) |&gt; \n  filter(titles != \"\") |&gt; \n  rename(title = titles)\ntitles\n#&gt; # A tibble: 52 √ó 2\n#&gt;      id title                                               \n#&gt;   &lt;int&gt; &lt;chr&gt;                                               \n#&gt; 1  1022 Prince of Winterfell                                \n#&gt; 2  1022 Lord of the Iron Islands (by law of the green lands)\n#&gt; 3  1052 Acting Hand of the King (former)                    \n#&gt; 4  1052 Master of Coin (former)                             \n#&gt; 5  1074 Lord Captain of the Iron Fleet                      \n#&gt; 6  1074 Master of the Iron Victory                          \n#&gt; # ‚Ñπ 46 more rows\n\nPodr√≠a imaginarse crear una tabla como esta para cada una de las columnas de la lista y luego usar uniones para combinarlas con los datos de los caracteres seg√∫n lo necesite.\n\n23.4.3 Profundamente anidado\nTerminaremos estos estudios de caso con una columna de lista que est√° muy anidada y requiere rondas repetidas de unnest_wider() y unnest_longer() para desentra√±ar: gmaps_cities. Este es un tibble de dos columnas que contiene cinco nombres de ciudades y los resultados del uso de la API de codificaci√≥n geogr√°fica de Google para determinar su ubicaci√≥n:\n\ngmaps_cities\n#&gt; # A tibble: 5 √ó 2\n#&gt;   city       json            \n#&gt;   &lt;chr&gt;      &lt;list&gt;          \n#&gt; 1 Houston    &lt;named list [2]&gt;\n#&gt; 2 Washington &lt;named list [2]&gt;\n#&gt; 3 New York   &lt;named list [2]&gt;\n#&gt; 4 Chicago    &lt;named list [2]&gt;\n#&gt; 5 Arlington  &lt;named list [2]&gt;\n\njson es una columna de lista con nombres internos, por lo que comenzamos con un unnest_wider():\n\ngmaps_cities |&gt; \n  unnest_wider(json)\n#&gt; # A tibble: 5 √ó 3\n#&gt;   city       results    status\n#&gt;   &lt;chr&gt;      &lt;list&gt;     &lt;chr&gt; \n#&gt; 1 Houston    &lt;list [1]&gt; OK    \n#&gt; 2 Washington &lt;list [2]&gt; OK    \n#&gt; 3 New York   &lt;list [1]&gt; OK    \n#&gt; 4 Chicago    &lt;list [1]&gt; OK    \n#&gt; 5 Arlington  &lt;list [2]&gt; OK\n\nEsto nos da el estado, status, y los resultados, results. Dejaremos la columna de estado ya que todos est√°n OK; en un an√°lisis real, tambi√©n querr√° capturar todas las filas donde status != \"OK\" y descubrir qu√© sali√≥ mal. results es una lista sin nombre, con uno o dos elementos (veremos por qu√© en breve), as√≠ que la dividiremos en filas:\n\ngmaps_cities |&gt; \n  unnest_wider(json) |&gt; \n  select(-status) |&gt; \n  unnest_longer(results)\n#&gt; # A tibble: 7 √ó 2\n#&gt;   city       results         \n#&gt;   &lt;chr&gt;      &lt;list&gt;          \n#&gt; 1 Houston    &lt;named list [5]&gt;\n#&gt; 2 Washington &lt;named list [5]&gt;\n#&gt; 3 Washington &lt;named list [5]&gt;\n#&gt; 4 New York   &lt;named list [5]&gt;\n#&gt; 5 Chicago    &lt;named list [5]&gt;\n#&gt; 6 Arlington  &lt;named list [5]&gt;\n#&gt; # ‚Ñπ 1 more row\n\nAhora results es una lista con nombre, as√≠ que usaremos unnest_wider():\n\nlocations &lt;- gmaps_cities |&gt; \n  unnest_wider(json) |&gt; \n  select(-status) |&gt; \n  unnest_longer(results) |&gt; \n  unnest_wider(results)\nlocations\n#&gt; # A tibble: 7 √ó 6\n#&gt;   city       address_components formatted_address   geometry        \n#&gt;   &lt;chr&gt;      &lt;list&gt;             &lt;chr&gt;               &lt;list&gt;          \n#&gt; 1 Houston    &lt;list [4]&gt;         Houston, TX, USA    &lt;named list [4]&gt;\n#&gt; 2 Washington &lt;list [2]&gt;         Washington, USA     &lt;named list [4]&gt;\n#&gt; 3 Washington &lt;list [4]&gt;         Washington, DC, USA &lt;named list [4]&gt;\n#&gt; 4 New York   &lt;list [3]&gt;         New York, NY, USA   &lt;named list [4]&gt;\n#&gt; 5 Chicago    &lt;list [4]&gt;         Chicago, IL, USA    &lt;named list [4]&gt;\n#&gt; 6 Arlington  &lt;list [4]&gt;         Arlington, TX, USA  &lt;named list [4]&gt;\n#&gt; # ‚Ñπ 1 more row\n#&gt; # ‚Ñπ 2 more variables: place_id &lt;chr&gt;, types &lt;list&gt;\n\nAhora podemos ver por qu√© dos ciudades obtuvieron dos resultados: Washington igual√≥ tanto al estado de Washington como a Washington, DC, y Arlington igual√≥ a Arlington, Virginia y Arlington, Texas.\nHay pocos lugares diferentes a los que podr√≠amos ir desde aqu√≠. Es posible que deseemos determinar la ubicaci√≥n exacta de la coincidencia, que se almacena en la columna de la lista geometry:\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  unnest_wider(geometry)\n#&gt; # A tibble: 7 √ó 6\n#&gt;   city       formatted_address   bounds           location     location_type\n#&gt;   &lt;chr&gt;      &lt;chr&gt;               &lt;list&gt;           &lt;list&gt;       &lt;chr&gt;        \n#&gt; 1 Houston    Houston, TX, USA    &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 2 Washington Washington, USA     &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 3 Washington Washington, DC, USA &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 4 New York   New York, NY, USA   &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 5 Chicago    Chicago, IL, USA    &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; 6 Arlington  Arlington, TX, USA  &lt;named list [2]&gt; &lt;named list&gt; APPROXIMATE  \n#&gt; # ‚Ñπ 1 more row\n#&gt; # ‚Ñπ 1 more variable: viewport &lt;list&gt;\n\nEso nos da nuevos l√≠mites, bounds, (una regi√≥n rectangular) y ubicaci√≥n, location, (un punto). Podemos anular location para ver la latitud (lat) y la longitud (lng):\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  unnest_wider(geometry) |&gt; \n  unnest_wider(location)\n#&gt; # A tibble: 7 √ó 7\n#&gt;   city       formatted_address   bounds             lat    lng location_type\n#&gt;   &lt;chr&gt;      &lt;chr&gt;               &lt;list&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;        \n#&gt; 1 Houston    Houston, TX, USA    &lt;named list [2]&gt;  29.8  -95.4 APPROXIMATE  \n#&gt; 2 Washington Washington, USA     &lt;named list [2]&gt;  47.8 -121.  APPROXIMATE  \n#&gt; 3 Washington Washington, DC, USA &lt;named list [2]&gt;  38.9  -77.0 APPROXIMATE  \n#&gt; 4 New York   New York, NY, USA   &lt;named list [2]&gt;  40.7  -74.0 APPROXIMATE  \n#&gt; 5 Chicago    Chicago, IL, USA    &lt;named list [2]&gt;  41.9  -87.6 APPROXIMATE  \n#&gt; 6 Arlington  Arlington, TX, USA  &lt;named list [2]&gt;  32.7  -97.1 APPROXIMATE  \n#&gt; # ‚Ñπ 1 more row\n#&gt; # ‚Ñπ 1 more variable: viewport &lt;list&gt;\n\nExtraer los l√≠mites requiere algunos pasos m√°s:\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  unnest_wider(geometry) |&gt; \n  # focus on the variables of interest\n  select(!location:viewport) |&gt;\n  unnest_wider(bounds)\n#&gt; # A tibble: 7 √ó 4\n#&gt;   city       formatted_address   northeast        southwest       \n#&gt;   &lt;chr&gt;      &lt;chr&gt;               &lt;list&gt;           &lt;list&gt;          \n#&gt; 1 Houston    Houston, TX, USA    &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 2 Washington Washington, USA     &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 3 Washington Washington, DC, USA &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 4 New York   New York, NY, USA   &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 5 Chicago    Chicago, IL, USA    &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; 6 Arlington  Arlington, TX, USA  &lt;named list [2]&gt; &lt;named list [2]&gt;\n#&gt; # ‚Ñπ 1 more row\n\nLuego renombramos southwest y northeast (las esquinas del rect√°ngulo) para que podamos usar names_sep para crear nombres cortos pero evocadores:\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  unnest_wider(geometry) |&gt; \n  select(!location:viewport) |&gt;\n  unnest_wider(bounds) |&gt; \n  rename(ne = northeast, sw = southwest) |&gt; \n  unnest_wider(c(ne, sw), names_sep = \"_\") \n#&gt; # A tibble: 7 √ó 6\n#&gt;   city       formatted_address   ne_lat ne_lng sw_lat sw_lng\n#&gt;   &lt;chr&gt;      &lt;chr&gt;                &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 Houston    Houston, TX, USA      30.1  -95.0   29.5  -95.8\n#&gt; 2 Washington Washington, USA       49.0 -117.    45.5 -125. \n#&gt; 3 Washington Washington, DC, USA   39.0  -76.9   38.8  -77.1\n#&gt; 4 New York   New York, NY, USA     40.9  -73.7   40.5  -74.3\n#&gt; 5 Chicago    Chicago, IL, USA      42.0  -87.5   41.6  -87.9\n#&gt; 6 Arlington  Arlington, TX, USA    32.8  -97.0   32.6  -97.2\n#&gt; # ‚Ñπ 1 more row\n\nTenga en cuenta c√≥mo desanidamos dos columnas simult√°neamente proporcionando un vector de nombres de variables a unnest_wider().\nUna vez que haya descubierto la ruta para llegar a los componentes que le interesan, puede extraerlos directamente usando otra funci√≥n tidyr, hoist():\n\nlocations |&gt; \n  select(city, formatted_address, geometry) |&gt; \n  hoist(\n    geometry,\n    ne_lat = c(\"bounds\", \"northeast\", \"lat\"),\n    sw_lat = c(\"bounds\", \"southwest\", \"lat\"),\n    ne_lng = c(\"bounds\", \"northeast\", \"lng\"),\n    sw_lng = c(\"bounds\", \"southwest\", \"lng\"),\n  )\n\nSi estos casos de estudio han abierto su apetito por m√°s rectangulares de la vida real, puede ver algunos ejemplos m√°s en `vignette(‚Äúrectangling‚Äù, package = ‚Äútidyr‚Äù)\n\n23.4.4 Ejercicios\n\nCalcula aproximadamente cu√°ndo se cre√≥ gh_repos. ¬øPor qu√© solo puedes estimar aproximadamente la fecha?\nLa columna owners de gh_repo contiene mucha informaci√≥n duplicada porque cada propietario puede tener muchos repositorios. ¬øPuede construir un marco de datos de owners que contenga una fila para cada propietario? (Pista: ¬ødistinct() funciona con list-cols?)\nSiga los pasos utilizados para los titles para crear tablas similares para los alias, lealtades, libros y series de televisi√≥n de los personajes de Game of Thrones.\n\nExplique el siguiente c√≥digo l√≠nea por l√≠nea. ¬øPor qu√© es interesante? ¬øPor qu√© funciona para got_chars pero podr√≠a no funciona en general?\n\ntibble(json = got_chars) |&gt; \n  unnest_wider(json) |&gt; \n  select(id, where(is.list)) |&gt; \n  pivot_longer(\n    where(is.list), \n    names_to = \"name\", \n    values_to = \"value\"\n  ) |&gt;  \n  unnest_longer(value)\n\n\nEn gmaps_cities, ¬øqu√© contiene address_components? ¬øPor qu√© var√≠a la longitud entre filas? Des anidalo apropiadamente para averiguarlo. (Pista: types siempre parece contener dos elementos. ¬øHace que sea m√°s f√°cil trabajar con unnest_wider() que con unnest_longer()?) .",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>23</span>¬† <span class='chapter-title'>Datos jer√°rquicos</span>"
    ]
  },
  {
    "objectID": "rectangling.html#json",
    "href": "rectangling.html#json",
    "title": "23¬† Datos jer√°rquicos",
    "section": "\n23.5 JSON",
    "text": "23.5 JSON\nTodos los estudios de casos de la secci√≥n anterior se obtuvieron de JSON. JSON es la abreviatura de javascript object notation y es la forma en que la mayor√≠a de las API web devuelven datos. Es importante comprenderlo porque, si bien los tipos de datos de JSON y R son bastante similares, no existe un mapeo 1 a 1 perfecto, por lo que es bueno comprender un poco acerca de JSON si algo sale mal.\n\n23.5.1 Tipos de datos\nJSON es un formato simple dise√±ado para ser le√≠do y escrito f√°cilmente por m√°quinas, no por humanos. Tiene seis tipos de datos clave. Cuatro de ellos son escalares:\n\nEl tipo m√°s simple es nulo (null) que juega el mismo papel que NA en R. Representa la ausencia de datos.\nUna cadena es muy parecida a una cadena en R, pero siempre debe usar comillas dobles.\nUn n√∫mero es similar a los n√∫meros de R: pueden usar notaci√≥n entera (por ejemplo, 123), decimal (por ejemplo, 123,45) o cient√≠fica (por ejemplo, 1,23e3). JSON no es compatible con Inf, -Inf o NaN.\nUn booleano es similar a TRUE y FALSE de R, pero usa true y false en min√∫sculas.\n\nLas cadenas, los n√∫meros y los valores booleanos de JSON son bastante similares a los vectores de caracteres, num√©ricos y l√≥gicos de R. La principal diferencia es que los escalares de JSON solo pueden representar un √∫nico valor. Para representar m√∫ltiples valores, debe usar uno de los dos tipos restantes: matrices y objetos.\nTanto las matrices como los objetos son similares a las listas en R; la diferencia es si tienen nombre o no. Una matriz es como una lista sin nombre y se escribe con []. Por ejemplo, [1, 2, 3] es una matriz que contiene 3 n√∫meros, y [null, 1, \"string\", false] es una matriz que contiene un valor nulo, un n√∫mero, una cadena y un valor booleano. Un objeto es como una lista con nombre y se escribe con {}. Los nombres (claves en terminolog√≠a JSON) son cadenas, por lo que deben estar entre comillas. Por ejemplo, {\"x\": 1, \"y\": 2} es un objeto que asigna x a 1 e y a 2.\nTenga en cuenta que JSON no tiene ninguna forma nativa de representar fechas o fechas y horas, por lo que a menudo se almacenan como cadenas y deber√° usar readr::parse_date() o readr::parse_datetime() para convertirlos en la estructura de datos correcta. De manera similar, las reglas de JSON para representar n√∫meros de punto flotante en JSON son un poco imprecisas, por lo que a veces tambi√©n encontrar√° n√∫meros almacenados en cadenas. Aplique readr::parse_double() seg√∫n sea necesario para obtener el tipo de variable correcto.\n\n23.5.2 jsonlite\nPara convertir JSON en estructuras de datos R, recomendamos el paquete jsonlite, de Jeroen Ooms. Usaremos solo dos funciones jsonlite: read_json() y parse_json(). En la vida real, usar√° read_json() para leer un archivo JSON del disco. Por ejemplo, el paquete repurrsive tambi√©n proporciona la fuente de gh_user como un archivo JSON y puede leerlo con read_json():\n\n# Una ruta a un archivo json dentro del paquete:\ngh_users_json()\n#&gt; [1] \"/home/runner/work/_temp/renv/cache/v5/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu/repurrrsive/1.1.0/83cf8bf4ada1dca8cfe94111c2a691d7/repurrrsive/extdata/gh_users.json\"\n\n# L√©alo con read_json()\ngh_users2 &lt;- read_json(gh_users_json())\n\n# Verifique que sea igual a los datos que est√°bamos usando anteriormente\nidentical(gh_users, gh_users2)\n#&gt; [1] TRUE\n\nEn este libro, tambi√©n usaremos parse_json(), ya que toma una cadena que contiene JSON, lo que lo hace bueno para generar ejemplos simples. Para comenzar, aqu√≠ hay tres conjuntos de datos JSON simples, comenzando con un n√∫mero, luego colocando algunos n√∫meros en una matriz y luego colocando esa matriz en un objeto:\n\nstr(parse_json('1'))\n#&gt;  int 1\nstr(parse_json('[1, 2, 3]'))\n#&gt; List of 3\n#&gt;  $ : int 1\n#&gt;  $ : int 2\n#&gt;  $ : int 3\nstr(parse_json('{\"x\": [1, 2, 3]}'))\n#&gt; List of 1\n#&gt;  $ x:List of 3\n#&gt;   ..$ : int 1\n#&gt;   ..$ : int 2\n#&gt;   ..$ : int 3\n\njsonlite tiene otra funci√≥n importante llamada fromJSON(). No lo usamos aqu√≠ porque realiza una simplificaci√≥n autom√°tica (simplifyVector = TRUE). Esto a menudo funciona bien, particularmente en casos simples, pero creemos que es mejor que usted mismo haga el rect√°ngulo para que sepa exactamente lo que est√° sucediendo y pueda manejar m√°s f√°cilmente las estructuras anidadas m√°s complicadas.\n\n23.5.3 Comenzando el proceso de rectangular\nEn la mayor√≠a de los casos, los archivos JSON contienen una √∫nica matriz de nivel superior porque est√°n dise√±ados para proporcionar datos sobre varias ‚Äúcosas‚Äù, p.ej., varias p√°ginas, varios registros o varios resultados. En este caso, comenzar√° su rect√°ngulo con tibble(json) para que cada elemento se convierta en una fila:\n\njson &lt;- '[\n  {\"name\": \"John\", \"age\": 34},\n  {\"name\": \"Susan\", \"age\": 27}\n]'\ndf &lt;- tibble(json = parse_json(json))\ndf\n#&gt; # A tibble: 2 √ó 1\n#&gt;   json            \n#&gt;   &lt;list&gt;          \n#&gt; 1 &lt;named list [2]&gt;\n#&gt; 2 &lt;named list [2]&gt;\n\ndf |&gt; \n  unnest_wider(json)\n#&gt; # A tibble: 2 √ó 2\n#&gt;   name    age\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 John     34\n#&gt; 2 Susan    27\n\nEn casos m√°s raros, el archivo JSON consta de un solo objeto JSON de nivel superior, que representa una ‚Äúcosa‚Äù. En este caso, deber√° iniciar el proceso de rectangular envolvi√©ndolo en una lista, antes de colocarlo en un tibble.\n\njson &lt;- '{\n  \"status\": \"OK\", \n  \"results\": [\n    {\"name\": \"John\", \"age\": 34},\n    {\"name\": \"Susan\", \"age\": 27}\n ]\n}\n'\ndf &lt;- tibble(json = list(parse_json(json)))\ndf\n#&gt; # A tibble: 1 √ó 1\n#&gt;   json            \n#&gt;   &lt;list&gt;          \n#&gt; 1 &lt;named list [2]&gt;\n\ndf |&gt; \n  unnest_wider(json) |&gt; \n  unnest_longer(results) |&gt; \n  unnest_wider(results)\n#&gt; # A tibble: 2 √ó 3\n#&gt;   status name    age\n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n#&gt; 1 OK     John     34\n#&gt; 2 OK     Susan    27\n\nAlternativamente, puede acceder al JSON analizado y comenzar con la parte que realmente le interesa:\n\ndf &lt;- tibble(results = parse_json(json)$results)\ndf |&gt; \n  unnest_wider(results)\n#&gt; # A tibble: 2 √ó 2\n#&gt;   name    age\n#&gt;   &lt;chr&gt; &lt;int&gt;\n#&gt; 1 John     34\n#&gt; 2 Susan    27\n\n\n23.5.4 Ejercicios\n\n\nRect√°ngulo df_col y df_row a continuaci√≥n. Representan las dos formas de codificar un marco de datos en JSON.\n\njson_col &lt;- parse_json('\n  {\n    \"x\": [\"a\", \"x\", \"z\"],\n    \"y\": [10, null, 3]\n  }\n')\njson_row &lt;- parse_json('\n  [\n    {\"x\": \"a\", \"y\": 10},\n    {\"x\": \"x\", \"y\": null},\n    {\"x\": \"z\", \"y\": 3}\n  ]\n')\n\ndf_col &lt;- tibble(json = list(json_col)) \ndf_row &lt;- tibble(json = json_row)",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>23</span>¬† <span class='chapter-title'>Datos jer√°rquicos</span>"
    ]
  },
  {
    "objectID": "rectangling.html#resumen",
    "href": "rectangling.html#resumen",
    "title": "23¬† Datos jer√°rquicos",
    "section": "\n23.6 Resumen",
    "text": "23.6 Resumen\nEn este cap√≠tulo, aprendi√≥ qu√© son las listas, c√≥mo puede generarlas a partir de archivos JSON y c√≥mo convertirlas en marcos de datos rectangulares. Sorprendentemente, solo necesitamos dos funciones nuevas: unnest_longer() para colocar los elementos de la lista en filas y unnest_wider() para colocar los elementos de la lista en columnas. No importa cu√°n profundamente anidada est√© la columna de la lista, todo lo que necesita hacer es llamar repetidamente a estas dos funciones.\nJSON es el formato de datos m√°s com√∫n devuelto por las API web. ¬øQu√© sucede si el sitio web no tiene una API, pero puede ver los datos que desea en el sitio web? Ese es el tema del pr√≥ximo cap√≠tulo: web scraping, extracci√≥n de datos de p√°ginas web HTML.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>23</span>¬† <span class='chapter-title'>Datos jer√°rquicos</span>"
    ]
  },
  {
    "objectID": "rectangling.html#footnotes",
    "href": "rectangling.html#footnotes",
    "title": "23¬† Datos jer√°rquicos",
    "section": "",
    "text": "Esta es una caracter√≠stica de RStudio.‚Ü©Ô∏é",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>23</span>¬† <span class='chapter-title'>Datos jer√°rquicos</span>"
    ]
  },
  {
    "objectID": "webscraping.html",
    "href": "webscraping.html",
    "title": "24¬† Web scraping",
    "section": "",
    "text": "24.1 Introducci√≥n\nEste cap√≠tulo le presenta los conceptos b√°sicos del web scraping con rvest. El web scraping es una herramienta muy √∫til para extraer datos de p√°ginas web. Algunos sitios web ofrecer√°n una API, un conjunto de solicitudes HTTP estructuradas que devuelven datos como JSON, que usted maneja utilizando las t√©cnicas de Cap√≠tulo 23. Siempre que sea posible, debe utilizar la API1, ya que, por lo general, le brindar√° datos m√°s confiables. Desafortunadamente, sin embargo, la programaci√≥n con API web est√° fuera del alcance de este libro. En cambio, estamos ense√±ando scraping, una t√©cnica que funciona ya sea que un sitio proporcione o no una API.\nEn este cap√≠tulo, primero discutiremos la √©tica y la legalidad del scraping antes de sumergirnos en los conceptos b√°sicos de HTML. Luego, aprender√° los conceptos b√°sicos de los selectores de CSS para ubicar elementos espec√≠ficos en la p√°gina y c√≥mo usar funciones rvest para obtener datos de texto y atributos de HTML y en R. Luego discutiremos algunas t√©cnicas para descubrir qu√© selector de CSS necesita para la p√°gina de la que desee extraer los datos, antes de terminar ver√° un par de casos de estudio y una breve discusi√≥n de sitios web din√°micos.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>24</span>¬† <span class='chapter-title'>Web scraping</span>"
    ]
  },
  {
    "objectID": "webscraping.html#introducci√≥n",
    "href": "webscraping.html#introducci√≥n",
    "title": "24¬† Web scraping",
    "section": "",
    "text": "24.1.1 Requisitos previos\nEn este cap√≠tulo, nos centraremos en las herramientas proporcionadas por rvest. rvest es miembro de tidyverse, pero no es un miembro central, por lo que deber√° cargarlo expl√≠citamente. Tambi√©n cargaremos el tidyverse completo, ya que lo encontraremos generalmente √∫til para trabajar con los datos que hemos recopilado.\n\nlibrary(tidyverse)\nlibrary(rvest)",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>24</span>¬† <span class='chapter-title'>Web scraping</span>"
    ]
  },
  {
    "objectID": "webscraping.html#scraping-√©ticas-y-legalidades",
    "href": "webscraping.html#scraping-√©ticas-y-legalidades",
    "title": "24¬† Web scraping",
    "section": "\n24.2 Scraping √©ticas y legalidades",
    "text": "24.2 Scraping √©ticas y legalidades\nAntes de comenzar a analizar el c√≥digo que necesitar√° para realizar el web scraping, debemos analizar si es legal y √©tico que lo haga. En general, la situaci√≥n es complicada con respecto a ambos.\nLa legalidad depende mucho del lugar donde vivas. Sin embargo, como principio general, si los datos son p√∫blicos, no personales y f√°cticos, es probable que est√© bien 2. Estos tres factores son importantes porque est√°n relacionados con los t√©rminos y condiciones del sitio, la informaci√≥n de identificaci√≥n personal y los derechos de autor, como veremos a continuaci√≥n.\nSi los datos no son p√∫blicos, no personales o f√°cticos, o si los extrae espec√≠ficamente para ganar dinero con ellos, deber√° hablar con un abogado. En cualquier caso, debe ser respetuoso con los recursos del servidor que aloja las p√°ginas de las que est√° haciendo scraping. Lo que es m√°s importante, esto significa que si est√° extrayendo datos de muchas p√°ginas, debe asegurarse de esperar un poco entre cada solicitud. Una forma f√°cil de hacerlo es usar el paquete polite de Dmytro Perepolkin. Se pausar√° autom√°ticamente entre las solicitudes y almacenar√° en cach√© los resultados para que nunca solicite la misma p√°gina dos veces.\n\n24.2.1 T√©rminos de servicio\nSi observa detenidamente, encontrar√° que muchos sitios web incluyen un enlace de ‚Äút√©rminos y condiciones‚Äù o ‚Äút√©rminos de servicio‚Äù en alg√∫n lugar de la p√°gina, y si lee esa p√°gina detenidamente, a menudo descubrir√° que el sitio proh√≠be espec√≠ficamente el web scraping. Estas p√°ginas tienden a ser una apropiaci√≥n legal de tierras donde las empresas hacen reclamos muy amplios. Es educado respetar estos t√©rminos de servicio siempre que sea posible, pero tome cualquier reclamo con pinzas.\nLos tribunales de EE. UU. generalmente han determinado que simplemente poner los t√©rminos de servicio en el pie de p√°gina del sitio web no es suficiente para que usted est√© sujeto a ellos, por ejemplo, [HiQ Labs v. LinkedIn] (https://en.wikipedia.org/ wiki/HiQ_Labs_v._LinkedIn). En general, para estar sujeto a los t√©rminos del servicio, debe haber realizado alguna acci√≥n expl√≠cita, como crear una cuenta o marcar una casilla. Por eso es importante si los datos son p√∫blicos o no; si no necesita una cuenta para acceder a ellos, es poco probable que est√© sujeto a los t√©rminos del servicio. Tenga en cuenta, sin embargo, que la situaci√≥n es bastante diferente en Europa, donde los tribunales han determinado que los t√©rminos de servicio son exigibles incluso si no los acepta expl√≠citamente.\n\n24.2.2 Informaci√≥n de identificaci√≥n personal\nIncluso si los datos son p√∫blicos, debe tener mucho cuidado al recopilar informaci√≥n de identificaci√≥n personal, como nombres, direcciones de correo electr√≥nico, n√∫meros de tel√©fono, fechas de nacimiento, etc. Europa tiene leyes particularmente estrictas sobre la recopilaci√≥n o el almacenamiento de dichos datos (GDPR), e independientemente de d√≥nde viva, es probable que est√© entrando en un atolladero √©tico. Por ejemplo, en 2016, un grupo de investigadores recopil√≥ informaci√≥n de perfil p√∫blico (por ejemplo, nombres de usuario, edad, sexo, ubicaci√≥n, etc.) de unas 70 000 personas en el sitio de citas OkCupid y publicaron estos datos sin intentar anonimizarlos. Si bien los investigadores sintieron que esto no ten√≠a nada de malo ya que los datos ya eran p√∫blicos, este trabajo fue ampliamente condenado debido a preocupaciones √©ticas sobre la identificabilidad de los usuarios cuya informaci√≥n se public√≥ en el conjunto de datos. Si su trabajo consiste en recopilar informaci√≥n de identificaci√≥n personal, le recomendamos leer sobre el estudio OkCupid3, as√≠ como estudios similares con √©tica de investigaci√≥n cuestionable que involucran la adquisici√≥n y divulgaci√≥n de informaci√≥n de identificaci√≥n personal.\n\n24.2.3 Derechos de autor\nFinalmente, tambi√©n debe preocuparse por la ley de derechos de autor. La ley de derechos de autor es complicada, pero vale la pena echar un vistazo a la [ley de EE. UU.] (https://www.law.cornell.edu/uscode/text/17/102) que describe exactamente lo que est√° protegido: ‚Äú[‚Ä¶ ] obras originales de autor√≠a fijadas en cualquier medio tangible de expresi√≥n, [‚Ä¶]‚Äù. Luego pasa a describir categor√≠as espec√≠ficas que aplica, como obras literarias, obras musicales, pel√≠culas y m√°s. Los datos est√°n notablemente ausentes de la protecci√≥n de los derechos de autor. Esto significa que mientras limite su extracci√≥n a datos, la protecci√≥n de derechos de autor no se aplica. (Pero tenga en cuenta que Europa tiene un derecho ‚Äúsui generis‚Äù separado que protege las bases de datos).\nComo un breve ejemplo, en los EE. UU., las listas de ingredientes y las instrucciones no tienen derechos de autor, por lo que los derechos de autor no se pueden usar para proteger una receta. Pero si esa lista de recetas va acompa√±ada de un contenido literario novedoso sustancial, eso tiene derechos de autor. Por eso, cuando buscas una receta en Internet, siempre hay mucho contenido de antemano.\nSi necesita extraer contenido original (como texto o im√°genes), a√∫n puede estar protegido por la [doctrina de uso justo] (https://en.wikipedia.org/wiki/Fair_use). El uso justo no es una regla estricta y r√°pida, pero sopesa una serie de factores. Es m√°s probable que se aplique si est√° recopilando los datos con fines de investigaci√≥n o no comerciales y si limita lo que extrae a solo lo que necesita.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>24</span>¬† <span class='chapter-title'>Web scraping</span>"
    ]
  },
  {
    "objectID": "webscraping.html#html-b√°sico",
    "href": "webscraping.html#html-b√°sico",
    "title": "24¬† Web scraping",
    "section": "\n24.3 HTML b√°sico",
    "text": "24.3 HTML b√°sico\nPara hacer web scraping, primero debe comprender un poco sobre HTML, el lenguaje que describe las p√°ginas web. HTML significa HyperText Markup Lidioma y se parece a esto:\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Page title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1 id='first'&gt;A heading&lt;/h1&gt;\n  &lt;p&gt;Some text &amp; &lt;b&gt;some bold text.&lt;/b&gt;&lt;/p&gt;\n  &lt;img src='myimg.png' width='100' height='100'&gt;\n&lt;/body&gt;\nHTML tiene una estructura jer√°rquica formada por elementos que consisten en una etiqueta de inicio (por ejemplo, &lt;etiqueta&gt;), atributos opcionales (id='primero'), una etiqueta final[^webscraping- 5] (como &lt;/etiqueta&gt;) y contenido (todo lo que se encuentra entre la etiqueta de inicio y final).\nDado que &lt; y &gt; se utilizan para las etiquetas de inicio y finalizaci√≥n, no puede escribirlas directamente. En su lugar, debe utilizar los escapes de HTML &gt; (mayor que) y &lt; (menor que). Y dado que esos escapes usan &, si quieres un ampersand literal, tienes que escapar como &amp;. Hay una amplia gama de posibles escapes de HTML, pero no necesita preocuparse demasiado por ellos porque rvest los maneja autom√°ticamente por usted.\nWeb scraping es posible porque la mayor√≠a de las p√°ginas que contienen datos que desea extraer generalmente tienen una estructura consistente.\n\n24.3.1 Elementos\nHay m√°s de 100 elementos HTML. Algunos de los m√°s importantes son:\n\nCada p√°gina HTML debe estar en un elemento &lt;html&gt; y debe tener dos elementos secundarios: &lt;head&gt;, que contiene metadatos del documento como el t√≠tulo de la p√°gina, y &lt;body&gt;, que contiene el contenido que ve en el navegador.\nLas etiquetas de bloque como &lt;h1&gt; (t√≠tulo 1), &lt;section&gt; (secci√≥n), &lt;p&gt; (p√°rrafo) y &lt;ol&gt; (lista ordenada) forman la estructura general de la p√°gina.\nLas etiquetas en l√≠nea como &lt;b&gt; (negrita), &lt;i&gt; (cursiva) y &lt;a&gt; (enlace) dan formato al texto dentro de las etiquetas de bloque.\n\nSi encuentra una etiqueta que nunca ha visto antes, puede averiguar qu√© hace con un poco de google. Otro buen lugar para comenzar son los MDN Web Docs que describen casi todos los aspectos de la programaci√≥n web.\nLa mayor√≠a de los elementos pueden tener contenido entre sus etiquetas de inicio y fin. Este contenido puede ser texto o m√°s elementos. Por ejemplo, el siguiente HTML contiene un p√°rrafo de texto, con una palabra en negrita.\n&lt;p&gt;\n  ¬°Hola! Mi &lt;b&gt;nombre&lt;/b&gt; es Hadley.\n&lt;/p&gt;\nLos hijos son los elementos que contiene, por lo que el elemento &lt;p&gt; de arriba tiene un hijo, el elemento &lt;b&gt;. El elemento &lt;b&gt; no tiene hijos, pero s√≠ tiene contenidos (el texto ‚Äúnombre‚Äù).\n\n24.3.2 Atributos\nLas etiquetas pueden tener atributos con nombre que se parecen a name1='value1' name2='value2'. Dos de los atributos m√°s importantes son id y class, que se utilizan junto con CSS (hojas de estilo en cascada) para controlar la apariencia visual de la p√°gina. Suelen ser √∫tiles cuando se extraen datos de una p√°gina. Los atributos tambi√©n se utilizan para registrar el destino de los enlaces (el atributo href de los elementos &lt;a&gt;) y la fuente de las im√°genes (el atributo src del elemento &lt;img&gt;).",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>24</span>¬† <span class='chapter-title'>Web scraping</span>"
    ]
  },
  {
    "objectID": "webscraping.html#extrayendo-datos",
    "href": "webscraping.html#extrayendo-datos",
    "title": "24¬† Web scraping",
    "section": "\n24.4 Extrayendo datos",
    "text": "24.4 Extrayendo datos\nPara comenzar a extraer, necesitar√° la URL de la p√°gina que desea, que generalmente puede copiar desde su navegador web. Luego deber√° leer el HTML de esa p√°gina en R con read_html(). Esto devuelve un objeto xml_document4 que luego manipular√°s usando las funciones rvest:\n\nhtml &lt;- read_html(\"http://rvest.tidyverse.org/\")\nhtml\n#&gt; {html_document}\n#&gt; &lt;html lang=\"en\"&gt;\n#&gt; [1] &lt;head&gt;\\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UT ...\n#&gt; [2] &lt;body&gt;\\n    &lt;a href=\"#container\" class=\"visually-hidden-focusable\"&gt;Ski ...\n\nrvest tambi√©n incluye una funci√≥n que te permite escribir HTML en l√≠nea. Usaremos esto un mont√≥n en este cap√≠tulo mientras ense√±amos c√≥mo funcionan las diversas funciones rvest con ejemplos simples.\n\nhtml &lt;- minimal_html(\"\n  &lt;p&gt;Esto es un p√°rrafo&lt;/p&gt;\n  &lt;ul&gt;\n    &lt;li&gt;Esta es una lista con vi√±etas&lt;/li&gt;\n  &lt;/ul&gt;\n\")\nhtml\n#&gt; {html_document}\n#&gt; &lt;html&gt;\n#&gt; [1] &lt;head&gt;\\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UT ...\n#&gt; [2] &lt;body&gt;\\n&lt;p&gt;Esto es un p√°rrafo&lt;/p&gt;\\n  &lt;ul&gt;\\n&lt;li&gt;Esta es una lista con v ...\n\nAhora que tiene el HTML en R, es hora de extraer los datos de inter√©s. Primero aprender√° sobre los selectores de CSS que le permiten identificar los elementos de inter√©s y las funciones rvest que puede usar para extraer datos de ellos. Luego cubriremos brevemente las tablas HTML, que tienen algunas herramientas especiales.\n\n24.4.1 Buscar elementos\nCSS es la abreviatura de hojas de estilo en cascada y es una herramienta para definir el estilo visual de los documentos HTML. CSS incluye un lenguaje en miniatura para seleccionar elementos en una p√°gina llamado selectores de CSS. Los selectores de CSS definen patrones para ubicar elementos HTML y son √∫tiles para la extracci√≥n de datos porque brindan una forma concisa de describir qu√© elementos desea extraer.\nVolveremos a los selectores de CSS con m√°s detalle en Secci√≥n 24.5, pero afortunadamente puedes recorrer un largo camino con solo tres:\n\np selecciona todos los elementos &lt;p&gt;.\n.title selecciona todos los elementos con clase, class, que equivale a ‚Äútitle‚Äù.\n#title selecciona el elemento con el atributo id que equivale a ‚Äútitle‚Äù. Los atributos de identificaci√≥n deben ser √∫nicos dentro de un documento, por lo que esto solo seleccionar√° un solo elemento.\n\nProbemos estos selectores con un ejemplo simple:\n\nhtml &lt;- minimal_html(\"\n  &lt;h1&gt;Este es un encabezado&lt;/h1&gt;\n  &lt;p id='first'&gt;Esto es un p√°rrafo&lt;/p&gt;\n  &lt;p class='important'&gt;Este es un p√°rrafo importante&lt;/p&gt;\n\")\n\nUsa html_elements() para encontrar todos los elementos que coincidan con el selector:\n\nhtml |&gt; html_elements(\"p\")\n#&gt; {xml_nodeset (2)}\n#&gt; [1] &lt;p id=\"first\"&gt;Esto es un p√°rrafo&lt;/p&gt;\n#&gt; [2] &lt;p class=\"important\"&gt;Este es un p√°rrafo importante&lt;/p&gt;\nhtml |&gt; html_elements(\".important\")\n#&gt; {xml_nodeset (1)}\n#&gt; [1] &lt;p class=\"important\"&gt;Este es un p√°rrafo importante&lt;/p&gt;\nhtml |&gt; html_elements(\"#first\")\n#&gt; {xml_nodeset (1)}\n#&gt; [1] &lt;p id=\"first\"&gt;Esto es un p√°rrafo&lt;/p&gt;\n\nOtra funci√≥n importante es html_element() que siempre devuelve el mismo n√∫mero de salidas que de entradas. Si lo aplica a un documento completo, obtendr√° la primera coincidencia:\n\nhtml |&gt; html_element(\"p\")\n#&gt; {html_node}\n#&gt; &lt;p id=\"first\"&gt;\n\nHay una diferencia importante entre html_element() y html_elements() cuando usas un selector que no coincide con ning√∫n elemento. html_elements() devuelve un vector de longitud 0, donde html_element() devuelve un valor faltante. Esto ser√° importante en breve.\n\nhtml |&gt; html_elements(\"b\")\n#&gt; {xml_nodeset (0)}\nhtml |&gt; html_element(\"b\")\n#&gt; {xml_missing}\n#&gt; &lt;NA&gt;\n\n\n24.4.2 Anidar selecciones\nEn la mayor√≠a de los casos, usar√° html_elements() y html_element() juntos, generalmente usando html_elements() para identificar elementos que se convertir√°n en observaciones y luego usar√° html_element() para encontrar elementos que se convertir√°n en variables. Veamos esto en acci√≥n usando un ejemplo simple. Aqu√≠ tenemos una lista desordenada (&lt;ul&gt;) donde cada elemento de la lista (&lt;li&gt;) contiene informaci√≥n sobre cuatro personajes de StarWars:\n\nhtml &lt;- minimal_html(\"\n  &lt;ul&gt;\n    &lt;li&gt;&lt;b&gt;C-3PO&lt;/b&gt; es un &lt;i&gt;androide&lt;/i&gt; que pesa &lt;span class='weight'&gt;167 kg&lt;/span&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;b&gt;R4-P17&lt;/b&gt; es un &lt;i&gt;androide&lt;/i&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;b&gt;R2-D2&lt;/b&gt; es un &lt;i&gt;androide&lt;/i&gt; que pesa &lt;span class='weight'&gt;96 kg&lt;/span&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;b&gt;Yoda&lt;/b&gt; pesa &lt;span class='weight'&gt;66 kg&lt;/span&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n  \")\n\nPodemos usar html_elements() para hacer un vector donde cada elemento corresponde a un car√°cter diferente:\n\ncharacters &lt;- html |&gt; html_elements(\"li\")\ncharacters\n#&gt; {xml_nodeset (4)}\n#&gt; [1] &lt;li&gt;\\n&lt;b&gt;C-3PO&lt;/b&gt; es un &lt;i&gt;androide&lt;/i&gt; que pesa &lt;span class=\"weight\" ...\n#&gt; [2] &lt;li&gt;\\n&lt;b&gt;R4-P17&lt;/b&gt; es un &lt;i&gt;androide&lt;/i&gt;\\n&lt;/li&gt;\n#&gt; [3] &lt;li&gt;\\n&lt;b&gt;R2-D2&lt;/b&gt; es un &lt;i&gt;androide&lt;/i&gt; que pesa &lt;span class=\"weight\" ...\n#&gt; [4] &lt;li&gt;\\n&lt;b&gt;Yoda&lt;/b&gt; pesa &lt;span class=\"weight\"&gt;66 kg&lt;/span&gt;\\n&lt;/li&gt;\n\nPara extraer el nombre de cada car√°cter, usamos html_element(), porque cuando se aplica a la salida de html_elements() se garantiza que devolver√° una respuesta por elemento:\n\ncharacters |&gt; html_element(\"b\")\n#&gt; {xml_nodeset (4)}\n#&gt; [1] &lt;b&gt;C-3PO&lt;/b&gt;\n#&gt; [2] &lt;b&gt;R4-P17&lt;/b&gt;\n#&gt; [3] &lt;b&gt;R2-D2&lt;/b&gt;\n#&gt; [4] &lt;b&gt;Yoda&lt;/b&gt;\n\nLa distinci√≥n entre html_element() y html_elements() no es importante para el nombre, pero s√≠ lo es para el peso. Queremos obtener un peso para cada car√°cter, incluso si no hay peso &lt;span&gt;. Eso es lo que hace html_element():\n\ncharacters |&gt; html_element(\".weight\")\n#&gt; {xml_nodeset (4)}\n#&gt; [1] &lt;span class=\"weight\"&gt;167 kg&lt;/span&gt;\n#&gt; [2] NA\n#&gt; [3] &lt;span class=\"weight\"&gt;96 kg&lt;/span&gt;\n#&gt; [4] &lt;span class=\"weight\"&gt;66 kg&lt;/span&gt;\n\nhtml_elements() encuentra todos los &lt;span&gt; de peso que son hijos de characters. Solo hay tres de estos, por lo que perdemos la conexi√≥n entre nombres y pesos:\n\ncharacters |&gt; html_elements(\".weight\")\n#&gt; {xml_nodeset (3)}\n#&gt; [1] &lt;span class=\"weight\"&gt;167 kg&lt;/span&gt;\n#&gt; [2] &lt;span class=\"weight\"&gt;96 kg&lt;/span&gt;\n#&gt; [3] &lt;span class=\"weight\"&gt;66 kg&lt;/span&gt;\n\nAhora que ha seleccionado los elementos de inter√©s, deber√° extraer los datos, ya sea del contenido del texto o de algunos atributos.\n\n24.4.3 Texto y atributos\nhtml_text2()5 extrae el contenido de texto sin formato de un elemento HTML:\n\ncharacters |&gt; \n  html_element(\"b\") |&gt; \n  html_text2()\n#&gt; [1] \"C-3PO\"  \"R4-P17\" \"R2-D2\"  \"Yoda\"\n\ncharacters |&gt; \n  html_element(\".weight\") |&gt; \n  html_text2()\n#&gt; [1] \"167 kg\" NA       \"96 kg\"  \"66 kg\"\n\nTenga en cuenta que cualquier escape se manejar√° autom√°ticamente; solo ver√° escapes de HTML en el HTML de origen, no en los datos devueltos por rvest.\nhtml_attr() extrae datos de atributos:\n\nhtml &lt;- minimal_html(\"\n  &lt;p&gt;&lt;a href='https://en.wikipedia.org/wiki/Cat'&gt;cats&lt;/a&gt;&lt;/p&gt;\n  &lt;p&gt;&lt;a href='https://en.wikipedia.org/wiki/Dog'&gt;dogs&lt;/a&gt;&lt;/p&gt;\n\")\n\nhtml |&gt; \n  html_elements(\"p\") |&gt; \n  html_element(\"a\") |&gt; \n  html_attr(\"href\")\n#&gt; [1] \"https://en.wikipedia.org/wiki/Cat\" \"https://en.wikipedia.org/wiki/Dog\"\n\nhtml_attr() siempre devuelve una cadena, por lo que si est√° extrayendo n√∫meros o fechas, deber√° realizar un procesamiento posterior.\n\n24.4.4 Tablas\nSi tiene suerte, sus datos ya estar√°n almacenados en una tabla HTML, y solo ser√° cuesti√≥n de leerlos de esa tabla. Por lo general, es sencillo reconocer una tabla en su navegador: tendr√° una estructura rectangular de filas y columnas, y puede copiarla y pegarla en una herramienta como Excel.\nLas tablas HTML se construyen a partir de cuatro elementos principales: &lt;table&gt;, &lt;tr&gt; (fila de la tabla), &lt;th&gt; (encabezado de la tabla) y &lt;td&gt; (datos de la tabla). Aqu√≠ hay una tabla HTML simple con dos columnas y tres filas:\n\nhtml &lt;- minimal_html(\"\n  &lt;table class='mytable'&gt;\n    &lt;tr&gt;&lt;th&gt;x&lt;/th&gt;   &lt;th&gt;y&lt;/th&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;1.5&lt;/td&gt; &lt;td&gt;2.7&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;4.9&lt;/td&gt; &lt;td&gt;1.3&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;7.2&lt;/td&gt; &lt;td&gt;8.1&lt;/td&gt;&lt;/tr&gt;\n  &lt;/table&gt;\n  \")\n\nrvest proporciona una funci√≥n que sabe c√≥mo leer este tipo de datos: html_table(). Devuelve una lista que contiene un tibble para cada tabla que se encuentra en la p√°gina. Use html_element() para identificar la tabla que desea extraer:\n\nhtml |&gt; \n  html_element(\".mytable\") |&gt; \n  html_table()\n#&gt; # A tibble: 3 √ó 2\n#&gt;       x     y\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1   1.5   2.7\n#&gt; 2   4.9   1.3\n#&gt; 3   7.2   8.1\n\nTenga en cuenta que x e y se han convertido autom√°ticamente en n√∫meros. Esta conversi√≥n autom√°tica no siempre funciona, por lo que en situaciones m√°s complejas es posible que desee desactivarla con convert = FALSE y luego hacer su propia conversi√≥n.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>24</span>¬† <span class='chapter-title'>Web scraping</span>"
    ]
  },
  {
    "objectID": "webscraping.html#sec-css-selectors",
    "href": "webscraping.html#sec-css-selectors",
    "title": "24¬† Web scraping",
    "section": "\n24.5 Encontrar los selectores apropiados",
    "text": "24.5 Encontrar los selectores apropiados\nAveriguar el selector que necesita para sus datos suele ser la parte m√°s dif√≠cil del problema. A menudo tendr√° que experimentar un poco para encontrar un selector que sea espec√≠fico (es decir, que no seleccione cosas que no le interesen) y sensible (es decir, que seleccione todo lo que le interese). ¬°Muchas pruebas y errores son una parte normal del proceso! Hay dos herramientas principales disponibles para ayudarlo con este proceso: SelectorGadget y las herramientas de desarrollo de su navegador.\nSelectorGadget es un bookmarklet de javascript que genera autom√°ticamente selectores de CSS en funci√≥n de los ejemplos positivos y negativos que proporcione. No siempre funciona, pero cuando lo hace, ¬°es m√°gico! Puede aprender a instalar y usar SelectorGadget leyendo https://rvest.tidyverse.org/articles/selectorgadget.html o viendo el video de Mine en https://www.youtube.com/watch?v=PetWV5g1Xsc.\nTodos los navegadores modernos vienen con un conjunto de herramientas para desarrolladores, pero recomendamos Chrome, incluso si no es su navegador habitual: sus herramientas para desarrolladores web son algunas de las mejores y est√°n disponibles de inmediato. Haga clic con el bot√≥n derecho en un elemento de la p√°gina y haga clic en Inspeccionar. Esto abrir√° una vista ampliable de la p√°gina HTML completa, centrada en el elemento en el que acaba de hacer clic. Puede usar esto para explorar la p√°gina y tener una idea de qu√© selectores podr√≠an funcionar. Preste especial atenci√≥n a los atributos class e id, ya que estos se usan a menudo para formar la estructura visual de la p√°gina y, por lo tanto, son buenas herramientas para extraer los datos que est√° buscando.\nDentro de la vista Elementos, tambi√©n puede hacer clic con el bot√≥n derecho en un elemento y elegir ‚ÄúCopiar como selector‚Äù para generar un selector que identificar√° de forma √∫nica el elemento de inter√©s.\nSi SelectorGadget o Chrome DevTools han generado un selector de CSS que no comprende, pruebe Explicaci√≥n de los selectores que traduce los selectores de CSS al ingl√©s. Si te encuentras haciendo esto mucho, es posible que desees obtener m√°s informaci√≥n sobre los selectores de CSS en general. Recomendamos comenzar con el divertido tutorial CSS Dinner y luego consultar los documentos web de MDN.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>24</span>¬† <span class='chapter-title'>Web scraping</span>"
    ]
  },
  {
    "objectID": "webscraping.html#poniendolo-todo-junto",
    "href": "webscraping.html#poniendolo-todo-junto",
    "title": "24¬† Web scraping",
    "section": "\n24.6 Poniendolo todo junto",
    "text": "24.6 Poniendolo todo junto\nPongamos todo esto junto para extraer datos de algunos sitios web. Existe cierto riesgo de que estos ejemplos ya no funcionen cuando los ejecute; ese es el desaf√≠o fundamental del web scraping; si la estructura del sitio cambia, entonces tendr√° que cambiar su c√≥digo de raspado.\n\n24.6.1 StarWars\nrvest incluye un ejemplo muy simple en vignette(\"starwars\"). Esta es una p√°gina simple con HTML m√≠nimo, por lo que es un buen lugar para comenzar. Te animo a navegar a esa p√°gina ahora y usar ‚ÄúInspeccionar elemento‚Äù para inspeccionar uno de los encabezados que es el t√≠tulo de una pel√≠cula de Star Wars. Use el teclado o el mouse para explorar la jerarqu√≠a del HTML y vea si puede tener una idea de la estructura compartida que usa cada pel√≠cula.\nDeber√≠a poder ver que cada pel√≠cula tiene una estructura compartida que se ve as√≠:\n&lt;section&gt;\n  &lt;h2 data-id=\"1\"&gt;The Phantom Menace&lt;/h2&gt;\n  &lt;p&gt;Released: 1999-05-19&lt;/p&gt;\n  &lt;p&gt;Director: &lt;span class=\"director\"&gt;George Lucas&lt;/span&gt;&lt;/p&gt;\n  \n  &lt;div class=\"crawl\"&gt;\n    &lt;p&gt;...&lt;/p&gt;\n    &lt;p&gt;...&lt;/p&gt;\n    &lt;p&gt;...&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/section&gt;\nNuestro objetivo es convertir estos datos en un marco de datos de 7 filas con las variables title, year, director e intro. Comenzaremos leyendo el HTML y extrayendo todos los elementos &lt;sectionn&gt;:\n\nurl &lt;- \"https://rvest.tidyverse.org/articles/starwars.html\"\nhtml &lt;- read_html(url)\n\nsection &lt;- html |&gt; html_elements(\"section\")\nsection\n#&gt; {xml_nodeset (7)}\n#&gt; [1] &lt;section&gt;&lt;h2 data-id=\"1\"&gt;\\nThe Phantom Menace\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 1 ...\n#&gt; [2] &lt;section&gt;&lt;h2 data-id=\"2\"&gt;\\nAttack of the Clones\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: ...\n#&gt; [3] &lt;section&gt;&lt;h2 data-id=\"3\"&gt;\\nRevenge of the Sith\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased:  ...\n#&gt; [4] &lt;section&gt;&lt;h2 data-id=\"4\"&gt;\\nA New Hope\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 1977-05-2 ...\n#&gt; [5] &lt;section&gt;&lt;h2 data-id=\"5\"&gt;\\nThe Empire Strikes Back\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleas ...\n#&gt; [6] &lt;section&gt;&lt;h2 data-id=\"6\"&gt;\\nReturn of the Jedi\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 1 ...\n#&gt; [7] &lt;section&gt;&lt;h2 data-id=\"7\"&gt;\\nThe Force Awakens\\n&lt;/h2&gt;\\n&lt;p&gt;\\nReleased: 20 ...\n\nEsto recupera siete elementos que coinciden con las siete pel√≠culas que se encuentran en esa p√°gina, lo que sugiere que usar section como selector es bueno. La extracci√≥n de los elementos individuales es sencilla ya que los datos siempre se encuentran en el texto. Solo es cuesti√≥n de encontrar el selector adecuado:\n\nsection |&gt; html_element(\"h2\") |&gt; html_text2()\n#&gt; [1] \"The Phantom Menace\"      \"Attack of the Clones\"   \n#&gt; [3] \"Revenge of the Sith\"     \"A New Hope\"             \n#&gt; [5] \"The Empire Strikes Back\" \"Return of the Jedi\"     \n#&gt; [7] \"The Force Awakens\"\n\nsection |&gt; html_element(\".director\") |&gt; html_text2()\n#&gt; [1] \"George Lucas\"     \"George Lucas\"     \"George Lucas\"    \n#&gt; [4] \"George Lucas\"     \"Irvin Kershner\"   \"Richard Marquand\"\n#&gt; [7] \"J. J. Abrams\"\n\nUna vez que hayamos hecho eso para cada componente, podemos envolver todos los resultados en un tibble:\n\ntibble(\n  title = section |&gt; \n    html_element(\"h2\") |&gt; \n    html_text2(),\n  released = section |&gt; \n    html_element(\"p\") |&gt; \n    html_text2() |&gt; \n    str_remove(\"Released: \") |&gt; \n    parse_date(),\n  director = section |&gt; \n    html_element(\".director\") |&gt; \n    html_text2(),\n  intro = section |&gt; \n    html_element(\".crawl\") |&gt; \n    html_text2()\n)\n#&gt; # A tibble: 7 √ó 4\n#&gt;   title                   released   director         intro                  \n#&gt;   &lt;chr&gt;                   &lt;date&gt;     &lt;chr&gt;            &lt;chr&gt;                  \n#&gt; 1 The Phantom Menace      1999-05-19 George Lucas     \"Turmoil has engulfed ‚Ä¶\n#&gt; 2 Attack of the Clones    2002-05-16 George Lucas     \"There is unrest in th‚Ä¶\n#&gt; 3 Revenge of the Sith     2005-05-19 George Lucas     \"War! The Republic is ‚Ä¶\n#&gt; 4 A New Hope              1977-05-25 George Lucas     \"It is a period of civ‚Ä¶\n#&gt; 5 The Empire Strikes Back 1980-05-17 Irvin Kershner   \"It is a dark time for‚Ä¶\n#&gt; 6 Return of the Jedi      1983-05-25 Richard Marquand \"Luke Skywalker has re‚Ä¶\n#&gt; # ‚Ñπ 1 more row\n\nHicimos un poco m√°s de procesamiento de released para obtener una variable que ser√° f√°cil de usar m√°s adelante en nuestro an√°lisis.\n\n24.6.2 Las mejores pel√≠culas de IMDB\nPara nuestra pr√≥xima tarea, abordaremos algo un poco m√°s complicado, extrayendo las 250 mejores pel√≠culas de la base de datos de pel√≠culas de Internet (IMDb). Cuando escribimos este cap√≠tulo, la p√°gina se parec√≠a a Figura¬†24.1.\n\n\n\n\n\n\n\nFigura¬†24.1: Captura de pantalla de la p√°gina web de las mejores pel√≠culas de IMDb tomada el 2022-12-05.\n\n\n\n\nEstos datos tienen una estructura tabular clara, por lo que vale la pena comenzar con html_table():\n\nurl &lt;- \"https://web.archive.org/web/20220201012049/https://www.imdb.com/chart/top/\"\nhtml &lt;- read_html(url)\n\ntable &lt;- html |&gt; \n  html_element(\"table\") |&gt; \n  html_table()\ntable\n#&gt; # A tibble: 250 √ó 5\n#&gt;   ``    `Rank & Title`                    `IMDb Rating` `Your Rating`   ``   \n#&gt;   &lt;lgl&gt; &lt;chr&gt;                                     &lt;dbl&gt; &lt;chr&gt;           &lt;lgl&gt;\n#&gt; 1 NA    \"1.\\n      The Shawshank Redempt‚Ä¶           9.2 \"12345678910\\n‚Ä¶ NA   \n#&gt; 2 NA    \"2.\\n      The Godfather\\n      ‚Ä¶           9.1 \"12345678910\\n‚Ä¶ NA   \n#&gt; 3 NA    \"3.\\n      The Godfather: Part I‚Ä¶           9   \"12345678910\\n‚Ä¶ NA   \n#&gt; 4 NA    \"4.\\n      The Dark Knight\\n    ‚Ä¶           9   \"12345678910\\n‚Ä¶ NA   \n#&gt; 5 NA    \"5.\\n      12 Angry Men\\n       ‚Ä¶           8.9 \"12345678910\\n‚Ä¶ NA   \n#&gt; 6 NA    \"6.\\n      Schindler's List\\n   ‚Ä¶           8.9 \"12345678910\\n‚Ä¶ NA   \n#&gt; # ‚Ñπ 244 more rows\n\nEsto incluye algunas columnas vac√≠as, pero en general hace un buen trabajo al capturar la informaci√≥n de la tabla. Sin embargo, necesitamos hacer un poco m√°s de procesamiento para que sea m√°s f√°cil de usar. Primero, cambiaremos el nombre de las columnas para que sea m√°s f√°cil trabajar con ellas y eliminaremos los espacios en blanco superfluos en la clasificaci√≥n y el t√≠tulo. Haremos esto con select() (en lugar de rename()) para renombrar y seleccionar solo estas dos columnas en un solo paso. Luego, eliminaremos las l√≠neas nuevas y los espacios adicionales, y luego aplicaremos separate_wider_regex() (de Secci√≥n 15.3.4) para extraer el t√≠tulo, el a√±o y la clasificaci√≥n en sus propias variables.\n\nratings &lt;- table |&gt;\n  select(\n    rank_title_year = `Rank & Title`,\n    rating = `IMDb Rating`\n  ) |&gt; \n  mutate(\n    rank_title_year = str_replace_all(rank_title_year, \"\\n +\", \" \")\n  ) |&gt; \n  separate_wider_regex(\n    rank_title_year,\n    patterns = c(\n      rank = \"\\\\d+\", \"\\\\. \",\n      title = \".+\", \" +\\\\(\",\n      year = \"\\\\d+\", \"\\\\)\"\n    )\n  )\nratings\n#&gt; # A tibble: 250 √ó 4\n#&gt;   rank  title                    year  rating\n#&gt;   &lt;chr&gt; &lt;chr&gt;                    &lt;chr&gt;  &lt;dbl&gt;\n#&gt; 1 1     The Shawshank Redemption 1994     9.2\n#&gt; 2 2     The Godfather            1972     9.1\n#&gt; 3 3     The Godfather: Part II   1974     9  \n#&gt; 4 4     The Dark Knight          2008     9  \n#&gt; 5 5     12 Angry Men             1957     8.9\n#&gt; 6 6     Schindler's List         1993     8.9\n#&gt; # ‚Ñπ 244 more rows\n\nIncluso en este caso, donde la mayor√≠a de los datos provienen de las celdas de la tabla, vale la pena mirar el c√≥digo HTML sin formato. Si lo hace, descubrir√° que podemos agregar un poco de informaci√≥n adicional usando uno de los atributos. Esta es una de las razones por las que vale la pena dedicar un poco de tiempo a explorar el origen de la p√°gina; puede encontrar datos adicionales o puede encontrar una ruta de an√°lisis que sea un poco m√°s f√°cil.\n\nhtml |&gt; \n  html_elements(\"td strong\") |&gt; \n  head() |&gt; \n  html_attr(\"title\")\n#&gt; [1] \"9.2 based on 2,536,415 user ratings\"\n#&gt; [2] \"9.1 based on 1,745,675 user ratings\"\n#&gt; [3] \"9.0 based on 1,211,032 user ratings\"\n#&gt; [4] \"9.0 based on 2,486,931 user ratings\"\n#&gt; [5] \"8.9 based on 749,563 user ratings\"  \n#&gt; [6] \"8.9 based on 1,295,705 user ratings\"\n\nPodemos combinar esto con los datos tabulares y aplicar de nuevo separate_wider_regex() para extraer los datos que nos interesan:\n\nratings |&gt;\n  mutate(\n    rating_n = html |&gt; html_elements(\"td strong\") |&gt; html_attr(\"title\")\n  ) |&gt; \n  separate_wider_regex(\n    rating_n,\n    patterns = c(\n      \"[0-9.]+ based on \",\n      number = \"[0-9,]+\",\n      \" user ratings\"\n    )\n  ) |&gt; \n  mutate(\n    number = parse_number(number)\n  )\n#&gt; # A tibble: 250 √ó 5\n#&gt;   rank  title                    year  rating  number\n#&gt;   &lt;chr&gt; &lt;chr&gt;                    &lt;chr&gt;  &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1 1     The Shawshank Redemption 1994     9.2 2536415\n#&gt; 2 2     The Godfather            1972     9.1 1745675\n#&gt; 3 3     The Godfather: Part II   1974     9   1211032\n#&gt; 4 4     The Dark Knight          2008     9   2486931\n#&gt; 5 5     12 Angry Men             1957     8.9  749563\n#&gt; 6 6     Schindler's List         1993     8.9 1295705\n#&gt; # ‚Ñπ 244 more rows",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>24</span>¬† <span class='chapter-title'>Web scraping</span>"
    ]
  },
  {
    "objectID": "webscraping.html#sitios-din√°micos",
    "href": "webscraping.html#sitios-din√°micos",
    "title": "24¬† Web scraping",
    "section": "\n24.7 Sitios din√°micos",
    "text": "24.7 Sitios din√°micos\nHasta ahora nos hemos centrado en sitios web donde html_elements() devuelve lo que ve en el navegador y discutimos c√≥mo analizar lo que devuelve y c√≥mo organizar esa informaci√≥n en marcos de datos ordenados. De vez en cuando, sin embargo, llegar√°s a un sitio donde html_elements() y tus amigos no devuelven nada parecido a lo que ves en el navegador. En muchos casos, eso se debe a que intenta extraer datos de un sitio web que genera din√°micamente el contenido de la p√°gina con javascript. Actualmente, esto no funciona con rvest, porque rvest descarga el HTML sin formato y no ejecuta ning√∫n javascript.\nTodav√≠a es posible raspar este tipo de sitios, pero rvest necesita usar un proceso m√°s costoso: simular completamente el navegador web, incluida la ejecuci√≥n de todo javascript. Esta funcionalidad no est√° disponible en el momento de escribir este art√≠culo, pero es algo en lo que estamos trabajando activamente y podr√≠a estar disponible para cuando lea esto. Utiliza el [paquete chromote] (https://rstudio.github.io/chromote/index.html) que en realidad ejecuta el navegador Chrome en segundo plano y le brinda herramientas adicionales para interactuar con el sitio, como un texto de escritura humano y haciendo clic en los botones. Consulte el sitio web de rvest para obtener m√°s detalles.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>24</span>¬† <span class='chapter-title'>Web scraping</span>"
    ]
  },
  {
    "objectID": "webscraping.html#resumen",
    "href": "webscraping.html#resumen",
    "title": "24¬† Web scraping",
    "section": "\n24.8 Resumen",
    "text": "24.8 Resumen\nEn este cap√≠tulo, ha aprendido sobre por qu√©, por qu√© no y c√≥mo extraer datos de p√°ginas web. Primero, aprendi√≥ los conceptos b√°sicos de HTML y el uso de selectores de CSS para hacer referencia a elementos espec√≠ficos, luego aprendi√≥ a usar el paquete rvest para obtener datos de HTML en R. Luego demostramos el web scraping con dos casos de estudio: un escenario m√°s simple sobre la extracci√≥n de datos sobre pel√≠culas de StarWars del sitio web del paquete rvest y un escenario m√°s complejo sobre el scraping de las 250 pel√≠culas principales de IMDB.\nLos detalles t√©cnicos de la extracci√≥n de datos de la web pueden ser complejos, especialmente cuando se trata de sitios; sin embargo, las consideraciones legales y √©ticas pueden ser a√∫n m√°s complejas. Es importante que se eduque sobre ambos antes de comenzar a recopilar datos.\nEsto nos lleva al final de la parte de importaci√≥n del libro donde aprendi√≥ t√©cnicas para obtener datos desde donde se encuentran (hojas de c√°lculo, bases de datos, archivos JSON y sitios web) en una forma ordenada en R. Ahora es el momento de dirigir nuestra mirada a un nuevo tema: sacar el m√°ximo provecho de R como lenguaje de programaci√≥n.",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>24</span>¬† <span class='chapter-title'>Web scraping</span>"
    ]
  },
  {
    "objectID": "webscraping.html#footnotes",
    "href": "webscraping.html#footnotes",
    "title": "24¬† Web scraping",
    "section": "",
    "text": "Y muchas API populares ya tienen paquetes CRAN que las envuelven, ¬°as√≠ que comience con una peque√±a investigaci√≥n primero!‚Ü©Ô∏é\nObviamente no somos abogados, y esto no es un consejo legal. Pero este es el mejor resumen que podemos dar despu√©s de haber le√≠do mucho sobre este tema.‚Ü©Ô∏é\nUn ejemplo de un art√≠culo sobre el estudio OkCupid fue publicado por el https://www.wired.com/2016/05/okcupid-study-reveals-perils-big-data-science.‚Ü©Ô∏é\nEsta clase viene del paquete xml2. xml2 es un paquete de bajo nivel en el que se basa rvest.‚Ü©Ô∏é\nrvest tambi√©n proporciona html_text() pero casi siempre debe usar html_text2() ya que hace un mejor trabajo al convertir HTML anidado en texto.‚Ü©Ô∏é",
    "crumbs": [
      "Importar",
      "<span class='chapter-number'>24</span>¬† <span class='chapter-title'>Web scraping</span>"
    ]
  },
  {
    "objectID": "program.html",
    "href": "program.html",
    "title": "Programa",
    "section": "",
    "text": "En esta parte del libro, mejorar√° sus habilidades de programaci√≥n. La programaci√≥n es una habilidad transversal necesaria para todo el trabajo de ciencia de datos: debe usar una computadora para hacer ciencia de datos; no puedes hacerlo en tu cabeza, o con l√°piz y papel.\n\n\n\n\n\n\n\nFigura¬†1: La programaci√≥n es el agua en la que nadan todos los dem√°s componentes.\n\n\n\n\nLa programaci√≥n produce c√≥digo, y el c√≥digo es una herramienta de comunicaci√≥n. Obviamente, el c√≥digo le dice a la computadora lo que quieres que haga. Pero tambi√©n comunica significado a otros humanos. Pensar en el c√≥digo como un veh√≠culo para la comunicaci√≥n es importante porque cada proyecto que haces es fundamentalmente colaborativo. Incluso si no est√° trabajando con otras personas, ¬°definitivamente estar√° trabajando con usted en el futuro! Escribir un c√≥digo claro es importante para que otros (como usted en el futuro) puedan entender por qu√© abord√≥ un an√°lisis de la forma en que lo hizo. Eso significa que mejorar en la programaci√≥n tambi√©n implica mejorar en la comunicaci√≥n. Con el tiempo, desea que su c√≥digo sea no solo m√°s f√°cil de escribir, sino m√°s f√°cil de leer para los dem√°s.\nEn los siguientes tres cap√≠tulos, aprender√° habilidades para mejorar sus habilidades de programaci√≥n:\n\nCopiar y pegar es una herramienta poderosa, pero debes evitar hacerlo m√°s de dos veces. Repetirse en el c√≥digo es peligroso porque puede conducir f√°cilmente a errores e inconsistencias. En cambio, en 25¬† Funciones, aprender√° a escribir funciones que le permitir√°n extraer c√≥digo tidyverse repetido para que pueda reutilizarse f√°cilmente.\nLas funciones extraen c√≥digo repetido, pero a menudo necesita repetir las mismas acciones en diferentes entradas. Necesita herramientas para iteraci√≥n que le permitan hacer cosas similares una y otra vez. Estas herramientas incluyen bucles for y programaci√≥n funcional, que aprender√° en 26¬† Iteraci√≥n.\nA medida que lea m√°s c√≥digo escrito por otros, ver√° m√°s c√≥digo que no usa el tidyverse. En 27¬† Una gu√≠a para R base, aprender√° algunas de las funciones b√°sicas de R m√°s importantes que ver√° en la naturaleza.\n\nEl objetivo de estos cap√≠tulos es ense√±arle lo m√≠nimo sobre programaci√≥n que necesita para la ciencia de datos. Una vez que haya dominado el material aqu√≠, le recomendamos que contin√∫e invirtiendo en sus habilidades de programaci√≥n. Hemos escrito dos libros que pueden resultarle √∫tiles. Hands on Programming with R, de Garrett Grolemund, es una introducci√≥n a R como lenguaje de programaci√≥n y es un excelente lugar para comenzar si R es su primer lenguaje de programaci√≥n. Advanced R por Hadley Wickham se sumerge en los detalles de el lenguaje de programaci√≥n R; es un excelente lugar para comenzar si ya tiene experiencia en programaci√≥n y un excelente pr√≥ximo paso una vez que haya interiorizado las ideas de estos cap√≠tulos.",
    "crumbs": [
      "Programa"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "25¬† Funciones",
    "section": "",
    "text": "25.1 Introducci√≥n\nUna de las mejores formas de mejorar su alcance como cient√≠fico de datos es escribir funciones. Las funciones le permiten automatizar tareas comunes de una manera m√°s potente y general que copiar y pegar. Escribir una funci√≥n tiene cuatro grandes ventajas sobre el uso de copiar y pegar:\nUna buena regla general es considerar escribir una funci√≥n siempre que haya copiado y pegado un bloque de c√≥digo m√°s de dos veces (es decir, ahora tiene tres copias del mismo c√≥digo). En este cap√≠tulo, aprender√° acerca de tres tipos √∫tiles de funciones:\nCada una de estas secciones incluye muchos ejemplos para ayudarlo a generalizar los patrones que ve. Estos ejemplos no ser√≠an posibles sin la ayuda de la gente de Twitter, y le recomendamos que siga los enlaces en el comentario para ver inspiraciones originales. Tambi√©n puede leer los tweets motivadores originales para funciones generales y funciones de gr√°ficas para ver a√∫n m√°s funciones.",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>25</span>¬† <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "functions.html#introducci√≥n",
    "href": "functions.html#introducci√≥n",
    "title": "25¬† Funciones",
    "section": "",
    "text": "Puede dar a una funci√≥n un nombre sugerente que haga que su c√≥digo sea m√°s f√°cil de entender.\nA medida que cambian los requisitos, solo necesita actualizar el c√≥digo en un lugar, en lugar de muchos.\nElimina la posibilidad de cometer errores incidentales al copiar y pegar (es decir, actualizar el nombre de una variable en un lugar, pero no en otro).\nHace que sea m√°s f√°cil reutilizar el trabajo de un proyecto a otro, aumentando su productividad con el tiempo.\n\n\n\nLas funciones vectoriales toman uno o m√°s vectores como entrada y devuelven un vector como salida.\nLas funciones de marco de datos toman un marco de datos como entrada y devuelven un marco de datos como salida.\nFunciones gr√°ficas que toman un marco de datos como entrada y devuelven un gr√°fico como salida.\n\n\n\n25.1.1 Requisitos previos\nAgruparemos una variedad de funciones de todo el tidyverse. Tambi√©n usaremos nycflights13 como fuente de datos familiares para usar nuestras funciones.\n\nlibrary(tidyverse)\nlibrary(nycflights13)",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>25</span>¬† <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "functions.html#funciones-vectoriales",
    "href": "functions.html#funciones-vectoriales",
    "title": "25¬† Funciones",
    "section": "\n25.2 Funciones vectoriales",
    "text": "25.2 Funciones vectoriales\nComenzaremos con las funciones vectoriales: funciones que toman uno o m√°s vectores y devuelven un resultado vectorial. Por ejemplo, eche un vistazo a este c√≥digo. ¬øQu√© hace?\n\ndf &lt;- tibble(\n  a = rnorm(5),\n  b = rnorm(5),\n  c = rnorm(5),\n  d = rnorm(5),\n)\n\ndf |&gt; mutate(\n  a = (a - min(a, na.rm = TRUE)) / \n    (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)),\n  b = (b - min(a, na.rm = TRUE)) / \n    (max(b, na.rm = TRUE) - min(b, na.rm = TRUE)),\n  c = (c - min(c, na.rm = TRUE)) / \n    (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),\n  d = (d - min(d, na.rm = TRUE)) / \n    (max(d, na.rm = TRUE) - min(d, na.rm = TRUE)),\n)\n#&gt; # A tibble: 5 √ó 4\n#&gt;       a       b     c     d\n#&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 0.339  0.387  0.291 0    \n#&gt; 2 0.880 -0.613  0.611 0.557\n#&gt; 3 0     -0.0833 1     0.752\n#&gt; 4 0.795 -0.0822 0     1    \n#&gt; 5 1     -0.0952 0.580 0.394\n\nEs posible que pueda descifrar que esto cambia la escala de cada columna para tener un rango de 0 a 1. Pero, ¬øviste el error? Cuando Hadley escribi√≥ este c√≥digo, cometi√≥ un error al copiar y pegar y olvid√≥ cambiar una a por una b. Prevenir este tipo de error es una muy buena raz√≥n para aprender a escribir funciones.\n\n25.2.1 Escribiendo una funci√≥n\nPara escribir una funci√≥n, primero debe analizar su c√≥digo repetido para determinar qu√© partes son constantes y qu√© partes var√≠an. Si tomamos el c√≥digo anterior y lo extraemos de mutate(), es un poco m√°s f√°cil ver el patr√≥n porque cada repetici√≥n ahora es una l√≠nea:\n\n(a - min(a, na.rm = TRUE)) / (max(a, na.rm = TRUE) - min(a, na.rm = TRUE))\n(b - min(b, na.rm = TRUE)) / (max(b, na.rm = TRUE) - min(b, na.rm = TRUE))\n(c - min(c, na.rm = TRUE)) / (max(c, na.rm = TRUE) - min(c, na.rm = TRUE))\n(d - min(d, na.rm = TRUE)) / (max(d, na.rm = TRUE) - min(d, na.rm = TRUE))  \n\nPara hacer esto un poco m√°s claro, podemos reemplazar el bit que var√≠a con ‚ñà:\n\n(‚ñà - min(‚ñà, na.rm = TRUE)) / (max(‚ñà, na.rm = TRUE) - min(‚ñà, na.rm = TRUE))\n\nPara convertir esto en una funci√≥n necesitas tres cosas:\n\nUn nombre. Aqu√≠ usaremos rescale01 porque esta funci√≥n cambia la escala de un vector para que est√© entre 0 y 1.\nLos argumentos. Los argumentos son cosas que var√≠an seg√∫n las llamadas y nuestro an√°lisis anterior nos dice que solo tenemos uno. Lo llamaremos x porque este es el nombre convencional para un vector num√©rico.\nEl cuerpo**. El cuerpo es el c√≥digo que se repite en todas las llamadas.\n\nLuego creas una funci√≥n siguiendo la plantilla:\n\nname &lt;- function(arguments) {\n  body\n}\n\nPara este caso que conduce a:\n\nrescale01 &lt;- function(x) {\n  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n}\n\nEn este punto, puede probar con algunas entradas simples para asegurarse de haber capturado la l√≥gica correctamente:\n\nrescale01(c(-10, 0, 10))\n#&gt; [1] 0.0 0.5 1.0\nrescale01(c(1, 2, 3, NA, 5))\n#&gt; [1] 0.00 0.25 0.50   NA 1.00\n\nEntonces puedes reescribir la llamada a mutate() como:\n\ndf |&gt; mutate(\n  a = rescale01(a),\n  b = rescale01(b),\n  c = rescale01(c),\n  d = rescale01(d),\n)\n#&gt; # A tibble: 5 √ó 4\n#&gt;       a     b     c     d\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 0.339 1     0.291 0    \n#&gt; 2 0.880 0     0.611 0.557\n#&gt; 3 0     0.530 1     0.752\n#&gt; 4 0.795 0.531 0     1    \n#&gt; 5 1     0.518 0.580 0.394\n\n(En Cap√≠tulo 26, aprender√° a usar across() para reducir a√∫n m√°s la duplicaci√≥n, por lo que todo lo que necesita es df |&gt; mutate(across(a:d, rescale01))).\n\n25.2.2 Mejorando nuestra funci√≥n\nPuede notar que la funci√≥n rescale01() hace un trabajo innecesario ‚Äî en lugar de calcular min() dos veces y max() una vez, podr√≠amos calcular tanto el m√≠nimo como el m√°ximo en un solo paso con range( ):\n\nrescale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\nO puede probar esta funci√≥n en un vector que incluye un valor infinito:\n\nx &lt;- c(1:10, Inf)\nrescale01(x)\n#&gt;  [1]   0   0   0   0   0   0   0   0   0   0 NaN\n\nEse resultado no es particularmente √∫til, por lo que podr√≠amos pedirle a range() que ignore valores infinitos:\n\nrescale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE, finite = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\nrescale01(x)\n#&gt;  [1] 0.0000000 0.1111111 0.2222222 0.3333333 0.4444444 0.5555556 0.6666667\n#&gt;  [8] 0.7777778 0.8888889 1.0000000       Inf\n\nEstos cambios ilustran un beneficio importante de las funciones: debido a que hemos movido el c√≥digo repetido a una funci√≥n, solo necesitamos hacer el cambio en un lugar.\n\n25.2.3 Funciones mutate\nAhora que tienes la idea b√°sica de las funciones, echemos un vistazo a un mont√≥n de ejemplos. Comenzaremos mirando las funciones de ‚Äúmutate‚Äù, es decir, funciones que funcionan bien dentro de mutate() y filter() porque devuelven una salida de la misma longitud que la entrada.\nComencemos con una variaci√≥n simple de rescale01(). Tal vez quiera calcular el puntaje Z, reescalar un vector para que tenga una media de cero y una desviaci√≥n est√°ndar de uno:\n\nz_score &lt;- function(x) {\n  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)\n}\n\nO tal vez quieras terminar un case_when() sencillo y darle un nombre √∫til. Por ejemplo, esta funci√≥n clamp() asegura que todos los valores de un vector se encuentran entre un m√≠nimo o un m√°ximo:\n\nclamp &lt;- function(x, min, max) {\n  case_when(\n    x &lt; min ~ min,\n    x &gt; max ~ max,\n    .default = x\n  )\n}\n\nclamp(1:10, min = 3, max = 7)\n#&gt;  [1] 3 3 3 4 5 6 7 7 7 7\n\nPor supuesto, las funciones no solo necesitan trabajar con variables num√©ricas. Es posible que desee realizar una manipulaci√≥n repetida de cadenas. Tal vez necesites hacer el primer car√°cter en may√∫sculas:\n\nfirst_upper &lt;- function(x) {\n  str_sub(x, 1, 1) &lt;- str_to_upper(str_sub(x, 1, 1))\n  x\n}\n\nfirst_upper(\"hello\")\n#&gt; [1] \"Hello\"\n\nO tal vez desee eliminar los signos de porcentaje, las comas y los signos de d√≥lar de una cadena antes de convertirla en un n√∫mero:\n\n# https://twitter.com/NVlabormarket/status/1571939851922198530\nclean_number &lt;- function(x) {\n  is_pct &lt;- str_detect(x, \"%\")\n  num &lt;- x |&gt; \n    str_remove_all(\"%\") |&gt; \n    str_remove_all(\",\") |&gt; \n    str_remove_all(fixed(\"$\")) |&gt; \n    as.numeric()\n  if_else(is_pct, num / 100, num)\n}\n\nclean_number(\"$12,300\")\n#&gt; [1] 12300\nclean_number(\"45%\")\n#&gt; [1] 0.45\n\nA veces, sus funciones estar√°n altamente especializadas para un paso de an√°lisis de datos. Por ejemplo, si tiene un mont√≥n de variables que registran valores faltantes como 997, 998 o 999, puede escribir una funci√≥n para reemplazarlos con NA:\n\nfix_na &lt;- function(x) {\n  if_else(x %in% c(997, 998, 999), NA, x)\n}\n\nNos hemos centrado en ejemplos que toman un solo vector porque creemos que son los m√°s comunes. Pero no hay raz√≥n para que su funci√≥n no pueda tomar m√∫ltiples entradas de vectores.\n\n25.2.4 Funciones summary\nOtra familia importante de funciones vectoriales son las funciones de resumen, funciones que devuelven un √∫nico valor para usar en summarize(). A veces, esto puede ser simplemente una cuesti√≥n de establecer uno o dos argumentos predeterminados:\n\ncommas &lt;- function(x) {\n  str_flatten(x, collapse = \", \", last = \" and \")\n}\n\ncommas(c(\"cat\", \"dog\", \"pigeon\"))\n#&gt; [1] \"cat, dog and pigeon\"\n\nO podr√≠a terminar un c√°lculo simple, como el coeficiente de variaci√≥n, que divide la desviaci√≥n est√°ndar por la media:\n\ncv &lt;- function(x, na.rm = FALSE) {\n  sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)\n}\n\ncv(runif(100, min = 0, max = 50))\n#&gt; [1] 0.5196276\ncv(runif(100, min = 0, max = 500))\n#&gt; [1] 0.5652554\n\nO tal vez solo quiera hacer que un patr√≥n com√∫n sea m√°s f√°cil de recordar d√°ndole un nombre f√°cil de recordar:\n\n# https://twitter.com/gbganalyst/status/1571619641390252033\nn_missing &lt;- function(x) {\n  sum(is.na(x))\n} \n\nTambi√©n puede escribir funciones con m√∫ltiples entradas vectoriales. Por ejemplo, tal vez desee calcular el error de predicci√≥n absoluto medio para ayudarlo a comparar las predicciones del modelo con los valores reales:\n\n# https://twitter.com/neilgcurrie/status/1571607727255834625\nmape &lt;- function(actual, predicted) {\n  sum(abs((actual - predicted) / actual)) / length(actual)\n}\n\n\n\n\n\n\n\nRStudio\n\n\n\nUna vez que comience a escribir funciones, hay dos accesos directos de RStudio que son muy √∫tiles:\n\nPara encontrar la definici√≥n de una funci√≥n que hayas escrito, coloca el cursor sobre el nombre de la funci√≥n y presiona F2.\nPara saltar r√°pidamente a una funci√≥n, presione Ctrl + . para abrir el archivo difuso y el buscador de funciones y escriba las primeras letras del nombre de su funci√≥n. Tambi√©n puede navegar a archivos, secciones en Quarto y m√°s, lo que la convierte en una herramienta de navegaci√≥n muy √∫til.\n\n\n\n\n25.2.5 Ejercicios\n\n\nPractique convertir los siguientes fragmentos de c√≥digo en funciones. Piensa en lo que hace cada funci√≥n. ¬øComo lo llamarias? ¬øCu√°ntos argumentos necesita?\n\nmean(is.na(x))\nmean(is.na(y))\nmean(is.na(z))\n\nx / sum(x, na.rm = TRUE)\ny / sum(y, na.rm = TRUE)\nz / sum(z, na.rm = TRUE)\n\nround(x / sum(x, na.rm = TRUE) * 100, 1)\nround(y / sum(y, na.rm = TRUE) * 100, 1)\nround(z / sum(z, na.rm = TRUE) * 100, 1)\n\n\nEn la segunda variante de rescale01(), los valores infinitos se dejan sin cambios. ¬øPuedes reescribir rescale01() para que -Inf se asigne a 0 e Inf se asigne a 1?\nDado un vector de fechas de nacimiento, escribe una funci√≥n para calcular la edad en a√±os.\nEscriba sus propias funciones para calcular la varianza y la asimetr√≠a de un vector num√©rico. Puede buscar las definiciones en Wikipedia o en otro lugar.\nEscriba both_na(), una funci√≥n de resumen que toma dos vectores de la misma longitud y devuelve el n√∫mero de posiciones que tienen un NA en ambos vectores.\n\nLea la documentaci√≥n para averiguar qu√© hacen las siguientes funciones. ¬øPor qu√© son √∫tiles a pesar de que son tan cortos?\n\nis_directory &lt;- function(x) {\n  file.info(x)$isdir\n}\nis_readable &lt;- function(x) {\n  file.access(x, 4) == 0\n}",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>25</span>¬† <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "functions.html#funciones-de-data-frame",
    "href": "functions.html#funciones-de-data-frame",
    "title": "25¬† Funciones",
    "section": "\n25.3 Funciones de data frame",
    "text": "25.3 Funciones de data frame\nLas funciones vectoriales son √∫tiles para extraer c√≥digo que se repite dentro de un verbo dplyr. Pero a menudo tambi√©n repetir√° los verbos, particularmente dentro de un pipe grande. Cuando se d√© cuenta de que est√° copiando y pegando varios verbos varias veces, podr√≠a pensar en escribir una funci√≥n de data frame. Las funciones de data frame funcionan como los verbos dplyr: toman un data frame como primer argumento, algunos argumentos adicionales que dicen qu√© hacer con √©l y devuelven un data frame o un vector.\nPara permitirle escribir una funci√≥n que use verbos dplyr, primero le presentaremos el desaf√≠o de la indirecci√≥n y c√≥mo puede superarlo abrazando, {{ }}. Con esta teor√≠a en su haber, le mostraremos un mont√≥n de ejemplos para ilustrar lo que podr√≠a hacer con ella.\n\n25.3.1 Evaluaci√≥n indirecta y ordenada\nCuando comienza a escribir funciones que usan verbos dplyr, r√°pidamente se encuentra con el problema de la indirecci√≥n. Ilustremos el problema con una funci√≥n muy simple: grouped_mean(). El objetivo de esta funci√≥n es calcular la media de mean_var agrupada por group_var:\n\ngrouped_mean &lt;- function(df, group_var, mean_var) {\n  df |&gt; \n    group_by(group_var) |&gt; \n    summarize(mean(mean_var))\n}\n\nSi lo intentamos y lo usamos, obtenemos un error:\n\ndiamonds |&gt; grouped_mean(cut, carat)\n#&gt; Error in `group_by()`:\n#&gt; ! Must group by variables found in `.data`.\n#&gt; ‚úñ Column `group_var` is not found.\n\nPara hacer el problema un poco m√°s claro, podemos usar un marco de datos inventado:\n\ndf &lt;- tibble(\n  mean_var = 1,\n  group_var = \"g\",\n  group = 1,\n  x = 10,\n  y = 100\n)\n\ndf |&gt; grouped_mean(group, x)\n#&gt; # A tibble: 1 √ó 2\n#&gt;   group_var `mean(mean_var)`\n#&gt;   &lt;chr&gt;                &lt;dbl&gt;\n#&gt; 1 g                        1\ndf |&gt; grouped_mean(group, y)\n#&gt; # A tibble: 1 √ó 2\n#&gt;   group_var `mean(mean_var)`\n#&gt;   &lt;chr&gt;                &lt;dbl&gt;\n#&gt; 1 g                        1\n\nIndependientemente de c√≥mo llamemos a grouped_mean(), siempre hace df |&gt; group_by(group_var) |&gt; resume(mean(mean_var)), en lugar de df |&gt; group_by(group) |&gt; resume(mean(x) ) o df |&gt; group_by(group) |&gt; resume(mean(y)). Este es un problema de direccionamiento indirecto, y surge porque dplyr usa evaluaci√≥n ordenada para permitirle referirse a los nombres de las variables dentro de su marco de datos sin ning√∫n tratamiento especial.\nLa evaluaci√≥n ordenada es excelente el 95% de las veces porque hace que sus an√°lisis de datos sean muy concisos, ya que nunca tiene que decir de qu√© marco de datos proviene una variable; es obvio por el contexto. La desventaja de la evaluaci√≥n ordenada surge cuando queremos envolver el c√≥digo tidyverse repetido en una funci√≥n. Aqu√≠ necesitamos alguna forma de decirle a group_mean() y summarize() que no traten group_var y mean_var como el nombre de las variables, sino que busquen dentro de ellas la variable que realmente queremos usar.\nLa evaluaci√≥n ordenada incluye una soluci√≥n a este problema llamada abrazar ü§ó. Abrazar una variable significa envolverla entre llaves para que (por ejemplo) var se convierta en {{ var }}. Abrazar una variable le dice a dplyr que use el valor almacenado dentro del argumento, no el argumento como el nombre literal de la variable. Una forma de recordar lo que est√° pasando es pensar en {{ }} como mirar hacia abajo en un t√∫nel ‚Äî {{ var }} har√° que una funci√≥n dplyr mire dentro de var en lugar de buscar una variable llamada var.\nEntonces, para hacer que grouped_mean() funcione, necesitamos rodear group_var y mean_var con {{ }}:\n\ngrouped_mean &lt;- function(df, group_var, mean_var) {\n  df |&gt; \n    group_by({{ group_var }}) |&gt; \n    summarize(mean({{ mean_var }}))\n}\n\ndf |&gt; grouped_mean(group, x)\n#&gt; # A tibble: 1 √ó 2\n#&gt;   group `mean(x)`\n#&gt;   &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1     1        10\n\n¬°√âxito!\n\n25.3.2 ¬øCu√°ndo abrazar?\nEntonces, el desaf√≠o clave al escribir funciones de data frame es descubrir qu√© argumentos deben adoptarse. Afortunadamente, esto es f√°cil porque puedes buscarlo en la documentaci√≥n üòÑ. Hay dos t√©rminos para buscar en los documentos que corresponden a los dos subtipos m√°s comunes de evaluaci√≥n ordenada:\n\nData-masking (Enmascaramiento de datos): esto se usa en funciones como arrange(), filter() y summarize() que calculan con variables.\nTidy-selection (Selecci√≥n ordenada): esto se usa para funciones como select(), relocate() y rename() que seleccionan variables.\n\nSu intuici√≥n sobre qu√© argumentos usan una evaluaci√≥n ordenada deber√≠a ser buena para muchas funciones comunes ‚Äî solo piense si puede calcular (por ejemplo, x + 1) o seleccionar (por ejemplo, a:x).\nEn las siguientes secciones, exploraremos los tipos de funciones √∫tiles que podr√≠a escribir una vez que comprenda la adopci√≥n.\n\n25.3.3 Casos de uso comunes\nSi normalmente realiza el mismo conjunto de res√∫menes cuando realiza la exploraci√≥n inicial de datos, podr√≠a considerar incluirlos en una funci√≥n de ayuda:\n\nsummary6 &lt;- function(data, var) {\n  data |&gt; summarize(\n    min = min({{ var }}, na.rm = TRUE),\n    mean = mean({{ var }}, na.rm = TRUE),\n    median = median({{ var }}, na.rm = TRUE),\n    max = max({{ var }}, na.rm = TRUE),\n    n = n(),\n    n_miss = sum(is.na({{ var }})),\n    .groups = \"drop\"\n  )\n}\n\ndiamonds |&gt; summary6(carat)\n#&gt; # A tibble: 1 √ó 6\n#&gt;     min  mean median   max     n n_miss\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1   0.2 0.798    0.7  5.01 53940      0\n\n(Cada vez que envuelve summarize() en un asistente, creemos que es una buena pr√°ctica configurar .groups = \"drop\" para evitar el mensaje y dejar los datos en un estado desagrupado).\nLo bueno de esta funci√≥n es que, debido a que envuelve summarize(), puede usarla en datos agrupados:\n\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summary6(carat)\n#&gt; # A tibble: 5 √ó 7\n#&gt;   cut         min  mean median   max     n n_miss\n#&gt;   &lt;ord&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1 Fair       0.22 1.05    1     5.01  1610      0\n#&gt; 2 Good       0.23 0.849   0.82  3.01  4906      0\n#&gt; 3 Very Good  0.2  0.806   0.71  4    12082      0\n#&gt; 4 Premium    0.2  0.892   0.86  4.01 13791      0\n#&gt; 5 Ideal      0.2  0.703   0.54  3.5  21551      0\n\nAdem√°s, dado que los argumentos para resumir son un enmascaramiento de datos, tambi√©n significa que el argumento var para summary6() es un enmascaramiento de datos. Eso significa que tambi√©n puede resumir las variables calculadas:\n\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summary6(log10(carat))\n#&gt; # A tibble: 5 √ó 7\n#&gt;   cut          min    mean  median   max     n n_miss\n#&gt;   &lt;ord&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1 Fair      -0.658 -0.0273  0      0.700  1610      0\n#&gt; 2 Good      -0.638 -0.133  -0.0862 0.479  4906      0\n#&gt; 3 Very Good -0.699 -0.164  -0.149  0.602 12082      0\n#&gt; 4 Premium   -0.699 -0.125  -0.0655 0.603 13791      0\n#&gt; 5 Ideal     -0.699 -0.225  -0.268  0.544 21551      0\n\nPara resumir varias variables, deber√° esperar hasta Secci√≥n 26.2, donde aprender√° a usar across().\nOtra funci√≥n auxiliar popular summarize() es una versi√≥n de count() que tambi√©n calcula proporciones:\n\n# https://twitter.com/Diabb6/status/1571635146658402309\ncount_prop &lt;- function(df, var, sort = FALSE) {\n  df |&gt;\n    count({{ var }}, sort = sort) |&gt;\n    mutate(prop = n / sum(n))\n}\n\ndiamonds |&gt; count_prop(clarity)\n#&gt; # A tibble: 8 √ó 3\n#&gt;   clarity     n   prop\n#&gt;   &lt;ord&gt;   &lt;int&gt;  &lt;dbl&gt;\n#&gt; 1 I1        741 0.0137\n#&gt; 2 SI2      9194 0.170 \n#&gt; 3 SI1     13065 0.242 \n#&gt; 4 VS2     12258 0.227 \n#&gt; 5 VS1      8171 0.151 \n#&gt; 6 VVS2     5066 0.0939\n#&gt; # ‚Ñπ 2 more rows\n\nEsta funci√≥n tiene tres argumentos: df, var y sort, y solo var debe aceptarse porque se pasa a count(), que utiliza el enmascaramiento de datos para todas las variables. Tenga en cuenta que usamos un valor predeterminado para sort, de modo que si el usuario no proporciona su propio valor, el valor predeterminado ser√° FALSE.\nO tal vez quiera encontrar los valores √∫nicos ordenados de una variable para un subconjunto de los datos. En lugar de proporcionar una variable y un valor para realizar el filtrado, permitiremos que el usuario proporcione una condici√≥n:\n\nunique_where &lt;- function(df, condition, var) {\n  df |&gt; \n    filter({{ condition }}) |&gt; \n    distinct({{ var }}) |&gt; \n    arrange({{ var }})\n}\n\n# Encuentra todos los destinos en diciembre\nflights |&gt; unique_where(month == 12, dest)\n#&gt; # A tibble: 96 √ó 1\n#&gt;   dest \n#&gt;   &lt;chr&gt;\n#&gt; 1 ABQ  \n#&gt; 2 ALB  \n#&gt; 3 ATL  \n#&gt; 4 AUS  \n#&gt; 5 AVL  \n#&gt; 6 BDL  \n#&gt; # ‚Ñπ 90 more rows\n\nAqu√≠ adoptamos condition porque se pasa a filter() y var porque se pasa a distinct() y arrange().\nHicimos todos estos ejemplos para tomar un data frame como el primer argumento, pero si est√° trabajando repetidamente con los mismos datos, puede tener sentido codificarlo. Por ejemplo, la siguiente funci√≥n siempre funciona con el conjunto de datos de vuelos y siempre selecciona time_hour, carrier y flight, ya que forman la clave principal compuesta que le permite identificar una fila.\n\nsubset_flights &lt;- function(rows, cols) {\n  flights |&gt; \n    filter({{ rows }}) |&gt; \n    select(time_hour, carrier, flight, {{ cols }})\n}\n\n\n25.3.4 Enmascaramiento de datos vs selecci√≥n ordenada\nA veces desea seleccionar variables dentro de una funci√≥n que usa enmascaramiento de datos. Por ejemplo, imagina que quieres escribir un count_missing() que cuente el n√∫mero de observaciones que faltan en las filas. Puedes intentar escribir algo como:\n\ncount_missing &lt;- function(df, group_vars, x_var) {\n  df |&gt; \n    group_by({{ group_vars }}) |&gt; \n    summarize(\n      n_miss = sum(is.na({{ x_var }})),\n      .groups = \"drop\"\n    )\n}\n\nflights |&gt; \n  count_missing(c(year, month, day), dep_time)\n#&gt; Error in `group_by()`:\n#&gt; ‚Ñπ In argument: `c(year, month, day)`.\n#&gt; Caused by error:\n#&gt; ! `c(year, month, day)` must be size 336776 or 1, not 1010328.\n\nEsto no funciona porque group_by() usa enmascaramiento de datos, no selecci√≥n ordenada. Podemos solucionar ese problema usando la pr√°ctica funci√≥n pick(), que le permite usar la selecci√≥n ordenada dentro de las funciones de enmascaramiento de datos:\n\ncount_missing &lt;- function(df, group_vars, x_var) {\n  df |&gt; \n    group_by(pick({{ group_vars }})) |&gt; \n    summarize(\n      n_miss = sum(is.na({{ x_var }})),\n      .groups = \"drop\"\n  )\n}\n\nflights |&gt; \n  count_missing(c(year, month, day), dep_time)\n#&gt; # A tibble: 365 √ó 4\n#&gt;    year month   day n_miss\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1  2013     1     1      4\n#&gt; 2  2013     1     2      8\n#&gt; 3  2013     1     3     10\n#&gt; 4  2013     1     4      6\n#&gt; 5  2013     1     5      3\n#&gt; 6  2013     1     6      1\n#&gt; # ‚Ñπ 359 more rows\n\nOtro uso conveniente de pick() es hacer una tabla de cuentas en 2D. Aqu√≠ contamos usando todas las variables en las filas y columnas, luego usamos pivot_wider() para reorganizar los conteos en una cuadr√≠cula:\n\n# https://twitter.com/pollicipes/status/1571606508944719876\ncount_wide &lt;- function(data, rows, cols) {\n  data |&gt; \n    count(pick(c({{ rows }}, {{ cols }}))) |&gt; \n    pivot_wider(\n      names_from = {{ cols }}, \n      values_from = n,\n      names_sort = TRUE,\n      values_fill = 0\n    )\n}\n\ndiamonds |&gt; count_wide(c(clarity, color), cut)\n#&gt; # A tibble: 56 √ó 7\n#&gt;   clarity color  Fair  Good `Very Good` Premium Ideal\n#&gt;   &lt;ord&gt;   &lt;ord&gt; &lt;int&gt; &lt;int&gt;       &lt;int&gt;   &lt;int&gt; &lt;int&gt;\n#&gt; 1 I1      D         4     8           5      12    13\n#&gt; 2 I1      E         9    23          22      30    18\n#&gt; 3 I1      F        35    19          13      34    42\n#&gt; 4 I1      G        53    19          16      46    16\n#&gt; 5 I1      H        52    14          12      46    38\n#&gt; 6 I1      I        34     9           8      24    17\n#&gt; # ‚Ñπ 50 more rows\n\nSi bien nuestros ejemplos se han centrado principalmente en dplyr, la evaluaci√≥n ordenada tambi√©n respalda a tidyr, y si observa los documentos pivot_wider(), puede ver que names_from usa una selecci√≥n ordenada.\n\n25.3.5 Ejercicios\n\n\nUsando los conjuntos de datos de nycflights13, escriba una funci√≥n que:\n\n\nEncuentra todos los vuelos que fueron cancelados (es decir, is.na(arr_time)) o retrasados por m√°s de una hora.\n\nflights |&gt; filter_severe()\n\n\n\nCuenta el n√∫mero de vuelos cancelados y el n√∫mero de vuelos retrasados por m√°s de una hora.\n\nflights |&gt; group_by(dest) |&gt; summarize_severe()\n\n\n\nEncuentra todos los vuelos que fueron cancelados o retrasados por m√°s de un n√∫mero de horas proporcionado por el usuario:\n\nflights |&gt; filter_severe(hours = 2)\n\n\n\nResume el clima para calcular el m√≠nimo, la media y el m√°ximo de una variable proporcionada por el usuario:\n\nweather |&gt; summarize_weather(temp)\n\n\n\nConvierte la variable proporcionada por el usuario que utiliza la hora del reloj (por ejemplo, dep_time, arr_time, etc.) en una hora decimal (es decir, hours + (minutes/60)).\n\nflights |&gt; standardize_time(sched_dep_time)\n\n\n\n\nPara cada una de las siguientes funciones, enumere todos los argumentos que usan evaluaci√≥n ordenada y describa si usan enmascaramiento de datos o selecci√≥n ordenada: distinct(), count(), group_by(), rename_with(), slice_min(), slice_sample().\n\nGeneralice la siguiente funci√≥n para que pueda proporcionar cualquier n√∫mero de variables para contar.\n\ncount_prop &lt;- function(df, var, sort = FALSE) {\n  df |&gt;\n    count({{ var }}, sort = sort) |&gt;\n    mutate(prop = n / sum(n))\n}",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>25</span>¬† <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "functions.html#funciones-de-gr√°ficas",
    "href": "functions.html#funciones-de-gr√°ficas",
    "title": "25¬† Funciones",
    "section": "\n25.4 Funciones de gr√°ficas",
    "text": "25.4 Funciones de gr√°ficas\nEn lugar de devolver un data frame, es posible que desee devolver un gr√°fico. Afortunadamente, puedes usar las mismas t√©cnicas con ggplot2, porque aes() es una funci√≥n de enmascaramiento de datos. Por ejemplo, imagina que est√°s haciendo muchos histogramas:\n\ndiamonds |&gt; \n  ggplot(aes(x = carat)) +\n  geom_histogram(binwidth = 0.1)\n\ndiamonds |&gt; \n  ggplot(aes(x = carat)) +\n  geom_histogram(binwidth = 0.05)\n\n¬øNo ser√≠a bueno si pudieras envolver esto en una funci√≥n de histograma? Esto es muy f√°cil una vez que sabe que aes () es una funci√≥n de enmascaramiento de datos y debe adoptar:\n\nhistogram &lt;- function(df, var, binwidth = NULL) {\n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth)\n}\n\ndiamonds |&gt; histogram(carat, 0.1)\n\n\n\n\n\n\n\nTenga en cuenta que histogram() devuelve un gr√°fico ggplot2, lo que significa que a√∫n puede agregar componentes adicionales si lo desea. Solo recuerda cambiar de |&gt; a +:\n\ndiamonds |&gt; \n  histogram(carat, 0.1) +\n  labs(x = \"Size (in carats)\", y = \"Number of diamonds\")\n\n\n25.4.1 M√°s variables\nEs sencillo agregar m√°s variables a la mezcla. Por ejemplo, tal vez desee una manera f√°cil de observar si un conjunto de datos es lineal o no al superponer una l√≠nea suave y una l√≠nea recta:\n\n# https://twitter.com/tyler_js_smith/status/1574377116988104704\nlinearity_check &lt;- function(df, x, y) {\n  df |&gt;\n    ggplot(aes(x = {{ x }}, y = {{ y }})) +\n    geom_point() +\n    geom_smooth(method = \"loess\", formula = y ~ x, color = \"red\", se = FALSE) +\n    geom_smooth(method = \"lm\", formula = y ~ x, color = \"blue\", se = FALSE) \n}\n\nstarwars |&gt; \n  filter(mass &lt; 1000) |&gt; \n  linearity_check(mass, height)\n\n\n\n\n\n\n\nO tal vez desee una alternativa a los diagramas de dispersi√≥n de colores para conjuntos de datos muy grandes en los que la superposici√≥n de gr√°ficos es un problema:\n\n# https://twitter.com/ppaxisa/status/1574398423175921665\nhex_plot &lt;- function(df, x, y, z, bins = 20, fun = \"mean\") {\n  df |&gt; \n    ggplot(aes(x = {{ x }}, y = {{ y }}, z = {{ z }})) + \n    stat_summary_hex(\n      aes(color = after_scale(fill)), # make border same color as fill\n      bins = bins, \n      fun = fun,\n    )\n}\n\ndiamonds |&gt; hex_plot(carat, price, depth)\n\n\n\n\n\n\n\n\n25.4.2 Combinando con otros tidyverse\nAlgunos de los ayudantes m√°s √∫tiles combinan una pizca de manipulaci√≥n de datos con ggplot2. Por ejemplo, si desea hacer un gr√°fico de barras verticales en el que ordene autom√°ticamente las barras en orden de frecuencia usando fct_infreq(). Dado que el gr√°fico de barras es vertical, tambi√©n debemos invertir el orden habitual para obtener los valores m√°s altos en la parte superior:\n\nsorted_bars &lt;- function(df, var) {\n  df |&gt; \n    mutate({{ var }} := fct_rev(fct_infreq({{ var }})))  |&gt;\n    ggplot(aes(y = {{ var }})) +\n    geom_bar()\n}\n\ndiamonds |&gt; sorted_bars(clarity)\n\n\n\n\n\n\n\nTenemos que usar un nuevo operador aqu√≠, := (com√∫nmente conocido como ‚Äúoperador morsa‚Äù), porque estamos generando el nombre de la variable en funci√≥n de los datos proporcionados por el usuario. Los nombres de las variables van en el lado izquierdo de =, pero la sintaxis de R no permite nada a la izquierda de = excepto un solo nombre literal. Para solucionar este problema, usamos el operador especial := que la evaluaci√≥n ordenada trata exactamente de la misma manera que =.\nO tal vez desee que sea m√°s f√°cil dibujar un gr√°fico de barras solo para un subconjunto de los datos:\n\nconditional_bars &lt;- function(df, condition, var) {\n  df |&gt; \n    filter({{ condition }}) |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_bar()\n}\n\ndiamonds |&gt; conditional_bars(cut == \"Good\", clarity)\n\n\n\n\n\n\n\nTambi√©n puede ser creativo y mostrar res√∫menes de datos de otras maneras. Puede encontrar una aplicaci√≥n interesante en https://gist.github.com/Gshotwell/b19ef520b6d56f61a830fabb3454965b; utiliza las etiquetas de los ejes para mostrar el valor m√°s alto. A medida que aprenda m√°s sobre ggplot2, el poder de sus funciones seguir√° aumentando.\nTerminaremos con un caso m√°s complicado: etiquetar las parcelas que creas.\n\n25.4.3 Etiquetado\n¬øRecuerdas la funci√≥n de histograma que te mostramos antes?\n\nhistogram &lt;- function(df, var, binwidth = NULL) {\n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth)\n}\n\n¬øNo ser√≠a bueno si pudi√©ramos etiquetar la salida con la variable y el ancho del contenedor que se us√≥? Para hacerlo, vamos a tener que pasar por debajo de las s√°banas de la evaluaci√≥n ordenada y usar una funci√≥n del paquete del que a√∫n no hemos hablado: rlang. rlang es un paquete de bajo nivel que es utilizado por casi todos los dem√°s paquetes en el tidyverse porque implementa una evaluaci√≥n ordenada (as√≠ como muchas otras herramientas √∫tiles).\nPara resolver el problema de etiquetado podemos usar rlang::englue(). Esto funciona de manera similar a str_glue(), por lo que cualquier valor envuelto en { } se insertar√° en la cadena. Pero tambi√©n entiende {{ }}, que inserta autom√°ticamente el nombre de variable apropiado:\n\nhistogram &lt;- function(df, var, binwidth) {\n  label &lt;- rlang::englue(\"A histogram of {{var}} with binwidth {binwidth}\")\n  \n  df |&gt; \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth) + \n    labs(title = label)\n}\n\ndiamonds |&gt; histogram(carat, 0.1)\n\n\n\n\n\n\n\nPuede usar el mismo enfoque en cualquier otro lugar donde desee proporcionar una cadena en un gr√°fico ggplot2.\n\n25.4.4 Ejercicios\nCree una funci√≥n de trazado enriquecida implementando de forma incremental cada uno de los pasos a continuaci√≥n:\n\nDibuje un diagrama de dispersi√≥n dado el conjunto de datos y las variables x e y.\nAgregue una l√≠nea de mejor ajuste (es decir, un modelo lineal sin errores est√°ndar).\nAgregue un t√≠tulo.",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>25</span>¬† <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "functions.html#estilo",
    "href": "functions.html#estilo",
    "title": "25¬† Funciones",
    "section": "\n25.5 Estilo",
    "text": "25.5 Estilo\nA R no le importa c√≥mo se llamen sus funciones o argumentos, pero los nombres marcan una gran diferencia para los humanos. Idealmente, el nombre de su funci√≥n ser√° corto, pero evocar√° claramente lo que hace la funci√≥n. ¬°Eso es dif√≠cil! Pero es mejor ser claro que breve, ya que el autocompletado de RStudio facilita la escritura de nombres largos.\nGeneralmente, los nombres de las funciones deben ser verbos y los argumentos deben ser sustantivos. Hay algunas excepciones: los sustantivos est√°n bien si la funci√≥n calcula un sustantivo muy conocido (es decir, mean() es mejor que compute_mean()), o acceder a alguna propiedad de un objeto (es decir, coef() es mejor que obtener_coeficientes()). Use su mejor juicio y no tenga miedo de cambiar el nombre de una funci√≥n si descubre un nombre mejor m√°s tarde.\n\n# Demasiado corto\nf()\n\n# Ni verbo ni descriptivo\nmy_awesome_function()\n\n# Largo pero no claro\nimpute_missing()\ncollapse_years()\n\nA R tampoco le importa c√≥mo usa el espacio en blanco en sus funciones, pero a los futuros lectores s√≠. Contin√∫e siguiendo las reglas de Cap√≠tulo 4. Adem√°s, function() siempre debe ir seguida de corchetes ondulados ({}), y el contenido debe tener una sangr√≠a de dos espacios adicionales. Esto hace que sea m√°s f√°cil ver la jerarqu√≠a en su c√≥digo rozando el margen izquierdo.\n\n# Faltan los dos espacios extras\ndensity &lt;- function(color, facets, binwidth = 0.1) {\ndiamonds |&gt; \n  ggplot(aes(x = carat, y = after_stat(density), color = {{ color }})) +\n  geom_freqpoly(binwidth = binwidth) +\n  facet_wrap(vars({{ facets }}))\n}\n\n# Canalizaci√≥n con sangr√≠a incorrecta\ndensity &lt;- function(color, facets, binwidth = 0.1) {\n  diamonds |&gt; \n  ggplot(aes(x = carat, y = after_stat(density), color = {{ color }})) +\n  geom_freqpoly(binwidth = binwidth) +\n  facet_wrap(vars({{ facets }}))\n}\n\nComo puede ver, recomendamos poner espacios adicionales dentro de {{ }}. Esto hace que sea muy obvio que algo inusual est√° sucediendo.\n\n25.5.1 Ejercicios\n\n\nLea el c√≥digo fuente de cada una de las siguientes dos funciones, averig√ºe lo que hacen y luego piense en mejores nombres.\n\nf1 &lt;- function(string, prefix) {\n  str_sub(string, 1, str_length(prefix)) == prefix\n}\n\nf3 &lt;- function(x, y) {\n  rep(y, length.out = length(x))\n}\n\n\nTome una funci√≥n que haya escrito recientemente y dedique 5 minutos a pensar en un mejor nombre para ella y sus argumentos.\nExplique por qu√© norm_r(), norm_d() etc. ser√≠a mejor que rnorm(), dnorm(). Haga un caso para lo contrario. ¬øC√≥mo podr√≠a hacer los nombres a√∫n m√°s claros?",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>25</span>¬† <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "functions.html#resumen",
    "href": "functions.html#resumen",
    "title": "25¬† Funciones",
    "section": "\n25.6 Resumen",
    "text": "25.6 Resumen\nEn este cap√≠tulo, aprendi√≥ a escribir funciones para tres escenarios √∫tiles: crear un vector, crear data frame o crear un gr√°fico. En el camino, vio muchos ejemplos, que con suerte comenzaron a hacer fluir su creatividad y le dieron algunas ideas sobre d√≥nde las funciones podr√≠an ayudar a su c√≥digo de an√°lisis.\nSolo le hemos mostrado lo m√≠nimo para comenzar con las funciones y hay mucho m√°s que aprender. Algunos lugares para aprender m√°s son:\n\nPara obtener m√°s informaci√≥n sobre la programaci√≥n con evaluaci√≥n ordenada, consulte recetas √∫tiles en programaci√≥n con dplyr y programaci√≥n con tidyr y obtenga m√°s informaci√≥n sobre la teor√≠a en ¬øQu√© es el enmascaramiento de datos y por qu√© necesito {{?.\nPara obtener m√°s informaci√≥n sobre c√≥mo reducir la duplicaci√≥n en su c√≥digo ggplot2, lea el cap√≠tulo Programaci√≥n con ggplot2 del libro de ggplot2.\nPara obtener m√°s consejos sobre el estilo de las funciones, consulta la gu√≠a de estilo de tidyverse.\n\nEn el pr√≥ximo cap√≠tulo, nos sumergiremos en la iteraci√≥n, que le brinda m√°s herramientas para reducir la duplicaci√≥n de c√≥digo.",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>25</span>¬† <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "iteration.html",
    "href": "iteration.html",
    "title": "26¬† Iteraci√≥n",
    "section": "",
    "text": "26.1 Introducci√≥n\nEn este cap√≠tulo, aprender√° herramientas para la iteraci√≥n, realizando repetidamente la misma acci√≥n en diferentes objetos. La iteraci√≥n en R generalmente tiende a verse bastante diferente de otros lenguajes de programaci√≥n porque gran parte de ella est√° impl√≠cita y la obtenemos de forma gratuita. Por ejemplo, si desea duplicar un vector num√©rico x en R, simplemente puede escribir 2 * x. En la mayor√≠a de los otros idiomas, necesitar√≠a duplicar expl√≠citamente cada elemento de x usando alg√∫n tipo de bucle for.\nEste libro ya le ha brindado una peque√±a pero poderosa cantidad de herramientas que realizan la misma acci√≥n para m√∫ltiples ‚Äúcosas‚Äù:\nAhora es el momento de aprender algunas herramientas m√°s generales, a menudo llamadas herramientas de programaci√≥n funcional porque est√°n construidas alrededor de funciones que toman otras funciones como entradas. El aprendizaje de la programaci√≥n funcional puede pasar f√°cilmente a lo abstracto, pero en este cap√≠tulo mantendremos las cosas concretas centr√°ndonos en tres tareas comunes: modificar varias columnas, leer varios archivos y guardar varios objetos.",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>26</span>¬† <span class='chapter-title'>Iteraci√≥n</span>"
    ]
  },
  {
    "objectID": "iteration.html#introducci√≥n",
    "href": "iteration.html#introducci√≥n",
    "title": "26¬† Iteraci√≥n",
    "section": "",
    "text": "facet_wrap() y facet_grid() dibuja una gr√°fica para cada subconjunto.\n\ngroup_by() m√°s summarize() calcula un resumen de estad√≠sticas para cada subconjunto.\n\nunnest_wider() y unnest_longer() crear nuevas filas y columnas para cada elemento de una lista-columna.\n\n\n\n26.1.1 Requisitos previos\nEn este cap√≠tulo, nos centraremos en las herramientas proporcionadas por dplyr y purrr, ambos miembros principales de tidyverse. Has visto dplyr antes, pero purrr es nuevo. Solo vamos a usar un par de funciones purrr en este cap√≠tulo, pero es un gran paquete para explorar a medida que mejora sus habilidades de programaci√≥n.\n\nlibrary(tidyverse)",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>26</span>¬† <span class='chapter-title'>Iteraci√≥n</span>"
    ]
  },
  {
    "objectID": "iteration.html#sec-across",
    "href": "iteration.html#sec-across",
    "title": "26¬† Iteraci√≥n",
    "section": "\n26.2 Modificar varias columnas",
    "text": "26.2 Modificar varias columnas\nImagina que tienes este tibble simple y quieres contar el n√∫mero de observaciones y calcular la mediana de cada columna.\n\ndf &lt;- tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\nPodr√≠as hacerlo con copiar y pegar:\n\ndf |&gt; summarize(\n  n = n(),\n  a = median(a),\n  b = median(b),\n  c = median(c),\n  d = median(d),\n)\n#&gt; # A tibble: 1 √ó 5\n#&gt;       n      a      b       c     d\n#&gt;   &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1    10 -0.246 -0.287 -0.0567 0.144\n\nEso rompe nuestra regla general de nunca copiar y pegar m√°s de dos veces, y puedes imaginar que esto se volver√° muy tedioso si tienes decenas o incluso cientos de columnas. En su lugar, puedes usar across():\n\ndf |&gt; summarize(\n  n = n(),\n  across(a:d, median),\n)\n#&gt; # A tibble: 1 √ó 5\n#&gt;       n      a      b       c     d\n#&gt;   &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1    10 -0.246 -0.287 -0.0567 0.144\n\nacross() tiene tres argumentos particularmente importantes, que discutiremos en detalle en las siguientes secciones. Usar√° los dos primeros cada vez que use across(): el primer argumento, .cols, especifica sobre qu√© columnas desea iterar, y el segundo argumento, .fns, especifica qu√© hacer con cada columna Puedes usar el argumento .names cuando necesites un control adicional sobre los nombres de las columnas de salida, lo cual es particularmente importante cuando usas across() con mutate(). Tambi√©n discutiremos dos variaciones importantes, if_any() y if_all(), que funcionan con filter().\n\n26.2.1 Selecci√≥n de columnas con .cols\n\nEl primer argumento de across(), .cols, selecciona las columnas para transformar. Esto usa las mismas especificaciones que select(), Secci√≥n 3.3.2, por lo que puede usar funciones como starts_with() y ends_with() para seleccionar columnas seg√∫n su nombre.\nHay dos t√©cnicas de selecci√≥n adicionales que son particularmente √∫tiles para across(): everything() y where(). everything() es sencillo: selecciona todas las columnas (no agrupadas):\n\ndf &lt;- tibble(\n  grp = sample(2, 10, replace = TRUE),\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\ndf |&gt; \n  group_by(grp) |&gt; \n  summarize(across(everything(), median))\n#&gt; # A tibble: 2 √ó 5\n#&gt;     grp       a       b     c     d\n#&gt;   &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1 -0.0935 -0.0163 0.363 0.364\n#&gt; 2     2  0.312  -0.0576 0.208 0.565\n\nTenga en cuenta que las columnas de agrupaci√≥n (grp aqu√≠) no se incluyen en across(), porque summarize() las conserva autom√°ticamente.\nwhere() le permite seleccionar columnas seg√∫n su tipo:\n\n\nwhere(is.numeric) selecciona todas las columnas num√©ricas.\n\nwhere(is.character) selecciona todas las columnas de cadena.\n\nwhere(is.Date) selecciona todas las columnas de fecha.\n\nwhere(is.POSIXct) selecciona todas las columnas de fecha y hora.\n\nwhere(is.logical) selecciona todas las columnas l√≥gicas.\n\nAl igual que otros selectores, puede combinarlos con √°lgebra booleana. Por ejemplo, !where(is.numeric) selecciona todas las columnas no num√©ricas, y starts_with(\"a\") & where(is.logical) selecciona todas las columnas l√≥gicas cuyo nombre comienza con ‚Äúa‚Äù.\n\n26.2.2 Llamar a una sola funci√≥n\nEl segundo argumento de across() define c√≥mo se transformar√° cada columna. En casos simples, como el anterior, esta ser√° una sola funci√≥n existente. Esta es una caracter√≠stica bastante especial de R: estamos pasando una funci√≥n (median, mean, str_flatten, ‚Ä¶) a otra funci√≥n (across). Esta es una de las caracter√≠sticas que hace de R un lenguaje de programaci√≥n funcional.\nEs importante tener en cuenta que estamos pasando esta funci√≥n a across(), por lo que across() puede llamarla; no lo estamos llamando nosotros mismos. Eso significa que el nombre de la funci√≥n nunca debe ir seguido de (). Si lo olvida, obtendr√° un error:\n\ndf |&gt; \n  group_by(grp) |&gt; \n  summarize(across(everything(), median()))\n#&gt; Error in `summarize()`:\n#&gt; ‚Ñπ In argument: `across(everything(), median())`.\n#&gt; Caused by error in `median.default()`:\n#&gt; ! argument \"x\" is missing, with no default\n\nEste error surge porque est√° llamando a la funci√≥n sin entrada, por ejemplo:\n\nmedian()\n#&gt; Error in median.default(): argument \"x\" is missing, with no default\n\n\n26.2.3 Llamar a m√∫ltiples funciones\nEn casos m√°s complejos, es posible que desee proporcionar argumentos adicionales o realizar varias transformaciones. Motivemos este problema con un ejemplo simple: ¬øqu√© sucede si tenemos algunos valores faltantes en nuestros datos? median() propaga esos valores perdidos, d√°ndonos un resultado sub√≥ptimo:\n\nrnorm_na &lt;- function(n, n_na, mean = 0, sd = 1) {\n  sample(c(rnorm(n - n_na, mean = mean, sd = sd), rep(NA, n_na)))\n}\n\ndf_miss &lt;- tibble(\n  a = rnorm_na(5, 1),\n  b = rnorm_na(5, 1),\n  c = rnorm_na(5, 2),\n  d = rnorm(5)\n)\ndf_miss |&gt; \n  summarize(\n    across(a:d, median),\n    n = n()\n  )\n#&gt; # A tibble: 1 √ó 5\n#&gt;       a     b     c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1    NA    NA    NA  1.15     5\n\nSer√≠a bueno si pudi√©ramos pasar na.rm = TRUE a median() para eliminar estos valores faltantes. Para hacerlo, en lugar de llamar a median() directamente, necesitamos crear una nueva funci√≥n que llame a median() con los argumentos deseados:\n\ndf_miss |&gt; \n  summarize(\n    across(a:d, function(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n#&gt; # A tibble: 1 √ó 5\n#&gt;       a     b      c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 0.139 -1.11 -0.387  1.15     5\n\nEsto es un poco detallado, por lo que R viene con un atajo √∫til: para este tipo de funci√≥n desechable, o an√≥nima1, puede reemplazar funci√≥n con \\[^iteration-2 ]:\n\ndf_miss |&gt; \n  summarize(\n    across(a:d, \\(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n\nEn cualquier caso, across() se expande efectivamente al siguiente c√≥digo:\n\ndf_miss |&gt; \n  summarize(\n    a = median(a, na.rm = TRUE),\n    b = median(b, na.rm = TRUE),\n    c = median(c, na.rm = TRUE),\n    d = median(d, na.rm = TRUE),\n    n = n()\n  )\n\nCuando eliminamos los valores que faltan de la mediana, median(), ser√≠a bueno saber cu√°ntos valores se eliminaron. Podemos averiguarlo proporcionando dos funciones a across(): una para calcular la mediana y la otra para contar los valores que faltan. Proporciona m√∫ltiples funciones usando una lista con nombre para .fns:\n\ndf_miss |&gt; \n  summarize(\n    across(a:d, list(\n      median = \\(x) median(x, na.rm = TRUE),\n      n_miss = \\(x) sum(is.na(x))\n    )),\n    n = n()\n  )\n#&gt; # A tibble: 1 √ó 9\n#&gt;   a_median a_n_miss b_median b_n_miss c_median c_n_miss d_median d_n_miss\n#&gt;      &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1    0.139        1    -1.11        1   -0.387        2     1.15        0\n#&gt; # ‚Ñπ 1 more variable: n &lt;int&gt;\n\nSi observa detenidamente, puede intuir que las columnas se nombran utilizando una especificaci√≥n de pegamento (Secci√≥n 14.3.2) como {.col}_{.fn} donde .col es el nombre de la columna original y . fn es el nombre de la funci√≥n. ¬°Eso no es una coincidencia! Como aprender√° en la siguiente secci√≥n, puede usar el argumento .names para proporcionar su propia especificaci√≥n de pegamento.\n\n26.2.4 Nombres de columna\nEl resultado de across() se nombra de acuerdo con la especificaci√≥n provista en el argumento .names. Podr√≠amos especificar el nuestro si quisi√©ramos que el nombre de la funci√≥n fuera primero 2:\n\ndf_miss |&gt; \n  summarize(\n    across(\n      a:d,\n      list(\n        median = \\(x) median(x, na.rm = TRUE),\n        n_miss = \\(x) sum(is.na(x))\n      ),\n      .names = \"{.fn}_{.col}\"\n    ),\n    n = n(),\n  )\n#&gt; # A tibble: 1 √ó 9\n#&gt;   median_a n_miss_a median_b n_miss_b median_c n_miss_c median_d n_miss_d\n#&gt;      &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1    0.139        1    -1.11        1   -0.387        2     1.15        0\n#&gt; # ‚Ñπ 1 more variable: n &lt;int&gt;\n\nEl argumento .names es particularmente importante cuando usas across() con mutate(). Por defecto, la salida de across() recibe los mismos nombres que las entradas. Esto significa que across() dentro de mutate() reemplazar√° las columnas existentes. Por ejemplo, aqu√≠ usamos coalesce() para reemplazar NAs con 0:\n\ndf_miss |&gt; \n  mutate(\n    across(a:d, \\(x) coalesce(x, 0))\n  )\n#&gt; # A tibble: 5 √ó 4\n#&gt;        a      b      c     d\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.434 -1.25   0     1.60 \n#&gt; 2  0     -1.43  -0.297 0.776\n#&gt; 3 -0.156 -0.980  0     1.15 \n#&gt; 4 -2.61  -0.683 -0.785 2.13 \n#&gt; 5  1.11   0     -0.387 0.704\n\nSi desea crear nuevas columnas, puede usar el argumento .names para dar nuevos nombres a la salida:\n\ndf_miss |&gt; \n  mutate(\n    across(a:d, \\(x) coalesce(x), .names = \"{.col}_na_zeros\")\n  )\n#&gt; # A tibble: 5 √ó 8\n#&gt;        a      b      c     d a_na_zeros b_na_zeros c_na_zeros d_na_zeros\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1  0.434 -1.25  NA     1.60       0.434     -1.25      NA          1.60 \n#&gt; 2 NA     -1.43  -0.297 0.776     NA         -1.43      -0.297      0.776\n#&gt; 3 -0.156 -0.980 NA     1.15      -0.156     -0.980     NA          1.15 \n#&gt; 4 -2.61  -0.683 -0.785 2.13      -2.61      -0.683     -0.785      2.13 \n#&gt; 5  1.11  NA     -0.387 0.704      1.11      NA         -0.387      0.704\n\n\n26.2.5 Filtrando\nacross() es una gran combinaci√≥n para summarize() y mutate(), pero es m√°s inc√≥modo de usar con filter(), porque generalmente combina varias condiciones con | o &. Est√° claro que across() puede ayudar a crear varias columnas l√≥gicas, pero ¬øentonces qu√©? As√≠ que dplyr proporciona dos variantes de across() llamadas if_any() y if_all():\n\n# igual que df_miss |&gt; filter(is.na(a) | is.na(b) | is.na(c) | is.na(d))\ndf_miss |&gt; filter(if_any(a:d, is.na))\n#&gt; # A tibble: 4 √ó 4\n#&gt;        a      b      c     d\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.434 -1.25  NA     1.60 \n#&gt; 2 NA     -1.43  -0.297 0.776\n#&gt; 3 -0.156 -0.980 NA     1.15 \n#&gt; 4  1.11  NA     -0.387 0.704\n\n# igual que df_miss |&gt; filter(is.na(a) & is.na(b) & is.na(c) & is.na(d))\ndf_miss |&gt; filter(if_all(a:d, is.na))\n#&gt; # A tibble: 0 √ó 4\n#&gt; # ‚Ñπ 4 variables: a &lt;dbl&gt;, b &lt;dbl&gt;, c &lt;dbl&gt;, d &lt;dbl&gt;\n\n\n26.2.6 across() en funciones\nacross() es particularmente √∫til para programar porque te permite operar en m√∫ltiples columnas. Por ejemplo, Jacob Scott usa este peque√±o ayudante que envuelve un mont√≥n de funciones de lubridate para expandir todas las columnas de fecha en columnas de a√±o, mes y d√≠a:\n\nexpand_dates &lt;- function(df) {\n  df |&gt; \n    mutate(\n      across(where(is.Date), list(year = year, month = month, day = mday))\n    )\n}\n\ndf_date &lt;- tibble(\n  name = c(\"Amy\", \"Bob\"),\n  date = ymd(c(\"2009-08-03\", \"2010-01-16\"))\n)\n\ndf_date |&gt; \n  expand_dates()\n#&gt; # A tibble: 2 √ó 5\n#&gt;   name  date       date_year date_month date_day\n#&gt;   &lt;chr&gt; &lt;date&gt;         &lt;dbl&gt;      &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1 Amy   2009-08-03      2009          8        3\n#&gt; 2 Bob   2010-01-16      2010          1       16\n\nacross() tambi√©n facilita el suministro de m√∫ltiples columnas en un solo argumento porque el primer argumento usa tidy-select; solo necesita recordar abrazar ese argumento, como discutimos en Secci√≥n 25.3.2. Por ejemplo, esta funci√≥n calcular√° las medias de las columnas num√©ricas de forma predeterminada. Pero al proporcionar el segundo argumento, puede optar por resumir solo las columnas seleccionadas:\n\nsummarize_means &lt;- function(df, summary_vars = where(is.numeric)) {\n  df |&gt; \n    summarize(\n      across({{ summary_vars }}, \\(x) mean(x, na.rm = TRUE)),\n      n = n(),\n      .groups = \"drop\"\n    )\n}\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summarize_means()\n#&gt; # A tibble: 5 √ó 9\n#&gt;   cut       carat depth table price     x     y     z     n\n#&gt;   &lt;ord&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 Fair      1.05   64.0  59.1 4359.  6.25  6.18  3.98  1610\n#&gt; 2 Good      0.849  62.4  58.7 3929.  5.84  5.85  3.64  4906\n#&gt; 3 Very Good 0.806  61.8  58.0 3982.  5.74  5.77  3.56 12082\n#&gt; 4 Premium   0.892  61.3  58.7 4584.  5.97  5.94  3.65 13791\n#&gt; 5 Ideal     0.703  61.7  56.0 3458.  5.51  5.52  3.40 21551\n\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summarize_means(c(carat, x:z))\n#&gt; # A tibble: 5 √ó 6\n#&gt;   cut       carat     x     y     z     n\n#&gt;   &lt;ord&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 Fair      1.05   6.25  6.18  3.98  1610\n#&gt; 2 Good      0.849  5.84  5.85  3.64  4906\n#&gt; 3 Very Good 0.806  5.74  5.77  3.56 12082\n#&gt; 4 Premium   0.892  5.97  5.94  3.65 13791\n#&gt; 5 Ideal     0.703  5.51  5.52  3.40 21551\n\n\n26.2.7 Comparar con pivot_longer()\n\nAntes de continuar, vale la pena se√±alar una conexi√≥n interesante entre across() y pivot_longer() (Secci√≥n 5.3). En muchos casos, usted realiza los mismos c√°lculos girando primero los datos y luego realizando las operaciones por grupo en lugar de por columna. Por ejemplo, tome este resumen multifunci√≥n:\n\ndf |&gt; \n  summarize(across(a:d, list(median = median, mean = mean)))\n#&gt; # A tibble: 1 √ó 8\n#&gt;   a_median a_mean b_median b_mean c_median c_mean d_median d_mean\n#&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1   0.0380  0.205  -0.0163 0.0910    0.260 0.0716    0.540  0.508\n\nPodr√≠amos calcular los mismos valores girando m√°s y luego resumiendo:\n\nlong &lt;- df |&gt; \n  pivot_longer(a:d) |&gt; \n  group_by(name) |&gt; \n  summarize(\n    median = median(value),\n    mean = mean(value)\n  )\nlong\n#&gt; # A tibble: 4 √ó 3\n#&gt;   name   median   mean\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 a      0.0380 0.205 \n#&gt; 2 b     -0.0163 0.0910\n#&gt; 3 c      0.260  0.0716\n#&gt; 4 d      0.540  0.508\n\nY si quisieras la misma estructura que across(), podr√≠as pivotar de nuevo:\n\nlong |&gt; \n  pivot_wider(\n    names_from = name,\n    values_from = c(median, mean),\n    names_vary = \"slowest\",\n    names_glue = \"{name}_{.value}\"\n  )\n#&gt; # A tibble: 1 √ó 8\n#&gt;   a_median a_mean b_median b_mean c_median c_mean d_median d_mean\n#&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1   0.0380  0.205  -0.0163 0.0910    0.260 0.0716    0.540  0.508\n\nEsta es una t√©cnica √∫til para conocer porque a veces te encontrar√°s con un problema que actualmente no es posible resolver con across(): cuando tienes grupos de columnas con las que quieres calcular simult√°neamente. Por ejemplo, imagine que nuestro data frame contiene valores y pesos y queremos calcular una media ponderada:\n\ndf_paired &lt;- tibble(\n  a_val = rnorm(10),\n  a_wts = runif(10),\n  b_val = rnorm(10),\n  b_wts = runif(10),\n  c_val = rnorm(10),\n  c_wts = runif(10),\n  d_val = rnorm(10),\n  d_wts = runif(10)\n)\n\nActualmente no hay forma de hacer esto con across()3, pero es relativamente sencillo con pivot_longer():\n\ndf_long &lt;- df_paired |&gt; \n  pivot_longer(\n    everything(), \n    names_to = c(\"group\", \".value\"), \n    names_sep = \"_\"\n  )\ndf_long\n#&gt; # A tibble: 40 √ó 3\n#&gt;   group    val   wts\n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 a      0.715 0.518\n#&gt; 2 b     -0.709 0.691\n#&gt; 3 c      0.718 0.216\n#&gt; 4 d     -0.217 0.733\n#&gt; 5 a     -1.09  0.979\n#&gt; 6 b     -0.209 0.675\n#&gt; # ‚Ñπ 34 more rows\n\ndf_long |&gt; \n  group_by(group) |&gt; \n  summarize(mean = weighted.mean(val, wts))\n#&gt; # A tibble: 4 √ó 2\n#&gt;   group    mean\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1 a      0.126 \n#&gt; 2 b     -0.0704\n#&gt; 3 c     -0.360 \n#&gt; 4 d     -0.248\n\nSi es necesario, puede pivot_wider() para devolverlo a la forma original.\n\n26.2.8 Ejercicios\n\n\nPractica tus habilidades across() al:\n\nCalcular el n√∫mero de valores √∫nicos en cada columna de palmerpenguins::penguins.\nCalcular la media de cada columna en mtcars.\nAgrupar ‚Äòdiamantes‚Äô por ‚Äòcorte‚Äô, ‚Äòclaridad‚Äô y ‚Äòcolor‚Äô y luego contar el n√∫mero de observaciones y calcular la media de cada columna num√©rica.\n\n\n¬øQu√© pasa si usas una lista de funciones en across(), pero no las nombras? ¬øC√≥mo se llama la salida?\nAjuste expand_dates() para eliminar autom√°ticamente las columnas de fecha despu√©s de que se hayan expandido. ¬øNecesitas aceptar alg√∫n argumento?\n\nExplique qu√© hace cada paso de la tuber√≠a en esta funci√≥n. ¬øQu√© caracter√≠stica especial de where() estamos aprovechando?\n\nshow_missing &lt;- function(df, group_vars, summary_vars = everything()) {\n  df |&gt; \n    group_by(pick({{ group_vars }})) |&gt; \n    summarize(\n      across({{ summary_vars }}, \\(x) sum(is.na(x))),\n      .groups = \"drop\"\n    ) |&gt;\n    select(where(\\(x) any(x &gt; 0)))\n}\nnycflights13::flights |&gt; show_missing(c(year, month, day))",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>26</span>¬† <span class='chapter-title'>Iteraci√≥n</span>"
    ]
  },
  {
    "objectID": "iteration.html#leer-varios-archivos",
    "href": "iteration.html#leer-varios-archivos",
    "title": "26¬† Iteraci√≥n",
    "section": "\n26.3 Leer varios archivos",
    "text": "26.3 Leer varios archivos\nEn la secci√≥n anterior, aprendiste a usar dplyr::across() para repetir una transformaci√≥n en varias columnas. En esta secci√≥n, aprender√° c√≥mo usar purrr::map() para hacer algo con cada archivo en un directorio. Empecemos con un poco de motivaci√≥n: imagine que tiene un directorio lleno de hojas de c√°lculo de Excel[^iteraci√≥n-4] que desea leer. Podr√≠as hacerlo con copiar y pegar:\n\ndata2019 &lt;- readxl::read_excel(\"data/y2019.xlsx\")\ndata2020 &lt;- readxl::read_excel(\"data/y2020.xlsx\")\ndata2021 &lt;- readxl::read_excel(\"data/y2021.xlsx\")\ndata2022 &lt;- readxl::read_excel(\"data/y2022.xlsx\")\n\nY luego usa dplyr::bind_rows() para combinarlos todos juntos:\n\ndata &lt;- bind_rows(data2019, data2020, data2021, data2022)\n\nPuede imaginar que esto se volver√≠a tedioso r√°pidamente, especialmente si tuviera cientos de archivos, no solo cuatro. Las siguientes secciones le muestran c√≥mo automatizar este tipo de tareas. Hay tres pasos b√°sicos: use list.files() para listar todos los archivos en un directorio, luego use purrr::map() para leer cada uno de ellos en una lista, luego use purrr::list_rbind( ) para combinarlos en un solo data frame. Luego, analizaremos c√≥mo puede manejar situaciones de creciente heterogeneidad, en las que no puede hacer exactamente lo mismo con todos los archivos.\n\n26.3.1 Listado de archivos en un directorio\nComo sugiere el nombre, list.files() enumera los archivos en un directorio. Casi siempre usar√°s tres argumentos:\n\nEl primer argumento, path, es el directorio en el que buscar.\npattern es una expresi√≥n regular utilizada para filtrar los nombres de archivo. El patr√≥n m√°s com√∫n es algo como [.]xlsx$ o [.]csv$ para encontrar todos los archivos con una extensi√≥n espec√≠fica.\nfull.names determina si el nombre del directorio debe incluirse o no en la salida. Casi siempre quieres que esto sea TRUE.\n\nPara concretar nuestro ejemplo motivador, este libro contiene una carpeta con 12 hojas de c√°lculo de Excel que contienen datos del paquete gapminder. Cada archivo contiene datos de un a√±o para 142 pa√≠ses. Podemos listarlos todos con la llamada apropiada a list.files():\n\npaths &lt;- list.files(\"data/gapminder\", pattern = \"[.]xlsx$\", full.names = TRUE)\npaths\n#&gt;  [1] \"data/gapminder/1952.xlsx\" \"data/gapminder/1957.xlsx\"\n#&gt;  [3] \"data/gapminder/1962.xlsx\" \"data/gapminder/1967.xlsx\"\n#&gt;  [5] \"data/gapminder/1972.xlsx\" \"data/gapminder/1977.xlsx\"\n#&gt;  [7] \"data/gapminder/1982.xlsx\" \"data/gapminder/1987.xlsx\"\n#&gt;  [9] \"data/gapminder/1992.xlsx\" \"data/gapminder/1997.xlsx\"\n#&gt; [11] \"data/gapminder/2002.xlsx\" \"data/gapminder/2007.xlsx\"\n\n\n26.3.2 Lists\nAhora que tenemos estas 12 rutas, podr√≠amos llamar a read_excel() 12 veces para obtener 12 data frames:\n\ngapminder_1952 &lt;- readxl::read_excel(\"data/gapminder/1952.xlsx\")\ngapminder_1957 &lt;- readxl::read_excel(\"data/gapminder/1957.xlsx\")\ngapminder_1962 &lt;- readxl::read_excel(\"data/gapminder/1962.xlsx\")\n ...,\ngapminder_2007 &lt;- readxl::read_excel(\"data/gapminder/2007.xlsx\")\n\nPero poner cada hoja en su propia variable har√° que sea dif√≠cil trabajar con ellas unos pasos m√°s adelante. En cambio, ser√° m√°s f√°cil trabajar con ellos si los ponemos en un solo objeto. Una lista es la herramienta perfecta para este trabajo:\n\nfiles &lt;- list(\n  readxl::read_excel(\"data/gapminder/1952.xlsx\"),\n  readxl::read_excel(\"data/gapminder/1957.xlsx\"),\n  readxl::read_excel(\"data/gapminder/1962.xlsx\"),\n  ...,\n  readxl::read_excel(\"data/gapminder/2007.xlsx\")\n)\n\nAhora que tiene estos data frames en una lista, ¬øc√≥mo obtiene uno? Puedes usar files[[i]] para extraer el i-√©simo elemento:\n\nfiles[[3]]\n#&gt; # A tibble: 142 √ó 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         32.0 10267083      853.\n#&gt; 2 Albania     Europe       64.8  1728137     2313.\n#&gt; 3 Algeria     Africa       48.3 11000948     2551.\n#&gt; 4 Angola      Africa       34    4826015     4269.\n#&gt; 5 Argentina   Americas     65.1 21283783     7133.\n#&gt; 6 Australia   Oceania      70.9 10794968    12217.\n#&gt; # ‚Ñπ 136 more rows\n\nVolveremos a [[ con m√°s detalle en Secci√≥n 27.3.\n\n26.3.3 purrr::map() and list_rbind()\n\nEl c√≥digo para recopilar esos data frames en una lista ‚Äúa mano‚Äù es b√°sicamente tan tedioso de escribir como el c√≥digo que lee los archivos uno por uno. Felizmente, podemos usar purrr::map() para hacer un mejor uso de nuestro vector paths. map() es similar a across(), pero en lugar de hacer algo con cada columna en un data frame, hace algo con cada elemento de un vector. map(x, f) es una abreviatura de:\n\nlist(\n  f(x[[1]]),\n  f(x[[2]]),\n  ...,\n  f(x[[n]])\n)\n\nEntonces podemos usar map() para obtener una lista de 12 data frames:\n\nfiles &lt;- map(paths, readxl::read_excel)\nlength(files)\n#&gt; [1] 12\n\nfiles[[1]]\n#&gt; # A tibble: 142 √ó 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 Albania     Europe       55.2  1282697     1601.\n#&gt; 3 Algeria     Africa       43.1  9279525     2449.\n#&gt; 4 Angola      Africa       30.0  4232095     3521.\n#&gt; 5 Argentina   Americas     62.5 17876956     5911.\n#&gt; 6 Australia   Oceania      69.1  8691212    10040.\n#&gt; # ‚Ñπ 136 more rows\n\n(Esta es otra estructura de datos que no se muestra de manera particularmente compacta con str(), por lo que es posible que desee cargarla en RStudio e inspeccionarla con View()).\nAhora podemos usar purrr::list_rbind() para combinar esa lista de data frames en un solo data frame:\n\nlist_rbind(files)\n#&gt; # A tibble: 1,704 √ó 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 Albania     Europe       55.2  1282697     1601.\n#&gt; 3 Algeria     Africa       43.1  9279525     2449.\n#&gt; 4 Angola      Africa       30.0  4232095     3521.\n#&gt; 5 Argentina   Americas     62.5 17876956     5911.\n#&gt; 6 Australia   Oceania      69.1  8691212    10040.\n#&gt; # ‚Ñπ 1,698 more rows\n\nO podr√≠amos hacer ambos pasos a la vez en una canalizaci√≥n:\n\npaths |&gt; \n  map(readxl::read_excel) |&gt; \n  list_rbind()\n\n¬øQu√© sucede si queremos pasar argumentos adicionales a read_excel()? Usamos la misma t√©cnica que usamos con across(). Por ejemplo, suele ser √∫til alcanzar un m√°ximo en las primeras filas de los datos con n_max = 1:\n\npaths |&gt; \n  map(\\(path) readxl::read_excel(path, n_max = 1)) |&gt; \n  list_rbind()\n#&gt; # A tibble: 12 √ó 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 Afghanistan Asia         30.3  9240934      821.\n#&gt; 3 Afghanistan Asia         32.0 10267083      853.\n#&gt; 4 Afghanistan Asia         34.0 11537966      836.\n#&gt; 5 Afghanistan Asia         36.1 13079460      740.\n#&gt; 6 Afghanistan Asia         38.4 14880372      786.\n#&gt; # ‚Ñπ 6 more rows\n\nEsto deja en claro que falta algo: no hay una columna year porque ese valor se registra en la ruta, no en los archivos individuales. Abordaremos ese problema a continuaci√≥n.\n\n26.3.4 Datos en la ruta\nA veces, el nombre del archivo es el propio dato. En este ejemplo, el nombre del archivo contiene el a√±o, que de otro modo no se registra en los archivos individuales. Para colocar esa columna en el data frame final, debemos hacer dos cosas:\nPrimero, nombramos el vector de rutas. La forma m√°s f√°cil de hacer esto es con la funci√≥n set_names(), que puede tomar una funci√≥n. Aqu√≠ usamos basename() para extraer solo el nombre del archivo de la ruta completa:\n\npaths |&gt; set_names(basename) \n#&gt;                  1952.xlsx                  1957.xlsx \n#&gt; \"data/gapminder/1952.xlsx\" \"data/gapminder/1957.xlsx\" \n#&gt;                  1962.xlsx                  1967.xlsx \n#&gt; \"data/gapminder/1962.xlsx\" \"data/gapminder/1967.xlsx\" \n#&gt;                  1972.xlsx                  1977.xlsx \n#&gt; \"data/gapminder/1972.xlsx\" \"data/gapminder/1977.xlsx\" \n#&gt;                  1982.xlsx                  1987.xlsx \n#&gt; \"data/gapminder/1982.xlsx\" \"data/gapminder/1987.xlsx\" \n#&gt;                  1992.xlsx                  1997.xlsx \n#&gt; \"data/gapminder/1992.xlsx\" \"data/gapminder/1997.xlsx\" \n#&gt;                  2002.xlsx                  2007.xlsx \n#&gt; \"data/gapminder/2002.xlsx\" \"data/gapminder/2007.xlsx\"\n\nEsos nombres son llevados autom√°ticamente por todas las funciones del mapa, por lo que la lista de data frames tendr√° esos mismos nombres:\n\nfiles &lt;- paths |&gt; \n  set_names(basename) |&gt; \n  map(readxl::read_excel)\n\nEso hace que esta llamada a map() sea abreviada para:\n\nfiles &lt;- list(\n  \"1952.xlsx\" = readxl::read_excel(\"data/gapminder/1952.xlsx\"),\n  \"1957.xlsx\" = readxl::read_excel(\"data/gapminder/1957.xlsx\"),\n  \"1962.xlsx\" = readxl::read_excel(\"data/gapminder/1962.xlsx\"),\n  ...,\n  \"2007.xlsx\" = readxl::read_excel(\"data/gapminder/2007.xlsx\")\n)\n\nTambi√©n puedes usar [[ para extraer elementos por nombre:\n\nfiles[[\"1962.xlsx\"]]\n#&gt; # A tibble: 142 √ó 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         32.0 10267083      853.\n#&gt; 2 Albania     Europe       64.8  1728137     2313.\n#&gt; 3 Algeria     Africa       48.3 11000948     2551.\n#&gt; 4 Angola      Africa       34    4826015     4269.\n#&gt; 5 Argentina   Americas     65.1 21283783     7133.\n#&gt; 6 Australia   Oceania      70.9 10794968    12217.\n#&gt; # ‚Ñπ 136 more rows\n\nLuego usamos el argumento names_to para list_rbind() para decirle que guarde los nombres en una nueva columna llamada year y luego usamos readr::parse_number() para extraer el n√∫mero de la cadena.\n\npaths |&gt; \n  set_names(basename) |&gt; \n  map(readxl::read_excel) |&gt; \n  list_rbind(names_to = \"year\") |&gt; \n  mutate(year = parse_number(year))\n#&gt; # A tibble: 1,704 √ó 6\n#&gt;    year country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1  1952 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2  1952 Albania     Europe       55.2  1282697     1601.\n#&gt; 3  1952 Algeria     Africa       43.1  9279525     2449.\n#&gt; 4  1952 Angola      Africa       30.0  4232095     3521.\n#&gt; 5  1952 Argentina   Americas     62.5 17876956     5911.\n#&gt; 6  1952 Australia   Oceania      69.1  8691212    10040.\n#&gt; # ‚Ñπ 1,698 more rows\n\nEn casos m√°s complicados, puede haber otras variables almacenadas en el nombre del directorio, o tal vez el nombre del archivo contenga varios bits de datos. En ese caso, use set_names() (sin ning√∫n argumento) para registrar la ruta completa y luego use tidyr::separate_wider_delim() y sus amigos para convertirlos en columnas √∫tiles.\n\npaths |&gt; \n  set_names() |&gt; \n  map(readxl::read_excel) |&gt; \n  list_rbind(names_to = \"year\") |&gt; \n  separate_wider_delim(year, delim = \"/\", names = c(NA, \"dir\", \"file\")) |&gt; \n  separate_wider_delim(file, delim = \".\", names = c(\"file\", \"ext\"))\n#&gt; # A tibble: 1,704 √ó 8\n#&gt;   dir       file  ext   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 gapminder 1952  xlsx  Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 gapminder 1952  xlsx  Albania     Europe       55.2  1282697     1601.\n#&gt; 3 gapminder 1952  xlsx  Algeria     Africa       43.1  9279525     2449.\n#&gt; 4 gapminder 1952  xlsx  Angola      Africa       30.0  4232095     3521.\n#&gt; 5 gapminder 1952  xlsx  Argentina   Americas     62.5 17876956     5911.\n#&gt; 6 gapminder 1952  xlsx  Australia   Oceania      69.1  8691212    10040.\n#&gt; # ‚Ñπ 1,698 more rows\n\n\n26.3.5 Guarda tu trabajo\nAhora que ha hecho todo este arduo trabajo para llegar a un buen data frame ordenado, es un buen momento para guardar su trabajo:\n\ngapminder &lt;- paths |&gt; \n  set_names(basename) |&gt; \n  map(readxl::read_excel) |&gt; \n  list_rbind(names_to = \"year\") |&gt; \n  mutate(year = parse_number(year))\n\nwrite_csv(gapminder, \"gapminder.csv\")\n\nAhora, cuando regrese a este problema en el futuro, puede leer en un solo archivo csv. Para conjuntos de datos m√°s grandes y ricos, usar parquet podr√≠a ser una mejor opci√≥n que .csv, como se explica en Secci√≥n 22.4.\nSi est√° trabajando en un proyecto, le sugerimos llamar al archivo que hace este tipo de trabajo de preparaci√≥n de datos algo as√≠ como 0-cleanup.R. El 0 en el nombre del archivo sugiere que esto debe ejecutarse antes que cualquier otra cosa.\nSi sus archivos de datos de entrada cambian con el tiempo, podr√≠a considerar aprender una herramienta como targets para configurar su c√≥digo de limpieza de datos para que se vuelva a ejecutar autom√°ticamente cada vez que una de las entradas se modifican los archivos.\n\n26.3.6 Muchas iteraciones simples\nAqu√≠ acabamos de cargar los datos directamente desde el disco y tuvimos la suerte de obtener un conjunto de datos ordenado. En la mayor√≠a de los casos, deber√° realizar algunas tareas de limpieza adicionales y tiene dos opciones b√°sicas: puede realizar una ronda de iteraci√≥n con una funci√≥n compleja o realizar varias rondas de iteraci√≥n con funciones simples. En nuestra experiencia, la mayor√≠a de la gente llega primero a una iteraci√≥n compleja, pero a menudo es mejor hacer varias iteraciones simples.\nPor ejemplo, imagine que desea leer un mont√≥n de archivos, filtrar los valores faltantes, pivotar y luego combinar. Una forma de abordar el problema es escribir una funci√≥n que tome un archivo y realice todos esos pasos y luego llame a map() una vez:\n\nprocess_file &lt;- function(path) {\n  df &lt;- read_csv(path)\n  \n  df |&gt; \n    filter(!is.na(id)) |&gt; \n    mutate(id = tolower(id)) |&gt; \n    pivot_longer(jan:dec, names_to = \"month\")\n}\n\npaths |&gt; \n  map(process_file) |&gt; \n  list_rbind()\n\nAlternativamente, podr√≠a realizar cada paso de process_file() para cada archivo:\n\npaths |&gt; \n  map(read_csv) |&gt; \n  map(\\(df) df |&gt; filter(!is.na(id))) |&gt; \n  map(\\(df) df |&gt; mutate(id = tolower(id))) |&gt; \n  map(\\(df) df |&gt; pivot_longer(jan:dec, names_to = \"month\")) |&gt; \n  list_rbind()\n\nRecomendamos este enfoque porque evita que se obsesione con obtener el primer archivo correctamente antes de pasar al resto. Al considerar todos los datos al ordenar y limpiar, es m√°s probable que piense de manera integral y termine con un resultado de mayor calidad.\nEn este ejemplo en particular, hay otra optimizaci√≥n que podr√≠a hacer al vincular todos los data frames antes. Entonces puede confiar en el comportamiento regular de dplyr:\n\npaths |&gt; \n  map(read_csv) |&gt; \n  list_rbind() |&gt; \n  filter(!is.na(id)) |&gt; \n  mutate(id = tolower(id)) |&gt; \n  pivot_longer(jan:dec, names_to = \"month\")\n\n\n26.3.7 Datos heterog√©neos\nDesafortunadamente, a veces no es posible pasar directamente de map() a list_rbind() porque los data frames son tan heterog√©neos que list_rbind() falla o produce un data frame que no es muy √∫til. En ese caso, sigue siendo √∫til comenzar cargando todos los archivos:\n\nfiles &lt;- paths |&gt; \n  map(readxl::read_excel) \n\nLuego, una estrategia muy √∫til es capturar la estructura de los data frames para que pueda explorarla usando sus habilidades de ciencia de datos. Una forma de hacerlo es con esta √∫til funci√≥n df_types 4 que devuelve un tibble con una fila para cada columna:\n\ndf_types &lt;- function(df) {\n  tibble(\n    col_name = names(df), \n    col_type = map_chr(df, vctrs::vec_ptype_full),\n    n_miss = map_int(df, \\(x) sum(is.na(x)))\n  )\n}\n\ndf_types(gapminder)\n#&gt; # A tibble: 6 √ó 3\n#&gt;   col_name  col_type  n_miss\n#&gt;   &lt;chr&gt;     &lt;chr&gt;      &lt;int&gt;\n#&gt; 1 year      double         0\n#&gt; 2 country   character      0\n#&gt; 3 continent character      0\n#&gt; 4 lifeExp   double         0\n#&gt; 5 pop       double         0\n#&gt; 6 gdpPercap double         0\n\nLuego puede aplicar esta funci√≥n a todos los archivos, y tal vez hacer algunos cambios para que sea m√°s f√°cil ver d√≥nde est√°n las diferencias. Por ejemplo, esto facilita la verificaci√≥n de que las hojas de c√°lculo de gapminder con las que hemos estado trabajando son bastante homog√©neas:\n\nfiles |&gt; \n  map(df_types) |&gt; \n  list_rbind(names_to = \"file_name\") |&gt; \n  select(-n_miss) |&gt; \n  pivot_wider(names_from = col_name, values_from = col_type)\n#&gt; # A tibble: 12 √ó 6\n#&gt;   file_name country   continent lifeExp pop    gdpPercap\n#&gt;   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;    \n#&gt; 1 1952.xlsx character character double  double double   \n#&gt; 2 1957.xlsx character character double  double double   \n#&gt; 3 1962.xlsx character character double  double double   \n#&gt; 4 1967.xlsx character character double  double double   \n#&gt; 5 1972.xlsx character character double  double double   \n#&gt; 6 1977.xlsx character character double  double double   \n#&gt; # ‚Ñπ 6 more rows\n\nSi los archivos tienen formatos heterog√©neos, es posible que deba realizar m√°s procesamiento antes de poder fusionarlos correctamente. Desafortunadamente, ahora vamos a dejar que lo averig√ºes por tu cuenta, pero es posible que desees leer acerca de map_if() y map_at(). map_if() te permite modificar elementos de una lista de forma selectiva en funci√≥n de sus valores; map_at() te permite modificar elementos de forma selectiva en funci√≥n de sus nombres.\n\n26.3.8 Manejo de fallas\nA veces, la estructura de sus datos puede ser lo suficientemente salvaje como para que ni siquiera pueda leer todos los archivos con un solo comando. Y luego te encontrar√°s con una de las desventajas de map: tiene √©xito o falla como un todo. map() leer√° con √©xito todos los archivos en un directorio o fallar√° con un error, leyendo cero archivos. Esto es molesto: ¬øpor qu√© una falla le impide acceder a todos los dem√°s √©xitos?\nAfortunadamente, purrr viene con un ayudante para abordar este problema: possibly(). possibly() es lo que se conoce como operador de funci√≥n: toma una funci√≥n y devuelve una funci√≥n con comportamiento modificado. En particular, possibly() cambia una funci√≥n de error a devolver un valor que especifique:\n\nfiles &lt;- paths |&gt; \n  map(possibly(\\(path) readxl::read_excel(path), NULL))\n\ndata &lt;- files |&gt; list_rbind()\n\nEsto funciona particularmente bien aqu√≠ porque list_rbind(), como muchas funciones de tidyverse, autom√°ticamente ignora NULLs.\nAhora tiene todos los datos que se pueden leer f√°cilmente, y es hora de abordar la parte dif√≠cil de averiguar por qu√© algunos archivos no se cargaron y qu√© hacer al respecto. Comience por obtener las rutas que fallaron:\n\nfailed &lt;- map_vec(files, is.null)\npaths[failed]\n#&gt; character(0)\n\nLuego, vuelva a llamar a la funci√≥n de importaci√≥n para cada falla y descubra qu√© sali√≥ mal.",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>26</span>¬† <span class='chapter-title'>Iteraci√≥n</span>"
    ]
  },
  {
    "objectID": "iteration.html#guardar-m√∫ltiples-salidas",
    "href": "iteration.html#guardar-m√∫ltiples-salidas",
    "title": "26¬† Iteraci√≥n",
    "section": "\n26.4 Guardar m√∫ltiples salidas",
    "text": "26.4 Guardar m√∫ltiples salidas\nEn la √∫ltima secci√≥n, aprendiste sobre map(), que es √∫til para leer m√∫ltiples archivos en un solo objeto. En esta secci√≥n, ahora exploraremos una especie de problema opuesto: ¬øc√≥mo puede tomar uno o m√°s objetos R y guardarlos en uno o m√°s archivos? Exploraremos este desaf√≠o usando tres ejemplos:\n\nGuardar m√∫ltiples data frames en una base de datos.\nGuardar m√∫ltiples data frames en m√∫ltiples archivos .csv.\nGuardar varias gr√°ficas en varios archivos .png.\n\n\n26.4.1 Escribir en una base de datos\nA veces, cuando se trabaja con muchos archivos a la vez, no es posible colocar todos los datos en la memoria a la vez y no se puede hacer map(files, read_csv). Un enfoque para lidiar con este problema es cargar sus datos en una base de datos para que pueda acceder solo a los bits que necesita con dbplyr.\nSi tiene suerte, el paquete de base de datos que est√° utilizando proporcionar√° una funci√≥n √∫til que toma un vector de rutas y las carga todas en la base de datos. Este es el caso con duckdb_read_csv() de duckdb:\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb())\nduckdb::duckdb_read_csv(con, \"gapminder\", paths)\n\nEsto funcionar√≠a bien aqu√≠, pero no tenemos archivos csv, sino hojas de c√°lculo de Excel. As√≠ que vamos a tener que hacerlo ‚Äúa mano‚Äù. Aprender a hacerlo a mano tambi√©n te ayudar√° cuando tengas un mont√≥n de csvs y la base de datos con la que est√°s trabajando no tenga una funci√≥n que los cargue todos.\nNecesitamos comenzar creando una tabla que se llene con datos. La forma m√°s sencilla de hacerlo es creando una plantilla, un data frame ficticio que contiene todas las columnas que queremos, pero solo una muestra de los datos. Para los datos de gapminder, podemos hacer esa plantilla leyendo un solo archivo y a√±adi√©ndole el a√±o:\n\ntemplate &lt;- readxl::read_excel(paths[[1]])\ntemplate$year &lt;- 1952\ntemplate\n#&gt; # A tibble: 142 √ó 6\n#&gt;   country     continent lifeExp      pop gdpPercap  year\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.  1952\n#&gt; 2 Albania     Europe       55.2  1282697     1601.  1952\n#&gt; 3 Algeria     Africa       43.1  9279525     2449.  1952\n#&gt; 4 Angola      Africa       30.0  4232095     3521.  1952\n#&gt; 5 Argentina   Americas     62.5 17876956     5911.  1952\n#&gt; 6 Australia   Oceania      69.1  8691212    10040.  1952\n#&gt; # ‚Ñπ 136 more rows\n\nAhora podemos conectarnos a la base de datos y usar DBI::dbCreateTable() para convertir nuestra plantilla en una tabla de base de datos:\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb())\nDBI::dbCreateTable(con, \"gapminder\", template)\n\ndbCreateTable() no usa los datos en template, solo los nombres y tipos de variables. As√≠ que si inspeccionamos la tabla gapminder ahora ver√°s que est√° vac√≠a pero tiene las variables que necesitamos con los tipos que esperamos:\n\ncon |&gt; tbl(\"gapminder\")\n#&gt; # Source:   table&lt;gapminder&gt; [0 x 6]\n#&gt; # Database: DuckDB v0.10.2 [unknown@Linux 6.11.0-1018-azure:R 4.4.0/:memory:]\n#&gt; # ‚Ñπ 6 variables: country &lt;chr&gt;, continent &lt;chr&gt;, lifeExp &lt;dbl&gt;, pop &lt;dbl&gt;,\n#&gt; #   gdpPercap &lt;dbl&gt;, year &lt;dbl&gt;\n\nA continuaci√≥n, necesitamos una funci√≥n que tome una √∫nica ruta de archivo, la lea en R y agregue el resultado a la tabla gapminder. Podemos hacerlo combinando read_excel() con DBI::dbAppendTable():\n\nappend_file &lt;- function(path) {\n  df &lt;- readxl::read_excel(path)\n  df$year &lt;- parse_number(basename(path))\n  \n  DBI::dbAppendTable(con, \"gapminder\", df)\n}\n\nAhora necesitamos llamar a append_file() una vez por cada elemento de paths. Eso es ciertamente posible con map():\n\npaths |&gt; map(append_file)\n\nPero no nos importa la salida de append_file(), as√≠ que en lugar de map() es un poco mejor usar walk(). walk() hace exactamente lo mismo que map() pero descarta el resultado:\n\npaths |&gt; walk(append_file)\n\nAhora podemos ver si tenemos todos los datos en nuestra tabla:\n\ncon |&gt; \n  tbl(\"gapminder\") |&gt; \n  count(year)\n#&gt; # Source:   SQL [?? x 2]\n#&gt; # Database: DuckDB v0.10.2 [unknown@Linux 6.11.0-1018-azure:R 4.4.0/:memory:]\n#&gt;    year     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  1967   142\n#&gt; 2  1977   142\n#&gt; 3  1987   142\n#&gt; 4  2007   142\n#&gt; 5  1952   142\n#&gt; 6  1957   142\n#&gt; # ‚Ñπ more rows\n\n\n26.4.2 Escribir archivos csv\nEl mismo principio b√°sico se aplica si queremos escribir varios archivos csv, uno para cada grupo. Imaginemos que queremos tomar los datos ggplot2::diamonds y guardar un archivo csv para cada clarity. Primero necesitamos hacer esos conjuntos de datos individuales. Hay muchas formas de hacerlo, pero hay una que nos gusta especialmente: group_nest().\n\nby_clarity &lt;- diamonds |&gt; \n  group_nest(clarity)\n\nby_clarity\n#&gt; # A tibble: 8 √ó 2\n#&gt;   clarity               data\n#&gt;   &lt;ord&gt;   &lt;list&lt;tibble[,9]&gt;&gt;\n#&gt; 1 I1               [741 √ó 9]\n#&gt; 2 SI2            [9,194 √ó 9]\n#&gt; 3 SI1           [13,065 √ó 9]\n#&gt; 4 VS2           [12,258 √ó 9]\n#&gt; 5 VS1            [8,171 √ó 9]\n#&gt; 6 VVS2           [5,066 √ó 9]\n#&gt; # ‚Ñπ 2 more rows\n\nEsto nos da un nuevo tibble con ocho filas y dos columnas. clarity es nuestra variable de agrupaci√≥n y data es una columna de lista que contiene un tibble para cada valor √∫nico de clarity:\n\nby_clarity$data[[1]]\n#&gt; # A tibble: 741 √ó 9\n#&gt;   carat cut       color depth table price     x     y     z\n#&gt;   &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.32 Premium   E      60.9    58   345  4.38  4.42  2.68\n#&gt; 2  1.17 Very Good J      60.2    61  2774  6.83  6.9   4.13\n#&gt; 3  1.01 Premium   F      61.8    60  2781  6.39  6.36  3.94\n#&gt; 4  1.01 Fair      E      64.5    58  2788  6.29  6.21  4.03\n#&gt; 5  0.96 Ideal     F      60.7    55  2801  6.37  6.41  3.88\n#&gt; 6  1.04 Premium   G      62.2    58  2801  6.46  6.41  4   \n#&gt; # ‚Ñπ 735 more rows\n\nYa que estamos aqu√≠, creemos una columna que d√© el nombre del archivo de salida, usando mutate() y str_glue():\n\nby_clarity &lt;- by_clarity |&gt; \n  mutate(path = str_glue(\"diamonds-{clarity}.csv\"))\n\nby_clarity\n#&gt; # A tibble: 8 √ó 3\n#&gt;   clarity               data path             \n#&gt;   &lt;ord&gt;   &lt;list&lt;tibble[,9]&gt;&gt; &lt;glue&gt;           \n#&gt; 1 I1               [741 √ó 9] diamonds-I1.csv  \n#&gt; 2 SI2            [9,194 √ó 9] diamonds-SI2.csv \n#&gt; 3 SI1           [13,065 √ó 9] diamonds-SI1.csv \n#&gt; 4 VS2           [12,258 √ó 9] diamonds-VS2.csv \n#&gt; 5 VS1            [8,171 √ó 9] diamonds-VS1.csv \n#&gt; 6 VVS2           [5,066 √ó 9] diamonds-VVS2.csv\n#&gt; # ‚Ñπ 2 more rows\n\nEntonces, si fu√©ramos a guardar estos data frames a mano, podr√≠amos escribir algo como:\n\nwrite_csv(by_clarity$data[[1]], by_clarity$path[[1]])\nwrite_csv(by_clarity$data[[2]], by_clarity$path[[2]])\nwrite_csv(by_clarity$data[[3]], by_clarity$path[[3]])\n...\nwrite_csv(by_clarity$by_clarity[[8]], by_clarity$path[[8]])\n\nEsto es un poco diferente a nuestros usos anteriores de map() porque hay dos argumentos que est√°n cambiando, no solo uno. Eso significa que necesitamos una nueva funci√≥n: map2(), que var√≠a tanto el primer como el segundo argumento. Y como tampoco nos importa la salida, queremos walk2() en lugar de map2(). Eso nos da:\n\nwalk2(by_clarity$data, by_clarity$path, write_csv)\n\n\n26.4.3 Guardar gr√°ficas\nPodemos tomar el mismo enfoque b√°sico para crear muchas gr√°ficas. Primero hagamos una funci√≥n que dibuje la gr√°fica que queremos:\n\ncarat_histogram &lt;- function(df) {\n  ggplot(df, aes(x = carat)) + geom_histogram(binwidth = 0.1)  \n}\n\ncarat_histogram(by_clarity$data[[1]])\n\n\n\n\n\n\n\nAhora podemos usar map() para crear una lista de muchos gr√°ficos[^iterationn-6] y sus posibles rutas de archivo:\n\nby_clarity &lt;- by_clarity |&gt; \n  mutate(\n    plot = map(data, carat_histogram),\n    path = str_glue(\"clarity-{clarity}.png\")\n  )\n\nLuego usa walk2() con ggsave() para guardar cada gr√°fico:\n\nwalk2(\n  by_clarity$path,\n  by_clarity$plot,\n  \\(path, plot) ggsave(path, plot, width = 6, height = 6)\n)\n\nEsta es la abreviatura de:\n\nggsave(by_clarity$path[[1]], by_clarity$plot[[1]], width = 6, height = 6)\nggsave(by_clarity$path[[2]], by_clarity$plot[[2]], width = 6, height = 6)\nggsave(by_clarity$path[[3]], by_clarity$plot[[3]], width = 6, height = 6)\n...\nggsave(by_clarity$path[[8]], by_clarity$plot[[8]], width = 6, height = 6)",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>26</span>¬† <span class='chapter-title'>Iteraci√≥n</span>"
    ]
  },
  {
    "objectID": "iteration.html#resumen",
    "href": "iteration.html#resumen",
    "title": "26¬† Iteraci√≥n",
    "section": "\n26.5 Resumen",
    "text": "26.5 Resumen\nEn este cap√≠tulo, ha visto c√≥mo usar la iteraci√≥n expl√≠cita para resolver tres problemas que surgen con frecuencia al hacer ciencia de datos: manipular m√∫ltiples columnas, leer m√∫ltiples archivos y guardar m√∫ltiples salidas. Pero, en general, la iteraci√≥n es un superpoder: si conoce la t√©cnica de iteraci√≥n correcta, puede pasar f√°cilmente de solucionar un problema a solucionar todos los problemas. Una vez que haya dominado las t√©cnicas de este cap√≠tulo, le recomendamos que aprenda m√°s leyendo el cap√≠tulo Funcionales de Advanced R y consultando el sitio web de purrr.\nSi sabe mucho sobre la iteraci√≥n en otros lenguajes, se sorprender√° de que no hayamos discutido el bucle for. Esto se debe a que la orientaci√≥n de R hacia el an√°lisis de datos cambia la forma en que iteramos: en la mayor√≠a de los casos, puede confiar en un idioma existente para hacer algo con cada columna o cada grupo. Y cuando no puedas, a menudo puedes usar una herramienta de programaci√≥n funcional como map() que hace algo con cada elemento de una lista. Sin embargo, ver√° bucles for en el c√≥digo capturado de forma salvaje, por lo que aprender√° sobre ellos en el pr√≥ximo cap√≠tulo, donde analizaremos algunas herramientas b√°sicas importantes de R.",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>26</span>¬† <span class='chapter-title'>Iteraci√≥n</span>"
    ]
  },
  {
    "objectID": "iteration.html#footnotes",
    "href": "iteration.html#footnotes",
    "title": "26¬† Iteraci√≥n",
    "section": "",
    "text": "An√≥nimo, porque nunca le dimos expl√≠citamente un nombre con &lt;-. Otro t√©rmino que usan los programadores para esto es ‚Äúfunci√≥n lambda‚Äù.‚Ü©Ô∏é\nactualmente no puede cambiar el orden de las columnas, pero podr√≠a reordenarlas despu√©s usando relocate() o similar.‚Ü©Ô∏é\nTal vez habr√° un d√≠a, pero actualmente no vemos c√≥mo.‚Ü©Ô∏é\nno vamos a explicar c√≥mo funciona, pero si miras los documentos de las funciones utilizadas, deber√≠as poder descifrarlo.‚Ü©Ô∏é",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>26</span>¬† <span class='chapter-title'>Iteraci√≥n</span>"
    ]
  },
  {
    "objectID": "base-R.html",
    "href": "base-R.html",
    "title": "27¬† Una gu√≠a para R base",
    "section": "",
    "text": "27.1 Introducci√≥n\nPara finalizar la secci√≥n de programaci√≥n, le daremos un recorrido r√°pido por las funciones b√°sicas de R m√°s importantes que no trataremos en este libro. Estas herramientas son particularmente √∫tiles a medida que programa m√°s y lo ayudar√°n a leer el c√≥digo que encontrar√° en la naturaleza.\nEste es un buen lugar para recordarle que tidyverse no es la √∫nica forma de resolver problemas de ciencia de datos. Ense√±amos el tidyverse en este libro porque los paquetes de tidyverse comparten una filosof√≠a de dise√±o com√∫n, aumentando la consistencia entre las funciones y haciendo que cada nueva funci√≥n o paquete sea un poco m√°s f√°cil de aprender y usar. No es posible usar tidyverse sin usar base R, por lo que en realidad ya te hemos ense√±ado un mont√≥n de funciones base R: desde library() para cargar paquetes, hasta sum() y mean () para res√∫menes num√©ricos, hasta los tipos de datos factor, fecha y POSIXct y, por supuesto, todos los operadores b√°sicos como +, -, /, *, |, &, y !. En lo que no nos hemos centrado hasta ahora son los flujos de trabajo b√°sicos de R, por lo que destacaremos algunos de ellos en este cap√≠tulo.\nDespu√©s de leer este libro, aprender√° otros enfoques para los mismos problemas usando base R, data.table y otros paquetes. Sin duda, encontrar√° estos otros enfoques cuando comience a leer el c√≥digo R escrito por otros, especialmente si est√° usando StackOverflow. Est√° 100 % bien escribir c√≥digo que use una combinaci√≥n de enfoques, ¬°y no dejes que nadie te diga lo contrario!\nEn este cap√≠tulo, nos centraremos en cuatro grandes temas: creaci√≥n de subconjuntos con [, creaci√≥n de subconjuntos con [[ y $, la familia de funciones apply y bucles for. Para terminar, discutiremos brevemente dos funciones de gr√°ficas esenciales.",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>27</span>¬† <span class='chapter-title'>Una gu√≠a para R base</span>"
    ]
  },
  {
    "objectID": "base-R.html#introducci√≥n",
    "href": "base-R.html#introducci√≥n",
    "title": "27¬† Una gu√≠a para R base",
    "section": "",
    "text": "27.1.1 Requisitos previos\nEste paquete se centra en la base R, por lo que no tiene requisitos previos reales, pero cargaremos el tidyverse para explicar algunas de las diferencias.\n\nlibrary(tidyverse)",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>27</span>¬† <span class='chapter-title'>Una gu√≠a para R base</span>"
    ]
  },
  {
    "objectID": "base-R.html#sec-subset-many",
    "href": "base-R.html#sec-subset-many",
    "title": "27¬† Una gu√≠a para R base",
    "section": "\n27.2 Selecci√≥n de varios elementos con [\n",
    "text": "27.2 Selecci√≥n de varios elementos con [\n\n[ se usa para extraer subcomponentes de vectores y marcos de datos, y se llama x[i] o x[i, j]. En esta secci√≥n, le presentaremos el poder de [, primero mostr√°ndole c√≥mo puede usarlo con vectores, luego c√≥mo los mismos principios se extienden de manera sencilla a estructuras bidimensionales (2d) como marcos de datos. Luego, lo ayudaremos a consolidar ese conocimiento al mostrar c√≥mo varios verbos dplyr son casos especiales de [.\n\n27.2.1 Subconjunto de vectores\nHay cinco tipos principales de elementos con los que puede crear subconjuntos de un vector, es decir, que pueden ser la i en x[i]:\n\n\nUn vector de enteros positivos. Subdividir con enteros positivos mantiene los elementos en esas posiciones:\n\nx &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\")\nx[c(3, 2, 5)]\n#&gt; [1] \"three\" \"two\"   \"five\"\n\nAl repetir una posici√≥n, en realidad puede hacer una salida m√°s larga que la entrada, lo que hace que el t√©rmino ‚Äúsubconjunto‚Äù sea un poco inapropiado.\n\nx[c(1, 1, 5, 5, 5, 2)]\n#&gt; [1] \"one\"  \"one\"  \"five\" \"five\" \"five\" \"two\"\n\n\n\nUn vector de enteros negativos. Los valores negativos colocan los elementos en las posiciones especificadas:\n\nx[c(-1, -3, -5)]\n#&gt; [1] \"two\"  \"four\"\n\n\n\nUn vector l√≥gico. La creaci√≥n de subconjuntos con un vector l√≥gico mantiene todos los valores correspondientes a un valor TRUE. Esto suele ser √∫til junto con las funciones de comparaci√≥n.\n\nx &lt;- c(10, 3, NA, 5, 8, 1, NA)\n\n# Todos los valores no faltante de x\nx[!is.na(x)]\n#&gt; [1] 10  3  5  8  1\n\n# Todos los valore de x pares (¬°o faltante!)\nx[x %% 2 == 0]\n#&gt; [1] 10 NA  8 NA\n\nA diferencia de filter(), los √≠ndices NA se incluir√°n en la salida como NAs.\n\n\nUn vector de caracteres. Si tiene un vector con nombre, puede crear subconjuntos con un vector de caracteres:\n\nx &lt;- c(abc = 1, def = 2, xyz = 5)\nx[c(\"xyz\", \"def\")]\n#&gt; xyz def \n#&gt;   5   2\n\nAl igual que con la creaci√≥n de subconjuntos con n√∫meros enteros positivos, puede usar un vector de caracteres para duplicar entradas individuales.\n\nNada. El √∫ltimo tipo de subconjunto es nada, x[], que devuelve la x completa. Esto no es √∫til para crear subconjuntos de vectores, pero como veremos en breve, es √∫til para crear subconjuntos de estructuras 2d como tibbles.\n\n27.2.2 Subconjuntos de data frames\nHay bastantes formas diferentes1 de usar [ con un marco de datos, pero la forma m√°s importante es seleccionar filas y columnas de forma independiente con df[rows, cols]. Aqu√≠ rows y cols son vectores como se describe arriba. Por ejemplo, df[rows, ] y df[, cols] seleccionan solo filas o solo columnas, utilizando el subconjunto vac√≠o para conservar la otra dimensi√≥n.\nAqu√≠ hay un par de ejemplos:\n\ndf &lt;- tibble(\n  x = 1:3, \n  y = c(\"a\", \"e\", \"f\"), \n  z = runif(3)\n)\n\n# Selecciona la primera fila y la segunda columna\ndf[1, 2]\n#&gt; # A tibble: 1 √ó 1\n#&gt;   y    \n#&gt;   &lt;chr&gt;\n#&gt; 1 a\n\n# Selecciona todas las filas y las columnas x e y\ndf[, c(\"x\" , \"y\")]\n#&gt; # A tibble: 3 √ó 2\n#&gt;       x y    \n#&gt;   &lt;int&gt; &lt;chr&gt;\n#&gt; 1     1 a    \n#&gt; 2     2 e    \n#&gt; 3     3 f\n\n# Selecciona las filas donde `x` es mayor que 1 y todas las columnas\ndf[df$x &gt; 1, ]\n#&gt; # A tibble: 2 √ó 3\n#&gt;       x y         z\n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     2 e     0.834\n#&gt; 2     3 f     0.601\n\nVolveremos a $ en breve, pero deber√≠a poder adivinar lo que hace df$x a partir del contexto: extrae la variable x de df. Necesitamos usarlo aqu√≠ porque [ no usa una evaluaci√≥n ordenada, por lo que debe ser expl√≠cito sobre la fuente de la variable x.\nHay una diferencia importante entre tibbles y marcos de datos cuando se trata de [. En este libro, hemos usado principalmente tibbles, que son marcos de datos, pero ajustan algunos comportamientos para hacer su vida un poco m√°s f√°cil. En la mayor√≠a de los lugares, puede usar ‚Äútibble‚Äù y ‚Äúmarco de datos‚Äù indistintamente, por lo que cuando queramos llamar la atenci√≥n sobre el marco de datos integrado de R, escribiremos data.frame. Si df es un data.frame, df[, cols] devolver√° un vector si col selecciona una sola columna y un marco de datos si selecciona m√°s de una columna. Si df es un tibble, entonces [ siempre devolver√° un tibble.\n\ndf1 &lt;- data.frame(x = 1:3)\ndf1[, \"x\"]\n#&gt; [1] 1 2 3\n\ndf2 &lt;- tibble(x = 1:3)\ndf2[, \"x\"]\n#&gt; # A tibble: 3 √ó 1\n#&gt;       x\n#&gt;   &lt;int&gt;\n#&gt; 1     1\n#&gt; 2     2\n#&gt; 3     3\n\nUna forma de evitar esta ambig√ºedad con data.frames es especificar expl√≠citamente drop = FALSE:\n\ndf1[, \"x\" , drop = FALSE]\n#&gt;   x\n#&gt; 1 1\n#&gt; 2 2\n#&gt; 3 3\n\n\n27.2.3 equivalentes de dplyr\nVarios verbos dplyr son casos especiales de [:\n\n\nfilter() es equivalente a subdividir las filas con un vector l√≥gico, teniendo cuidado de excluir los valores faltantes:\n\ndf &lt;- tibble(\n  x = c(2, 3, 1, 1, NA), \n  y = letters[1:5], \n  z = runif(5)\n)\ndf |&gt; filter(x &gt; 1)\n\n# igual que\ndf[!is.na(df$x) & df$x &gt; 1, ]\n\nOtra t√©cnica com√∫n en la naturaleza es usar which() por su efecto secundario de descartar valores faltantes: df[which(df$x &gt; 1), ].\n\n\narrange() es equivalente a dividir las filas en subconjuntos con un vector entero, generalmente creado con order():\n\ndf |&gt; arrange(x, y)\n\n# igual que\ndf[order(df$x, df$y), ]\n\nPuede usar order(decreasing = TRUE) para ordenar todas las columnas en orden descendente o -rank(col) para ordenar las columnas en orden decreciente individualmente.\n\n\nTanto select() como relocate() son similares a subdividir las columnas con un vector de caracteres:\n\ndf |&gt; select(x, z)\n\n# igual que\ndf[, c(\"x\", \"z\")]\n\n\n\nBase R tambi√©n proporciona una funci√≥n que combina las caracter√≠sticas de filter() y select()2 llamada subset():\n\ndf |&gt; \n  filter(x &gt; 1) |&gt; \n  select(y, z)\n#&gt; # A tibble: 2 √ó 2\n#&gt;   y           z\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1 a     0.157  \n#&gt; 2 b     0.00740\n\n\n# same as\ndf |&gt; subset(x &gt; 1, c(y, z))\n\nEsta funci√≥n fue la inspiraci√≥n para gran parte de la sintaxis de dplyr.\n\n27.2.4 Ejercicios\n\n\nCrear funciones que tomen un vector como entrada y retorno:\n\nLos elementos en posiciones pares.\nTodos los elementos excepto el √∫ltimo valor.\nSolo valores pares (y sin valores faltantes).\n\n\n¬øPor qu√© x[-which(x &gt; 0)] no es lo mismo que x[x &lt;= 0]? Lea la documentaci√≥n de which() y haga algunos experimentos para averiguarlo..",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>27</span>¬† <span class='chapter-title'>Una gu√≠a para R base</span>"
    ]
  },
  {
    "objectID": "base-R.html#sec-subset-one",
    "href": "base-R.html#sec-subset-one",
    "title": "27¬† Una gu√≠a para R base",
    "section": "\n27.3 Seleccionando un solo elemento con $ y [[\n",
    "text": "27.3 Seleccionando un solo elemento con $ y [[\n\n[, que selecciona muchos elementos, se combina con [[ y $, que extraen un solo elemento. En esta secci√≥n, le mostraremos c√≥mo usar [[ y $ para extraer columnas de los marcos de datos, analizaremos un par de diferencias m√°s entre data.frames y tibbles, y enfatizaremos algunas diferencias importantes entre [ y [[ cuando se usa con listas.\n\n27.3.1 Data frames\n[[ y $ se puede usar para extraer columnas de un marco de datos. [[ puede acceder por posici√≥n o por nombre, y $ est√° especializado para acceder por nombre:\n\ntb &lt;- tibble(\n  x = 1:4,\n  y = c(10, 4, 1, 21)\n)\n\n# por posici√≥nn\ntb[[1]]\n#&gt; [1] 1 2 3 4\n\n# por nombre\ntb[[\"x\"]]\n#&gt; [1] 1 2 3 4\ntb$x\n#&gt; [1] 1 2 3 4\n\nTambi√©n se pueden usar para crear nuevas columnas, el equivalente base R de mutate():\n\ntb$z &lt;- tb$x + tb$y\ntb\n#&gt; # A tibble: 4 √ó 3\n#&gt;       x     y     z\n#&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    10    11\n#&gt; 2     2     4     6\n#&gt; 3     3     1     4\n#&gt; 4     4    21    25\n\nHay varios otros enfoques b√°sicos de R para crear nuevas columnas, incluidos transform(), with() y within(). Hadley reuni√≥ algunos ejemplos en https://gist.github.com/hadley/1986a273e384fb2d4d752c18ed71bedf.\nUsar $ directamente es conveniente cuando se realizan res√∫menes r√°pidos. Por ejemplo, si solo desea encontrar el tama√±o del diamante m√°s grande o los posibles valores de cut, no es necesario usar summarize():\n\nmax(diamonds$carat)\n#&gt; [1] 5.01\n\nlevels(diamonds$cut)\n#&gt; [1] \"Fair\"      \"Good\"      \"Very Good\" \"Premium\"   \"Ideal\"\n\ndplyr tambi√©n proporciona un equivalente a [[/$ que no mencionamos en Cap√≠tulo 3: pull(). pull() toma un nombre de variable o una posici√≥n de variable y devuelve solo esa columna. Eso significa que podr√≠amos reescribir el c√≥digo anterior para usar pipe:\n\ndiamonds |&gt; pull(carat) |&gt; max()\n#&gt; [1] 5.01\n\ndiamonds |&gt; pull(cut) |&gt; levels()\n#&gt; [1] \"Fair\"      \"Good\"      \"Very Good\" \"Premium\"   \"Ideal\"\n\n\n27.3.2 Tibbles\nHay un par de diferencias importantes entre tibbles y data.frames base cuando se trata de $. Los marcos de datos coinciden con el prefijo de cualquier nombre de variable (la llamada coincidencia parcial) y no se quejan si una columna no existe:\n\ndf &lt;- data.frame(x1 = 1)\ndf$x\n#&gt; [1] 1\ndf$z\n#&gt; NULL\n\nLos Tibbles son m√°s estrictos: solo coinciden exactamente con los nombres de las variables y generar√°n una advertencia si la columna a la que intenta acceder no existe:\n\ntb &lt;- tibble(x1 = 1)\n\ntb$x\n#&gt; Warning: Unknown or uninitialised column: `x`.\n#&gt; NULL\ntb$z\n#&gt; Warning: Unknown or uninitialised column: `z`.\n#&gt; NULL\n\nPor eso a veces bromeamos diciendo que los tibbles son holgazanes y hoscos: hacen menos y se quejan m√°s.\n\n27.3.3 Listas\n[[ y $ tambi√©n son muy importantes para trabajar con listas, y es importante comprender en qu√© se diferencian de [. Ilustremos las diferencias con una lista llamada l:\n\nl &lt;- list(\n  a = 1:3, \n  b = \"a string\", \n  c = pi, \n  d = list(-1, -5)\n)\n\n\n\n[ extrae una sublista. No importa cu√°ntos elementos extraiga, el resultado siempre ser√° una lista.\n\nstr(l[1:2])\n#&gt; List of 2\n#&gt;  $ a: int [1:3] 1 2 3\n#&gt;  $ b: chr \"a string\"\n\nstr(l[1])\n#&gt; List of 1\n#&gt;  $ a: int [1:3] 1 2 3\n\nstr(l[4])\n#&gt; List of 1\n#&gt;  $ d:List of 2\n#&gt;   ..$ : num -1\n#&gt;   ..$ : num -5\n\nAl igual que con los vectores, puede crear subconjuntos con un vector l√≥gico, entero o de caracteres.\n\n\n[[ y $ extrae un solo componente de una lista. Eliminan un nivel de jerarqu√≠a de la lista.\n\nstr(l[[1]])\n#&gt;  int [1:3] 1 2 3\n\nstr(l[[4]])\n#&gt; List of 2\n#&gt;  $ : num -1\n#&gt;  $ : num -5\n\nstr(l$a)\n#&gt;  int [1:3] 1 2 3\n\n\n\nLa diferencia entre [ y [[ es particularmente importante para las listas porque [[ profundiza en la lista mientras que [ devuelve una nueva lista m√°s peque√±a. Para ayudarlo a recordar la diferencia, eche un vistazo al pimentero inusual que se muestra en Figura¬†27.1. Si este pimentero es su lista pepper, entonces pepper[1] es un pimentero que contiene un solo paquete de pimienta. pepper[2] se ver√≠a igual, pero contendr√≠a el segundo paquete. pepper[1:2] ser√≠a un pimentero que contiene dos paquetes de pimienta. pepper[[1]] extraer√≠a el propio paquete de pimienta.\n\n\n\n\n\n\n\nFigura¬†27.1: (Izquierda) Un pimentero que Hadley encontr√≥ una vez en su habitaci√≥n de hotel. (Centro) pepper[1] (Derecha) pepper[[1]]\n\n\n\n\nEste mismo principio se aplica cuando usa 1d [ con un marco de datos: df[\"x\"] devuelve un marco de datos de una columna y df[[\"x\"]] devuelve un vector.\n\n27.3.4 Ejercicios\n\n¬øQu√© sucede cuando usas [[ con un entero positivo que es m√°s grande que la longitud del vector? ¬øQu√© sucede cuando creas un subconjunto con un nombre que no existe?\n¬øQu√© ser√≠a pepper[[1]][1]? ¬øQu√© pasa con pepper[[1]][[1]]?",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>27</span>¬† <span class='chapter-title'>Una gu√≠a para R base</span>"
    ]
  },
  {
    "objectID": "base-R.html#familia-apply",
    "href": "base-R.html#familia-apply",
    "title": "27¬† Una gu√≠a para R base",
    "section": "\n27.4 Familia apply",
    "text": "27.4 Familia apply\nEn Cap√≠tulo 26, aprendi√≥ t√©cnicas tidyverse para la iteraci√≥n como dplyr::across() y la familia de funciones map. En esta secci√≥n, aprender√° sobre sus equivalentes b√°sicos, la familia apply. En este contexto, aplicar y mapear son sin√≥nimos porque otra forma de decir ‚Äúmapear una funci√≥n sobre cada elemento de un vector‚Äù es ‚Äúaplicar una funci√≥n sobre cada elemento de un vector‚Äù. Aqu√≠ le daremos una descripci√≥n general r√°pida de esta familia para que pueda reconocerlos en la naturaleza.\nEl miembro m√°s importante de esta familia es lapply(), que es muy similar a purrr::map()3. De hecho, debido a que no hemos usado ninguna de las caracter√≠sticas m√°s avanzadas de map(), puede reemplazar cada llamada map() en Cap√≠tulo 26 con lapply().\nNo hay una base R equivalente exacta a across() pero puedes acercarte usando [ con lapply(). Esto funciona porque, bajo el cap√≥, los marcos de datos son listas de columnas, por lo que llamar a lapply() en un marco de datos aplica la funci√≥n a cada columna.\n\ndf &lt;- tibble(a = 1, b = 2, c = \"a\", d = \"b\", e = 4)\n\n# Primero encuentra columnas num√©ricas\nnum_cols &lt;- sapply(df, is.numeric)\nnum_cols\n#&gt;     a     b     c     d     e \n#&gt;  TRUE  TRUE FALSE FALSE  TRUE\n\n# Luego transforme cada columna con lapply() y luego reemplace los valores originales\ndf[, num_cols] &lt;- lapply(df[, num_cols, drop = FALSE], \\(x) x * 2)\ndf\n#&gt; # A tibble: 1 √ó 5\n#&gt;       a     b c     d         e\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     2     4 a     b         8\n\nEl c√≥digo anterior usa una nueva funci√≥n, sapply(). Es similar a lapply() pero siempre intenta simplificar el resultado, de ah√≠ la s en su nombre, produciendo aqu√≠ un vector l√≥gico en lugar de una lista. No recomendamos usarlo para programar, porque la simplificaci√≥n puede fallar y generar un tipo inesperado, pero generalmente est√° bien para uso interactivo. purrr tiene una funci√≥n similar llamada map_vec() que no mencionamos en Cap√≠tulo 26.\nBase R proporciona una versi√≥n m√°s estricta de sapply() llamada vapply(), abreviatura de vector apply. Toma un argumento adicional que especifica el tipo esperado, lo que garantiza que la simplificaci√≥n ocurra de la misma manera, independientemente de la entrada. Por ejemplo, podr√≠amos reemplazar la llamada sapply() anterior con vapply() donde especificamos que esperamos que is.numeric() devuelva un vector l√≥gico de longitud 1:\n\nvapply(df, is.numeric, logical(1))\n#&gt;     a     b     c     d     e \n#&gt;  TRUE  TRUE FALSE FALSE  TRUE\n\nLa distinci√≥n entre sapply() y vapply() es realmente importante cuando est√°n dentro de una funci√≥n (porque hace una gran diferencia en la solidez de la funci√≥n ante entradas inusuales), pero generalmente no importa en el an√°lisis de datos.\nOtro miembro importante de la familia apply es tapply(), que calcula un solo resumen agrupado:\n\ndiamonds |&gt; \n  group_by(cut) |&gt; \n  summarize(price = mean(price))\n#&gt; # A tibble: 5 √ó 2\n#&gt;   cut       price\n#&gt;   &lt;ord&gt;     &lt;dbl&gt;\n#&gt; 1 Fair      4359.\n#&gt; 2 Good      3929.\n#&gt; 3 Very Good 3982.\n#&gt; 4 Premium   4584.\n#&gt; 5 Ideal     3458.\n\ntapply(diamonds$price, diamonds$cut, mean)\n#&gt;      Fair      Good Very Good   Premium     Ideal \n#&gt;  4358.758  3928.864  3981.760  4584.258  3457.542\n\nDesafortunadamente, tapply() devuelve sus resultados en un vector con nombre que requiere algo de gimnasia si desea recopilar m√∫ltiples res√∫menes y agrupar variables en un marco de datos (ciertamente es posible no hacer esto y solo trabajar con vectores flotantes libres, pero en nuestro experiencia que s√≥lo retrasa el trabajo). Si desea ver c√≥mo podr√≠a usar tapply() u otras t√©cnicas b√°sicas para realizar otros res√∫menes agrupados, Hadley ha recopilado algunas t√©cnicas en un gist .\nEl √∫ltimo miembro de la familia apply es el titular apply(), que funciona con matrices y arreglos. En particular, tenga cuidado con apply(df, 2, something), que es una forma lenta y potencialmente peligrosa de hacer lapply(df, something). Esto rara vez surge en la ciencia de datos porque generalmente trabajamos con marcos de datos y no con matrices.",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>27</span>¬† <span class='chapter-title'>Una gu√≠a para R base</span>"
    ]
  },
  {
    "objectID": "base-R.html#bucles-for",
    "href": "base-R.html#bucles-for",
    "title": "27¬† Una gu√≠a para R base",
    "section": "\n27.5 Bucles for\n",
    "text": "27.5 Bucles for\n\nLos bucles for son el bloque de construcci√≥n fundamental de la iteraci√≥n que tanto la familia apply como la funci√≥n map utilizan bajo el cap√≥. Los bucles for son herramientas poderosas y generales que es importante aprender a medida que se convierte en un programador de R m√°s experimentado. La estructura b√°sica de un bucle for se ve as√≠:\n\nfor (element in vector) {\n  # hacer algo con el elemento\n}\n\nEl uso m√°s directo de los bucles for es lograr el mismo efecto que walk(): llamar a alguna funci√≥n con un efecto secundario en cada elemento de una lista. Por ejemplo, en Secci√≥n 26.4.1 en lugar de caminar:\n\npaths |&gt; walk(append_file)\n\nPodr√≠amos haber usado un bucle for:\n\nfor (path in paths) {\n  append_file(path)\n}\n\nLas cosas se vuelven un poco m√°s complicadas si desea guardar la salida del bucle for, por ejemplo, leyendo todos los archivos de Excel en un directorio como hicimos en Cap√≠tulo 26:\n\npaths &lt;- dir(\"data/gapminder\", pattern = \"\\\\.xlsx$\", full.names = TRUE)\nfiles &lt;- map(paths, readxl::read_excel)\n\nHay algunas t√©cnicas diferentes que puede usar, pero le recomendamos que sea expl√≠cito sobre c√≥mo se ver√° la salida por adelantado. En este caso, vamos a querer una lista de la misma longitud que paths, que podemos crear con vector():\n\nfiles &lt;- vector(\"list\", length(paths))\n\nLuego, en lugar de iterar sobre los elementos de paths, iteramos sobre sus √≠ndices, usando seq_along() para generar un √≠ndice para cada elemento de las rutas:\n\nseq_along(paths)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\nUsar los √≠ndices es importante porque nos permite vincular cada posici√≥n en la entrada con la posici√≥n correspondiente en la salida:\n\nfor (i in seq_along(paths)) {\n  files[[i]] &lt;- readxl::read_excel(paths[[i]])\n}\n\nPara combinar la lista de tibbles en un solo tibble puedes usar do.call() + rbind():\n\ndo.call(rbind, files)\n#&gt; # A tibble: 1,704 √ó 5\n#&gt;   country     continent lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Afghanistan Asia         28.8  8425333      779.\n#&gt; 2 Albania     Europe       55.2  1282697     1601.\n#&gt; 3 Algeria     Africa       43.1  9279525     2449.\n#&gt; 4 Angola      Africa       30.0  4232095     3521.\n#&gt; 5 Argentina   Americas     62.5 17876956     5911.\n#&gt; 6 Australia   Oceania      69.1  8691212    10040.\n#&gt; # ‚Ñπ 1,698 more rows\n\nEn lugar de hacer una lista y guardar los resultados a medida que avanzamos, un enfoque m√°s simple es construir el marco de datos pieza por pieza:\n\nout &lt;- NULL\nfor (path in paths) {\n  out &lt;- rbind(out, readxl::read_excel(path))\n}\n\nRecomendamos evitar este patr√≥n porque puede volverse muy lento cuando el vector es muy largo. Esta es la fuente del bulo persistente de que los bucles for son lentos: no lo son, pero el crecimiento iterativo de un vector s√≠ lo es.",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>27</span>¬† <span class='chapter-title'>Una gu√≠a para R base</span>"
    ]
  },
  {
    "objectID": "base-R.html#gr√°ficas",
    "href": "base-R.html#gr√°ficas",
    "title": "27¬† Una gu√≠a para R base",
    "section": "\n27.6 Gr√°ficas",
    "text": "27.6 Gr√°ficas\nMuchos usuarios de R que no usan tidyverse igualmente prefieren ggplot2 para gr√°ficar debido a caracter√≠sticas √∫tiles como valores predeterminados sensibles, leyendas autom√°ticas y una apariencia moderna. Sin embargo, las funciones gr√°ficas base R a√∫n pueden ser √∫tiles porque son muy concisas; se necesita escribir muy poco para hacer un gr√°fico exploratorio b√°sico.\nHay dos tipos principales de gr√°ficos base que ver√° en la naturaleza: diagramas de dispersi√≥n e histogramas, producidos con plot() y hist() respectivamente. Aqu√≠ hay un ejemplo r√°pido del conjunto de datos de diamantes:\n# Izquierda\nhist(diamonds$carat)\n\n# Derecha\nplot(diamonds$carat, diamonds$price)\n\n\n\n\n\n\n\n\n\n\nTenga en cuenta que las funciones de trazado base funcionan con vectores, por lo que debe extraer columnas del marco de datos utilizando $ o alguna otra t√©cnica.",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>27</span>¬† <span class='chapter-title'>Una gu√≠a para R base</span>"
    ]
  },
  {
    "objectID": "base-R.html#resumen",
    "href": "base-R.html#resumen",
    "title": "27¬† Una gu√≠a para R base",
    "section": "\n27.7 Resumen",
    "text": "27.7 Resumen\nEn este cap√≠tulo, le mostramos una selecci√≥n de funciones b√°sicas de R √∫tiles para la creaci√≥n de subconjuntos y la iteraci√≥n. En comparaci√≥n con los enfoques discutidos en otras partes del libro, estas funciones tienden a tener m√°s un sabor de ‚Äúvector‚Äù que un sabor de ‚Äúmarco de datos‚Äù porque las funciones base de R tienden a tomar vectores individuales, en lugar de un marco de datos y alguna especificaci√≥n de columna. Esto a menudo hace que la vida sea m√°s f√°cil para la programaci√≥n y, por lo tanto, se vuelve m√°s importante a medida que escribe m√°s funciones y comienza a escribir sus propios paquetes.\nEste cap√≠tulo concluye la secci√≥n de programaci√≥n del libro. Ha tenido un comienzo s√≥lido en su viaje para convertirse no solo en un cient√≠fico de datos que usa R, sino en un cient√≠fico de datos que puede programar en R. Esperamos que estos cap√≠tulos hayan despertado su inter√©s en la programaci√≥n y que desee aprender m√°s fuera de este libro.",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>27</span>¬† <span class='chapter-title'>Una gu√≠a para R base</span>"
    ]
  },
  {
    "objectID": "base-R.html#footnotes",
    "href": "base-R.html#footnotes",
    "title": "27¬† Una gu√≠a para R base",
    "section": "",
    "text": "Lea https://adv-r.hadley.nz/subsetting.html#subset-multiple para ver c√≥mo tambi√©n puede crear subconjuntos de un marco de datos como si fuera un objeto 1d y c√≥mo puede crear subconjuntos con una matriz.‚Ü©Ô∏é\nPero no maneja marcos de datos agrupados de manera diferente y no admite funciones auxiliares de selecci√≥n como starts_with().‚Ü©Ô∏é\nSimplemente carece de caracter√≠sticas convenientes como barras de progreso e informar qu√© elemento caus√≥ el problema si hay un error.‚Ü©Ô∏é",
    "crumbs": [
      "Programa",
      "<span class='chapter-number'>27</span>¬† <span class='chapter-title'>Una gu√≠a para R base</span>"
    ]
  },
  {
    "objectID": "communicate.html",
    "href": "communicate.html",
    "title": "Comunicar",
    "section": "",
    "text": "Hasta ahora, aprendi√≥ las herramientas para obtener sus datos en R, ordenarlos en una forma conveniente para el an√°lisis y luego comprender sus datos a trav√©s de la transformaci√≥n y la visualizaci√≥n. Sin embargo, no importa qu√© tan bueno sea su an√°lisis a menos que pueda explic√°rselo a otros: necesita comunicar sus resultados.\n\n\n\n\n\n\n\nFigura¬†1: La comunicaci√≥n es la parte final del proceso de ciencia de datos; si no puede comunicar sus resultados a otros humanos, no importa cu√°n bueno sea su an√°lisis.\n\n\n\n\nLa comunicaci√≥n es el tema de los dos cap√≠tulos siguientes:\n\nEn 28¬† Quarto, aprender√° sobre Quarto, una herramienta para integrar prosa, c√≥digo y resultados. Puede utilizar Quarto para la comunicaci√≥n de analista a analista, as√≠ como para la comunicaci√≥n de analista a responsable de la toma de decisiones. Gracias a la potencia de los formatos Quarto, incluso puede utilizar el mismo documento para ambos fines.\nEn 29¬† Formatos Quarto, aprender√° un poco sobre las muchas otras variedades de salidas que puede producir con Quarto, incluidos paneles, sitios web y libros.\n\nEstos cap√≠tulos se centran principalmente en la mec√°nica t√©cnica de la comunicaci√≥n, no en los problemas realmente dif√≠ciles de comunicar tus pensamientos a otros humanos. Sin embargo, hay muchos otros grandes libros sobre comunicaci√≥n, a los que le indicaremos al final de cada cap√≠tulo.",
    "crumbs": [
      "Comunicar"
    ]
  },
  {
    "objectID": "quarto.html",
    "href": "quarto.html",
    "title": "28¬† Quarto",
    "section": "",
    "text": "28.1 Introducci√≥n\nQuarto proporciona un marco de creaci√≥n unificado para la ciencia de datos, combinando su c√≥digo, sus resultados y su prosa. Los documentos Quarto son totalmente reproducibles y admiten docenas de formatos de salida, como PDF, archivos de Word, presentaciones y m√°s.\nLos archivos Quarto est√°n dise√±ados para usarse de tres maneras:\nQuarto es una herramienta de interfaz de l√≠nea de comandos, no un paquete R. Esto significa que la ayuda, en general, no est√° disponible a trav√©s de ?. En cambio, mientras trabaja en este cap√≠tulo y usa Quarto en el futuro, debe consultar la documentaci√≥n de Quarto.\nSi es un usuario de R Markdown, podr√≠a estar pensando ‚ÄúQuarto se parece mucho a R Markdown‚Äù. ¬°Tu no estas equivocado! Quarto unifica la funcionalidad de muchos paquetes del ecosistema R Markdown (rmarkdown, bookdown, destilar, xaringan, etc.) en un solo sistema consistente y lo ampl√≠a con soporte nativo para m√∫ltiples lenguajes de programaci√≥n como Python y Julia adem√°s de R. En cierto modo, Quarto refleja todo lo que se aprendi√≥ al expandir y respaldar el ecosistema R Markdown durante una d√©cada.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>28</span>¬† <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#introducci√≥n",
    "href": "quarto.html#introducci√≥n",
    "title": "28¬† Quarto",
    "section": "",
    "text": "Para comunicarse con los tomadores de decisiones, que quieren centrarse en las conclusiones, no en el c√≥digo detr√°s del an√°lisis.\nPara colaborar con otros cient√≠ficos de datos (¬°incluido el futuro usted!), que est√°n interesados tanto en sus conclusiones como en c√≥mo las alcanz√≥ (es decir, el c√≥digo).\nComo un entorno en el que hacer ciencia de datos, como un cuaderno de laboratorio moderno donde puede capturar no solo lo que hizo, sino tambi√©n lo que estaba pensando.\n\n\n\n\n28.1.1 Requisitos previos\nNecesita la interfaz de l√≠nea de comandos de Quarto (Quarto CLI), pero no necesita instalarla o cargarla expl√≠citamente, ya que RStudio hace ambas cosas autom√°ticamente cuando es necesario.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>28</span>¬† <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#quarto-basics",
    "href": "quarto.html#quarto-basics",
    "title": "28¬† Quarto",
    "section": "\n28.2 Quarto basics",
    "text": "28.2 Quarto basics\nEste es un archivo Quarto, un archivo de texto sin formato que tiene la extensi√≥n .qmd:\n\n---\ntitle: \"Diamond sizes\"\ndate: 2022-09-12\nformat: html\n---\n\n```{r}\n#| label: setup\n#| include: false\n\nlibrary(tidyverse)\n\nsmaller &lt;- diamonds |&gt; \n  filter(carat &lt;= 2.5)\n```\n\nWe have data about `r nrow(diamonds)` diamonds.\nOnly `r nrow(diamonds) - nrow(smaller)` are larger than 2.5 carats.\nThe distribution of the remainder is shown below:\n\n```{r}\n#| label: plot-smaller-diamonds\n#| echo: false\n\nsmaller |&gt; \n  ggplot(aes(x = carat)) + \n  geom_freqpoly(binwidth = 0.01)\n```\n\nContiene tres tipos importantes de contenido:\n\nUn encabezado YAML (opcional) rodeado de ---s.\n\nPorciones de c√≥digo R rodeadas por ```.\nTexto mezclado con formato de texto simple como #t√≠tulo y _cursiva_.\n\nFigura¬†28.1 muestra un documento .qmd en RStudio con interfaz de notebook donde el c√≥digo y la salida est√°n intercalados. Puede ejecutar cada fragmento de c√≥digo haciendo clic en el √≠cono Ejecutar (parece un bot√≥n de reproducci√≥n en la parte superior del fragmento), o presionando Cmd/Ctrl + Shift + Enter. RStudio ejecuta el c√≥digo y muestra los resultados en l√≠nea con el c√≥digo.\n\n\n\n\n\n\n\nFigura¬†28.1: Un documento de Quarto en RStudio. C√≥digo y salida intercalados en el documento, con la salida de la gr√°fica apareciendo justo debajo del c√≥digo.\n\n\n\n\nSi no le gusta ver sus gr√°ficos y resultados en su documento y prefiere utilizar la consola y los paneles de gr√°ficos de RStudio, puede hacer clic en el icono de engranaje junto a ‚ÄúRender‚Äù y cambiar a ‚ÄúChunk Output in Console‚Äù, como se muestra en Figura¬†28.2.\n\n\n\n\n\n\n\nFigura¬†28.2: Un documento Quarto en RStudio con la salida del gr√°fico en el panel Gr√°ficos.\n\n\n\n\nPara generar un informe completo que contenga todo el texto, el c√≥digo y los resultados, haga clic en ‚ÄúRender‚Äù o presione Cmd/Ctrl + Shift + K. Tambi√©n puede hacer esto mediante programaci√≥n con quarto::quarto_render(\"diamond-sizes.qmd\"). Esto mostrar√° el informe en el panel del visor como se muestra en Figura¬†28.3 y crear√° un archivo HTML.\n\n\n\n\n\n\n\nFigura¬†28.3: Un documento de Quarto en RStudio con el documento renderizado en el panel del View.\n\n\n\n\nCuando renderiza el documento, Quarto env√≠a el archivo .qmd a knitr, https://yihui.org/knitr/, que ejecuta todos los fragmentos de c√≥digo y crea un nuevo documento de markdown (.md) que incluye el c√≥digo y su salida. El archivo markdown generado por knitr luego es procesado por pandoc, https://pandoc.org, que es responsable de crear el archivo terminado. Este proceso se muestra en Figura¬†28.4. La ventaja de este flujo de trabajo de dos pasos es que puede crear una amplia gama de formatos de salida, como aprender√° en Cap√≠tulo 29.\n\n\n\n\n\n\n\nFigura¬†28.4: Diagrama del flujo de trabajo de Quarto de qmd, a knitr, a md, a pandoc, a la salida en formato PDF, MS Word o HTML.\n\n\n\n\nPara comenzar con su propio archivo .qmd, seleccione File &gt; New File &gt; Quarto Document‚Ä¶ en la barra de men√∫. RStudio lanzar√° un asistente que puede usar para completar previamente su archivo con contenido √∫til que le recuerda c√≥mo funcionan las funciones clave de Quarto\nLas siguientes secciones se sumergen en los tres componentes de un documento Quarto con m√°s detalles: el texto markdown, los fragmentos de c√≥digo y el encabezado YAML.\n\n28.2.1 Ejercicios\n\nCrear un nuevo documento Quarto usando File &gt; New File &gt; Quarto Document. Lee las instrucciones. Practique ejecutar los fragmentos individualmente. Luego renderice el documento haciendo clic en el bot√≥n apropiado y luego usando el atajo de teclado apropiado. Verifique que puede modificar el c√≥digo, volver a ejecutarlo y ver el resultado modificado.\nCree un nuevo documento Quarto para cada uno de los tres formatos integrados: HTML, PDF y Word. Renderice cada uno de los tres documentos. ¬øC√≥mo difieren las salidas? ¬øC√≥mo difieren las entradas? (Es posible que deba instalar LaTeX para generar la salida en PDF; RStudio le indicar√° si es necesario).",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>28</span>¬† <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#editor-visual",
    "href": "quarto.html#editor-visual",
    "title": "28¬† Quarto",
    "section": "\n28.3 Editor Visual",
    "text": "28.3 Editor Visual\nEl editor visual de RStudio proporciona una interfaz WYSIWYM para crear documentos Quarto. En el fondo, la prosa de los documentos Quarto (archivos .qmd) est√° escrita en Markdown, un conjunto ligero de convenciones para formatear archivos de texto sin formato. De hecho, Quarto usa Pandoc Markdown (una versi√≥n ligeramente extendida de Markdown que Quarto entiende), que incluye tablas, citas, referencias cruzadas, notas al pie, divs/spans, listas de definiciones, atributos, HTML/TeX sin formato y m√°s, as√≠ como soporte para ejecutar celdas de c√≥digo y ver su salida en l√≠nea. Si bien Markdown est√° dise√±ado para que sea f√°cil de leer y escribir, como ver√° en Secci√≥n 28.4, a√∫n requiere aprender una nueva sintaxis. Por lo tanto, si es nuevo en documentos computacionales como archivos .qmd pero tiene experiencia en el uso de herramientas como Google Docs o MS Word, la forma m√°s f√°cil de comenzar con Quarto en RStudio es el editor visual.\nEn el editor visual, puede usar los botones en la barra de men√∫ para insertar im√°genes, tablas, referencias cruzadas, etc. o puede usar el atajo general ‚åò + / or Ctrl + / para insertar casi cualquier cosa. Si est√° al comienzo de una l√≠nea (como se muestra en Figura¬†28.5), tambi√©n puede ingresar solo / para invocar el atajo.\n\n\n\n\n\n\n\nFigura¬†28.5: Editor visual de Quarto.\n\n\n\n\nLa inserci√≥n de im√°genes y la personalizaci√≥n de c√≥mo se muestran tambi√©n se facilitan con el editor visual. Puede pegar una imagen de su portapapeles directamente en el editor visual (y RStudio colocar√° una copia de esa imagen en el directorio del proyecto y la vincular√°) o puede usar el editor visual Insert &gt; Figure / Image menu para buscar la imagen que desea insertar o pegar su URL. Adem√°s, utilizando el mismo men√∫, puede cambiar el tama√±o de la imagen y agregar un t√≠tulo, texto alternativo y un enlace.\nEl editor visual tiene muchas m√°s funciones que no hemos enumerado aqu√≠ y que pueden resultarle √∫tiles a medida que adquiera experiencia creando con √©l.\nLo que es m√°s importante, mientras que el editor visual muestra su contenido con formato, debajo del cap√≥, guarda su contenido en Markdown simple y puede alternar entre los editores visual y fuente para ver y editar su contenido usando cualquiera de las herramientas.\n\n28.3.1 Ejercicios\n\nVuelva a crear el documento en Figura¬†28.5 usando el editor visual.\nUsando el editor visual, inserte un fragmento de c√≥digo usando el men√∫ Insertar y luego la herramienta Insertar cualquier cosa.\nUsando el editor visual, descubra c√≥mo:\n\nA√±adir una nota al pie.\nAgregue una regla horizontal.\nAgregue una cita en bloque.\n\n\nEn el editor visual, vaya a Insert &gt; Citation e inserte una cita al art√≠culo titulado Bienvenido a Tidyverse usando su DOI (objeto digital identificador), que es 10.21105/joss.01686. Renderice el documento y observe c√≥mo aparece la referencia en el documento. ¬øQu√© cambio observa en el YAML de su documento?",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>28</span>¬† <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#sec-source-editor",
    "href": "quarto.html#sec-source-editor",
    "title": "28¬† Quarto",
    "section": "\n28.4 Editor Source",
    "text": "28.4 Editor Source\nTambi√©n puede editar documentos Quarto usando el editor de origen en RStudio, sin la ayuda del editor visual. Mientras que el editor visual les resultar√° familiar a quienes tengan experiencia escribiendo en herramientas como Google docs, el editor de c√≥digo fuente les resultar√° familiar a quienes tengan experiencia escribiendo scripts R o documentos R Markdown. El editor de c√≥digo fuente tambi√©n puede ser √∫til para depurar cualquier error de sintaxis de Quarto, ya que a menudo es m√°s f√°cil detectarlos en texto sin formato.\nLa siguiente gu√≠a muestra c√≥mo usar Markdown de Pandoc para crear documentos Quarto en el editor de c√≥digo fuente.\n\n## Text formatting\n\n*italic* **bold** ~~strikeout~~ `code`\n\nsuperscript^2^ subscript~2~\n\n[underline]{.underline} [small caps]{.smallcaps}\n\n## Headings\n\n# 1st Level Header\n\n## 2nd Level Header\n\n### 3rd Level Header\n\n## Lists\n\n-   Bulleted list item 1\n\n-   Item 2\n\n    -   Item 2a\n\n    -   Item 2b\n\n1.  Numbered list item 1\n\n2.  Item 2.\n    The numbers are incremented automatically in the output.\n\n## Links and images\n\n&lt;http://example.com&gt;\n\n[linked phrase](http://example.com)\n\n![optional caption text](quarto.png){fig-alt=\"Quarto logo and the word quarto spelled in small case letters\"}\n\n## Tables\n\n| First Header | Second Header |\n|--------------|---------------|\n| Content Cell | Content Cell  |\n| Content Cell | Content Cell  |\n\nLa mejor manera de aprender estos es simplemente probarlos. Tomar√° algunos d√≠as, pero pronto se convertir√°n en una segunda naturaleza y no necesitar√° pensar en ellos. Si lo olvida, puede acceder a una pr√°ctica hoja de referencia con Help &gt; Markdown Quick Reference.\n\n28.4.1 Ejercicios\n\nPractica lo que has aprendido creando un breve CV. El t√≠tulo debe ser su nombre y debe incluir encabezados para (al menos) educaci√≥n o empleo. Cada una de las secciones debe incluir una lista con vi√±etas de trabajos/t√≠tulos. Resalta el a√±o en negrita.\n\nCon el editor de c√≥digo fuente y la referencia r√°pida de Markdown, descubra c√≥mo:\n\nA√±adir una nota al pie.\nAgregue una regla horizontal.\n\n\nAgregue una cita en bloque.\n\n\nCopie y pegue el contenido de diamond-sizes.qmd de https://github.com/hadley/r4ds/tree/main/quarto en un documento R Quarto local. Comprueba que puedes ejecutarlo, luego agrega texto despu√©s del pol√≠gono de frecuencia que describe sus caracter√≠sticas m√°s llamativas.\nCree un documento en un documento de Google o MS Word (o busque un documento que haya creado anteriormente) con alg√∫n contenido, como encabezados, hiperv√≠nculos, texto formateado, etc. Copie el contenido de este documento y p√©guelo en un documento Quarto en el editor visual. Luego, cambie al editor de c√≥digo fuente e inspeccione el c√≥digo fuente.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>28</span>¬† <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#fragmentos-de-c√≥digo",
    "href": "quarto.html#fragmentos-de-c√≥digo",
    "title": "28¬† Quarto",
    "section": "\n28.5 Fragmentos de c√≥digo",
    "text": "28.5 Fragmentos de c√≥digo\nPara ejecutar c√≥digo dentro de un documento Quarto, debe insertar un fragmento. Hay tres formas de hacerlo:\n\nEl m√©todo abreviado de teclado Cmd + Opci√≥n + I / Ctrl + Alt + I.\nEl icono del bot√≥n ‚ÄúInsert‚Äù en la barra de herramientas del editor.\nAl escribir manualmente los delimitadores de fragmentos ```{r} y ```.\n\nLe recomendamos que aprenda el atajo de teclado. ¬°Te ahorrar√° mucho tiempo a largo plazo!\nPuede continuar ejecutando el c√≥digo usando el atajo de teclado que ahora (¬°esperamos!) conoce y ama: Cmd/Ctrl + Enter. Sin embargo, los fragmentos obtienen un nuevo atajo de teclado: Cmd/Ctrl + Shift + Enter, que ejecuta todo el c√≥digo en el fragmento. Piensa en un trozo como una funci√≥n. Un fragmento debe ser relativamente independiente y centrarse en una sola tarea.\nLas siguientes secciones describen el encabezado del fragmento que consta de ```{r}, seguido de una etiqueta de fragmento opcional y varias otras opciones de fragmento, cada una en su propia l√≠nea, marcada por #|.\n\n28.5.1 Etiqueta de fragmento de c√≥digo\nA los fragmento de c√≥digo se les puede dar una etiqueta opcional, p.ej.\n\n```{r}\n#| label: simple-addition\n\n1 + 1\n```\n#&gt; [1] 2\n\nEsto tiene tres ventajas:\n\n\nPuede navegar m√°s f√°cilmente a fragmentos espec√≠ficos utilizando el navegador de c√≥digo desplegable en la parte inferior izquierda del editor de secuencias de comandos:\n\n\n\n\n\n\n\n\n\nLos gr√°ficos producidos por los fragmentos tendr√°n nombres √∫tiles que los har√°n m√°s f√°ciles de usar en otros lugares. M√°s sobre eso en Secci√≥n 28.6.\nPuede configurar redes de fragmentos almacenados en cach√© para evitar volver a realizar c√°lculos costosos en cada ejecuci√≥n. M√°s sobre eso en Secci√≥n 28.8.\n\nLas etiquetas de fragmentos deben ser cortas pero sugerentes y no deben contener espacios. Recomendamos usar guiones (-) para separar palabras (en lugar de guiones bajos, _) y evitar otros caracteres especiales en las etiquetas de fragmentos.\nPor lo general, eres libre de etiquetar tu fragmento como quieras, pero hay un nombre de fragmento que imbuye un comportamiento especial: setup. Cuando est√© en modo notebook, el fragmento denominado setup se ejecutar√° autom√°ticamente una vez, antes de que se ejecute cualquier otro c√≥digo.\nAdem√°s, las etiquetas de fragmentos no se pueden duplicar. Cada etiqueta de fragmento debe ser √∫nica.\n\n28.5.2 Opciones de fragmentos de c√≥digo\nLa salida del fragmento se puede personalizar con opciones, campos proporcionados al encabezado del fragmento. Knitr proporciona casi 60 opciones que puede usar para personalizar sus fragmentos de c√≥digo. Aqu√≠ cubriremos las opciones de fragmentos m√°s importantes que usar√° con frecuencia. Puedes ver la lista completa en https://yihui.org/knitr/options.\nEl conjunto de opciones m√°s importante controla si su bloque de c√≥digo se ejecuta y qu√© resultados se insertan en el informe terminado:\n\neval: false impide que se eval√∫e el c√≥digo. (Y obviamente si no se ejecuta el c√≥digo, no se generar√°n resultados). Esto es √∫til para mostrar c√≥digo de ejemplo o para deshabilitar un gran bloque de c√≥digo sin comentar cada l√≠nea.\ninclude: false ejecuta el c√≥digo, pero no muestra el c√≥digo ni da como resultado el documento final. √öselo para el c√≥digo de configuraci√≥n que no desea que abarrote su informe.\necho: false evita que el c√≥digo, pero no los resultados, aparezca en el archivo terminado. Use esto cuando escriba informes dirigidos a personas que no quieren ver el c√≥digo R subyacente.\nmessage: false o warning: false evita que aparezcan mensajes o advertencias en el archivo terminado.\nresults: hide oculta la salida impresa; fig-show: hide oculta gr√°ficas.\nerror: true hace que el procesamiento contin√∫e incluso si el c√≥digo devuelve un error. Esto rara vez es algo que desee incluir en la versi√≥n final de su informe, pero puede ser muy √∫til si necesita depurar exactamente lo que est√° sucediendo dentro de su .qmd. Tambi√©n es √∫til si est√° ense√±ando R y quiere incluir deliberadamente un error. El valor predeterminado error: false hace que la representaci√≥n falle si hay un solo error en el documento.\n\nCada una de estas opciones de fragmento se agrega al encabezado del fragmento, despu√©s de #|, por ejemplo, en el siguiente fragmento, el resultado no se imprime ya que eval se establece en falso.\n\n```{r}\n#| label: simple-multiplication\n#| eval: false\n\n2 * 2\n```\n\nLa siguiente tabla resume qu√© tipos de salida suprime cada opci√≥n:\n\n\n\n\n\n\n\n\n\n\n\nOpci√≥n\nEjecutar c√≥digo\nMostrar c√≥digo\nSalida\nGr√°ficas\nMensages\nAdvertencias\n\n\n\neval: false\nX\n\nX\nX\nX\nX\n\n\ninclude: false\n\nX\nX\nX\nX\nX\n\n\necho: false\n\nX\n\n\n\n\n\n\nresults: hide\n\n\nX\n\n\n\n\n\nfig-show: hide\n\n\n\nX\n\n\n\n\nmessage: false\n\n\n\n\nX\n\n\n\nwarning: false\n\n\n\n\n\nX\n\n\n\n28.5.3 Opciones globales\nA medida que trabaje m√°s con knitr, descubrir√° que algunas de las opciones de fragmentos predeterminadas no se ajustan a sus necesidades y querr√° cambiarlas.\nPuede hacerlo agregando las opciones preferidas en el documento YAML, en execute. Por ejemplo, si est√° preparando un informe para una audiencia que no necesita ver su c√≥digo sino solo sus resultados y narraci√≥n, puede establecer echo: false en el nivel del documento. Eso ocultar√° el c√≥digo de forma predeterminada, por lo que solo mostrar√° los fragmentos que elija mostrar deliberadamente (con echo: true). Podr√≠a considerar configurar message: false y warning: false, pero eso dificultar√≠a la depuraci√≥n de problemas porque no ver√≠a ning√∫n mensaje en el documento final.\ntitle: \"My report\"\nexecute:\n  echo: false\nDado que Quarto est√° dise√±ado para ser multiling√ºe (funciona con R y otros lenguajes como Python, Julia, etc.), todas las opciones de knitr no est√°n disponibles en el nivel de ejecuci√≥n del documento, ya que algunas de ellas solo funcionan con knitr y no otros motores que usa Quarto para ejecutar c√≥digo en otros lenguajes (por ejemplo, Jupyter). Sin embargo, a√∫n puede configurarlas como opciones globales para su documento en el campo knitr, en opts_chunk. Por ejemplo, al escribir libros y tutoriales establecemos:\ntitle: \"Tutorial\"\nknitr:\n  opts_chunk:\n    comment: \"#&gt;\"\n    collapse: true\nEsto utiliza nuestro formato de comentario preferido y garantiza que el c√≥digo y la salida se mantengan estrechamente entrelazados.\n\n28.5.4 c√≥digo en l√≠nea\nHay otra forma de incrustar c√≥digo R en un documento de Quarto: directamente en el texto, con: `r `. Esto puede ser muy √∫til si menciona propiedades de sus datos en el texto. Por ejemplo, el documento de ejemplo utilizado al comienzo del cap√≠tulo ten√≠a:\n\nWe have data about `r nrow(diamonds)` diamonds. Only `r nrow(diamonds) - nrow(smaller)` are larger than 2.5 carats. The distribution of the remainder is shown below:\n\nCuando se presenta el informe, los resultados de estos c√°lculos se insertan en el texto:\n\nWe have data about 53940 diamonds. Only 126 are larger than 2.5 carats. The distribution of the remainder is shown below:\n\nAl insertar n√∫meros en el texto, format() es tu amigo. Le permite configurar el n√∫mero de digits para que no imprima con un grado rid√≠culo de precisi√≥n, y una big.mark para que los n√∫meros sean m√°s f√°ciles de leer. Puede combinarlos en una funci√≥n de ayuda:\n\ncomma &lt;- function(x) format(x, digits = 2, big.mark = \",\")\ncomma(3452345)\n#&gt; [1] \"3,452,345\"\ncomma(.12358124331)\n#&gt; [1] \"0.12\"\n\n\n28.5.5 Ejercicios\n\nAgregue una secci√≥n que explore c√≥mo los tama√±os de los diamantes var√≠an seg√∫n el corte, el color y la claridad. Suponga que est√° escribiendo un informe para alguien que no conoce R y, en lugar de establecer echo: false en cada fragmento, establezca una opci√≥n global.\nDescargue diamond-sizes.qmd desde https://github.com/hadley/r4ds/tree/main/quarto. Agregue una secci√≥n que describa los 20 diamantes m√°s grandes, incluida una tabla que muestre sus atributos m√°s importantes.\nModifique diamonds-sizes.qmd para usar label_comma() para producir una salida bien formateada. Incluya tambi√©n el porcentaje de diamantes de m√°s de 2,5 quilates.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>28</span>¬† <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#sec-figures",
    "href": "quarto.html#sec-figures",
    "title": "28¬† Quarto",
    "section": "\n28.6 Figuras",
    "text": "28.6 Figuras\nLas figuras en un documento Quarto se pueden incrustar (por ejemplo, un archivo PNG o JPEG) o generarse como resultado de un fragmento de c√≥digo.\nPara incrustar una imagen de un archivo externo, puede usar el men√∫ Insertar en el Editor visual en RStudio y seleccionar Figura/Imagen. Esto abrir√° un men√∫ emergente donde puede buscar la imagen que desea insertar, as√≠ como agregarle un texto alternativo o un t√≠tulo y ajustar su tama√±o. En el editor visual tambi√©n puede simplemente pegar una imagen de su portapapeles en su documento y RStudio colocar√° una copia de esa imagen en su carpeta de proyecto.\nSi incluye un fragmento de c√≥digo que genera una figura (por ejemplo, incluye una llamada ggplot()), la figura resultante se incluir√° autom√°ticamente en su documento Quarto.\n\n28.6.1 Tama√±o de la figura\nEl mayor desaf√≠o de los gr√°ficos Quarto es conseguir que las figuras tengan el tama√±o y la forma adecuados. Hay cinco opciones principales que controlan el tama√±o de la figura: fig-width, fig-height, fig-asp, out-width y out-height. El tama√±o de la imagen es un desaf√≠o porque hay dos tama√±os (el tama√±o de la figura creada por R y el tama√±o en el que se inserta en el documento de salida) y varias formas de especificar el tama√±o (es decir, alto, ancho y relaci√≥n de aspecto: seleccione dos de tres).\nRecomendamos tres de las cinco opciones:\n\nLas gr√°ficas tienden a ser m√°s agradables est√©ticamente si tienen un ancho uniforme. Para hacer cumplir esto, configure fig-width: 6 (6‚Äù) y fig-asp: 0.618 (la proporci√≥n √°urea) en los valores predeterminados. Luego, en los fragmentos individuales, solo ajuste fig-asp.\n\nControle el tama√±o de salida con out-width y config√∫relo en un porcentaje del ancho del cuerpo del documento de salida. Sugerimos out-width: \"70%\" y fig-align: center.\nEso le da a las gr√°ficas espacio para respirar, sin ocupar demasiado espacio.\n\nPara colocar varias gr√°ficas en una sola fila, establezca layout-ncol en 2 para dos gr√°ficas, 3 para tres gr√°ficas, etc. Esto establece efectivamente out-width en ‚Äú50%‚Äù para cada una de sus parcelas si layout-ncol es 2, ‚Äú33%‚Äù si layout-ncol es 3, etc. Dependiendo de lo que est√© tratando de ilustrar (por ejemplo, mostrar datos o mostrar variaciones de gr√°ficos), tambi√©n puede modificar fig-width, como se explica a continuaci√≥n.\n\nSi encuentra que tiene que entrecerrar los ojos para leer el texto en su gr√°fica, necesita modificar fig-width. Si fig-width es m√°s grande que el tama√±o de la figura en el documento final, el texto ser√° demasiado peque√±o; si fig-width es m√°s peque√±o, el texto ser√° demasiado grande. A menudo necesitar√°s hacer un poco de experimentaci√≥n para encontrar la proporci√≥n correcta entre el fig-width y el ancho final en tu documento. Para ilustrar el principio, las siguientes tres gr√°ficas tienen un ancho de figura de 4, 6 y 8 respectivamente:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSi desea asegurarse de que el tama√±o de la fuente sea consistente en todas sus figuras, cada vez que configure out-width, tambi√©n deber√° ajustar fig-width para mantener la misma proporci√≥n con su out-width predeterminado. Por ejemplo, si su fig-width predeterminado es 6 y out-width es ‚Äú70%‚Äù, cuando establezca out-width: \"50%\", deber√° establecer fig-width en 4.3 (6 * 0.5 / 0.7).\nEl dimensionamiento y escalado de figuras es un arte y una ciencia, y hacer las cosas bien puede requerir un enfoque iterativo de prueba y error. Puede obtener m√°s informaci√≥n sobre el tama√±o de la figura en la publicaci√≥n del blog sobre c√≥mo tomar el control de la escala de la gr√°fica.\n\n28.6.2 Otras opciones importantes\nAl mezclar c√≥digo y texto, como en este libro, puede configurar fig-show: hold para que los gr√°ficos se muestren despu√©s del c√≥digo. Esto tiene el agradable efecto secundario de obligarte a dividir grandes bloques de c√≥digo con sus explicaciones.\nPara agregar un t√≠tulo a la gr√°fica, use fig-cap. En Quarto, esto cambiar√° la figura de en l√≠nea a ‚Äúfloating‚Äù.\nSi est√° produciendo una salida en PDF, el tipo de gr√°fico predeterminado es PDF. Este es un buen valor predeterminado porque los archivos PDF son gr√°ficos vectoriales de alta calidad. Sin embargo, pueden producir gr√°ficos muy grandes y lentos si muestra miles de puntos. En ese caso, configure fig-format: \"png\" para forzar el uso de PNG. Son de calidad ligeramente inferior, pero ser√°n mucho m√°s compactos.\nEs una buena idea nombrar fragmentos de c√≥digo que produzcan figuras, incluso si no etiqueta otros fragmentos de forma rutinaria. La etiqueta de fragmento se usa para generar el nombre de archivo del gr√°fico en el disco, por lo que nombrar sus fragmentos hace que sea mucho m√°s f√°cil seleccionar gr√°ficos y reutilizarlos en otras circunstancias (es decir, si desea colocar r√°pidamente un solo gr√°fico en un correo electr√≥nico).\n\n28.6.3 Ejercicios\n\nAbra diamond-sizes.qmd en el editor visual, busque una imagen de un diamante, c√≥piela y p√©guela en el documento. Haga doble clic en la imagen y agregue un t√≠tulo. Cambie el tama√±o de la imagen y renderice su documento. Observe c√≥mo se guarda la imagen en su directorio de trabajo actual.\nEdite la etiqueta del fragmento de c√≥digo en diamond-sizes.qmd que genera un gr√°fico que comience con el sufijo fig- y agregue un t√≠tulo a la figura con la opci√≥n de fragmento fig-cap. Luego, edite el texto sobre el fragmento de c√≥digo para agregar una referencia cruzada a la figura con Insert &gt; Cross Reference.\n\nCambie el tama√±o de la figura con las siguientes opciones de fragmento, una a la vez, renderice su documento y describa c√≥mo cambia la figura.\n\nfig-width: 10\nfig-height: 3\nout-width: \"100%\"\nout-width: \"20%\"",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>28</span>¬† <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#tablas",
    "href": "quarto.html#tablas",
    "title": "28¬† Quarto",
    "section": "\n28.7 Tablas",
    "text": "28.7 Tablas\nAl igual que las figuras, puede incluir dos tipos de tablas en un documento Quarto. Pueden ser tablas de markdown que crea directamente en su documento Quarto (usando el men√∫ Insert table) o pueden ser tablas generadas como resultado de un fragmento de c√≥digo. En esta secci√≥n nos centraremos en las √∫ltimas, tablas generadas mediante computaci√≥n.\nDe forma predeterminada, Quarto imprime data frames y matrices como los ver√≠a en la consola:\n\nmtcars[1:5, ]\n#&gt;                    mpg cyl disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n\nSi prefiere que los datos se muestren con un formato adicional, puede usar la funci√≥n knitr::kable(). El siguiente c√≥digo genera Tabla¬†28.1.\n\nknitr::kable(mtcars[1:5, ], )\n\n\nTabla¬†28.1: A knitr kable.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\nMazda RX4\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\nMazda RX4 Wag\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\nDatsun 710\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\nHornet 4 Drive\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\nHornet Sportabout\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\n\n\n\n\n\n\nLee la documentaci√≥n de ?knitr::kable para ver otras formas en las que puedes personalizar la tabla. Para una personalizaci√≥n a√∫n m√°s profunda, considere gt, huxtable, reactable, kableExtra, xtable, stargazer, pander, * Paquetes *tables y ascii**. Cada uno proporciona un conjunto de herramientas para devolver tablas formateadas desde el c√≥digo R.\n\n28.7.1 Ejercicios\n\nAbra diamond-sizes.qmd en el editor visual, inserte un fragmento de c√≥digo y agregue una tabla con knitr::kable() que muestre las primeras 5 filas del data frame diamonds.\nMuestre la misma tabla con gt::gt() en su lugar.\nAgregue una etiqueta de fragmento que comience con el sufijo tbl- y agregue un t√≠tulo a la tabla con la opci√≥n de fragmento tbl-cap. Luego, edite el texto sobre el fragmento de c√≥digo para agregar una referencia cruzada a la tabla con Insert &gt; Cross Reference.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>28</span>¬† <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#sec-caching",
    "href": "quarto.html#sec-caching",
    "title": "28¬† Quarto",
    "section": "\n28.8 Almacenamiento en cach√©",
    "text": "28.8 Almacenamiento en cach√©\nNormalmente, cada renderizado de un documento comienza desde cero. Esto es excelente para la reproducibilidad, porque garantiza que haya capturado todos los c√°lculos importantes en el c√≥digo. Sin embargo, puede ser doloroso si tiene algunos c√°lculos que toman mucho tiempo. La solucion es cache: true.\nPuede habilitar el cach√© de Knitr a nivel de documento para almacenar en cach√© los resultados de todos los c√°lculos en un documento usando las opciones est√°ndar de YAML:\n---\ntitle: \"My Document\"\nexecute: \n  cache: true\n---\nTambi√©n puede habilitar el almacenamiento en cach√© a nivel de fragmento para almacenar en cach√© los resultados del c√°lculo en un fragmento espec√≠fico:\n\n```{r}\n#| cache: true\n\n# c√≥digo para c√°lculos largos...\n```\n\nCuando se establece, esto guardar√° la salida del fragmento en un archivo con un nombre especial en el disco. En ejecuciones posteriores, knitr verificar√° si el c√≥digo ha cambiado y, si no es as√≠, reutilizar√° los resultados almacenados en cach√©.\nEl sistema de almacenamiento en cach√© debe usarse con cuidado, ya que, de manera predeterminada, se basa solo en el c√≥digo, no en sus dependencias. Por ejemplo, aqu√≠ el fragmento processed_data depende del fragmento raw-data:\n```{r}\n#| label: raw-data\n#| cache: true\n\nrawdata &lt;- readr::read_csv(\"a_very_large_file.csv\")\n```\n```{r}\n#| label: processed_data\n#| cache: true\n\nprocessed_data &lt;- rawdata |&gt; \n  filter(!is.na(import_var)) |&gt; \n  mutate(new_variable = complicated_transformation(x, y, z))\n```\nAlmacenar en cach√© el fragmento processed_data significa que se volver√° a ejecutar si se cambia la canalizaci√≥n de dplyr, pero no se volver√° a ejecutar si cambia la llamada read_csv(). Puede evitar ese problema con la opci√≥n de fragmento dependson:\n```{r}\n#| label: processed-data\n#| cache: true\n#| dependson: \"raw-data\"\n\nprocessed_data &lt;- rawdata |&gt; \n  filter(!is.na(import_var)) |&gt; \n  mutate(new_variable = complicated_transformation(x, y, z))\n```\ndependson debe contener un vector de caracteres de cada fragmento del que depende el fragmento almacenado en cach√©. Knitr actualizar√° los resultados del fragmento en cach√© cada vez que detecte que una de sus dependencias ha cambiado.\nTenga en cuenta que los fragmentos no se actualizar√°n si un_archivo_muy_grande.csv cambia, porque el almacenamiento en cach√© de knitr solo rastrea los cambios dentro del archivo .qmd. Si tambi√©n desea realizar un seguimiento de los cambios en ese archivo, puede usar la opci√≥n cache.extra. Esta es una expresi√≥n R arbitraria que invalidar√° el cach√© cada vez que cambie. Una buena funci√≥n para usar es file.mtime(): regresa cuando fue modificada por √∫ltima vez. Entonces puedes escribir:\n```{r}\n#| label: raw-data\n#| cache: true\n#| cache.extra: !expr file.mtime(\"a_very_large_file.csv\")\n\nrawdata &lt;- readr::read_csv(\"un_archivo_muy_grande.csv\")\n```\nSeguimos el consejo de David Robinson para nombrar estos fragmentos: cada fragmento lleva el nombre del objeto principal que crea. Esto facilita la comprensi√≥n de la especificaci√≥n dependson.\nA medida que sus estrategias de almacenamiento en cach√© se vuelven progresivamente m√°s complicadas, es una buena idea borrar regularmente todos sus cach√©s con knitr::clean_cache().\n\n28.8.1 Ejercicios\n\nConfigure una red de fragmentos donde d dependa de c y b, y tanto b como c dependan de a. Haga que cada fragmento imprima lubridate::now(), configure cache: true y luego verifique su comprensi√≥n del almacenamiento en cach√©.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>28</span>¬† <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#soluci√≥n-de-problemas",
    "href": "quarto.html#soluci√≥n-de-problemas",
    "title": "28¬† Quarto",
    "section": "\n28.9 Soluci√≥n de problemas",
    "text": "28.9 Soluci√≥n de problemas\nLa soluci√≥n de problemas de documentos Quarto puede ser un desaf√≠o porque ya no se encuentra en un entorno R interactivo y deber√° aprender algunos trucos nuevos. Adem√°s, el error podr√≠a deberse a problemas con el propio documento Quarto o al c√≥digo R en el documento Quarto.\nUn error com√∫n en los documentos con fragmentos de c√≥digo son las etiquetas de fragmentos duplicados, que son especialmente frecuentes si su flujo de trabajo implica copiar y pegar fragmentos de c√≥digo. Para solucionar este problema, todo lo que necesita hacer es cambiar una de sus etiquetas duplicadas.\nSi los errores se deben al c√≥digo R del documento, lo primero que debes intentar siempre es recrear el problema en una sesi√≥n interactiva. Reinicie R, luego ‚ÄúEjecute todos los fragmentos‚Äù ya sea desde el men√∫ C√≥digo, en la regi√≥n Ejecutar, o con el atajo de teclado Ctrl + Alt + R. Si tiene suerte, eso recrear√° el problema y podr√° averiguar qu√© est√° pasando de forma interactiva.\nSi eso no ayuda, debe haber algo diferente entre su entorno interactivo y el entorno de Quarto. Vas a necesitar explorar sistem√°ticamente las opciones. La diferencia m√°s com√∫n es el directorio de trabajo: el directorio de trabajo de Quarto es el directorio en el que vive. Comprueba que el directorio de trabajo es lo que esperas al incluir getwd() en un fragmento.\nA continuaci√≥n, haga una lluvia de ideas sobre todas las cosas que podr√≠an causar el error. Deber√° verificar sistem√°ticamente que sean iguales en su sesi√≥n R y en su sesi√≥n Quarto. La forma m√°s f√°cil de hacerlo es configurar error: true en el fragmento que causa el problema, luego usar print() y str() para verificar que la configuraci√≥n sea la esperada.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>28</span>¬† <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#encabezado-yaml",
    "href": "quarto.html#encabezado-yaml",
    "title": "28¬† Quarto",
    "section": "\n28.10 Encabezado YAML",
    "text": "28.10 Encabezado YAML\nPuede controlar muchas otras configuraciones de ‚Äúdocumento completo‚Äù ajustando los par√°metros del encabezado YAML. Quiz√°s se pregunte qu√© significa YAML: es ‚ÄúYAML Ain‚Äôt Markup Language‚Äù, que est√° dise√±ado para representar datos jer√°rquicos de una manera que sea f√°cil de leer y escribir para los humanos. Quarto lo usa para controlar muchos detalles de la salida. Aqu√≠ discutiremos tres: documentos independientes, par√°metros de documentos y bibliograf√≠as.\n\n28.10.1 Independientes\nLos documentos HTML suelen tener una serie de dependencias externas (por ejemplo, im√°genes, hojas de estilo CSS, JavaScript, etc.) y, de forma predeterminada, Quarto coloca estas dependencias en una carpeta _files en el mismo directorio que su archivo .qmd. Si publica el archivo HTML en una plataforma de alojamiento (p.¬†ej., QuartoPub, https://quartopub.com/), las dependencias de este directorio se publican con su documento y, por lo tanto, est√°n disponibles en el informe publicado. Sin embargo, si desea enviar el informe por correo electr√≥nico a un colega, es posible que prefiera tener un documento HTML √∫nico e independiente que incorpore todas sus dependencias. Puedes hacer esto especificando la opci√≥n embed-resources:\nformat:\n  html:\n    embed-resources: true\nEl archivo resultante ser√° aut√≥nomo, por lo que no necesitar√° archivos externos ni acceso a Internet para que un navegador lo muestre correctamente.\n\n28.10.2 Par√°metros\nLos documentos Quarto pueden incluir uno o m√°s par√°metros cuyos valores se pueden establecer al representar el informe. Los par√°metros son √∫tiles cuando desea volver a representar el mismo informe con valores distintos para varias entradas clave. Por ejemplo, podr√≠a generar informes de ventas por sucursal, resultados de ex√°menes por estudiante o res√∫menes demogr√°ficos por pa√≠s. Para declarar uno o m√°s par√°metros, utilice el campo params.\nEste ejemplo usa un par√°metro my_class para determinar qu√© clase de autos mostrar:\n\n---\noutput: html\nparams:\n  my_class: \"suv\"\n---\n\n```{r}\n#| label: setup\n#| include: false\n\nlibrary(tidyverse)\n\nclass &lt;- mpg |&gt; filter(class == params$my_class)\n```\n\n# Fuel economy for `r params$my_class`s\n\n```{r}\n#| message: false\n\nggplot(class, aes(x = displ, y = hwy)) + \n  geom_point() + \n  geom_smooth(se = FALSE)\n```\n\nComo puede ver, los par√°metros est√°n disponibles dentro de los fragmentos de c√≥digo como una lista de solo lectura llamada params.\nPuede escribir vectores at√≥micos directamente en el encabezado YAML. Tambi√©n puede ejecutar expresiones R arbitrarias anteponiendo el valor del par√°metro con !expr. Esta es una buena forma de especificar par√°metros de fecha/hora.\nparams:\n  start: !expr lubridate::ymd(\"2015-01-01\")\n  snapshot: !expr lubridate::ymd_hms(\"2015-01-01 12:30:00\")\n\n28.10.3 Bibliograf√≠as y citas\nQuarto puede generar autom√°ticamente citas y una bibliograf√≠a en varios estilos. La forma m√°s sencilla de agregar citas y bibliograf√≠as a un documento Quarto es usar el editor visual en RStudio.\nPara agregar una cita usando el editor visual, vaya a Insert &gt; Citation. Citations se puede insertar desde una variedad de fuentes:\n\nDOI (Identificador de objeto de documento) referencias.\nZotero bibliotecas personales o de grupo.\nB√∫squedas de Crossref, DataCite, o PubMed.\nLa bibliograf√≠a de su documento (un archivo .bib en el directorio de su documento)\n\nDebajo del cap√≥, el modo visual utiliza la representaci√≥n de markdown est√°ndar de Pandoc para las citas (por ejemplo, [@citation]).\nSi agrega una cita utilizando uno de los primeros tres m√©todos, el editor visual crear√° autom√°ticamente un archivo bibliography.bib y le agregar√° la referencia. Tambi√©n agregar√° un campo bibliography al documento YAML. A medida que agregue m√°s referencias, este archivo se completar√° con sus citas. Tambi√©n puede editar directamente este archivo utilizando muchos formatos de bibliograf√≠a comunes, incluidos BibLaTeX, BibTeX, EndNote, Medline.\nPara crear una cita dentro de su archivo .qmd en el editor de c√≥digo fuente, use una clave compuesta por ‚Äò@‚Äô + el identificador de cita del archivo de bibliograf√≠a. Luego coloque la cita entre corchetes. Aqu√≠ hay unos ejemplos:\nSepare las citas m√∫ltiples con un `;`: Bla bla [@smith04; @doe99].\n\nPuede agregar comentarios arbitrarios dentro de los corchetes: \nBla bla [vea @doe99, p√°g. 33-35; tambi√©n @smith04, c√°p. 1].\n\nElimina los corchetes para crear una cita en el texto: @smith04 \ndice bla, o @smith04 [p√°g. 33] dice bla.\n\nAgregue un `-` antes de la cita para suprimir el nombre del autor: \n\nSmith dice bla [-@smith04].\nCuando Quarto renderice su archivo, crear√° y agregar√° una bibliograf√≠a al final de su documento. La bibliograf√≠a contendr√° cada una de las referencias citadas de su archivo de bibliograf√≠a, pero no contendr√° un encabezado de secci√≥n. Como resultado, es una pr√°ctica com√∫n terminar su archivo con un encabezado de secci√≥n para la bibliograf√≠a, como # Referencias o # Bibliograf√≠a.\nPuede cambiar el estilo de sus citas y bibliograf√≠a haciendo referencia a un archivo CSL (lenguaje de estilo de citas) en el campo csl:\nbibliography: rmarkdown.bib\ncsl: apa.csl\nAl igual que con el campo de bibliograf√≠a, su archivo csl debe contener una ruta al archivo. Aqu√≠ asumimos que el archivo csl est√° en el mismo directorio que el archivo .qmd. Un buen lugar para encontrar archivos de estilo CSL para estilos de bibliograf√≠a comunes es https://github.com/citation-style-language/styles.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>28</span>¬† <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#flujo-de-trabajo",
    "href": "quarto.html#flujo-de-trabajo",
    "title": "28¬† Quarto",
    "section": "\n28.11 Flujo de trabajo",
    "text": "28.11 Flujo de trabajo\nAnteriormente, discutimos un flujo de trabajo b√°sico para capturar su c√≥digo R donde trabaja de forma interactiva en la consola, luego captura lo que funciona en el editor de scripts. Quarto re√∫ne la consola y el editor de secuencias de comandos, desdibujando las l√≠neas entre la exploraci√≥n interactiva y la captura de c√≥digo a largo plazo. Puede iterar r√°pidamente dentro de un fragmento, editar y volver a ejecutar con Cmd/Ctrl + Shift + Enter. Cuando est√°s feliz, sigues adelante y comienzas una nueva etapa.\nQuarto tambi√©n es importante porque integra muy estrechamente la prosa y el c√≥digo. Esto lo convierte en un excelente cuaderno de an√°lisis porque le permite desarrollar c√≥digo y registrar sus pensamientos. Un cuaderno de an√°lisis comparte muchos de los mismos objetivos que un cuaderno de laboratorio cl√°sico en las ciencias f√≠sicas. Quarto:\n\nRegistra lo que hiciste y por qu√© lo hiciste. Por muy buena que sea tu memoria, si no registras lo que haces, llegar√° un momento en que habr√°s olvidado detalles importantes. ¬°Escr√≠belas para que no las olvides!\nApoya el pensamiento riguroso. Es m√°s probable que obtenga un an√°lisis s√≥lido si registra sus pensamientos a medida que avanza y contin√∫a reflexionando sobre ellos. Esto tambi√©n le ahorra tiempo cuando eventualmente escribe su an√°lisis para compartirlo con otros.\nAyuda a otros a entender su trabajo. Es raro que haga el an√°lisis de datos usted mismo y, a menudo, trabajar√° como parte de un equipo. Un cuaderno de laboratorio lo ayuda a compartir no solo lo que ha hecho, sino tambi√©n por qu√© lo hizo con sus colegas o compa√±eros de laboratorio.\n\nGran parte de los buenos consejos sobre el uso efectivo de los cuadernos de laboratorio tambi√©n se pueden traducir en cuadernos de an√°lisis. Nos hemos basado en nuestras propias experiencias y en los consejos de Colin Purrington sobre cuadernos de laboratorio (https://colinpurrington.com/tips/lab-notebooks) para llegar a los siguientes consejos:\n\nAseg√∫rese de que cada cuaderno tenga un t√≠tulo descriptivo, un nombre de archivo sugerente y un primer p√°rrafo que describa brevemente los objetivos del an√°lisis.\n\nUse el campo de fecha del encabezado YAML para registrar la fecha en que comenz√≥ a trabajar en el cuaderno:\ndate: 2016-08-23\nUse ISO8601 YYYY-MM-DD formato para que no haya ambig√ºedad. ¬°√öselo incluso si normalmente no escribe las fechas de esa manera!\n\nSi dedica mucho tiempo a una idea de an√°lisis y resulta ser un callej√≥n sin salida, ¬°no la elimine! Escriba una breve nota sobre por qu√© fall√≥ y d√©jela en el cuaderno. Eso le ayudar√° a evitar caer en el mismo callej√≥n sin salida cuando vuelva al an√°lisis en el futuro.\nEn general, es mejor ingresar datos fuera de R. Pero si necesita registrar un peque√±o fragmento de datos, exp√≥ngalo claramente usando tibble::tribble().\nSi descubre un error en un archivo de datos, nunca lo modifique directamente, sino que escriba c√≥digo para corregir el valor. Explique por qu√© hizo la correcci√≥n.\nAntes de terminar el d√≠a, aseg√∫rese de poder renderizar el cuaderno. Si est√° utilizando el almacenamiento en cach√©, aseg√∫rese de borrar los cach√©s. Eso le permitir√° solucionar cualquier problema mientras el c√≥digo a√∫n est√° fresco en su mente.\nSi desea que su c√≥digo sea reproducible a largo plazo (es decir, para que pueda volver a ejecutarlo el pr√≥ximo mes o el pr√≥ximo a√±o), deber√° realizar un seguimiento de las versiones de los paquetes que utiliza su c√≥digo. Un enfoque riguroso es usar renv, https://rstudio.github.io/renv/index.html, que almacena paquetes en el directorio de su proyecto. Un truco r√°pido y sucio es incluir un trozo que ejecute sessionInfo() ‚Äî que no le permitir√° recrear f√°cilmente sus paquetes como son hoy, pero al menos sabr√° lo que eran.\nVas a crear muchos, muchos cuadernos de an√°lisis a lo largo de tu carrera. ¬øC√≥mo los va a organizar para poder encontrarlos nuevamente en el futuro? Recomendamos almacenarlos en proyectos individuales y crear un buen esquema de nombres.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>28</span>¬† <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto.html#resumen",
    "href": "quarto.html#resumen",
    "title": "28¬† Quarto",
    "section": "\n28.12 Resumen",
    "text": "28.12 Resumen\nEn este cap√≠tulo, le presentamos Quarto para crear y publicar documentos computacionales reproducibles que incluyen su c√≥digo y su prosa en un solo lugar. Aprendi√≥ a escribir documentos de Quarto en RStudio con el editor visual o de c√≥digo fuente, c√≥mo funcionan los fragmentos de c√≥digo y c√≥mo personalizar las opciones para ellos, c√≥mo incluir figuras y tablas en sus documentos de Quarto y opciones de almacenamiento en cach√© para c√°lculos. Adem√°s, aprendi√≥ a ajustar las opciones de encabezado YAML para crear documentos independientes o parametrizados, as√≠ como a incluir citas y bibliograf√≠a. Tambi√©n le hemos dado algunos consejos para la resoluci√≥n de problemas y el flujo de trabajo.\nSi bien esta introducci√≥n deber√≠a ser suficiente para comenzar con Quarto, a√∫n queda mucho por aprender. Quarto es todav√≠a relativamente joven y sigue creciendo r√°pidamente. El mejor lugar para estar al tanto de las innovaciones es el sitio web oficial de Quarto: https://quarto.org.\nHay dos temas importantes que no hemos cubierto aqu√≠: la colaboraci√≥n y los detalles de comunicar con precisi√≥n sus ideas a otros humanos. La colaboraci√≥n es una parte vital de la ciencia de datos moderna y puede hacer su vida mucho m√°s f√°cil utilizando herramientas de control de versiones, como Git y GitHub. Recomendamos ‚ÄúHappy Git with R‚Äù, una introducci√≥n f√°cil de usar a Git y GitHub de usuarios de R, por Jenny Bryan. El libro est√° disponible gratuitamente en l√≠nea: https://happygitwithr.com.\nTampoco hemos mencionado lo que realmente debe escribir para comunicar claramente los resultados de su an√°lisis. Para mejorar su escritura, recomendamos leer Style: Lessons in Clarity and Grace de Joseph M. Williams & Joseph Bizup, o The Sense of Structure: Writing from the Reader‚Äôs Perspective de George Gopen. Ambos libros lo ayudar√°n a comprender la estructura de oraciones y p√°rrafos, y le brindar√°n las herramientas para que su escritura sea m√°s clara. (Estos libros son bastante caros si se compran nuevos, pero muchas clases de ingl√©s los usan, por lo que hay muchas copias baratas de segunda mano). George Gopen tambi√©n tiene una serie de art√≠culos breves sobre escritura en https://www.georgegopen.com/litigation-articles.html. Est√°n dirigidos a abogados, pero casi todo se aplica tambi√©n a los cient√≠ficos de datos.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>28</span>¬† <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html",
    "href": "quarto-formats.html",
    "title": "29¬† Formatos Quarto",
    "section": "",
    "text": "29.1 Introducci√≥n\nHasta ahora, ha visto que Quarto se usa para producir documentos HTML. Este cap√≠tulo ofrece una breve descripci√≥n general de algunos de los muchos otros tipos de salida que puede producir con Quarto.\nHay dos formas de configurar la salida de un documento:",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>29</span>¬† <span class='chapter-title'>Formatos Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#introducci√≥n",
    "href": "quarto-formats.html#introducci√≥n",
    "title": "29¬† Formatos Quarto",
    "section": "",
    "text": "De forma permanente, modificando el encabezado YAML:\ntitle: \"Diamond sizes\"\nformat: html\n\n\nDe forma transitoria, llamando quarto::quarto_render() a mano:\n\nquarto::quarto_render(\"diamond-sizes.qmd\", output_format = \"docx\")\n\nEsto es √∫til si desea producir m√∫ltiples tipos de salida mediante programaci√≥n, ya que el argumento output_format tambi√©n puede tomar una lista de valores.\n\nquarto::quarto_render(\"diamond-sizes.qmd\", output_format = c(\"docx\", \"pdf\"))",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>29</span>¬† <span class='chapter-title'>Formatos Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#opciones-de-salida",
    "href": "quarto-formats.html#opciones-de-salida",
    "title": "29¬† Formatos Quarto",
    "section": "\n29.2 Opciones de salida",
    "text": "29.2 Opciones de salida\nQuarto ofrece una amplia gama de formatos de salida. Puedes encontrar la lista completa en https://quarto.org/docs/output-formats/all-formats.html. Muchos formatos comparten algunas opciones de salida (p.¬†ej., toc: true para incluir una tabla de contenido), pero otros tienen opciones que son espec√≠ficas del formato (p.¬†ej., code-fold: true colapsa fragmentos de c√≥digo en un &lt;details&gt; etiqueta para la salida HTML para que el usuario pueda mostrarla a pedido, no es aplicable en un documento PDF o Word).\nPara anular las opciones predeterminadas, debe usar un campo format expandido. Por ejemplo, si quisiera representar un html con una tabla de contenido flotante, usar√≠a:\nformat:\n  html:\n    toc: true\n    toc_float: true\nIncluso puede renderizar en m√∫ltiples salidas proporcionando una lista de formatos:\nformat:\n  html:\n    toc: true\n    toc_float: true\n  pdf: default\n  docx: default\nTenga en cuenta la sintaxis especial (pdf: default) si no desea anular ninguna opci√≥n predeterminada.\nPara representar todos los formatos especificados en el YAML de un documento, puede usar output_format = \"all\".\n\nquarto::quarto_render(\"diamond-sizes.qmd\", output_format = \"all\")",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>29</span>¬† <span class='chapter-title'>Formatos Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#documentos",
    "href": "quarto-formats.html#documentos",
    "title": "29¬† Formatos Quarto",
    "section": "\n29.3 Documentos",
    "text": "29.3 Documentos\nEl cap√≠tulo anterior se centr√≥ en la salida html predeterminada. Hay varias variaciones b√°sicas sobre ese tema, generando diferentes tipos de documentos. Por ejemplo:\n\npdf crea un PDF con LaTeX (un sistema de dise√±o de documentos de c√≥digo abierto), que deber√° instalar. RStudio le preguntar√° si a√∫n no lo tiene.\ndocx para documentos de Microsoft Word (.docx).\nodt para documentos OpenDocument Text (.odt).\nrtf para documentos en formato de texto enriquecido (.rtf).\ngfm para un documento Markdown de GitHub (.md).\nipynb para Jupyter Notebooks (.ipynb).\n\nRecuerde, al generar un documento para compartir con los responsables de la toma de decisiones, puede desactivar la visualizaci√≥n predeterminada del c√≥digo configurando las opciones globales en el documento YAML:\nexecute:\n  echo: false\nPara los documentos html, otra opci√≥n es hacer que los fragmentos de c√≥digo est√©n ocultos de forma predeterminada, pero visibles con un clic:\nformat:\n  html:\n    code: true",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>29</span>¬† <span class='chapter-title'>Formatos Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#presentaciones",
    "href": "quarto-formats.html#presentaciones",
    "title": "29¬† Formatos Quarto",
    "section": "\n29.4 Presentaciones",
    "text": "29.4 Presentaciones\nTambi√©n puede usar Quarto para producir presentaciones. Obtiene menos control visual que con una herramienta como Keynote o PowerPoint, pero insertar autom√°ticamente los resultados de su c√≥digo R en una presentaci√≥n puede ahorrar una gran cantidad de tiempo. Las presentaciones funcionan dividiendo su contenido en diapositivas, con una nueva diapositiva que comienza en cada segundo encabezado de nivel (##). Adem√°s, los encabezados de primer nivel (#) indican el comienzo de una nueva secci√≥n con una diapositiva de t√≠tulo de secci√≥n que, de manera predeterminada, est√° centrada en el medio.\nQuarto admite una variedad de formatos de presentaci√≥n, que incluyen:\n\nrevealjs - Presentaci√≥n HTML con revealjs\npptx - Presentaci√≥n de PowerPoint\nbeamer - Presentaci√≥n en PDF con LaTeX Beamer.\n\nPuede leer m√°s sobre la creaci√≥n de presentaciones con Quarto en https://quarto.org/docs/presentations.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>29</span>¬† <span class='chapter-title'>Formatos Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#interactividad",
    "href": "quarto-formats.html#interactividad",
    "title": "29¬† Formatos Quarto",
    "section": "\n29.5 Interactividad",
    "text": "29.5 Interactividad\nAl igual que cualquier documento HTML, los documentos HTML creados con Quarto tambi√©n pueden contener componentes interactivos. Aqu√≠ presentamos dos opciones para incluir interactividad en sus documentos Quarto: htmlwidgets y Shiny.\n\n29.5.1 htmlwidgets\nHTML es un formato interactivo y puede aprovechar esa interactividad con htmlwidgets, funciones de R que producen visualizaciones HTML interactivas. Por ejemplo, tome el mapa del leaflet a continuaci√≥n. Si est√° viendo esta p√°gina en la web, puede arrastrar el mapa, acercar y alejar, etc. Obviamente, no puede hacer eso en un libro, por lo que Quarto inserta autom√°ticamente una captura de pantalla est√°tica para usted.\n\nlibrary(leaflet)\nleaflet() |&gt;\n  setView(174.764, -36.877, zoom = 16) |&gt; \n  addTiles() |&gt;\n  addMarkers(174.764, -36.877, popup = \"Maungawhau\") \n\n\n\n\n\nLo mejor de los htmlwidgets es que no necesita saber nada sobre HTML o JavaScript para usarlos. Todos los detalles est√°n envueltos dentro del paquete, por lo que no necesita preocuparse por eso.\nHay muchos paquetes que proporcionan htmlwidgets, incluidos:\n\ndygraphs para visualizaciones interactivas de series de tiempo.\nDT para tablas interactivas.\nthreejs para gr√°ficos 3d interactivos.\nDiagrammeR para diagramas (como diagramas de flujo y diagramas de enlace de nodo simples).\n\nPara obtener m√°s informaci√≥n sobre los htmlwidgets y ver una lista completa de los paquetes que los proporcionan, visite https://www.htmlwidgets.org.\n\n29.5.2 Shiny\nhtmlwidgets proporcionar interactividad del lado del cliente ‚Äî toda la interactividad ocurre en el navegador, independientemente de R. Por un lado, eso es genial porque puedes distribuir el archivo HTML sin ninguna conexi√≥n con R. Sin embargo, eso limita fundamentalmente lo que puede hacer con las cosas que se han implementado en HTML y JavaScript. Un enfoque alternativo es usar shiny, un paquete que le permite crear interactividad usando c√≥digo R, no JavaScript.\nPara llamar al c√≥digo Shiny desde un documento Quarto, agregue server: shiny al encabezado YAML:\ntitle: \"Shiny Web App\"\nformat: html\nserver: shiny\nLuego puede usar las funciones de entrada ‚Äúinput‚Äù para agregar componentes interactivos al documento:\n\nlibrary(shiny)\n\ntextInput(\"name\", \"What is your name?\")\nnumericInput(\"age\", \"How old are you?\", NA, min = 0, max = 150)\n\nY tambi√©n necesita un fragmento de c√≥digo con la opci√≥n de fragmento context: server que contiene el c√≥digo que debe ejecutarse en un servidor Shiny.\n\n\n\n\n\n\n\n\nLuego puede hacer referencia a los valores con input$name y input$age, y el c√≥digo que los usa se volver√° a ejecutar autom√°ticamente cada vez que cambien.\nNo podemos mostrarle una aplicaci√≥n brillante en vivo aqu√≠ porque las interacciones brillantes ocurren en el lado del servidor. Esto significa que puede escribir aplicaciones interactivas sin saber JavaScript, pero necesita un servidor para ejecutarlas. Esto introduce un problema log√≠stico: las aplicaciones Shiny necesitan un servidor Shiny para ejecutarse en l√≠nea. Cuando ejecuta aplicaciones Shiny en su propia computadora, Shiny configura autom√°ticamente un servidor Shiny para usted, pero necesita un servidor Shiny p√∫blico si desea publicar este tipo de interactividad en l√≠nea. Esa es la compensaci√≥n fundamental de shiny: puede hacer cualquier cosa en un documento brillante que pueda hacer en R, pero requiere que alguien est√© ejecutando R.\nPara aprender m√°s sobre Shiny, recomendamos leer Mastering Shiny de Hadley Wickham, https://mastering-shiny.org.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>29</span>¬† <span class='chapter-title'>Formatos Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#sitios-web-y-libros",
    "href": "quarto-formats.html#sitios-web-y-libros",
    "title": "29¬† Formatos Quarto",
    "section": "\n29.6 Sitios web y libros",
    "text": "29.6 Sitios web y libros\nCon un poco de infraestructura adicional, puede usar Quarto para generar un sitio web completo o un libro:\n\nColoque sus archivos .qmd en un solo directorio. index.qmd se convertir√° en la p√°gina de inicio.\n\nAgregue un archivo YAML llamado _quarto.yml que proporciona la navegaci√≥n para el sitio. En este archivo, establezca el tipo de project en book o website, por ejemplo:\nproject:\n  type: book\n\n\nPor ejemplo, el siguiente archivo _quarto.yml crea un sitio web a partir de tres archivos fuente: index.qmd (la p√°gina de inicio), viridis-colors.qmd y terrain-colors.qmd.\n\nproject:\n  type: website\n\nwebsite:\n  title: \"A website on color scales\"\n  navbar:\n    left:\n      - href: index.qmd\n        text: Home\n      - href: viridis-colors.qmd\n        text: Viridis colors\n      - href: terrain-colors.qmd\n        text: Terrain colors\n\nEl archivo _quarto.yml que necesita para un libro tiene una estructura muy similar. El siguiente ejemplo muestra c√≥mo puede crear un libro con cuatro cap√≠tulos que se muestra en tres salidas diferentes (html, pdf y epub). Una vez m√°s, los archivos de origen son archivos .qmd.\n\nproject:\n  type: book\n\nbook:\n  title: \"A book on color scales\"\n  author: \"Jane Coloriste\"\n  chapters:\n    - index.qmd\n    - intro.qmd\n    - viridis-colors.qmd\n    - terrain-colors.qmd\n\nformat:\n  html:\n    theme: cosmo\n  pdf: default\n  epub: default\n\nLe recomendamos que utilice un proyecto de RStudio para sus sitios web y libros. Basado en el archivo _quarto.yml, RStudio reconocer√° el tipo de proyecto en el que est√° trabajando y agregar√° una pesta√±a Build al IDE que puede usar para renderizar y obtener una vista previa de sus sitios web y libros. Tanto los sitios web como los libros tambi√©n se pueden renderizar usando quarto::quarto_render().\nLea m√°s sobre sitios web de Quarto en https://quarto.org/docs/websites y sobre libros en https://quarto.org/docs/books.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>29</span>¬† <span class='chapter-title'>Formatos Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#otros-formatos",
    "href": "quarto-formats.html#otros-formatos",
    "title": "29¬† Formatos Quarto",
    "section": "\n29.7 Otros formatos",
    "text": "29.7 Otros formatos\nQuarto ofrece a√∫n m√°s formatos de salida:\n\nPuede escribir art√≠culos de revistas usando Plantillas de revistas en cuarto: https://quarto.org/docs/journals/templates.html.\nPuede exportar documentos Quarto a Jupyter Notebooks con formato: ipynb: https://quarto.org/docs/reference/formats/ipynb.html.\n\nVea https://quarto.org/docs/output-formats/all-formats.html para una lista de incluso m√°s formatos.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>29</span>¬† <span class='chapter-title'>Formatos Quarto</span>"
    ]
  },
  {
    "objectID": "quarto-formats.html#resumen",
    "href": "quarto-formats.html#resumen",
    "title": "29¬† Formatos Quarto",
    "section": "\n29.8 Resumen",
    "text": "29.8 Resumen\nEn este cap√≠tulo le presentamos una variedad de opciones para comunicar sus resultados con Quarto, desde documentos est√°ticos e interactivos hasta presentaciones, sitios web y libros.\nPara aprender m√°s sobre la comunicaci√≥n efectiva en estos diferentes formatos, recomendamos los siguientes recursos:\n\nPara mejorar sus habilidades de presentaci√≥n, intente Presentation Patterns de Neal Ford, Matthew McCollough, y Nathaniel Schutta. Proporciona un conjunto de patrones efectivos (tanto de bajo como de alto nivel) que puede aplicar para mejorar sus presentaciones.\nSi das charlas acad√©micas, tal vez te gusten las Leek group guide to giving talks.\nNo lo hemos tomado nosotros mismos, pero hemos escuchado cosas buenas sobre el curso en l√≠nea de Matt McGarrity sobre hablar en p√∫blico: https://www.coursera.org/learn/public-speaking.\nSi est√° creando muchos tableros, aseg√∫rese de leer Stephen Few‚Äôs Information Dashboard Design: The Effective Visual Communication of Data. Le ayudar√° a crear tableros que sean realmente √∫tiles, no solo bonitos a la vista.\nLa comunicaci√≥n efectiva de sus ideas a menudo se beneficia de alg√∫n conocimiento de dise√±o gr√°fico. Robin Williams‚Äô The Non-Designer‚Äôs Design Book es un gran lugar para comenzar.",
    "crumbs": [
      "Comunicar",
      "<span class='chapter-number'>29</span>¬† <span class='chapter-title'>Formatos Quarto</span>"
    ]
  }
]
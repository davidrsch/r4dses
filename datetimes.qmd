# Fechas y horas {#sec-dates-and-times}

```{r}
#| results: "asis"
#| echo: false
source("_common.R")
status("complete")

# https://github.com/tidyverse/lubridate/issues/1058
options(warnPartialMatchArgs = FALSE)
```

## Introducción

Este capítulo le mostrará cómo trabajar con fechas y horas en R.
A primera vista, las fechas y horas parecen simples.
Los usa todo el tiempo en su vida normal y no parecen causar mucha confusión.
Sin embargo, cuanto más aprendes sobre las fechas y las horas, ¡más complicadas parecen volverse!

Para entrar en calor, piensa en cuántos días hay en un año y cuántas horas hay en un día.
Probablemente recordó que la mayoría de los años tienen 365 días, pero los años bisiestos tienen 366.
¿Conoces la regla completa para determinar si un año es bisiesto[^datetimes-1]?
La cantidad de horas en un día es un poco menos obvia: la mayoría de los días tienen 24 horas, pero en lugares que usan el horario de verano (DST), un día cada año tiene 23 horas y otro tiene 25.

[^datetimes-1]: Un año es bisiesto si es divisible por 4, a menos que también sea divisible por 100, excepto si también es divisible por 400.
    En otras palabras, en cada conjunto de 400 años, hay 97 años bisiestos.

Las fechas y las horas son difíciles porque tienen que conciliar dos fenómenos físicos (la rotación de la Tierra y su órbita alrededor del sol) con toda una serie de fenómenos geopolíticos, incluidos los meses, las zonas horarias y el horario de verano.
Este capítulo no le enseñará hasta el último detalle sobre fechas y horas, pero le brindará una base sólida de habilidades prácticas que lo ayudarán con los desafíos comunes de análisis de datos.

Comenzaremos mostrándole cómo crear fechas y horas a partir de varias entradas y luego, una vez que tenga una fecha y hora, cómo puede extraer componentes como año, mes y día.
Luego nos sumergiremos en el tema complicado de trabajar con intervalos de tiempo, que vienen en una variedad de sabores dependiendo de lo que esté tratando de hacer.
Concluiremos con una breve discusión de los desafíos adicionales que plantean las zonas horarias.

### Requisitos previos

Este capítulo se centrará en el paquete **lubridate**, que facilita el trabajo con fechas y horas en R.
A partir de la última versión de tidyverse, lubridate es parte del núcleo de tidyverse.
También necesitaremos nycflights13 para datos de práctica.

```{r}
#| message: false
library(tidyverse)
library(nycflights13)
```

## Creando fecha/horas {#sec-creating-datetimes}

Hay tres tipos de datos de fecha/hora que se refieren a un instante en el tiempo:

-   Una **fecha**.
    Tibbles imprime esto como `<date>`.

-   Una **hora** en un d'ia.
    Tibbles impreme esto como `<time>`.

-   Una **fecha-hora** es una fecha más una hora: identifica de manera única un instante en el tiempo (generalmente al segundo más cercano).
    Tibbles imprime esto como `<dttm>`.
    Base R los llama POSIXct, pero no se sale de la lengua exactamente.

En este capítulo nos vamos a centrar en fechas y fechas y horas, ya que R no tiene una clase nativa para almacenar horas.
Si necesita uno, puede usar el paquete **hms**.

Siempre debe usar el tipo de datos más simple posible que funcione para sus necesidades.
Eso significa que si puede usar una fecha en lugar de una fecha y hora, debería hacerlo.
Las fechas y horas son sustancialmente más complicadas debido a la necesidad de manejar las zonas horarias, a lo que volveremos al final del capítulo.

Para obtener la fecha actual o la fecha y hora, puede usar `today()` o `now()`:

```{r}
today()
now()
```

De lo contrario, las siguientes secciones describen las cuatro formas en las que es probable que cree una fecha/hora:

-   Al leer un archivo con readr.
-   De una cadena de caracteres.
-   A partir de componentes individuales de fecha y hora.
-   De un objeto de fecha/hora existente.

### Durante la importación

Si su CSV contiene una fecha ISO8601 o una fecha y hora, no necesita hacer nada; readr lo reconocerá automáticamente:

```{r}
#| message: false
csv <- "
  date,datetime
  2022-01-02,2022-01-02 05:12
"
read_csv(csv)
```

Si no ha oído hablar de **ISO8601** antes, es un estándar internacional[^datetimes-2] para escribir fechas donde los componentes de una fecha se organizan de mayor a menor separados por `-`. Por ejemplo, en ISO8601 el 5 de marzo de 2022 es `2022-05-03`. Las fechas ISO8601 también pueden incluir horas, donde la hora, el minuto y el segundo están separados por `:`, y los componentes de fecha y hora están separados por una `T` o un espacio.
Por ejemplo, podría escribir 4:26 p. m.
el 5 de marzo de 2022 como `2022-05-03 16:26` o `2022-05-03T16:26`.

[^datetimes-2]: <https://xkcd.com/1179/>

Para otros formatos de fecha y hora, necesitará usar `col_types` más `col_date()` o `col_datetime()` junto con un formato de fecha y hora.
El formato de fecha y hora utilizado por readr es un estándar utilizado en muchos lenguajes de programación, que describe un componente de fecha con un `%` seguido de un solo carácter.
Por ejemplo, `%Y-%m-%d` especifica una fecha que es un año, `-`, mes (como número) `-`, día.
La tabla @tbl-date-formats enumera todas las opciones.

| Type  | Code  | Meaning                               | Example         |
|-------|-------|---------------------------------------|-----------------|
| Año   | `%Y`  | año de 4 digitos                      | 2021            |
|       | `%y`  | año de 2 digitos                      | 21              |
| Mes   | `%m`  | Número                                | 2               |
|       | `%b`  | Nombre abreviado                      | Feb             |
|       | `%B`  | Nombre completo                       | Februrary       |
| Día   | `%d`  | Dos digitos                           | 02              |
|       | `%e`  | Uno o dos digitos                     | 2               |
| Hora  | `%H`  | Horas en 24-horas                     | 13              |
|       | `%I`  | Horas en 12-horas                     | 1               |
|       | `%p`  | AM/PM                                 | pm              |
|       | `%M`  | Minutos                               | 35              |
|       | `%S`  | Segundos                              | 45              |
|       | `%OS` | Segundos con componente decimal       | 45.35           |
|       | `%Z`  | Nombre de la zona horaria             | America/Chicago |
|       | `%z`  | Desplazamiento de UTC                 | +0800           |
| Otros | `%.`  | Evitar un no digito                   | :               |
|       | `%*`  | Evitar cualquier número de no digitos |                 |

: Todos los formatos de fecha entendidos por readr {#tbl-date-formats}

Y este código muestra algunas opciones aplicadas a una fecha muy ambigua:

```{r}
#| messages: false

csv <- "
  date
  01/02/15
"

read_csv(csv, col_types = cols(date = col_date("%m/%d/%y")))

read_csv(csv, col_types = cols(date = col_date("%d/%m/%y")))

read_csv(csv, col_types = cols(date = col_date("%y/%m/%d")))
```

Tenga en cuenta que no importa cómo especifique el formato de fecha, siempre se muestra de la misma manera una vez que lo ingresa en R.

Si está utilizando `%b` o `%B` y trabaja con fechas que no están en inglés, también deberá proporcionar un `locale()`.
Vea la lista de idiomas integrados en `date_names_langs()`, o cree el suyo propio con `date_names()`.

### De una cadena de caracteres

El lenguaje de especificación de fecha y hora es poderoso, pero requiere un análisis cuidadoso del formato de fecha.
Un enfoque alternativo es usar los ayudantes de lubridate que intentan determinar automáticamente el formato una vez que especifica el orden del componente.
Para usarlos, identifique el orden en que aparecen el año, el mes y el día en sus fechas, luego organice "y", "m" y "d" en el mismo orden.
Eso le da el nombre de la función lubridate que analizará su fecha.
Por ejemplo:

```{r}
ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2017")
```

`ymd()` y amigos crean fechas.
Para crear una fecha y hora, agregue un guión bajo y uno o más de "h", "m" y "s" al nombre de la función de análisis:

```{r}
ymd_hms("2017-01-31 20:11:59")
mdy_hm("01/31/2017 08:01")
```

También puede forzar la creación de una fecha y hora a partir de una fecha proporcionando una zona horaria:

```{r}
ymd("2017-01-31", tz = "UTC")
```

Aquí utilizo la zona horaria UTC[^datetimes-3] que también puede conocer como GMT, o Greenwich Mean Time, la hora en 0° de longitud[^datetimes-4]
. No utiliza el horario de verano, por lo que es un poco más fácil de calcular
.

[^datetimes-3]: Quizás se pregunte qué significa UTC.
    Es un compromiso entre el "Coordinated Universal Time" inglés y el "Temps Universel Coordonné" francés.

[^datetimes-4]: No hay premios por adivinar a qué país se le ocurrió el sistema de longitud.

### De componentes individuales

En lugar de una sola cadena, a veces tendrá los componentes individuales de la fecha y hora distribuidos en varias columnas.
Esto es lo que tenemos en los datos de `flights`:

```{r}
flights |> 
  select(year, month, day, hour, minute)
```

Para crear una fecha/hora a partir de este tipo de entrada, usa `make_date()` para fechas, o `make_datetime()` para fechas y horas:

```{r}
flights |> 
  select(year, month, day, hour, minute) |> 
  mutate(departure = make_datetime(year, month, day, hour, minute))
```

Hagamos lo mismo para cada una de las cuatro columnas de tiempo en `flights`.
Los tiempos se representan en un formato ligeramente extraño, por lo que usamos aritmética de módulo para extraer los componentes de hora y minuto.
Una vez que hayamos creado las variables de fecha y hora, nos centraremos en las variables que exploraremos en el resto del capítulo.

```{r}
make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights |> 
  filter(!is.na(dep_time), !is.na(arr_time)) |> 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) |> 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
```

Con estos datos, podemos visualizar la distribución de los horarios de salida a lo largo del año:

```{r}
#| fig.alt: >
#|   Un polígono de frecuencia con hora de salida (enero-diciembre de 2013) en
#|    el eje x y número de vuelos en el eje y (0-1000). El polígono de frecuencia está
#|     agrupado por día para que vea una serie temporal de vuelos por día. El patrón está
#|      dominado por un patrón semanal; hay menos vuelos los fines de semana. Son pocos los
#|       días que se destacan por tener sorprendentemente pocos vuelos a principios de
#|        febrero, principios de julio, finales de noviembre y finales de diciembre.

flights_dt |> 
  ggplot(aes(x = dep_time)) + 
  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day
```

O dentro de un solo día:

```{r}
#| fig.alt: >
#|   Un polígono de frecuencia con hora de salida (6 am - medianoche del 1 de enero) en
#|    el eje x, número de vuelos en el eje y (0-17), agrupados en incrementos de 10
#|     minutos. Es difícil ver muchos patrones debido a la gran variabilidad, pero la 
#|     mayoría de los contenedores tienen de 8 a 12 vuelos, y hay muchos menos vuelos antes
#|     de las 6 a. m. y después de las 8 p. m.

flights_dt |> 
  filter(dep_time < ymd(20130102)) |> 
  ggplot(aes(x = dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes
```

Tenga en cuenta que cuando usa fecha y hora en un contexto numérico (como en un histograma), 1 significa 1 segundo, por lo que un ancho de bin de 86400 significa un día.
Para fechas, 1 significa 1 día.

### De otros tipos

Es posible que desee cambiar entre una fecha y hora y una fecha.
Ese es el trabajo de `as_datetime()` y `as_date()`:

```{r}
as_datetime(today())
as_date(now())
```

A veces obtendrá la fecha/hora como compensaciones numéricas de la "época de Unix", 1970-01-01.
Si el desplazamiento está en segundos, use `as_datetime()`; si es en días, usa `as_date()`.

```{r}
as_datetime(60 * 60 * 10)
as_date(365 * 10 + 2)
```

### Ejercicios

1.  ¿Qué sucede si analiza una cadena que contiene fechas no válidas?

    ```{r}
    #| eval: false

    ymd(c("2010-10-10", "bananas"))
    ```

2.  ¿Qué hace el argumento `tzone` para `today()`?
    ¿Por qué es importante?

3.  Para cada una de las siguientes fechas y horas, muestre cómo las analizaría utilizando una especificación de columna readr y una función lubridate.

    ```{r}
    d1 <- "January 1, 2010"
    d2 <- "2015-Mar-07"
    d3 <- "06-Jun-2017"
    d4 <- c("August 19 (2015)", "July 1 (2015)")
    d5 <- "12/30/14" # Dec 30, 2014
    t1 <- "1705"
    t2 <- "11:15:10.12 PM"
    ```

## Componentes de fecha y hora

Ahora que sabe cómo obtener datos de fecha y hora en las estructuras de datos de fecha y hora de R, exploremos qué puede hacer con ellos.
Esta sección se centrará en las funciones de acceso que le permiten obtener y configurar componentes individuales.
La siguiente sección verá cómo funciona la aritmética con fechas y horas.

### Obtener componentes

Puede extraer partes individuales de la fecha con las funciones de acceso `year()`, `month()`, `mday()` (día del mes), `yday()` (día del año), `wday()` (día de la semana), `hour()`, `minute()` y `second()`.
Estos son efectivamente los opuestos de `make_datetime()`.

```{r}
datetime <- ymd_hms("2026-07-08 12:34:56")

year(datetime)
month(datetime)
mday(datetime)

yday(datetime)
wday(datetime)
```

Para `month()` y `wday()` puede configurar `label = TRUE` para devolver el nombre abreviado del mes o día de la semana.
Establezca `abbr = FALSE` para devolver el nombre completo.

```{r}
month(datetime, label = TRUE)
wday(datetime, label = TRUE, abbr = FALSE)
```

Podemos usar `wday()` para ver que salen más vuelos durante la semana que el fin de semana:

```{r}
#| fig-alt: >
#|   Un gráfico de barras con los días de la semana en el eje x y el número de vuelos
#|    en el eje y. De lunes a viernes tienen aproximadamente la misma cantidad de vuelos, 
#|    ~48,0000, disminuyendo ligeramente en el transcurso de la semana. El domingo es un 
#|    poco más bajo (~45 000) y el sábado es mucho más bajo (~38 000).

flights_dt |> 
  mutate(wday = wday(dep_time, label = TRUE)) |> 
  ggplot(aes(x = wday)) +
  geom_bar()
```

Hay un patrón interesante si observamos el retraso de salida promedio por minuto dentro de la hora.
¡Parece que los vuelos que salen en los minutos 20-30 y 50-60 tienen retrasos mucho menores que el resto de la hora!

```{r}
#| fig-alt: > 
#|   Un gráfico de líneas con el minuto de salida real (0-60) en el eje x y el retraso 
#|   promedio (4-20) en el eje y. El retraso promedio comienza en (0, 12), aumenta 
#|   constantemente a (18, 20), luego cae bruscamente, alcanzando un mínimo de ~23 
#|   minutos después de la hora y 9 minutos de retraso. Luego aumenta de nuevo a (17, 
#|   35), y disminuye bruscamente a (55, 4). Termina con un aumento a (60, 9).

flights_dt |> 
  mutate(minute = minute(dep_time)) |> 
  group_by(minute) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE),
    n = n()
  ) |> 
  ggplot(aes(x = minute, y = avg_delay)) +
  geom_line()
```

Curiosamente, si observamos la hora de salida *programada*, no vemos un patrón tan fuerte:

```{r}
#| fig-alt: > 
#|   Un gráfico de líneas con minutos de salida programada (0-60) en el eje x y demora 
#|   promedio (4-16). Hay un patrón relativamente pequeño, solo una pequeña sugerencia 
#|   de que el retraso promedio disminuye de quizás 10 minutos a 8 minutos en el 
#|   transcurso de la hora.

sched_dep <- flights_dt |> 
  mutate(minute = minute(sched_dep_time)) |> 
  group_by(minute) |> 
  summarize(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

ggplot(sched_dep, aes(x = minute, y = avg_delay)) +
  geom_line()
```

Entonces, ¿por qué vemos ese patrón con los horarios de salida reales?
Bueno, como gran parte de los datos recopilados por humanos, hay un fuerte sesgo hacia los vuelos que salen en "buenos" horarios de salida, como muestra @fig-human-rounding.
¡Esté siempre alerta a este tipo de patrón cada vez que trabaje con datos que involucran el juicio humano!

```{r}
#| label: fig-human-rounding
#| fig-cap: >
#|   Un polígono de frecuencia que muestra el número de vuelos programados para salir 
#|   cada hora. Puede ver una fuerte preferencia por los números redondos como el 0 y 
#|   el 30 y, en general, por los números que son múltiplos de cinco.
#| fig-alt: >
#|   Un gráfico de líneas con el minuto de salida (0-60) en el eje x y el número de vuelos 
#|   (0-60000) en el eje y. La mayoría de los vuelos están programados para salir a la hora 
#|   (~60 000) o a la media hora (~35 000). De lo contrario, la mayoría de los vuelos están 
#|   programados para salir en múltiplos de cinco, con algunos adicionales a los 15, 
#|   45 y 55 minutos.
#| echo: false

ggplot(sched_dep, aes(x = minute, y = n)) +
  geom_line()
```

### Redondeo

Un enfoque alternativo para trazar componentes individuales es redondear la fecha a una unidad de tiempo cercana, con `floor_date()`, `round_date()` y `ceiling_date()`.
Cada función toma un vector de fechas para ajustar y luego el nombre de la unidad redondea hacia abajo (floor), redondea hacia arriba (ceiling) o redondea a.
Esto, por ejemplo, nos permite graficar el número de vuelos por semana:

```{r}
#| fig-alt: >
#|   Un gráfico de líneas con la semana (enero-diciembre de 2013) en el eje x y el número 
#|   de vuelos (2000-7000) en el eje y. El patrón es bastante plano de febrero a 
#|   noviembre con alrededor de 7.000 vuelos por semana. Hay muchos menos vuelos en la 
#|   primera (aproximadamente 4.500 vuelos) y la última semana del año (aproximadamente 
#|   2.500 vuelos).

flights_dt |> 
  count(week = floor_date(dep_time, "week")) |> 
  ggplot(aes(x = week, y = n)) +
  geom_line() + 
  geom_point()
```

Puede usar el redondeo para mostrar la distribución de vuelos a lo largo de un día calculando la diferencia entre `dep_time` y el primer instante de ese día:

```{r}
#| fig-alt: >
#|   Un gráfico de líneas con el tiempo de salida en el eje x. Estas son unidades de 
#|   segundos desde la medianoche, por lo que es difícil de interpretar.

flights_dt |> 
  mutate(dep_hour = dep_time - floor_date(dep_time, "day")) |> 
  ggplot(aes(x = dep_hour)) +
  geom_freqpoly(binwidth = 60 * 30)
```

Calcular la diferencia entre un par de fechas y horas produce un tiempo de diferencia (más sobre eso en @sec-intervals).
Podemos convertir eso en un objeto `hms` para obtener un eje x más útil:

```{r}
#| fig-alt: >
#|   Un gráfico de líneas con la hora de salida (medianoche a medianoche) en el eje x 
#|   y el número de vuelos en el eje y (0 a 15 000). Hay muy pocos (<100) vuelos antes 
#|   de las 5 am. El número de vuelos luego aumenta rápidamente a 12 000 por 
#|   hora, con un máximo de 15 000 a las 9 a. m., antes de caer a alrededor de 8 000 
#|   por hora entre las 10 a. m. y las 2 p. m. Luego, el número de vuelos aumenta 
#|   a alrededor de 12,000 por hora hasta las 8:00 p. m., cuando vuelven a caer 
#|   rápidamente.. 

flights_dt |> 
  mutate(dep_hour = hms::as_hms(dep_time - floor_date(dep_time, "day"))) |> 
  ggplot(aes(x = dep_hour)) +
  geom_freqpoly(binwidth = 60 * 30)
```

### Modificación de componentes

También puede utilizar cada función de acceso para modificar los componentes de una fecha/hora.
Esto no aparece mucho en el análisis de datos, pero puede ser útil cuando se limpian datos que tienen fechas claramente incorrectas.

```{r}
(datetime <- ymd_hms("2026-07-08 12:34:56"))

year(datetime) <- 2030
datetime
month(datetime) <- 01
datetime
hour(datetime) <- hour(datetime) + 1
datetime
```

Alternatively, rather than modifying an existing variable, you can create a new date-time with `update()`.
This also allows you to set multiple values in one step:

```{r}
update(datetime, year = 2030, month = 2, mday = 2, hour = 2)
```

If values are too big, they will roll-over:

```{r}
update(ymd("2023-02-01"), mday = 30)
update(ymd("2023-02-01"), hour = 400)
```

### Exercises

1.  How does the distribution of flight times within a day change over the course of the year?

2.  Compare `dep_time`, `sched_dep_time` and `dep_delay`.
    Are they consistent?
    Explain your findings.

3.  Compare `air_time` with the duration between the departure and arrival.
    Explain your findings.
    (Hint: consider the location of the airport.)

4.  How does the average delay time change over the course of a day?
    Should you use `dep_time` or `sched_dep_time`?
    Why?

5.  On what day of the week should you leave if you want to minimise the chance of a delay?

6.  What makes the distribution of `diamonds$carat` and `flights$sched_dep_time` similar?

7.  Confirm our hypothesis that the early departures of flights in minutes 20-30 and 50-60 are caused by scheduled flights that leave early.
    Hint: create a binary variable that tells you whether or not a flight was delayed.

## Time spans

Next you'll learn about how arithmetic with dates works, including subtraction, addition, and division.
Along the way, you'll learn about three important classes that represent time spans:

-   **Durations**, which represent an exact number of seconds.
-   **Periods**, which represent human units like weeks and months.
-   **Intervals**, which represent a starting and ending point.

How do you pick between duration, periods, and intervals?
As always, pick the simplest data structure that solves your problem.
If you only care about physical time, use a duration; if you need to add human times, use a period; if you need to figure out how long a span is in human units, use an interval.

### Durations

In R, when you subtract two dates, you get a difftime object:

```{r}
# How old is Hadley?
h_age <- today() - ymd("1979-10-14")
h_age
```

A difftime class object records a time span of seconds, minutes, hours, days, or weeks.
This ambiguity can make difftimes a little painful to work with, so lubridate provides an alternative which always uses seconds: the **duration**.

```{r}
as.duration(h_age)
```

Durations come with a bunch of convenient constructors:

```{r}
dseconds(15)
dminutes(10)
dhours(c(12, 24))
ddays(0:5)
dweeks(3)
dyears(1)
```

Durations always record the time span in seconds.
Larger units are created by converting minutes, hours, days, weeks, and years to seconds: 60 seconds in a minute, 60 minutes in an hour, 24 hours in a day, and 7 days in a week.
Larger time units are more problematic.
A year uses the "average" number of days in a year, i.e. 365.25.
There's no way to convert a month to a duration, because there's just too much variation.

You can add and multiply durations:

```{r}
2 * dyears(1)
dyears(1) + dweeks(12) + dhours(15)
```

You can add and subtract durations to and from days:

```{r}
tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)
```

However, because durations represent an exact number of seconds, sometimes you might get an unexpected result:

```{r}
one_am <- ymd_hms("2026-03-08 01:00:00", tz = "America/New_York")

one_am
one_am + ddays(1)
```

Why is one day after 1am March 8, 2am March 9?
If you look carefully at the date you might also notice that the time zones have changed.
March 8 only has 23 hours because it's when DST starts, so if we add a full days worth of seconds we end up with a different time.

### Periods

To solve this problem, lubridate provides **periods**.
Periods are time spans but don't have a fixed length in seconds, instead they work with "human" times, like days and months.
That allows them to work in a more intuitive way:

```{r}
one_am
one_am + days(1)
```

Like durations, periods can be created with a number of friendly constructor functions.

```{r}
hours(c(12, 24))
days(7)
months(1:6)
```

You can add and multiply periods:

```{r}
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)
```

And of course, add them to dates.
Compared to durations, periods are more likely to do what you expect:

```{r}
# A leap year
ymd("2024-01-01") + dyears(1)
ymd("2024-01-01") + years(1)

# Daylight Savings Time
one_am + ddays(1)
one_am + days(1)
```

Let's use periods to fix an oddity related to our flight dates.
Some planes appear to have arrived at their destination *before* they departed from New York City.

```{r}
flights_dt |> 
  filter(arr_time < dep_time) 
```

These are overnight flights.
We used the same date information for both the departure and the arrival times, but these flights arrived on the following day.
We can fix this by adding `days(1)` to the arrival time of each overnight flight.

```{r}
flights_dt <- flights_dt |> 
  mutate(
    overnight = arr_time < dep_time,
    arr_time = arr_time + days(!overnight),
    sched_arr_time = sched_arr_time + days(overnight)
  )
```

Now all of our flights obey the laws of physics.

```{r}
flights_dt |> 
  filter(overnight, arr_time < dep_time) 
```

### Intervals {#sec-intervals}

What does `dyears(1) / ddays(365)` return?
It's not quite one, because `dyear()` is defined as the number of seconds per average year, which is 365.25 days.

What does `years(1) / days(1)` return?
Well, if the year was 2015 it should return 365, but if it was 2016, it should return 366!
There's not quite enough information for lubridate to give a single clear answer.
What it does instead is give an estimate:

```{r}
years(1) / days(1)
```

If you want a more accurate measurement, you'll have to use an **interval**.
An interval is a pair of starting and ending date times, or you can think of it as a duration with a starting point.

You can create an interval by writing `start %--% end`:

```{r}
y2023 <- ymd("2023-01-01") %--% ymd("2024-01-01")
y2024 <- ymd("2024-01-01") %--% ymd("2025-01-01")

y2023
y2024
```

You could then divide it by `days()` to find out how many days fit in the year:

```{r}
y2023 / days(1)
y2024 / days(1)
```

### Exercises

1.  Explain `days(!overnight)` and `days(overnight)` to someone who has just started learning R.
    What is the key fact you need to know?

2.  Create a vector of dates giving the first day of every month in 2015.
    Create a vector of dates giving the first day of every month in the *current* year.

3.  Write a function that given your birthday (as a date), returns how old you are in years.

4.  Why can't `(today() %--% (today() + years(1))) / months(1)` work?

## Time zones

Time zones are an enormously complicated topic because of their interaction with geopolitical entities.
Fortunately we don't need to dig into all the details as they're not all important for data analysis, but there are a few challenges we'll need to tackle head on.

<!--# https://www.ietf.org/timezones/tzdb-2018a/theory.html -->

The first challenge is that everyday names of time zones tend to be ambiguous.
For example, if you're American you're probably familiar with EST, or Eastern Standard Time.
However, both Australia and Canada also have EST!
To avoid confusion, R uses the international standard IANA time zones.
These use a consistent naming scheme `{area}/{location}`, typically in the form `{continent}/{city}` or `{ocean}/{city}`.
Examples include "America/New_York", "Europe/Paris", and "Pacific/Auckland".

You might wonder why the time zone uses a city, when typically you think of time zones as associated with a country or region within a country.
This is because the IANA database has to record decades worth of time zone rules.
Over the course of decades, countries change names (or break apart) fairly frequently, but city names tend to stay the same.
Another problem is that the name needs to reflect not only the current behavior, but also the complete history.
For example, there are time zones for both "America/New_York" and "America/Detroit".
These cities both currently use Eastern Standard Time but in 1969-1972 Michigan (the state in which Detroit is located), did not follow DST, so it needs a different name.
It's worth reading the raw time zone database (available at <https://www.iana.org/time-zones>) just to read some of these stories!

You can find out what R thinks your current time zone is with `Sys.timezone()`:

```{r}
Sys.timezone()
```

(If R doesn't know, you'll get an `NA`.)

And see the complete list of all time zone names with `OlsonNames()`:

```{r}
length(OlsonNames())
head(OlsonNames())
```

In R, the time zone is an attribute of the date-time that only controls printing.
For example, these three objects represent the same instant in time:

```{r}
x1 <- ymd_hms("2024-06-01 12:00:00", tz = "America/New_York")
x1

x2 <- ymd_hms("2024-06-01 18:00:00", tz = "Europe/Copenhagen")
x2

x3 <- ymd_hms("2024-06-02 04:00:00", tz = "Pacific/Auckland")
x3
```

You can verify that they're the same time using subtraction:

```{r}
x1 - x2
x1 - x3
```

Unless otherwise specified, lubridate always uses UTC.
UTC (Coordinated Universal Time) is the standard time zone used by the scientific community and is roughly equivalent to GMT (Greenwich Mean Time).
It does not have DST, which makes a convenient representation for computation.
Operations that combine date-times, like `c()`, will often drop the time zone.
In that case, the date-times will display in your local time zone:

```{r}
x4 <- c(x1, x2, x3)
x4
```

You can change the time zone in two ways:

-   Keep the instant in time the same, and change how it's displayed.
    Use this when the instant is correct, but you want a more natural display.

    ```{r}
    x4a <- with_tz(x4, tzone = "Australia/Lord_Howe")
    x4a
    x4a - x4
    ```

    (This also illustrates another challenge of times zones: they're not all integer hour offsets!)

-   Change the underlying instant in time.
    Use this when you have an instant that has been labelled with the incorrect time zone, and you need to fix it.

    ```{r}
    x4b <- force_tz(x4, tzone = "Australia/Lord_Howe")
    x4b
    x4b - x4
    ```

## Summary

This chapter has introduced you to the tools that lubridate provides to help you work with date-time data.
Working with dates and times can seem harder than necessary, but hopefully this chapter has helped you see why --- date-times are more complex than they seem at first glance, and handling every possible situation adds complexity.
Even if your data never crosses a day light savings boundary or involves a leap year, the functions need to be able to handle it.

The next chapter gives a round up of missing values.
You've seen them in a few places and have no doubt encounter in your own analysis, and it's now time to provide a grab bag of useful techniques for dealing with them.

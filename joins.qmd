# Uniones {#sec-joins}

```{r}
#| results: "asis"
#| echo: false
source("_common.R")
status("complete")
```

## Introducción

Es raro que un análisis de datos involucre solo un único marco de datos.
Por lo general, tiene muchos marcos de datos y debe **unirlos** para responder las preguntas que le interesan.
Este capítulo le presentará dos tipos importantes de uniones:

-   Combinaciones mutantes, que agregan nuevas variables a un marco de datos a partir de observaciones coincidentes en otro.
-   Combinaciones de filtrado, que filtran las observaciones de un marco de datos en función de si coinciden o no con una observación en otro.

Comenzaremos analizando las llaves, las variables que se utilizan para conectar un par de marcos de datos en una combinación.
Cimentamos la teoría con un examen de las llaves en los conjuntos de datos del paquete nycflights13, luego usamos ese conocimiento para comenzar a unir marcos de datos.
A continuación, analizaremos cómo funcionan las uniones, centrándonos en su acción en las filas.
Terminaremos con una discusión sobre las uniones no equitativas, una familia de uniones que proporcionan una forma más flexible de hacer coincidir llaves que la relación de igualdad predeterminada.

### Requisitos previos

En este capítulo, exploraremos los cinco conjuntos de datos relacionados de nycflights13 utilizando las funciones de combinación de dplyr.

```{r}
#| label: setup
#| message: false

library(tidyverse)
library(nycflights13)
```

## Llaves

Para comprender las uniones, primero debe comprender cómo se pueden conectar dos tablas a través de un par de llaves, dentro de cada tabla.
En esta sección, aprenderá sobre los dos tipos de llave y verá ejemplos de ambos en los conjuntos de datos del paquete nycflights13.
También aprenderá cómo verificar que sus llaves sean válidas y qué hacer si su tabla no tiene una llave.

### Llaves primarias y foráneas

Cada unión implica un par de llaves: una llave principal y una llave externa.
Una **Llave principal** es una variable o un conjunto de variables que identifica de forma única cada observación.
Cuando se necesita más de una variable, la llave se denomina **Llave compuesta.** Por ejemplo, en nycfights13:

-   `airlines` registra dos datos sobre cada aerolínea: su código de aerolínea y su nombre completo.
    Puede identificar una línea aérea con su código de dos letras, haciendo que `carrier` sea la llave principal.

    ```{r}
    airlines
    ```

-   `airports` registra datos sobre cada aeropuerto.
    Puede identificar cada aeropuerto por su código de aeropuerto de tres letras, haciendo que `faa` sea la llave principal.

    ```{r}
    #| R.options:
    #|   width: 67
    airports
    ```

-   `planes` registra datos sobre cada plano.
    Puede identificar un avión por su número de cola, haciendo que `tailnum` sea la llave principal.

    ```{r}
    #| R.options:
    #|   width: 67
    planes
    ```

-   `weather` registra datos sobre el clima en los aeropuertos de origen.
    Puede identificar cada observación por la combinación de ubicación y hora, haciendo que `origin` y `time_hour` sean la llave principal compuesta.

    ```{r}
    #| R.options:
    #|   width: 67
    weather
    ```

Una **llave externa** es una variable (o conjunto de variables) que corresponde a una llave principal en otra tabla.
Por ejemplo:

-   `flights$tailnum` es una llave foránea que corresponde a la llave primaria `planes$tailnum`.
-   `flights$carrier` es una llave foránea que corresponde a la llave primaria `airlines$carrier`.
-   `flights$origin` es una llave foránea que corresponde a la llave primaria `airports$faa`.
-   `flights$dest` es una llave foránea que corresponde a la llave primaria `airports$faa`.
-   `flights$origin`-`flights$time_hour` es una llave foránea compuesta que corresponde a la llave primaria compuesta `weather$origin`-`weather$time_hour`.

Estas relaciones se resumen visualmente en @fig-flights-relationships.

```{r}
#| label: fig-flights-relationships
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Conexiones entre los cinco marcos de datos en el paquete nycflights13. 
#|   Las variables que componen una llave primaria son de color gris y están 
#|   conectadas a sus correspondientes llaves foráneas con flechas.
#| fig-alt: |
#|   Las relaciones entre aeropuertos, aviones, vuelos, clima y conjuntos de 
#|   datos de aerolíneas del paquete nycflights13. airports$faa conectados 
#|   a los flights$origin y flights$dest. planes$tailnum está conectado a los 
#|   flights$tailnum. weather$time_hour y weather$origin están conectados 
#|   conjuntamente con los flights$time_hour y los flights$origin. 
#|   airlines$carrier está conectado a flights$carrier. No hay conexiones directas 
#|   entre aeropuertos, aviones, aerolíneas y marcos de datos meteorológicos.

knitr::include_graphics("diagrams/relational.png", dpi = 270)
```

Notará una buena característica en el diseño de estas claves: las claves principal y externa casi siempre tienen los mismos nombres, lo que, como verá en breve, hará que su vida de unión sea mucho más fácil.
También vale la pena señalar la relación opuesta: casi todos los nombres de variables utilizados en varias tablas tienen el mismo significado en cada lugar.
Sólo hay una excepción: `year` significa año de salida en `flights` y año de fabricación en `planes`.
Esto se volverá importante cuando empecemos a unir tablas.

### Comprobación de llaves primarias

Ahora que hemos identificado las claves principales en cada tabla, es una buena práctica verificar que realmente identifiquen de manera única cada observación.
Una forma de hacerlo es contar, `count()`, las llaves primarias y buscar entradas donde `n` sea mayor que uno.
Esto revela que `planes` y `weather` se ven bien:

```{r}
planes |> 
  count(tailnum) |> 
  filter(n > 1)

weather |> 
  count(time_hour, origin) |> 
  filter(n > 1)
```

También debe verificar si faltan valores en sus llaves principales --- si falta un valor, ¡entonces no puede identificar una observación!

```{r}
planes |> 
  filter(is.na(tailnum))

weather |> 
  filter(is.na(time_hour) | is.na(origin))
```

### Llaves sustitutas

Hasta ahora no hemos hablado de la llave principal para `flights`.
No es muy importante aquí, porque no hay marcos de datos que lo usen como clave externa, pero aún así es útil considerarlo porque es más fácil trabajar con observaciones si tenemos alguna forma de describirlas a otros.

Después de pensar un poco y experimentar, determinamos que hay tres variables que juntas identifican de manera única cada vuelo:

```{r}
flights |> 
  count(time_hour, carrier, flight) |> 
  filter(n > 1)
```

¿La ausencia de duplicados convierte automáticamente a `time_hour`-`carrier`-`flight` en una llave principal?
Sin duda es un buen comienzo, pero no lo garantiza.
Por ejemplo, ¿son la altitud y la latitud una buena clave principal para `airports`?

```{r}
airports |>
  count(alt, lat) |> 
  filter(n > 1)
```

Identificar un aeropuerto por su altitud y latitud es claramente una mala idea y, en general, no es posible saber solo a partir de los datos si una combinación de variables constituye o no una buena clave primaria.
Pero para los vuelos, la combinación de `time_hour`, `carrier` y `flight` parece razonable porque sería realmente confuso para una aerolínea y sus clientes si hubiera varios vuelos con el mismo número de vuelo en el aire al mismo tiempo.

Dicho esto, sería mejor que introdujéramos una clave sustituta numérica simple usando el número de fila:

```{r}
flights2 <- flights |> 
  mutate(id = row_number(), .before = 1)
flights2
```

Las claves sustitutas pueden ser particularmente útiles cuando se comunican con otros humanos: es mucho más fácil decirle a alguien que mire el vuelo 2001 que decir que mire el UA430 que partió 9am 2013-01-03.

### Ejercicios

1.  Nos olvidamos de dibujar la relación entre `weather` y `airports` en @fig-flights-relationships.
    ¿Cuál es la relación y cómo debería aparecer en el diagrama?

2.  `weather` solo contiene información de los tres aeropuertos de origen en NYC.
    Si contuviera registros meteorológicos de todos los aeropuertos de EE.UU.
    ¿qué conexión adicional haría con `flights`?

3.  Las variables `year`, `month`, `day`, `hour` y `origin` casi forman una clave compuesta para `weather`, pero hay una hora que tiene observaciones duplicadas.
    ¿Puedes averiguar qué tiene de especial esa hora?

4.  Sabemos que algunos días del año son especiales y en ellos vuelan menos personas de lo habitual (por ejemplo, la víspera de Navidad y el día de Navidad).
    ¿Cómo podría representar esos datos como un marco de datos?
    ¿Cuál sería la llave principal?
    ¿Cómo se conectaría a los marcos de datos existentes?

5.  Dibuje un diagrama que ilustre las conexiones entre los marcos de datos `Batting`, `People` y `Salaries` en el paquete Lahman.
    Dibuja otro diagrama que muestre la relación entre `People`, `Managers`, `AwardsManagers`.
    ¿Cómo caracterizaría la relación entre los data frames `Batting`, `Pitching`, y `Fielding`?

## Uniones básicas {#sec-mutating-joins}

Ahora que comprende cómo se conectan los marcos de datos a través de claves, podemos comenzar a usar uniones para comprender mejor el conjunto de datos de `flights`.
dplyr proporciona seis funciones de unión: `left_join()`, `inner_join()`, `right_join()`, `full_join()`, `semi_join()` y `anti_join()`.
Todas tienen la misma interfaz: toman un par de marcos de datos (`x` e `y`) y devuelven un marco de datos.
El orden de las filas y columnas en la salida está determinado principalmente por `x`.

En esta sección, aprenderá a usar una unión mutante, `left_join()`, y dos uniones de filtrado, `semi_join()` y `anti_join()`.
En la siguiente sección, aprenderá exactamente cómo funcionan estas funciones y sobre las `inner_join()`, `right_join()` y `full_join()` restantes.

### Uniones mutantes

Una **unión mutante** le permite combinar variables de dos marcos de datos: primero hace coincidir las observaciones por sus claves, luego copia las variables de un marco de datos al otro.
Al igual que `mutate()`, las funciones de combinación agregan variables a la derecha, por lo que si su conjunto de datos tiene muchas variables, no verá las nuevas.
Para estos ejemplos, facilitaremos ver lo que sucede creando un conjunto de datos más estrecho con solo seis variables[^joins-1]:

[^joins-1]: Recuerda que en RStudio también puedes usar `View()` para evitar este problema.

```{r}
flights2 <- flights |> 
  select(year, time_hour, origin, dest, tailnum, carrier)
flights2
```

Hay cuatro tipos de unión mutante, pero hay una que usará casi todo el tiempo: `left_join()`.
Es especial porque la salida siempre tendrá las mismas filas que `x`[^joins-2].
El uso principal de `left_join()` es agregar metadatos adicionales.
Por ejemplo, podemos usar `left_join()` para agregar el nombre completo de la aerolínea a los datos de `flights2`:

[^joins-2]: Eso no es 100% cierto, pero recibirás una advertencia cuando no lo sea.

```{r}
flights2 |>
  left_join(airlines)
```

O podríamos averiguar la temperatura y la velocidad del viento cuando partió cada avión:

```{r}
flights2 |> 
  left_join(weather |> select(origin, time_hour, temp, wind_speed))
```

O qué tamaño de avión estaba volando:

```{r}
flights2 |> 
  left_join(planes |> select(tailnum, type, engines, seats))
```

Cuando `left_join()` no encuentra una coincidencia para una fila en `x`, completa las nuevas variables con los valores que faltan.
Por ejemplo, no hay información sobre el avión con el número de cola `N3ALAA`, por lo que faltarán el `type`, los `engines` y los `seats`:

```{r}
flights2 |> 
  filter(tailnum == "N3ALAA") |> 
  left_join(planes |> select(tailnum, type, engines, seats))
```

Volveremos a este problema unas cuantas veces en el resto del capítulo.

### Especificación de llaves de combinación

Por defecto, `left_join()` usará todas las variables que aparecen en ambos marcos de datos como llave de unión, la llamada unión **natural**.
Esta es una heurística útil, pero no siempre funciona.
Por ejemplo, ¿qué sucede si tratamos de unir `flights2` con el conjunto de datos completo `planes`?

```{r}
flights2 |> 
  left_join(planes)
```

Nos faltan muchas coincidencias porque nuestra combinación intenta usar `tailnum` y `year` como clave compuesta.
Tanto `flights` como `planes` tienen una columna de `year` pero significan cosas diferentes: `flights$year` es el año en que ocurrió el vuelo y `planes$year` es el año en que se construyó el avión.
Solo queremos unirnos en `tailnum`, por lo que debemos proporcionar una especificación explícita con `join_by ()`:

```{r}
flights2 |> 
  left_join(planes, join_by(tailnum))
```

Tenga en cuenta que las variables `year` se eliminan de la ambigüedad en la salida con un sufijo (`year.x` y `year.y`), que le indica si la variable proviene del argumento `x` o `y`.
Puede anular los sufijos predeterminados con el argumento `suffix`.

`join_by(tailnum)` es corto para `join_by(tailnum == tailnum)`.
Es importante saber acerca de esta forma más completa por dos razones.
En primer lugar, describe la relación entre las dos tablas: las claves deben ser iguales.
Es por eso que este tipo de unión a menudo se denomina **equi-unión**.
Aprenderá acerca de las uniones no equitativas en @sec-non-equi-joins.

En segundo lugar, es cómo especifica diferentes claves de combinación en cada tabla.
Por ejemplo, hay dos formas de unirs las tablas `flight2` y `airports`: ya sea por `dest` o `origin`:

```{r}
flights2 |> 
  left_join(airports, join_by(dest == faa))

flights2 |> 
  left_join(airports, join_by(origin == faa))
```

En el código anterior, es posible que vea una forma diferente de especificar las claves de combinación, utilizando un vector de caracteres:

-   `by = "x"` corresponde a `join_by(x)`.
-   `by = c("a" = "x")` corresponde a `join_by(a == x)`.

Ahora que existe, preferimos `join_by()` ya que proporciona una especificación más clara y flexible.

`inner_join()`, `right_join()`, `full_join()` tienen la misma que `left_join()`.
La diferencia es qué filas conservan: la combinación izquierda mantiene todas las filas en `x`, la combinación derecha mantiene todas las filas en `y`, la combinación completa mantiene todas las filas en `x` o `y`, y la combinación interna solo mantiene las filas que aparecen tanto en `x` como en `y`.
Volveremos a esto con más detalle más adelante.

### Filtrado de uniones

Como puede suponer, la acción principal de una **unión de filtrado** es filtrar las filas.
Hay dos tipos: semi-uniones y anti-uniones.
**Semi-uniones** mantienen todas las filas en `x` que tienen una coincidencia en `y`.
Por ejemplo, podríamos usar una semi-unión para filtrar el conjunto de datos `airports` para mostrar solo los aeropuertos de origen:

```{r}
airports |> 
  semi_join(flights2, join_by(faa == origin))
```

O solo los destinos:

```{r}
airports |> 
  semi_join(flights2, join_by(faa == dest))
```

**Anti-joins** son lo contrario: devuelven todas las filas en `x` que no tienen una coincidencia en `y`.
Son útiles para encontrar valores perdidos que están **implícitos** en los datos, el tema de @sec-missing-implicit.
Los valores faltantes implícitos no se muestran como `NA`, sino que solo existen como una ausencia.
Por ejemplo, podemos encontrar filas que faltan en `airports` buscando vuelos que no tengan un aeropuerto de destino coincidente:

```{r}
flights2 |> 
  anti_join(airports, join_by(dest == faa)) |> 
  distinct(dest)
```

O podemos encontrar qué `tailnum`s faltan en `planes`:

```{r}
flights2 |>
  anti_join(planes, join_by(tailnum)) |> 
  distinct(tailnum)
```

### Ejercicios

1.  Encuentra las 48 horas (en el transcurso de todo el año) que tienen los peores retrasos.
    Haga una referencia cruzada con los datos del `weather`.
    ¿Puedes ver algún patrón?

2.  Imagina que has encontrado los 10 destinos más populares usando este código:

    ```{r}
    top_dest <- flights2 |>
      count(dest, sort = TRUE) |>
      head(10)
    ```

    ¿Cómo puede encontrar todos los vuelos a esos destinos?

3.  ¿Todos los vuelos que salen tienen los datos meteorológicos correspondientes a esa hora?

4.  ¿Qué tienen en común los números de cola que no tienen un registro coincidente en `planes`?
    (Pista: una variable explica \~90% de los problemas.)

5.  Agregue una columna a `planes` que enumere cada `carrier` que ha volado ese avión.
    Es de esperar que haya una relación implícita entre el avión y la línea aérea, porque cada avión lo pilota una sola línea aérea.
    Confirme o rechace esta hipótesis utilizando las herramientas que ha aprendido en los capítulos anteriores.

6.  Añade la latitud y la longitud del aeropuerto de origen *y* de destino a `flights`.
    ¿Es más fácil cambiar el nombre de las columnas antes o después de la unión?

7.  Calcule el retraso promedio por destino, luego únase al marco de datos `airports` para que pueda mostrar la distribución espacial de los retrasos.
    Aquí hay una manera fácil de dibujar un mapa de los Estados Unidos.:

    ```{r}
    #| eval: false

    airports |>
      semi_join(flights, join_by(faa == dest)) |>
      ggplot(aes(x = lon, y = lat)) +
        borders("state") +
        geom_point() +
        coord_quickmap()
    ```

    Es posible que desee utilizar el `size` o el `color` de los puntos para mostrar el retraso promedio de cada aeropuerto.

8.  ¿Qué pasó el 13 de junio de 2013?
    Dibuje un mapa de los retrasos y luego use Google para hacer una referencia cruzada con el clima.

    ```{r}
    #| eval: false
    #| include: false

    worst <- filter(flights, !is.na(dep_time), month == 6, day == 13)
    worst |>
      group_by(dest) |>
      summarize(delay = mean(arr_delay), n = n()) |>
      filter(n > 5) |>
      inner_join(airports, by = c("dest" = "faa")) |>
      ggplot(aes(x = lon, y = lat)) +
        borders("state") +
        geom_point(aes(size = n, color = delay)) +
        coord_quickmap()
    ```

## ¿Cómo funcionan las uniones?

Ahora que ha usado combinaciones varias veces, es hora de aprender más sobre cómo funcionan, enfocándose en cómo cada fila en `x` coincide con las filas en `y`.
Comenzaremos presentando una representación visual de las uniones, usando los simples tibbles definidos a continuación y que se muestran en @fig-join-setup.
En estos ejemplos, usaremos una sola llave llamada `key` y una sola columna de valor (`val_x` y `val_y`), pero todas las ideas se generalizan a múltiples llaves y múltiples valores.

```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)
```

```{r}
#| label: fig-join-setup
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Representación gráfica de dos tablas simples. Las columnas `key`
#|   coloreadas asignan el color de fondo al valor clave. Las columnas 
#|   grises representan las columnas de "value" que se llevan durante 
#|   el viaje.
#| fig-alt: |
#|   x e y son dos marcos de datos con 2 columnas y 3 filas, con contenidos 
#|   como se describe en el texto. Los valores de las claves están coloreados: 
#|   1 es verde, 2 es morado, 3 es naranja y 4 es amarillo.

knitr::include_graphics("diagrams/join/setup.png", dpi = 270)
```

@fig-join-setup2 introduce la base para nuestra representación visual.
Muestra todas las posibles coincidencias entre `x` e `y` como la intersección entre las líneas dibujadas desde cada fila de `x` y cada fila de `y`.
Las filas y columnas en la salida están determinadas principalmente por `x`, por lo que la tabla `x` es horizontal y se alinea con la salida.

```{r}
#| label: fig-join-setup2
#| echo: false
#| out-width: ~
#| fig-cap: | 
#|   Para comprender cómo funcionan las uniones, es útil pensar en todas 
#|   las coincidencias posibles. Aquí lo mostramos con una cuadrícula de 
#|   líneas de conexión.
#| fig-alt: |
#|   x e y se colocan en ángulo recto, con líneas horizontales que se 
#|   extienden desde x y líneas verticales que se extienden desde y. Hay 3 filas 
#|   en x y 3 filas en y, lo que lleva a nueve intersecciones que 
#|   representan nueve posibles coincidencias.

knitr::include_graphics("diagrams/join/setup2.png", dpi = 270)
```

Para describir un tipo específico de combinación, indicamos coincidencias con puntos.
Las coincidencias determinan las filas en la salida, un nuevo marco de datos que contiene la clave, los valores x y los valores y.
Por ejemplo, @fig-join-inner muestra una combinación interna, donde las filas se retienen si y solo si las claves son iguales.

```{r}
#| label: fig-join-inner
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Una unión interna hace coincidir cada fila en `x` con la fila en `y` que 
#|   tiene el mismo valor de `key`. Cada coincidencia se convierte en una 
#|   fila en la salida.
#| fig-alt: |
#|   x e y se colocan en ángulo recto con líneas que forman una cuadrícula de 
#|   coincidencias potenciales. Las claves 1 y 2 aparecen tanto en x como en y, 
#|   por lo que obtenemos una coincidencia, indicada por un punto. Cada punto 
#|   corresponde a una fila en la salida, por lo que el marco de datos combinado 
#|   resultante tiene dos filas.

knitr::include_graphics("diagrams/join/inner.png", dpi = 270)
```

Podemos aplicar los mismos principios para explicar las **uniones externas**, que mantienen las observaciones que aparecen en al menos uno de los marcos de datos.
Estas uniones funcionan agregando una observación "virtual" adicional a cada marco de datos.
Esta observación tiene una clave que coincide si ninguna otra clave coincide, y los valores se completan con `NA`.
Hay tres tipos de uniones externas:

-   Una **unión izquierda** mantiene todas las observaciones en `x`, @fig-join-left.
    Cada fila de `x` se conserva en la salida porque puede volver a coincidir con una fila de `NA`s en `y`.

    ```{r}
    #| label: fig-join-left
    #| echo: false
    #| out-width: ~
    #| fig-cap: | 
    #|   Una representación visual de la combinación izquierda donde cada 
    #|   fila en `x` aparece en la salida.
    #| fig-alt: |
    #|   En comparación con el diagrama anterior que muestra una combinación interna, 
    #|   la tabla y obtiene una nueva fila virtual que contiene NA que coincidirá 
    #|   con cualquier fila en x que de otro modo no coincidiría. Esto significa 
    #|   que la salida ahora tiene tres filas. Para key = 3, que coincide con esta fila 
    #|   virtual, val_y toma el valor NA.

    knitr::include_graphics("diagrams/join/left.png", dpi = 270)
    ```

-   Una **unión derecha** mantiene todas las observaciones en `y`, @fig-join-right.
    Cada fila de `y` se conserva en la salida porque puede volver a hacer coincidir una fila de `NA`s en `x`.
    La salida aún coincide con `x` tanto como sea posible; cualquier fila adicional de `y` se agrega al final.

    ```{r}
    #| label: fig-join-right
    #| echo: false
    #| out-width: ~
    #| fig-cap: | 
    #|   Una representación visual de la combinación correcta donde cada 
    #|   fila de `y` aparece en la salida. 
    #| fig-alt: |
    #|   En comparación con el diagrama anterior que muestra una combinación izquierda, 
    #|   la tabla x ahora gana una fila virtual para que cada fila en y tenga 
    #|   una coincidencia en x. val x contiene NAN para la fila en y que no 
    #|   coincide con x.

    knitr::include_graphics("diagrams/join/right.png", dpi = 270)
    ```

-   Una **combinación completa** mantiene todas las observaciones que aparecen en `x` o `y`, @fig-join-full.
    Cada fila de `x` e `y` se incluye en la salida porque tanto `x` como `y` tienen una fila de reserva de `NA`.
    Una vez más, la salida comienza con todas las filas desde `x`, seguidas de las filas restantes `y` no coincidentes.

    ```{r}
    #| label: fig-join-full
    #| echo: false
    #| out-width: ~
    #| fig-cap: | 
    #|   Una representación visual de la combinación completa donde cada 
    #|   fila en `x` e `y` aparece en la salida.
    #| fig-alt: |
    #|   Ahora tanto x como y tienen una fila virtual que siempre coincide. El 
    #|   resultado tiene 4 filas: llaves 1, 2, 3 y 4 con todos los valores de 
    #|   val_x y val_y, sin embargo, la llave 2, val_y y la llave 4, val_x son NA 
    #|   ya que esas llaves no coinciden con los otros marcos de datos.

    knitr::include_graphics("diagrams/join/full.png", dpi = 270)
    ```

Otra forma de mostrar cómo difieren los tipos de unión externa es con un diagrama de Venn, como en @fig-join-venn.
Sin embargo, esta no es una gran representación porque, si bien puede refrescar su memoria sobre qué filas se conservan, no ilustra lo que sucede con las columnas.

```{r}
#| label: fig-join-venn
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Diagramas de Venn que muestran la diferencia entre uniones internas, izquierdas, 
#|   derechas y completas.
#| fig-alt: |
#|   Diagramas de Venn para uniones internas, completas, izquierdas y derechas. Cada 
#|   unión representada con dos círculos que se cruzan que representan marcos de datos 
#|   x e y, con x a la derecha e y a la izquierda. El sombreado indica el resultado 
#|   de la unión. 
#|
#|   Unión interna: la intersección está sombreada. 
#|   Unión completa: todo está sombreado. 
#|   Unión izquierda: todo x está sombreado.
#|   Unión derecha: Todo y está sombreado.

knitr::include_graphics("diagrams/join/venn.png", dpi = 270)
```

Las uniones que se muestran aquí son las denominadas **equi** **uniones**, donde las filas coinciden si las claves son iguales.
Las uniones equitativas son el tipo de unión más común, por lo que normalmente omitiremos el prefijo equi y solo diremos "unión interna" en lugar de "unión interna equi".
Volveremos a las uniones no equitativas en @sec-non-equi-joins.

### Coincidencia de filas

Hasta ahora hemos explorado lo que sucede si una fila en `x` coincide con cero o una fila en `y`.
¿Qué sucede si coincide con más de una fila?
Para comprender lo que sucede, primero limitemos nuestro enfoque a `inner_join()` y luego dibujemos una imagen, @fig-join-match-types.

```{r}
#| label: fig-join-match-types
#| echo: false
#| out-width: ~
#| fig-cap: | 
#|   Las tres formas en que una fila en `x` puede coincidir. `x1` coincide con una
#|    fila en `y`, `x2` coincide con dos filas en `y`, `x3` coincide con cero 
#|    filas en y. Tenga en cuenta que si bien hay tres filas en `x` y tres filas 
#|    en la salida, no hay una correspondencia directa entre las filas.
#| fig-alt: |
#|   Un diagrama de combinación donde x tiene valores clave 1, 2 y 3, e y tiene 
#|   valores clave 1, 2, 2. La salida tiene tres filas porque la clave 1 
#|   coincide con una fila, la clave 2 coincide con dos filas y la clave 
#|   3 coincide con cero filas.

knitr::include_graphics("diagrams/join/match-types.png", dpi = 270)
```

Hay tres resultados posibles para una fila en `x`:

-   Si no coincide con nada, se descarta.
-   Si coincide con 1 fila en `y`, se conserva.
-   Si coincide con más de 1 fila en `y`, se duplica una vez para cada coincidencia.

En principio, esto significa que no hay una correspondencia garantizada entre las filas de la salida y las filas de `x`, pero en la práctica, esto rara vez causa problemas.
Hay, sin embargo, un caso particularmente peligroso que puede provocar una explosión combinatoria de filas.
Imagina unir las siguientes dos tablas:

```{r}
df1 <- tibble(key = c(1, 2, 2), val_x = c("x1", "x2", "x3"))
df2 <- tibble(key = c(1, 2, 2), val_y = c("y1", "y2", "y3"))
```

Mientras que la primera fila en `df1` solo coincide con una fila en `df2`, la segunda y la tercera fila coinciden con dos filas.
Esto a veces se denomina unión `de muchos a muchos` y hará que dplyr emita una advertencia:

```{r}
df1 |> 
  inner_join(df2, join_by(key))
```

Si está haciendo esto deliberadamente, puede configurar `relationship = "many-to-many"`, como sugiere la advertencia.

### Filtrado de uniones

El número de coincidencias también determina el comportamiento de las uniones de filtrado.
El semi-join mantiene filas en `x` que tienen una o más coincidencias en `y`, como en @fig-join-semi.
El anti-join mantiene filas en `x` que coinciden con cero filas en `y`, como en @fig-join-anti.
En ambos casos, solo es importante la existencia de una coincidencia; no importa cuantas veces coincida.
Esto significa que las uniones de filtrado nunca duplican filas como lo hacen las uniones mutantes.

```{r}
#| label: fig-join-semi
#| echo: false
#| out-width: null
#| fig-cap: |
#|   En un semi-join solo importa que haya coincidencia; de lo contrario, 
#|   los valores en `y` no afectan la salida.
#| fig-alt: |
#|   Un diagrama de unión con viejos amigos x e y. En una combinación semi, 
#|   solo importa la presencia de una coincidencia, por lo que la salida 
#|   contiene las mismas columnas que x.

knitr::include_graphics("diagrams/join/semi.png", dpi = 270)
```

```{r}
#| label: fig-join-anti
#| echo: false
#| out-width: null
#| fig-cap: |
#|   Un anti-join es lo contrario de un semi-join, eliminando filas de `x` 
#|   que tienen una coincidencia en `y`.
#| fig-alt: |
#|   Un anti-join es lo contrario de un semi-join, por lo que las coincidencias 
#|   se dibujan con líneas rojas que indican que se eliminarán de la salida.

knitr::include_graphics("diagrams/join/anti.png", dpi = 270)
```

## Non-equi joins {#sec-non-equi-joins}

Hasta ahora solo has visto uniones de igualdad, uniones donde las filas coinciden si la tecla `x` es igual a la tecla `y`.
Ahora relajaremos esa restricción y analizaremos otras formas de determinar si un par de filas coinciden.

Pero antes de que podamos hacer eso, debemos revisar una simplificación que hicimos anteriormente.
En equi-joins, las teclas `x` e `y` son siempre iguales, por lo que solo necesitamos mostrar una en la salida.
Podemos solicitar que dplyr mantenga ambas claves con `keep = TRUE`, lo que lleva al siguiente código y `inner_join()` redibujado en @fig-inner-both.

```{r}
x |> left_join(y, by = "key", keep = TRUE)
```

```{r}
#| label: fig-inner-both
#| fig-cap: |
#|   Una combinación interna que muestra `x` e `y` en la salida.
#| fig-alt: |
#|   Un diagrama de unión que muestra una unión interna entre x e y. El 
#|   resultado ahora incluye cuatro columnas: key.x, val_x, key.y y val_y. 
#|   Los valores de key.x y key.y son idénticos, por lo que generalmente 
#|   solo mostramos uno.
#| echo: false
#| out-width: ~

knitr::include_graphics("diagrams/join/inner-both.png", dpi = 270)
```

Cuando nos alejamos de las combinaciones de igualdad, siempre mostraremos las claves, porque los valores de las claves a menudo serán diferentes.
Por ejemplo, en lugar de hacer coincidir solo cuando la `x$key` y la `y$key` son iguales, podríamos hacer coincidir siempre que la `x$key` sea mayor o igual que la `y$key`, lo que lleva a @fig-join-gte.
Las funciones de combinación de dplyr entienden esta distinción entre combinaciones equi y no equi, por lo que siempre mostrará ambas teclas cuando realice una combinación no equi.

```{r}
#| label: fig-join-gte
#| echo: false
#| fig-cap: |
#|   Una combinación no equitativa en la que la tecla `x` debe ser mayor o igual 
#|   que la tecla `y`. Muchas filas generan múltiples coincidencias.
#| fig-alt: |
#|   Un diagrama de unión que ilustra join_by(key >= key). La primera fila 
#|   de x coincide con una fila de y y la segunda y la tercera fila coinciden 
#|   con dos filas. Esto significa que la salida tiene cinco filas que contienen 
#|   cada uno de los siguientes pares (key.x, key.y): (1, 1), (2, 1), (2, 2), 
#|   (3, 1), (3, 2).

knitr::include_graphics("diagrams/join/gte.png", dpi = 270)
```

Unión no equitativa no es un término particularmente útil porque solo le dice qué no es la unión, no qué es.
dplyr ayuda identificando cuatro tipos particularmente útiles de unión no equitativa:

-   **Uniones cruzadas** coinciden con cada par de filas.
-   **Uniones de desigualdad** use `<`, `<=`, `>` y `>=` en lugar de `==`.
-   **Las uniones continuas** son similares a las uniones de desigualdad, pero solo encuentran la coincidencia más cercana.
-   **Las uniones superpuestas** son un tipo especial de unión de desigualdades diseñadas para trabajar con rangos.

Cada uno de estos se describe con más detalle en las siguientes secciones.

### Uniones cruzadas

Una unión cruzada coincide con todo, como en @fig-join-cross, generando el producto cartesiano de filas.
Esto significa que la salida tendrá filas `nrow(x) * nrow(y)`.

```{r}
#| label: fig-join-cross
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Una combinación cruzada hace coincidir cada fila en `x` con cada fila en `y`.
#| fig-alt: |
#|   Un diagrama de unión que muestra un punto para cada combinación de x e y.

knitr::include_graphics("diagrams/join/cross.png", dpi = 270)
```

Las uniones cruzadas son útiles cuando se generan permutaciones.
Por ejemplo, el siguiente código genera todos los pares de nombres posibles.
Dado que estamos uniendo `df` a sí mismo, esto a veces se denomina **autounión**.
Las uniones cruzadas usan una función de unión diferente porque no hay distinción entre inner/left/right/full cuando estás haciendo coincidir cada fila.

```{r}
df <- tibble(name = c("John", "Simon", "Tracy", "Max"))
df |> cross_join(df)
```

### Uniones de desigualdad

Las uniones de desigualdad usan `<`, `<=`, `>=` o `>` para restringir el conjunto de posibles coincidencias, como en @fig-join-gte y @fig-join-lt.

```{r}
#| label: fig-join-lt
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Una unión de desigualdad donde 'x' se une a 'y' en filas donde la clave 
#|   de 'x' es menor que la clave de 'y'. Esto crea una forma triangular en 
#|   la esquina superior izquierda.
#|   fig-alt: |
#|   Un diagrama que representa una unión de desigualdad donde un marco de datos x 
#|   se une a un marco de datos y donde la clave de x es menor que la clave de y, 
#|   lo que da como resultado una forma triangular en la esquina superior izquierda.

knitr::include_graphics("diagrams/join/lt.png", dpi = 270)
```

Las uniones de desigualdad son extremadamente generales, tan generales que es difícil encontrar casos de uso específicos significativos.
Una pequeña técnica útil es usarlos para restringir la unión cruzada de modo que, en lugar de generar todas las permutaciones, generemos todas las combinaciones:

```{r}
df <- tibble(id = 1:4, name = c("John", "Simon", "Tracy", "Max"))

df |> left_join(df, join_by(id < id))
```

### Uniones rodantes

Las combinaciones rotativas son un tipo especial de combinación de desigualdad donde en lugar de obtener *todas* las filas que satisfacen la desigualdad, obtienes solo la fila más cercana, como en @fig-join-closest.
Puede convertir cualquier combinación de desigualdad en una combinación continua agregando `closest()`.
Por ejemplo, `join_by(closest(x <= y))` coincide con la `y` más pequeña que es mayor o igual que x, y `join_by(closest(x > y))` coincide con la `y` más grande que es menor que `x`.

```{r}
#| label: fig-join-closest
#| echo: false
#| out-width: ~
#| fig-cap: |
#|   Una unión continua es similar a una unión de desigualdad mayor 
#|   o igual, pero solo coincide con el primer valor.
#| fig-alt: |
#|   Una unión continua es un subconjunto de una unión de desigualdad, por lo 
#|   que algunas coincidencias están atenuadas, lo que indica que no se usan 
#|   porque no son las "más cercanas".

knitr::include_graphics("diagrams/join/closest.png", dpi = 270)
```

Las uniones rotativas son particularmente útiles cuando tiene dos tablas de fechas que no se alinean perfectamente y desea encontrar (por ejemplo) la fecha más cercana en la tabla 1 que viene antes (o después) de alguna fecha en la tabla 2.

Por ejemplo, imagina que estás a cargo de la comisión de planificación de fiestas de tu oficina.
Su empresa es bastante barata, por lo que en lugar de tener fiestas individuales, solo tiene una fiesta una vez cada trimestre.
Las reglas para determinar cuándo se realizará una fiesta son un poco complejas: las fiestas siempre son los lunes, te saltas la primera semana de enero porque mucha gente está de vacaciones y el primer lunes del tercer trimestre de 2022 es el 4 de julio, por lo que eso tiene que ser retrasado una semana.
Eso lleva a los siguientes días de fiesta:

```{r}
parties <- tibble(
  q = 1:4,
  party = ymd(c("2022-01-10", "2022-04-04", "2022-07-11", "2022-10-03"))
)
```

Ahora imagina que tienes una tabla de cumpleaños de los empleados:

```{r}
employees <- tibble(
  name = sample(babynames::babynames$name, 100),
  birthday = ymd("2022-01-01") + (sample(365, 100, replace = TRUE) - 1)
)
employees
```

Y para cada empleado queremos encontrar la fecha de la primera fiesta que viene después (o en) su cumpleaños.
Podemos expresar eso con una unión rodante:

```{r}
employees |> 
  left_join(parties, join_by(closest(birthday >= party)))
```

Sin embargo, hay un problema con este enfoque: las personas que cumplen años antes del 10 de enero no organizan una fiesta:

```{r}
employees |> 
  anti_join(parties, join_by(closest(birthday >= party)))
```

Para resolver ese problema, necesitaremos abordar el problema de una manera diferente, con uniones superpuestas.

### Uniones superpuestas

Las uniones superpuestas proporcionan tres ayudantes que usan uniones de desigualdad para facilitar el trabajo con intervalos:

-   `between(x, y_lower, y_upper)` es abreviatura para `x >= y_lower, x <= y_upper`.
-   `within(x_lower, x_upper, y_lower, y_upper)` es abreviatura para `x_lower >= y_lower, x_upper <= y_upper`.
-   `overlaps(x_lower, x_upper, y_lower, y_upper)` es abreviatura para `x_lower <= y_upper, x_upper >= y_lower`.

Sigamos con el ejemplo del cumpleaños para ver cómo podría usarlos.
Hay un problema con la estrategia que usamos anteriormente: no hay fiesta antes de los cumpleaños del 1 al 9 de enero.
Por lo tanto, sería mejor ser explícito sobre los rangos de fechas que abarca cada fiesta y hacer un caso especial para esos cumpleaños anticipados:

```{r}
parties <- tibble(
  q = 1:4,
  party = ymd(c("2022-01-10", "2022-04-04", "2022-07-11", "2022-10-03")),
  start = ymd(c("2022-01-01", "2022-04-04", "2022-07-11", "2022-10-03")),
  end = ymd(c("2022-04-03", "2022-07-11", "2022-10-02", "2022-12-31"))
)
parties
```

Hadley es terriblemente malo ingresando datos, por lo que también quería verificar que los períodos de las fiestas no se superpusieran.
Una forma de hacer esto es usar una autounión para verificar si algún intervalo de inicio-fin se superpone con otro:

```{r}
parties |> 
  inner_join(parties, join_by(overlaps(start, end, start, end), q < q)) |> 
  select(start.x, end.x, start.y, end.y)
```

Vaya, hay una superposición, así que solucionemos ese problema y continuemos:

```{r}
parties <- tibble(
  q = 1:4,
  party = ymd(c("2022-01-10", "2022-04-04", "2022-07-11", "2022-10-03")),
  start = ymd(c("2022-01-01", "2022-04-04", "2022-07-11", "2022-10-03")),
  end = ymd(c("2022-04-03", "2022-07-10", "2022-10-02", "2022-12-31"))
)
```

Ahora podemos emparejar a cada empleado con su partido.
Este es un buen lugar para usar `unmatched = "error"` porque queremos averiguar rápidamente si a algún empleado no se le asignó una fiesta.

```{r}
employees |> 
  inner_join(parties, join_by(between(birthday, start, end)), unmatched = "error")
```

### Ejercicios

1.  ¿Puedes explicar qué está pasando con las claves en esta unión equitativa?
    ¿Por qué son diferentes?

    ```{r}
    x |> full_join(y, by = "key")

    x |> full_join(y, by = "key", keep = TRUE)
    ```

2.  Al encontrar si algún período de fiesta se superponía con otro período de fiesta, usamos `q < q` en `join_by ()` ¿Por qué?
    ¿Qué pasa si eliminas esta desigualdad?

## Resumen

En este capítulo, aprendió a usar combinaciones de mutación y filtrado para combinar datos de un par de marcos de datos.
En el camino, aprendió cómo identificar claves y la diferencia entre claves primarias y externas.
También comprende cómo funcionan las uniones y cómo averiguar cuántas filas tendrá la salida.
Finalmente, ha logrado vislumbrar el poder de las uniones no equitativas y ha visto algunos casos de uso interesantes.

Este capítulo concluye la parte "Transformar" del libro, donde la atención se centró en las herramientas que podría usar con columnas y tibbles individuales.
Aprendió sobre las funciones dplyr y base para trabajar con vectores lógicos, números y tablas completas, funciones stringr para trabajar con cadenas, funciones lubridate para trabajar con fechas y horas y funciones forcats para trabajar con factores.

En la siguiente parte del libro, aprenderá más sobre cómo obtener varios tipos de datos en R de forma ordenada.

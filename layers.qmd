# Capas {#sec-layers}

```{r}
#| results: "asis"
#| echo: false
source("_common.R")
status("complete")
```

## Introducción

En @sec-data-visualization, aprendió mucho más que solo cómo hacer diagramas de dispersión, gráficos de barras y diagramas de caja.
Aprendiste una base que puedes usar para hacer *cualquier* tipo de gráfico con ggplot2.

En este capítulo, ampliará esa base a medida que aprenda sobre la gramática en capas de los gráficos.
Comenzaremos con una inmersión más profunda en mapeos estéticos, objetos geométricos y facetas.
Luego, aprenderá sobre las transformaciones estadísticas que ggplot2 hace bajo el capó al crear un gráfico.
Estas transformaciones se utilizan para calcular nuevos valores para graficar, como las alturas de las barras en un diagrama de barras o las medianas en un diagrama de caja.
También aprenderá sobre los ajustes de posición, que modifican cómo se muestran los geoms en sus gráficos.
Finalmente, presentaremos brevemente los sistemas de coordenadas.

No cubriremos todas las funciones y opciones para cada una de estas capas, pero lo guiaremos a través de la funcionalidad más importante y de uso común proporcionada por ggplot2 y le presentaremos los paquetes que amplían ggplot2.

### Requisitos previos

Este capítulo se centra en ggplot2, uno de los paquetes principales de tidyverse.
Para acceder a los conjuntos de datos, las páginas de ayuda y las funciones utilizadas en este capítulo, cargue tidyverse ejecutando este código:

```{r}
#| label: setup
#| message: false

library(tidyverse)
```

## Asignaciones de aesthetic

> "El mayor valor de una imagen es cuando nos obliga a notar lo que nunca esperábamos ver." --- John Tukey

El data frame `mpg` que se incluye con el paquete ggplot2 contiene `r nrow(mpg)` observaciones recopiladas por la Agencia de Protección Ambiental de los EU.

```{r}
mpg
```

Entre las variables en `mpg` están:

1.  `displ`: Tamaño del motor de un automóvil, en litros.
    Una variable numérica.

2.  `hwy`: La eficiencia de combustible de un automóvil en la carretera, en millas por galón (mpg).
    Un automóvil con una eficiencia de combustible baja consume más combustible que un automóvil con una eficiencia de combustible alta cuando recorren la misma distancia.
    Una variable numérica.

3.  `class`: Tipo de coche.
    Una variable categórica.

Puede obtener información sobre `mpg` en su página de ayuda ejecutando `?mpg`.

Comencemos visualizando la relación entre `displ` y `hwy` para varias `clases` de autos.
Podemos hacer esto con un diagrama de dispersión donde las variables numéricas se asignan a la estética `x` e `y` y la variable categórica se asigna a una estética como `color` o `shape`.

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-height: 2
#| fig-alt: >
#|   Dos diagramas de dispersión uno al lado del otro, ambos visualizando la eficiencia de combustible
#|   en carretera versus el tamaño del motor de los automóviles y mostrando una asociación  
#|   negativa. En el gráfico de la izquierda, la variable clase (class) se asigna a la aesthetic
#|   color, dando como resultado diferentes colores para cada clase. 
#|   En la gráfica de la derecha la variable clase (class) se asigna a la aesthetic shape,
#|   dando como resultado diferentes formas de caracteres de trazado para cada clase,
#|   excepto todoterreno. Cada gráfico viene con una leyenda que muestra el
#|   mapeo entre color o shape y los niveles de la variable clase (class).

# Left
ggplot(mpg, aes(x = displ, y = hwy, color = class)) +
  geom_point()

# Right
ggplot(mpg, aes(x = displ, y = hwy, shape = class)) +
  geom_point()
```

Cuando `class` se asigna a `shape`, recibimos dos advertencias:

> 1: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; you have 7.
> Consider specifying shapes manually if you must have them.
>
> 2: Removed 62 rows containing missing values (`geom_point()`).

Dado que ggplot2 solo usará seis formas a la vez, de manera predeterminada, los grupos adicionales no se trazarán cuando use la aesthetic shape.
La segunda advertencia está relacionada: hay 62 SUV (todoterrenos) en el conjunto de datos y no están representados.

Del mismo modo, también podemos mapear la esthetic `class` a `size` o `alpha` (transparencia).

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-height: 2
#| fig-alt: >
#|   Dos diagramas de dispersión uno al lado del otro, ambos visualizando la eficiencia de combustible
#|   en carretera versus el tamaño del motor de los automóviles y mostrando una asociación  
#|   negativa. En el gráfico de la izquierda, la clase (class) se asigna a la aesthetic
#|   size, dando como resultado diferentes tamaños para cada clase. 
#|   En la gráfica de la derecha clase (class) se asigna a la aesthetic alpha,
#|   resultando en diferentes niveles alpha (transparencia) para cada clase. 
#|   Cada gráfica viene con una leyenda que muestra el mapeo entre el tamaño
#|   o nivel alfa y niveles de la variable de clase (class).

# Left
ggplot(mpg, aes(x = displ, y = hwy, size = class)) +
  geom_point()

# Right
ggplot(mpg, aes(x = displ, y = hwy, alpha = class)) +
  geom_point()
```

Ambos producen advertencias también:

> Using alpha for a discrete variable is not advised.

Asignar una variable discreta (categórica) no ordinal (`class`) a una aesthetic ordenada (`size` o `alpha`) generalmente no es una buena idea porque implica una clasificación que de hecho no existe.

De manera similar, podríamos haber asignado `class` a la aesthetic `alpha`, que controla la transparencia de los puntos, o a la aesthetic `shape`, que controla la forma de los puntos.

Una vez que mapeas una aesthetic, ggplot2 se encarga del resto.
Selecciona una escala razonable para usar con la aesthetic y construye una leyenda que explica el mapeo entre niveles y valores.
Para las aesthetics x e y, ggplot2 no crea una leyenda, pero crea una línea de eje con marcas y una etiqueta.
La línea del eje actúa como una leyenda; explica el mapeo entre ubicaciones y valores.

También puede establecer las propiedades estéticas de su geom manualmente.
Por ejemplo, podemos hacer que todos los puntos de nuestro gráfico sean azules:

```{r}
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles
#|   que muestra una asociación negativa. Todos los puntos son azules.

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(color = "blue")
```

Aquí, el color no transmite información sobre una variable, sino que solo cambia la apariencia de la gráfica.
Puede establecer una estética manualmente por nombre como argumento de su función geom.
En otras palabras, va *fuera* de `aes()`.
Deberá elegir un valor que tenga sentido para esa estética:

-   El nombre de un color como una cadena de caracteres.
-   El tamaño de un punto en mm.
-   La forma de un punto como un número, como se muestra en @fig-shapes.

```{r}
#| label: fig-shapes
#| echo: false
#| warning: false
#| fig.asp: 0.364
#| fig-align: "center"
#| fig-cap: >
#|   R tiene 25 formas integradas que se identifican con números. Hay algunos
#|   duplicados aparentes: por ejemplo, 0, 15 y 22 son todos cuadrados. La
#|   diferencia proviene de la interacción de las asthetics `color` y 
#|   `fill`. Las formas huecas (0--14) tienen un borde determinado por `color`;
#|   las formas sólidas (15--20) se rellenan con `color`; las formas rellenas
#|   (21--24) tienen un borde de `color` y se rellenan con `fill`.
#| fig-alt: >
#|   Mapeo entre formas y los números que las representan: 0 - cuadrado,
#|   1 - círculo, 2 - triángulo apuntando hacia arriba, 3 - más, 4 - cruz, 5 - rombo,
#|   6 - triángulo apuntando hacia abajo, 7 - cruz cuadrada, 8 - estrella, 9 - diamante más,
#|   10 - círculo más, 11 - triángulos arriba y abajo, 12 - cuadrado más,
#|   13 - cruz circular, 14 - cuadrado y triángulo hacia abajo, 15 - cuadrado relleno,
#|   16 - círculo relleno, 17 - triángulo relleno apuntando hacia arriba, 18 - diamante relleno,
#|   19 - círculo sólido, 20 - viñeta (círculo más pequeño), 21 - círculo relleno azul,
#|   22 - azul cuadrado relleno, 23 - azul diamante relleno, 24 - triángulo relleno
#|   apuntando hacia arriba azul, 25 - triángulo relleno apuntando hacia abajo azul.

shapes <- tibble(
  shape = c(0, 1, 2, 5, 3, 4, 6:19, 22, 21, 24, 23, 20),
  x = (0:24 %/% 5) / 2,
  y = (-(0:24 %% 5)) / 4
)
ggplot(shapes, aes(x, y)) + 
  geom_point(aes(shape = shape), size = 5, fill = "red") +
  geom_text(aes(label = shape), hjust = 0, nudge_x = 0.15) +
  scale_shape_identity() +
  expand_limits(x = 4.1) +
  scale_x_continuous(NULL, breaks = NULL) + 
  scale_y_continuous(NULL, breaks = NULL, limits = c(-1.2, 0.2)) + 
  theme_minimal() +
  theme(aspect.ratio = 1/2.75)
```

Hasta ahora hemos discutido la estética que podemos mapear o establecer en un diagrama de dispersión, cuando usamos un geom_point.
Puede obtener más información sobre todas las asignaciones estéticas posibles en la viñeta de especificaciones estéticas en <https://ggplot2.tidyverse.org/articles/ggplot2-specs.html>.

La estética específica que puede usar para una gráfica depende de la geom que use para representar los datos.
En la siguiente sección profundizaremos en las geomas.

### Ejercicios

1.  Cree un diagrama de dispersión de `hwy` vs. `displ` donde los puntos son triángulos rellenos de rosa.

2.  ¿Por qué el siguiente código no dio como resultado un gráfico con puntos azules?

    ```{r}
    #| fig-alt: >
    #|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles
    #|   que muestra una asociación negativa. Todos los puntos son rojos y
    #|   la leyenda muestra un punto rojo que se asigna a la palabra azul.

    ggplot(mpg) + 
      geom_point(aes(x = displ, y = hwy, color = "blue"))
    ```

3.  ¿Qué hace la estética `stroke`?
    ¿Con qué formas trabaja?
    (Pista: usa `?geom_point`)

4.  ¿Qué sucede si asigna una estética a algo que no sea un nombre de variable, como `aes (color = displ < 5)`?
    Tenga en cuenta que también deberá especificar x e y.

## Objetos geométricos {#sec-geometric-objects}

¿En qué se parecen estas dos gráficas?

```{r}
#| echo: false
#| message: false
#| layout-ncol: 2
#| fig-width: 4
#| fig-height: 2
#| fig-alt: >
#|   Hay dos gráficas. El diagrama de la izquierda es un diagrama de dispersión de eficiecia
#|   de combustible en carretera frente al tamaño del motor de los automóviles y el gráfico de la derecha
#|   muestra una curva suave que sigue la trayectoria de la relación
#|   entre estas variables. También se muestra Un intervalo de confianza 
#|   alrededor de la curva suave.

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point()

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_smooth()
```

Ambas gráficas contienen la misma variable x, la misma variable y, y ambas describen los mismos datos.
Pero las tramas no son idénticas.
Cada gráfico utiliza un objeto geométrico diferente, geom, para representar los datos.
La gráfica de la izquierda usa geom_point, y la gráfica de la derecha usa geom_smooth, una línea suave ajustada a los datos.

Para cambiar la geom en su gráfico, cambie la función geom que agrega a `ggplot()`.
Por ejemplo, para hacer los diagramas de arriba, puedes usar este código:

```{r}
#| eval: false

# Left
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point()

# Right
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_smooth()
```

Cada función geom en ggplot2 toma un argumento `mapping`.
Sin embargo, no todas las estéticas funcionan con todas las geom.
Puede establecer la forma de un punto, pero no puede establecer la "forma" de una línea.
Si lo intenta, ggplot2 ignorará silenciosamente ese mapeo estético.
Por otro lado, *podría* establecer el tipo de línea de una línea.
`geom_smooth()` dibujará una línea diferente, con un tipo de línea diferente, para cada valor único de la variable que asignas al tipo de línea.

```{r}
#| message: false
#| fig-alt: >
#|   Dos gráficas de eficiencia de combustible en carretera frente al tamaño del motor de los automóviles.
#|   Los datos se representan con curvas suaves. A la izquierda, tres
#|   curvas suaves, todas con el mismo tipo de línea. A la derecha, tres
#|   curvas suaves con diferentes tipos de líneas (continuas, discontinuas o largas
#|   discontinua) para cada tipo de tren de transmisión. En ambas gráficas, también se
#|   los intervalos de confianza alrededor de las curvas suaves.

ggplot(mpg, aes(x = displ, y = hwy, shape = drv)) + 
  geom_smooth()
ggplot(mpg, aes(x = displ, y = hwy, linetype = drv)) + 
  geom_smooth()
```

Aquí, `geom_smooth()` separa los autos en tres líneas según su valor `drv`, que describe el tren de transmisión de un auto.
Una línea describe todos los puntos que tienen un valor `4`, una línea describe todos los puntos que tienen un valor `f` y una línea describe todos los puntos que tienen un valor `r`.
Aquí, `4` significa tracción en las cuatro ruedas, `f` para tracción delantera y `r` para tracción trasera.

Si esto suena extraño, podemos hacerlo más claro superponiendo las líneas sobre los datos sin procesar y luego coloreando todo de acuerdo con `drv`.

```{r}
#| echo: false
#| message: false
#| fig-alt: >
#|   Un gráfico de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles. Los datos
#|   se representan con puntos (coloreados por el tren de transmisión), así como con curvas
#|   suaves (donde el tipo de línea también se determina en función del tren de transmisión).
#|   También se muestran los intervalos de confianza alrededor de las curvas suaves.

ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + 
  geom_point() +
  geom_smooth(aes(linetype = drv))
```

Observe que este gráfico contiene dos geomas en el mismo gráfico.

Muchos geoms, como `geom_smooth()`, utilizan un único objeto geométrico para mostrar varias filas de datos.
Para estos geoms, puede establecer la estética `group` en una variable categórica para dibujar múltiples objetos.
ggplot2 dibujará un objeto separado para cada valor único de la variable de agrupación.
En la práctica, ggplot2 agrupará automáticamente los datos de estos geoms siempre que asigne una estética a una variable discreta (como en el ejemplo de `linetype`).
Es conveniente confiar en esta característica porque la estética `group` por sí misma no agrega una leyenda o características distintivas a las geomas.

```{r}
#| layout-ncol: 3
#| fig-width: 3
#| fig-height: 3
#| message: false
#| fig-alt: >
#|   Tres gráficas, cada una con eficiencia de combustible en carretera en el eje y y el tamaño
#|   del motor de los automóviles, donde los datos se representan mediante una curva suave. La primera gráfica 
#|   solo tiene estas dos variables, la gráfica central tiene tres
#|   curvas para cada nivel de tren de transmisión, y la gráfica de la derecha no solo tiene las
#|   mismas tres curvas suaves separadas para cada nivel del tren de transmisión, también
#|   se trazan las curvas en diferentes colores, sin una leyenda que explique qué
#|   color se asigna a qué nivel. También se muestran los intervalos de confianza alrededor de 
#|   las curvas suaves.

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth()
              
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth(aes(group = drv))
    
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth(aes(color = drv), show.legend = FALSE)
```

Si coloca asignaciones en una función geom, ggplot2 las tratará como asignaciones locales para la capa.
Utilizará estas asignaciones para extender o sobrescribir las asignaciones globales *solo para esa capa*.
Esto hace posible mostrar diferentes estéticas en diferentes capas.

```{r}
#| message: false
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles, donde
#|   los puntos se colorean según la clase de coche. Una curva suave siguiendo
#|   la trayectoria de la relación entre la eficiencia de combustible en carretera versus
#|   el tamaño del motor de los automóviles se superpone junto con un intervalo de confianza a su alrededor.

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(aes(color = class)) + 
  geom_smooth()
```

Puede usar la misma idea para especificar `datos` diferentes para cada capa.
Aquí, usamos puntos rojos y círculos abiertos para resaltar los autos de dos plazas.
El argumento de datos locales en `geom_smooth()` anula el argumento de datos globales en `ggplot()` solo para esa capa.

```{r}
#| message: false
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles, donde
#|   los puntos se colorean según la clase de coche. Una curva suave siguiendo
#|   la trayectoria de la relación entre la eficiencia de combustible en carretera versus
#|   el tamaño del motor de los automóviles subcompactos se superpone junto con un intervalo de confianza
#|   alrededor.

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_point(
    data = mpg |> filter(class == "2seater"), 
    color = "red"
  ) +
  geom_point(
    data = mpg |> filter(class == "2seater"), 
    shape = "circle open", size = 3, color = "red"
  )
```

(Aprenderá cómo funciona `filter()` en el capítulo sobre transformaciones de datos: por ahora, solo sepa que este comando selecciona solo los autos subcompactos.)

Las geomas son los bloques de construcción fundamentales de ggplot2.
Puede transformar por completo el aspecto de su gráfico cambiando su geom, y diferentes geoms pueden revelar diferentes características de sus datos.
Por ejemplo, el histograma y el diagrama de densidad a continuación revelan que la distribución del kilometraje en carretera es bimodal y sesgada hacia la derecha, mientras que el diagrama de caja revela dos posibles valores atípicos.

```{r}
#| fig-asp: 0.33
#| fig-alt: >
#|   Tres gráficos: histograma, gráfico de densidad y gráfico de caja kilometraje
#|   de carretera.
 
# Left
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(binwidth = 2)

# Middle
ggplot(mpg, aes(x = hwy)) +
  geom_density()

# Right
ggplot(mpg, aes(x = hwy)) +
  geom_boxplot()
```

ggplot2 proporciona más de 40 geoms, pero estos no cubren todos los gráficos posibles que uno podría hacer.
Si necesita un geom diferente, le recomendamos que busque primero en los paquetes de extensión para ver si alguien más ya lo ha implementado (vea <https://exts.ggplot2.tidyverse.org/gallery/> para ver una muestra).
Por ejemplo, el paquete **ggridges** ([https://wilkelab.org/ggridges](https://wilkelab.org/ggridges/){.uri}) es útil para hacer gráficos de líneas de crestas, que pueden ser útiles para visualizar la densidad de una variable numérica para diferentes niveles de una variable categórica.
En la siguiente gráfica, no solo usamos un nuevo geom (`geom_density_ridges()`), sino que también asignamos la misma variable a múltiples estéticas (`drv` a `y`, `fill` y `color`) así como establecer una estética (`alpha = 0.5`) para hacer que las curvas de densidad sean transparentes.

```{r}
#| fig-asp: 0.33
#| fig-alt: 
#|   Curvas de densidad para kilometraje en carretera para automóviles con tracción en 
#|   las ruedas traseras, ruedas delanteras y en las 4 ruedas trazadas por separado. La
#|   distribución es bimodal y aproximadamente simétrica para los automóviles con tracción en 
#|   las ruedas traseras y en las 4 ruedas, y unimodales y sesgadas a la derecha para los
#|   coches con tracción en las ruedas delanteras.

library(ggridges)

ggplot(mpg, aes(x = hwy, y = drv, fill = drv, color = drv)) +
  geom_density_ridges(alpha = 0.5, show.legend = FALSE)
```

El mejor lugar para obtener una descripción completa de todos los geoms que ofrece ggplot2, así como de todas las funciones del paquete, es la página de referencia: <https://ggplot2.tidyverse.org/reference>.
Para obtener más información sobre cualquier geom individual, use la ayuda (por ejemplo, `? geom_smooth`).

### Ejercicios

1.  ¿Qué geom usarías para dibujar un gráfico de líneas?
    ¿Un diagrama de caja?
    ¿Un histograma?
    ¿Un gráfico de áreas?

2.  Anteriormente en este capítulo usamos `show.legend` sin explicarlo:

    ```{r}
    #| eval: false
    ggplot(mpg, aes(x = displ, y = hwy)) +
      geom_smooth(aes(color = drv), show.legend = FALSE)
    ```

    ¿Qué hace `show.legend = FALSE` aquí?
    ¿Qué pasa si lo quitas?
    ¿Por qué crees que lo usamos antes?

3.  ¿Qué hace el argumento `se` para `geom_smooth()`?

4.  Vuelva a crear el código R necesario para generar los siguientes gráficos.
    Tenga en cuenta que siempre que se use una variable categórica en el gráfico, es `drv`.

    ```{r}
    #| echo: false
    #| message: false
    #| layout-ncol: 2
    #| fig-width: 4
    #| fig-height: 2
    #| fig-alt: >
    #|   Hay seis diagramas de dispersión en esta figura, dispuestos en una cuadrícula de 3x2.
    #|   En todas las gráficas, la eficiencia de combustible de los automóviles en carretera está en el eje y y
    #|   el tamaño del motor está en el eje x. La primera gráfica muestra todos los puntos en negro
    #|   con una suave curva superpuesta sobre ellos. En la segunda gráfica los puntos son
    #|   también negros, con curvas suaves  superpuestas separadas para cada nivel de
    #|   tren de transmisión. En la tercera gráfica, los puntos y las curvas suaves son
    #|   representados en diferentes colores para cada nivel de tren de transmisión. En la
    #|   cuarta gráfica los puntos están representados en diferentes colores para cada
    #|   nivel del tren de transmisión, pero solo hay una línea suave que esta ajustada a
    #|   todos los datos. En el quinto gráfico, los puntos se representan en diferentes
    #|   colores para cada nivel de tren de transmisión y una curva suave separada por
    #|   diferentes tipos de línea para cada nivel del tren de transmisión. Y
    #|   finalmente en la sexta gráfica los puntos se representan en diferentes colores
    #|   para cada nivel de transmisión y tienen un borde blanco grueso.

    ggplot(mpg, aes(x = displ, y = hwy)) + 
      geom_point() + 
      geom_smooth(se = FALSE)
    ggplot(mpg, aes(x = displ, y = hwy)) + 
      geom_smooth(aes(group = drv), se = FALSE) +
      geom_point()
    ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + 
      geom_point() + 
      geom_smooth(se = FALSE)
    ggplot(mpg, aes(x = displ, y = hwy)) + 
      geom_point(aes(color = drv)) + 
      geom_smooth(se = FALSE)
    ggplot(mpg, aes(x = displ, y = hwy)) + 
      geom_point(aes(color = drv)) +
      geom_smooth(aes(linetype = drv), se = FALSE)
    ggplot(mpg, aes(x = displ, y = hwy)) + 
      geom_point(size = 4, color = "white") + 
      geom_point(aes(color = drv))
    ```

## Facetas

En @sec-data-visualization, aprendió sobre facetas con `facet_wrap()`, que divide una gráfica en sub-gráficas, cada una de las cuales muestra un subconjunto de los datos en función de una variable categórica.

```{r}
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles,
#|   facetado por clase, con facetas que abarcan dos filas.

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_wrap(~cyl)
```

Para facetar su gráfico con la combinación de dos variables, cambie de `facet_wrap()` a `facet_grid()`.
El primer argumento de `facet_grid()` también es una fórmula, pero ahora es una fórmula de doble cara: `rows ~ cols`.

```{r}
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles, facetado
#|   por número de cilindros a través de filas y por tipo de tren de transmisión a través
#|   columnas. Esto da como resultado una cuadrícula de 4x3 de 12 facetas. Algunas de estas facetas no tienen
#|   observaciones: 5 cilindros y tracción en las 4 ruedas, 4 o 5 cilindros y tracción
#|   en las ruedas delanteras.

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_grid(drv ~ cyl)
```

Por defecto, cada una de las facetas comparte la misma escala para los ejes x e y.
Esto es útil cuando desea comparar datos entre facetas, pero puede ser limitante cuando desea visualizar mejor la relación dentro de cada faceta.
Establecer el argumento `scales` en una función de facetado en `"libre"` permitirá diferentes escalas de eje tanto en filas como en columnas.
Otras opciones para este argumento son `"free_x"` (diferentes escalas en las filas) y `"free_y"` (diferentes escalas en las columnas).

```{r}
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles,
#|   facetado por número de cilindros a través de filas y por tipo de tren de transmisión
#|   a través de columnas. Esto da como resultado una cuadrícula de 4x3 de 12 facetas. Algunos de estos
#|   facetas no tienen observaciones: 5 cilindros y 4 ruedas motrices, 4 o 5
#|   cilindros y tracción delantera. Las facetas dentro de una fila comparten el mismo
#|   la escala y y las facetas dentro de una columna comparten la misma escala x.

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_grid(drv ~ cyl, scales = "free")
```

### Ejercicios

1.  ¿Qué sucede si facetas en una variable continua?

2.  ¿Qué significan las celdas vacías en el gráfico con `facet_grid(drv ~ cyl)`?
    ¿Cómo se relacionan con esta gráfica?

    ```{r}
    #| fig-alt: >
    #|   Diagrama de dispersión del número de ciclos frente al tipo de tren de transmisión de los automóviles.
    #|   El gráfico muestra que no hay coches de 5 cilindros que tengan tracción
    #|   en las 4 ruedas o con 4 o 5 cilindros que sean de tracción delantera.

    ggplot(mpg) + 
      geom_point(aes(x = drv, y = cyl))
    ```

3.  ¿Qué gráficas hace el siguiente código?
    ¿Qué hace `.`?

    ```{r}
    #| eval: false

    ggplot(mpg) + 
      geom_point(aes(x = displ, y = hwy)) +
      facet_grid(drv ~ .)

    ggplot(mpg) + 
      geom_point(aes(x = displ, y = hwy)) +
      facet_grid(. ~ cyl)
    ```

4.  Tome la primera gráfica facetada en esta sección:

    ```{r}
    #| eval: false

    ggplot(mpg) + 
      geom_point(aes(x = displ, y = hwy)) + 
      facet_wrap(~ class, nrow = 2)
    ```

¿Cuáles son las ventajas de usar facetas en lugar de la estética del color?
¿Cuales son las desventajas?
¿Cómo podría cambiar el equilibrio si tuviera un conjunto de datos más grande?

5.  Lee `?facet_wrap`.
    ¿Qué hace `nrow`?
    ¿Qué hace `ncol`?
    ¿Qué otras opciones controlan el diseño de los paneles individuales?
    ¿Por qué `facet_grid()` no tiene argumentos `nrow` y `ncol`?

6.  ¿Cuál de las siguientes dos gráficas facilita la comparación del tamaño del motor (`displ`) entre automóviles con diferentes trenes motrices?
    ¿Qué dice esto acerca de cuándo colocar una variable de facetado en filas o columnas?

    ```{r}
    #| fig-alt: >
    #|   Gráficos de dos facetas, ambos visualizando la eficiencia de combustible en carretera versus
    #|   el tamaño del motor de los automóviles, facetado por tren de transmisión. En el gráfico superior, las faceta
    #|   se organizan por filas y en el segundo, por columnas.

    ggplot(mpg) + 
      geom_point(aes(x = displ, y = hwy)) + 
      facet_grid(drv ~ .)

    ggplot(mpg) + 
      geom_point(aes(x = displ, y = hwy)) + 
      facet_grid(. ~ drv)
    ```

7.  Vuelva a crear este diagrama usando `facet_wrap()` en lugar de `facet_grid()`.
    ¿Cómo cambian las posiciones de las etiquetas de las facetas?

    ```{r}
    #| fig-alt: >
    #|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles,
    #|   facetado por tipo de tren de transmisión a través de filas.

    ggplot(mpg) + 
      geom_point(aes(x = displ, y = hwy)) +
      facet_grid(drv ~ .)
    ```

## Transformaciones estadísticas

Considere un gráfico de barras básico, dibujado con `geom_bar()` o `geom_col()`.
El siguiente gráfico muestra el número total de diamantes en el conjunto de datos de `diamonds`, agrupados por corte `curt`.
El conjunto de datos de `diamond` está en el paquete ggplot2 y contiene información sobre \~54 000 diamantes, incluido el precio `price`, el quilate `carat`, el `color`, la claridad `clarity` y el corte `cut` de cada diamante.
El gráfico muestra que hay más diamantes disponibles con cortes de alta calidad que con cortes de baja calidad.

```{r}
#| fig-alt: >
#|   Gráfico de barras de número de cada corte de diamante. Hay aproximadamente 1500
#|   Regulares, 5000 Bueno, 12000 Muy Bueno, 14000 Premium y 22000 diamantes de Corte
#|   Ideal.

ggplot(diamonds, aes(x = cut)) + 
  geom_bar()
```

En el eje x, el gráfico muestra `cut`, una variable de `diamond`.
En el eje y, muestra el conteo, ¡pero el conteo no es una variable en `diamond`!
¿De dónde viene el conteo?
Muchos gráficos, como diagramas de dispersión, trazan los valores sin procesar de su conjunto de datos.
Otros gráficos, como gráficos de barras, calculan nuevos valores para trazar:

-   Los gráficos de barras, los histogramas y los polígonos de frecuencia agrupan sus datos y luego trazan los recuentos de contenedores, la cantidad de puntos que caen en cada contenedor.

-   Los suavizadores ajustan un modelo a sus datos y luego trazan predicciones del modelo.

-   Los diagramas de caja calculan un resumen sólido de la distribución y luego muestran ese resumen como un cuadro con formato especial.

El algoritmo utilizado para calcular nuevos valores para un gráfico se llama **stat**, abreviatura de transformación estadística.
@fig-vis-stat-bar muestra cómo funciona este proceso con `geom_bar()`.

```{r}
#| label: fig-vis-stat-bar
#| echo: false
#| out-width: "100%"
#| fig-cap: >
#|   Cuando creamos un gráfico de barras, primero comenzamos con los datos sin procesar, luego
#|   agregarlo para contar el número de observaciones en cada barra,
#|   y finalmente mapear esas variables calculadas para trazar las aesthetics.
#| fig-alt: >
#|   Una figura que muestra tres pasos para crear un gráfico de barras.
#|   Paso 1. geom_bar() comienza con el conjunto de datos de diamantes. Paso 2. geom_bar()
#|   transforma los datos con la cuenta estadística, que devuelve un conjunto de datos de
#|   valores de corte y conteos. Paso 3. geom_bar() usa los datos transformados para
#|   construir la trama. el corte se asigna al eje x, el conteo se asigna al eje y.

knitr::include_graphics("images/visualization-stat-bar.png")
```

Puede saber qué estadística usa un geom inspeccionando el valor predeterminado para el argumento `stat`.
Por ejemplo, `?geom_bar` muestra que el valor predeterminado para `stat` es "count", lo que significa que `geom_bar()` usa `stat_count()`.
`stat_count()` está documentado en la misma página que `geom_bar()`.
Si se desplaza hacia abajo, la sección llamada "Variables calculadas" explica que calcula dos nuevas variables: `count` y `prop`.

Cada geom tiene una estadística predeterminada; y cada estadística tiene un geom predeterminado.
Esto significa que normalmente puede usar geoms sin preocuparse por la transformación estadística subyacente.
Sin embargo, hay tres razones por las que podría necesitar usar una estadística explícitamente:

1.  Es posible que desee anular la estadística predeterminada.
    En el siguiente código, cambiamos la estadística de `geom_bar()` de contar (el valor predeterminado) a identidad.
    Esto nos permite asignar la altura de las barras a los valores brutos de una variable $y$.

    ```{r}
    #| warning: false
    #| fig-alt: >
    #|   Gráfico de barras de número de cada corte de diamante. Hay aproximadamente 1500
    #|   Regulares, 5000 Bueno, 12000 Muy Bueno, 14000 Premium y 22000 diamantes de
    #|   Corte Ideal.

    cut_frequencies <- tribble(
      ~cut,         ~freq,
      "Fair",       1610,
      "Good",       4906,
      "Very Good",  12082,
      "Premium",    13791,
      "Ideal",      21551
    )

    ggplot(cut_frequencies, aes(x = cut, y = freq)) +
      geom_bar(stat = "identity")
    ```

2.  Es posible que desee anular la asignación predeterminada de variables transformadas a estética.
    Por ejemplo, es posible que desee mostrar un gráfico de barras de proporciones, en lugar de recuentos:

    ```{r}
    #| fig-alt: >
    #|   Gráfico de barras de proporción de cada corte de diamante. Aproximadamente, los
    #|   diamantes Regulares componen 0,03, Bueno 0,09, Muy bueno 0,22, Premium 0,26 y
    #|   Ideal 0,40.

    ggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) + 
      geom_bar()
    ```

    Para encontrar las variables calculadas por la estadística, busque la sección titulada "computed variables" en la ayuda de `geom_bar()`.

3.  Es posible que desee llamar más la atención sobre la transformación estadística en su código.
    Por ejemplo, puede usar `stat_summary()`, que resume los valores de y para cada valor único de x, para llamar la atención sobre el resumen que está calculando:

    ```{r}
    #| fig-alt: >
    #|   Un gráfico con profundidad en el eje y y corte en el eje x (con niveles
    #|   regular, bueno, muy bueno, premium e ideal) de diamantes. para cada nivel
    #|   de corte, las líneas verticales se extienden desde la profundidad mínima hasta la máxima para los diamantes
    #|   en esa categoría de corte, y la profundidad mediana se indica en la línea
    #|   con un punto.

    ggplot(diamonds) + 
      stat_summary(
        aes(x = cut, y = depth),
        fun.min = min,
        fun.max = max,
        fun = median
      )
    ```

ggplot2 proporciona más de 20 estadísticas para su uso.
Cada estadística es una función, por lo que puede obtener ayuda de la forma habitual, p. `?stat_bin`.

### Ejercicios

1.  ¿Cuál es el geom predeterminado asociado con `stat_summary()`?
    ¿Cómo podría reescribir el diagrama anterior para usar esa función geom en lugar de la función stat?

2.  ¿Qué hace `geom_col()`?
    ¿En qué se diferencia de `geom_bar()`?

3.  La mayoría de los geoms y estadísticas vienen en pares que casi siempre se usan en conjunto.
    Lea la documentación y haga una lista de todos los pares.
    ¿Qué tienen en común?

4.  ¿Qué variables calcula `stat_smooth()`?
    ¿Qué argumentos controlan su comportamiento?

5.  En nuestro gráfico de barras de proporciones, debemos establecer `group = 1`.
    ¿Por qué?
    En otras palabras, ¿cuál es el problema con estos dos gráficos?

    ```{r}
    #| eval: false

    ggplot(diamonds, aes(x = cut, y = after_stat(prop))) + 
      geom_bar()
    ggplot(diamonds, aes(x = cut, fill = color, y = after_stat(prop))) + 
      geom_bar()
    ```

## Ajustes de posición

There's one more piece of magic associated with bar charts.
You can color a bar chart using either the `color` aesthetic, or, more usefully, `fill`:

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-height: 2
#| fig-alt: >
#|   Two bar charts of cut of diamonds. In the first plot, the bars have colored 
#|   borders. In the second plot, they're filled with colors. Heights of the 
#|   bars correspond to the number of diamonds in each cut category.

ggplot(diamonds, aes(x = cut, color = cut)) + 
  geom_bar()
ggplot(diamonds, aes(x = cut, fill = cut)) + 
  geom_bar()
```

Note what happens if you map the fill aesthetic to another variable, like `clarity`: the bars are automatically stacked.
Each colored rectangle represents a combination of `cut` and `clarity`.

```{r}
#| fig-alt: >
#|   Segmented bar chart of cut of diamonds, where each bar is filled with 
#|   colors for the levels of clarity. Heights of the bars correspond to the 
#|   number of diamonds in each cut category, and heights of the colored 
#|   segments are proportional to the number of diamonds with a given clarity 
#|   level within a given cut level.

ggplot(diamonds, aes(x = cut, fill = clarity)) + 
  geom_bar()
```

The stacking is performed automatically using the **position adjustment** specified by the `position` argument.
If you don't want a stacked bar chart, you can use one of three other options: `"identity"`, `"dodge"` or `"fill"`.

-   `position = "identity"` will place each object exactly where it falls in the context of the graph.
    This is not very useful for bars, because it overlaps them.
    To see that overlapping we either need to make the bars slightly transparent by setting `alpha` to a small value, or completely transparent by setting `fill = NA`.

    ```{r}
    #| layout-ncol: 2
    #| fig-width: 4
    #| fig-height: 2
    #| fig-alt: >
    #|   Two segmented bar charts of cut of diamonds, where each bar is filled 
    #|   with colors for the levels of clarity. Heights of the bars correspond 
    #|   to the number of diamonds in each cut category, and heights of the 
    #|   colored segments are proportional to the number of diamonds with a 
    #|   given clarity level within a given cut level. However the segments 
    #|   overlap. In the first plot the segments are filled with transparent 
    #|   colors, in the second plot the segments are only outlined with colors.

    ggplot(diamonds, aes(x = cut, fill = clarity)) + 
      geom_bar(alpha = 1/5, position = "identity")
    ggplot(diamonds, aes(x = cut, color = clarity)) + 
      geom_bar(fill = NA, position = "identity")
    ```

    The identity position adjustment is more useful for 2d geoms, like points, where it is the default.

-   `position = "fill"` works like stacking, but makes each set of stacked bars the same height.
    This makes it easier to compare proportions across groups.

    ```{r}
    #| fig-alt: >
    #|   Segmented bar chart of cut of diamonds, where each bar is filled with 
    #|   colors for the levels of clarity. Height of each bar is 1 and heights 
    #|   of the colored segments are proportional to the proportion of diamonds 
    #|   with a given clarity level within a given cut level.

    ggplot(diamonds, aes(x = cut, fill = clarity)) + 
      geom_bar(position = "fill")
    ```

-   `position = "dodge"` places overlapping objects directly *beside* one another.
    This makes it easier to compare individual values.

    ```{r}
    #| fig-alt: >
    #|   Dodged bar chart of cut of diamonds. Dodged bars are grouped by levels 
    #|   of cut (fair, good, very good, premium, and ideal). In each group there 
    #|   are eight bars, one for each level of clarity, and filled with a 
    #|   different color for each level. Heights of these bars represent the 
    #|   number of diamonds with a given level of cut and clarity.

    ggplot(diamonds, aes(x = cut, fill = clarity)) + 
      geom_bar(position = "dodge")
    ```

There's one other type of adjustment that's not useful for bar charts, but can be very useful for scatterplots.
Recall our first scatterplot.
Did you notice that the plot displays only 126 points, even though there are 234 observations in the dataset?

```{r}
#| echo: false
#| fig-alt: >
#|   Scatterplot of highway fuel efficiency versus engine size of cars that 
#|   shows a negative association.

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point()
```

The underlying values of `hwy` and `displ` are rounded so the points appear on a grid and many points overlap each other.
This problem is known as **overplotting**.
This arrangement makes it difficult to see the distribution of the data.
Are the data points spread equally throughout the graph, or is there one special combination of `hwy` and `displ` that contains 109 values?

You can avoid this gridding by setting the position adjustment to "jitter".
`position = "jitter"` adds a small amount of random noise to each point.
This spreads the points out because no two points are likely to receive the same amount of random noise.

```{r}
#| fig-alt: >
#|   Jittered scatterplot of highway fuel efficiency versus engine size of cars. 
#|   The plot shows a negative association.

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(position = "jitter")
```

Adding randomness seems like a strange way to improve your plot, but while it makes your graph less accurate at small scales, it makes your graph *more* revealing at large scales.
Because this is such a useful operation, ggplot2 comes with a shorthand for `geom_point(position = "jitter")`: `geom_jitter()`.

To learn more about a position adjustment, look up the help page associated with each adjustment: `?position_dodge`, `?position_fill`, `?position_identity`, `?position_jitter`, and `?position_stack`.

### Exercises

1.  What is the problem with this plot?
    How could you improve it?

    ```{r}
    #| fig-alt: >
    #|   Scatterplot of highway fuel efficiency versus city fuel efficiency 
    #|   of cars that shows a positive association. The number of points 
    #|   visible in this plot is less than the number of points in the dataset.

    ggplot(mpg, aes(x = cty, y = hwy)) + 
      geom_point()
    ```

2.  What parameters to `geom_jitter()` control the amount of jittering?

3.  Compare and contrast `geom_jitter()` with `geom_count()`.

4.  What's the default position adjustment for `geom_boxplot()`?
    Create a visualization of the `mpg` dataset that demonstrates it.

## Coordinate systems

Coordinate systems are probably the most complicated part of ggplot2.
The default coordinate system is the Cartesian coordinate system where the x and y positions act independently to determine the location of each point.
There are two other coordinate systems that are occasionally helpful.

-   `coord_quickmap()` sets the aspect ratio correctly for maps.
    This is very important if you're plotting spatial data with ggplot2.
    We don't have the space to discuss maps in this book, but you can learn more in the [Maps chapter](https://ggplot2-book.org/maps.html) of *ggplot2: Elegant graphics for data analysis*.

    ```{r}
    #| layout-ncol: 2
    #| fig-width: 4
    #| fig-height: 2
    #| message: false
    #| fig-alt: >
    #|   Two maps of the boundaries of New Zealand. In the first plot the aspect 
    #|   ratio is incorrect, in the second plot it is correct.

    nz <- map_data("nz")

    ggplot(nz, aes(x = long, y = lat, group = group)) +
      geom_polygon(fill = "white", color = "black")

    ggplot(nz, aes(x = long, y = lat, group = group)) +
      geom_polygon(fill = "white", color = "black") +
      coord_quickmap()
    ```

-   `coord_polar()` uses polar coordinates.
    Polar coordinates reveal an interesting connection between a bar chart and a Coxcomb chart.

    ```{r}
    #| layout-ncol: 2
    #| fig-width: 4
    #| fig-asp: 1
    #| fig-alt: >
    #|   There are two plots. On the left is a bar chart of cut of diamonds, 
    #|   on the right is a Coxcomb chart of the same data.

    bar <- ggplot(data = diamonds) + 
      geom_bar(
        mapping = aes(x = cut, fill = cut), 
        show.legend = FALSE,
        width = 1
      ) + 
      theme(aspect.ratio = 1) +
      labs(x = NULL, y = NULL)

    bar + coord_flip()
    bar + coord_polar()
    ```

### Exercises

1.  Turn a stacked bar chart into a pie chart using `coord_polar()`.

2.  What's the difference between `coord_quickmap()` and `coord_map()`?

3.  What does the plot below tell you about the relationship between city and highway mpg?
    Why is `coord_fixed()` important?
    What does `geom_abline()` do?

    ```{r}
    #| fig-alt: >
    #|   Scatterplot of highway fuel efficiency versus engine size of cars that 
    #|   shows a negative association. The plot also has a straight line that 
    #|   follows the trend of the relationship between the variables but does not 
    #|   go through the cloud of points, it is beneath it.

    ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
      geom_point() + 
      geom_abline() +
      coord_fixed()
    ```

## The layered grammar of graphics

We can expand on the graphing template you learned in @sec-graphing-template by adding position adjustments, stats, coordinate systems, and faceting:

    ggplot(data = <DATA>) + 
      <GEOM_FUNCTION>(
         mapping = aes(<MAPPINGS>),
         stat = <STAT>, 
         position = <POSITION>
      ) +
      <COORDINATE_FUNCTION> +
      <FACET_FUNCTION>

Our new template takes seven parameters, the bracketed words that appear in the template.
In practice, you rarely need to supply all seven parameters to make a graph because ggplot2 will provide useful defaults for everything except the data, the mappings, and the geom function.

The seven parameters in the template compose the grammar of graphics, a formal system for building plots.
The grammar of graphics is based on the insight that you can uniquely describe *any* plot as a combination of a dataset, a geom, a set of mappings, a stat, a position adjustment, a coordinate system, and a faceting scheme.

To see how this works, consider how you could build a basic plot from scratch: you could start with a dataset and then transform it into the information that you want to display (with a stat).
Next, you could choose a geometric object to represent each observation in the transformed data.
You could then use the aesthetic properties of the geoms to represent variables in the data.
You would map the values of each variable to the levels of an aesthetic.
You'd then select a coordinate system to place the geoms into, using the location of the objects (which is itself an aesthetic property) to display the values of the x and y variables.

```{r}
#| echo: false
#| fig-alt: >
#|   A figure demonstrating the steps for going from raw data to table of counts 
#|   where each row represents one level of cut and a count column shows how many 
#|   diamonds are in that cut level. 

knitr::include_graphics("images/visualization-grammar.png")
```

At this point, you would have a complete graph, but you could further adjust the positions of the geoms within the coordinate system (a position adjustment) or split the graph into subplots (faceting).
You could also extend the plot by adding one or more additional layers, where each additional layer uses a dataset, a geom, a set of mappings, a stat, and a position adjustment.

You could use this method to build *any* plot that you imagine.
In other words, you can use the code template that you've learned in this chapter to build hundreds of thousands of unique plots.

If you'd like to learn more about the theoretical underpinnings of ggplot2, you might enjoy reading "[The Layered Grammar of Graphics](https://vita.had.co.nz/papers/layered-grammar.pdf)", the scientific paper that describes the theory of ggplot2 in detail.

## Summary

In this chapter you learned about the layered grammar of graphics starting with aesthetics and geometries to build a simple plot, facets for splitting the plot into subsets, statistics for understanding how geoms are calculated, position adjustments for controlling the fine details of position when geoms might otherwise overlap, and coordinate systems allow you fundamentally change what `x` and `y` mean.
One layer we have not yet touched on is theme, which we will introduce in @sec-themes.

Two very useful resources for getting an overview of the complete ggplot2 functionality are the ggplot2 cheatsheet (which you can find at <https://posit.co/resources/cheatsheets> ) and the ggplot2 package website ([https://ggplot2.tidyverse.org](https://ggplot2.tidyverse.org/)).

An important lesson you should take from this chapter is that when you feel the need for a geom that is not provided by ggplot2, it's always a good idea to look into whether someone else has already solved your problem by creating a ggplot2 extension package that offers that geom.

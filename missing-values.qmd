# Valores faltanres {#sec-missing-values}

```{r}
#| results: "asis"
#| echo: false
source("_common.R")
status("complete")
```

## Introducción

Ya aprendiste los conceptos básicos de los valores faltantes anteriormente en el libro.
Los vio por primera vez en @sec-data-visualization, donde resultaron en una advertencia al hacer un gráfico, así como en @sec-summarize, donde interfirieron con el cálculo de estadísticas de resumen, y aprendió sobre su naturaleza infecciosa y cómo verificar su presencia en @sec-na-comparation.
Ahora volveremos a ellos con más profundidad, para que pueda conocer más detalles.

Comenzaremos discutiendo algunas herramientas generales para trabajar con valores faltantes registrados como `NA`s.
Luego, exploraremos la idea de valores que faltan implícitamente, los valores que simplemente están ausentes de sus datos, y mostraremos algunas herramientas que puede usar para hacerlos explícitos.
Terminaremos con una discusión relacionada con los grupos vacíos, causados por niveles de factores que no aparecen en los datos.

### Requisitos previos

Las funciones para trabajar con datos faltantes provienen principalmente de dplyr y tidyr, que son miembros centrales de tidyverse.

```{r}
#| label: setup
#| message: false

library(tidyverse)
```

## Valores perdidos explícitos

Para comenzar, exploremos algunas herramientas útiles para crear o eliminar valores explícitos que faltan, es decir, celdas en las que ve un `NA`.

### Última observación llevada adelante

Un uso común para los valores faltantes es como una comodidad para la entrada de datos.
Cuando los datos se ingresan a mano, los valores que faltan a veces indican que el valor en la fila anterior se ha repetido (o trasladado):

```{r}
treatment <- tribble(
  ~person,           ~treatment, ~response,
  "Derrick Whitmore", 1,         7,
  NA,                 2,         10,
  NA,                 3,         NA,
  "Katherine Burke",  1,         4
)
```

Puede completar estos valores faltantes con `tidyr::fill()`.
Funciona como `select()`, tomando un conjunto de columnas:

```{r}
treatment |>
  fill(everything())
```

Este tratamiento a veces se denomina "última observación realizada", o **locf** (del inglés "last observation carried forward") para abreviar.
Puede usar el argumento `.direction` para completar los valores faltantes que se han generado de formas más exóticas.

### Valores fijos

Algunas veces, los valores faltantes representan algún valor fijo y conocido, más comúnmente 0.
Puedes usar `dplyr::coalesce()` para reemplazarlos:

```{r}
x <- c(1, 4, 5, 7, NA)
coalesce(x, 0)
```

A veces te encontrarás con el problema opuesto en el que algún valor concreto en realidad representa un valor faltante.
Por lo general, esto surge en los datos generados por un software antiguo que no tiene una forma adecuada de representar los valores faltantes, por lo que debe usar algún valor especial como 99 o -999.

Si es posible, maneje esto cuando lea los datos, por ejemplo, usando el argumento `na` para `readr::read_csv()`, p. `read_csv(ruta, na = "99")`.
Si descubre el problema más tarde, o su fuente de datos no proporciona una forma de manejarlo, puede usar `dplyr::na_if()`:

```{r}
x <- c(1, 4, 5, 7, -99)
na_if(x, -99)
```

### NaN

Antes de continuar, hay un tipo especial de valor faltante que encontrará de vez en cuando: un `NaN` (pronunciado "nan"), del inglés **n**ot **a** **n**number.
No es tan importante saberlo porque generalmente se comporta como `NA`:

```{r}
x <- c(NA, NaN)
x * 10
x == 1
is.na(x)
```

En el raro caso de que necesites distinguir un `NA` de un `NaN`, puedes usar `is.nan(x)`.

Por lo general, encontrará un `NaN` cuando realice una operación matemática que tenga un resultado indeterminado:

```{r}
0 / 0 
0 * Inf
Inf - Inf
sqrt(-1)
```

## Valores perdidos implícitos {#sec-missing-implicit}

Hasta ahora hemos hablado de los valores que faltan **explícitamente**, es decir, puede ver un `NA` en sus datos.
Pero los valores faltantes también pueden faltar **implícitamente**, si una fila completa de datos simplemente está ausente de los datos.
Ilustremos la diferencia con un conjunto de datos simple que registra el precio de algunas acciones cada trimestre:

```{r}
stocks <- tibble(
  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),
  qtr   = c(   1,    2,    3,    4,    2,    3,    4),
  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)
```

This dataset has two missing observations:

-   The `price` in the fourth quarter of 2020 is explicitly missing, because its value is `NA`.

-   The `price` for the first quarter of 2021 is implicitly missing, because it simply does not appear in the dataset.

One way to think about the difference is with this Zen-like koan:

> An explicit missing value is the presence of an absence.\
>
> An implicit missing value is the absence of a presence.

Sometimes you want to make implicit missings explicit in order to have something physical to work with.
In other cases, explicit missings are forced upon you by the structure of the data and you want to get rid of them.
The following sections discuss some tools for moving between implicit and explicit missingness.

### Pivoting

You've already seen one tool that can make implicit missings explicit and vice versa: pivoting.
Making data wider can make implicit missing values explicit because every combination of the rows and new columns must have some value.
For example, if we pivot `stocks` to put the `quarter` in the columns, both missing values become explicit:

```{r}
stocks |>
  pivot_wider(
    names_from = qtr, 
    values_from = price
  )
```

By default, making data longer preserves explicit missing values, but if they are structurally missing values that only exist because the data is not tidy, you can drop them (make them implicit) by setting `values_drop_na = TRUE`.
See the examples in @sec-tidy-data for more details.

### Complete

`tidyr::complete()` allows you to generate explicit missing values by providing a set of variables that define the combination of rows that should exist.
For example, we know that all combinations of `year` and `qtr` should exist in the `stocks` data:

```{r}
stocks |>
  complete(year, qtr)
```

Typically, you'll call `complete()` with names of existing variables, filling in the missing combinations.
However, sometimes the individual variables are themselves incomplete, so you can instead provide your own data.
For example, you might know that the `stocks` dataset is supposed to run from 2019 to 2021, so you could explicitly supply those values for `year`:

```{r}
stocks |>
  complete(year = 2019:2021, qtr)
```

If the range of a variable is correct, but not all values are present, you could use `full_seq(x, 1)` to generate all values from `min(x)` to `max(x)` spaced out by 1.

In some cases, the complete set of observations can't be generated by a simple combination of variables.
In that case, you can do manually what `complete()` does for you: create a data frame that contains all the rows that should exist (using whatever combination of techniques you need), then combine it with your original dataset with `dplyr::full_join()`.

### Joins

This brings us to another important way of revealing implicitly missing observations: joins.
You'll learn more about joins in @sec-joins, but we wanted to quickly mention them to you here since you can often only know that values are missing from one dataset when you compare it another.

`dplyr::anti_join(x, y)` is a particularly useful tool here because it selects only the rows in `x` that don't have a match in `y`.
For example, we can use two `anti_join()`s to reveal that we're missing information for four airports and 722 planes mentioned in `flights`:

```{r}
library(nycflights13)

flights |> 
  distinct(faa = dest) |> 
  anti_join(airports)

flights |> 
  distinct(tailnum) |> 
  anti_join(planes)
```

### Exercises

1.  Can you find any relationship between the carrier and the rows that appear to be missing from `planes`?

## Factors and empty groups

A final type of missingness is the empty group, a group that doesn't contain any observations, which can arise when working with factors.
For example, imagine we have a dataset that contains some health information about people:

```{r}
health <- tibble(
  name   = c("Ikaia", "Oletta", "Leriah", "Dashay", "Tresaun"),
  smoker = factor(c("no", "no", "no", "no", "no"), levels = c("yes", "no")),
  age    = c(34, 88, 75, 47, 56),
)
```

And we want to count the number of smokers with `dplyr::count()`:

```{r}
health |> count(smoker)
```

This dataset only contains non-smokers, but we know that smokers exist; the group of non-smoker is empty.
We can request `count()` to keep all the groups, even those not seen in the data by using `.drop = FALSE`:

```{r}
health |> count(smoker, .drop = FALSE)
```

The same principle applies to ggplot2's discrete axes, which will also drop levels that don't have any values.
You can force them to display by supplying `drop = FALSE` to the appropriate discrete axis:

```{r}
#| layout-ncol: 2
#| fig-width: 3
#| fig-alt: >
#|   A bar chart with a single value on the x-axis, "no".
#| 
#|   The same bar chart as the last plot, but now with two values on
#|   the x-axis, "yes" and "no". There is no bar for the "yes" category.
ggplot(health, aes(x = smoker)) +
  geom_bar() +
  scale_x_discrete()

ggplot(health, aes(x = smoker)) +
  geom_bar() +
  scale_x_discrete(drop = FALSE)
```

The same problem comes up more generally with `dplyr::group_by()`.
And again you can use `.drop = FALSE` to preserve all factor levels:

```{r}
#| warning: false
health |> 
  group_by(smoker, .drop = FALSE) |> 
  summarize(
    n = n(),
    mean_age = mean(age),
    min_age = min(age),
    max_age = max(age),
    sd_age = sd(age)
  )
```

We get some interesting results here because when summarizing an empty group, the summary functions are applied to zero-length vectors.
There's an important distinction between empty vectors, which have length 0, and missing values, each of which has length 1.

```{r}
# A vector containing two missing values
x1 <- c(NA, NA)
length(x1)

# A vector containing nothing
x2 <- numeric()
length(x2)
```

All summary functions work with zero-length vectors, but they may return results that are surprising at first glance.
Here we see `mean(age)` returning `NaN` because `mean(age)` = `sum(age)/length(age)` which here is 0/0.
`max()` and `min()` return -Inf and Inf for empty vectors so if you combine the results with a non-empty vector of new data and recompute you'll get the minimum or maximum of the new data[^missing-values-1].

[^missing-values-1]: In other words, `min(c(x, y))` is always equal to `min(min(x), min(y))`.

Sometimes a simpler approach is to perform the summary and then make the implicit missings explicit with `complete()`.

```{r}
health |> 
  group_by(smoker) |> 
  summarize(
    n = n(),
    mean_age = mean(age),
    min_age = min(age),
    max_age = max(age),
    sd_age = sd(age)
  ) |> 
  complete(smoker)
```

The main drawback of this approach is that you get an `NA` for the count, even though you know that it should be zero.

## Summary

Missing values are weird!
Sometimes they're recorded as an explicit `NA` but other times you only notice them by their absence.
This chapter has given you some tools for working with explicit missing values, tools for uncovering implicit missing values, and discussed some of the ways that implicit can become explicit and vice versa.

In the next chapter, we tackle the final chapter in this part of the book: joins.
This is a bit of a change from the chapters so far because we're going to discuss tools that work with data frames as a whole, not something that you put inside a data frame.

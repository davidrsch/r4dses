# Comunicación {#sec-communication}

```{r}
#| results: "asis"
#| echo: false
source("_common.R")
status("complete")
```

## Introducción

En @sec-exploratory-data-analysis, aprendió a usar gráficos como herramientas para *exploración*.
Cuando hace gráficos exploratorios, sabe, incluso antes de mirar, qué variables mostrará el gráfico.
Hiciste cada gráfica con un propósito, podías mirarla rápidamente y luego pasar a la siguiente gráfica.
En el curso de la mayoría de los análisis, producirá decenas o cientos de gráficas, la mayoría de las cuales se desechan de inmediato.

Ahora que comprende sus datos, necesita *comunicar* su comprensión a los demás.
Es probable que su audiencia no comparta su conocimiento previo y no esté profundamente interesado en los datos.
Para ayudar a otros a construir rápidamente un buen modelo mental de los datos, deberá invertir un esfuerzo considerable para hacer que sus diagramas se expliquen por sí mismos tanto como sea posible.
En este capítulo, aprenderá algunas de las herramientas que proporciona ggplot2 para hacerlo.

Este capítulo se centra en las herramientas que necesita para crear buenos gráficos.
Suponemos que sabe lo que quiere y solo necesita saber cómo hacerlo.
Por esa razón, recomendamos combinar este capítulo con un buen libro de visualización general.
Nos gusta especialmente [The Truthful Art](https://www.amazon.com/gp/product/0321934075/), de Albert Cairo.
No enseña la mecánica de crear visualizaciones, sino que se enfoca en lo que necesita pensar para crear gráficos efectivos.

### Requisitos previos

En este capítulo, nos centraremos una vez más en ggplot2.
También usaremos un poco de dplyr para la manipulación de datos, **scales** para anular las rupturas, etiquetas, transformaciones y paletas predeterminadas, y algunos paquetes de extensión de ggplot2, incluido **ggrepel** ([https://ggrepel. slowkow.com](https://ggrepel.slowkow.com/)) de Kamil Slowikowski y **patchwork** ([https://patchwork.data-imaginist.com](https://patchwork.data-imaginist%20.com/)) por Thomas Lin Pedersen.
No olvides que necesitarás instalar esos paquetes con `install.packages()` si aún no los tienes.

```{r}
#| label: setup
#| message: false

library(tidyverse)
library(ggrepel)
library(patchwork)
```

## Etiquetas

El lugar más fácil para comenzar a convertir un gráfico exploratorio en un gráfico expositivo es con buenas etiquetas.
Agregas etiquetas con la función `labs()`.
Este ejemplo agrega un título de gráfica:

```{r}
#| message: false
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles, donde
#|   los puntos se colorean según la clase de coche. Una curva suave siguiendo
#|   la trayectoria de la relación entre la eficiencia de combustible en carretera versus
#|   el tamaño del motor de los automóviles está superpuesto. La gráfica se titula "Eficiencia de combustible
#|   generalmente disminuye con el tamaño del motor".

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(title = "Eficiencia de combustible generalmente disminuye con el tamaño del motor")
```

El propósito del título de una gráfica es resumir el hallazgo principal.
Evite títulos que solo describan cuál es la gráfica, por ejemplo "Un diagrama de dispersión de la cilindrada del motor frente a la economía de combustible".

Si necesita agregar más texto, hay otras dos etiquetas útiles:

-   `subtítulo` agrega detalles adicionales en una fuente más pequeña debajo del título.

-   `caption` agrega texto en la parte inferior derecha de la gráfica, que a menudo se usa para describir la fuente de los datos.

```{r}
#| message: false
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles, donde
#|   los puntos se colorean según la clase de coche. Una curva suave siguiendo
#|   la trayectoria de la relación entre la eficiencia de combustible en carretera versus
#|   el tamaño del motor de los automóviles está superpuesto. La gráfica se titula "Eficiencia de combustible
#|   generalmente disminuye con el tamaño del motor". El subtítulo es "Dos plazas
#|   (automóviles deportivos) son una excepción debido a su peso ligero" y la
#|   descripción es "Datos de fueleconomy.gov".

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(
    title = "Eficiencia de combustible generalmente disminuye con el tamaño del motor",
    subtitle = "Dos plazas son una excepción debido a su peso ligero",
    caption = "Datos de fueleconomy.gov"
  )
```

También puede usar `labs()` para reemplazar los títulos de los ejes y las leyendas.
Por lo general, es una buena idea reemplazar los nombres cortos de las variables con descripciones más detalladas e incluir las unidades.

```{r}
#| message: false
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles, donde
#|   los puntos se colorean según la clase de coche. Una curva suave siguiendo
#|   la trayectoria de la relación entre la eficiencia de combustible en carretera versus
#|   el tamaño del motor de los automóviles está superpuesto. El eje x está etiquetado como "Motor
#|   desplazamiento (L)" y el eje y está etiquetado como "Economía de combustible en carretera (mpg)".
#|   La leyenda está etiquetada como "Tipo de coche".

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(
    x = "Motor desplazamiento (L)",
    y = "Economía de combustible en carretera (mpg)",
    color = "Tipo de coche"
  )
```

Es posible usar ecuaciones matemáticas en lugar de cadenas de texto.
Simplemente cambia `""` por `quote()` y lee acerca de las opciones disponibles en `?plotmath`:

```{r}
#| fig-asp: 1
#| out-width: "50%"
#| fig-width: 3
#| fig-alt: >
#|   Diagrama de dispersión con texto matemático en las etiquetas de los ejes x e y. etiqueta del eje X
#|   dice suma de x_i al cuadrado, para i de 1 a n. La etiqueta del eje Y dice alfa +
#|   beta + delta sobre theta.

df <- tibble(
  x = 1:10,
  y = x ^ 2
)

ggplot(df, aes(x, y)) +
  geom_point() +
  labs(
    x = quote(sum(x[i] ^ 2, i == 1, n)),
    y = quote(alpha + beta + frac(delta, theta))
  )
```

### Ejercicios

1.  Cree un gráfico en los datos de economía de combustible con etiquetas personalizadas de `título`, `subtítulo`, `título`, `x`, `y` y `color`.

2.  Vuelva a crear la siguiente gráfica usando los datos de economía de combustible.
    Tenga en cuenta que tanto los colores como las formas de los puntos varían según el tipo de transmisión.

    ```{r}
    #| echo: false
    #| fig-alt: >
    #|   Diagrama de dispersión de eficiencia de combustible en carretera versus ciudad. Formas y
    #|   los colores de los puntos están determinados por el tipo de tren de transmisión.

    ggplot(mpg, aes(x = cty, y = hwy, color = drv, shape = drv)) +
      geom_point() +
      labs(
        x = "MPG de la ciudad",
        y = "MPG en carretera",
        shape = "Tipo de\ntren de transmisión",
        color = "Tipo de\ntren de transmisión"
      )
    ```

3.  Tome un gráfico exploratorio que haya creado en el último mes y agregue títulos informativos para que sea más fácil de entender para otros.

## Anotaciones

Además de etiquetar los componentes principales de su gráfico, suele ser útil etiquetar observaciones individuales o grupos de observaciones.
La primera herramienta que tienes a tu disposición es `geom_text()`.
`geom_text()` es similar a `geom_point()`, pero tiene una estética adicional: `label`.
Esto hace posible agregar etiquetas textuales a sus gráficas.

Hay dos posibles fuentes de etiquetas.
Primero, es posible que tenga un tibble que proporcione etiquetas.
En la siguiente gráfica, sacamos los autos con el tamaño de motor más alto en cada tipo de unidad y guardamos su información como un nuevo data frames llamado `label_info`.
Para crear el data frames `label_info`, utilizamos varias funciones nuevas de dplyr.
¡Aprenderás más sobre cada uno de estos pronto!

```{r}
label_info <- mpg |>
  group_by(drv) |>
  arrange(desc(displ)) |>
  slice_head(n = 1) |>
  mutate(
    drive_type = case_when(
      drv == "f" ~ "front-wheel drive",
      drv == "r" ~ "rear-wheel drive",
      drv == "4" ~ "4-wheel drive"
    )
  ) |>
  select(displ, hwy, drv, drive_type)

label_info
```

Luego, usamos este nuevo marco de datos para etiquetar directamente los tres grupos para reemplazar la leyenda con etiquetas colocadas directamente en la gráfica.
Usando los argumentos `fontface` y `size` podemos personalizar el aspecto de las etiquetas de texto.
Son más grandes que el resto del texto de la gráfica y están en negrita.
(`theme(legend.position = "none"`) desactiva la leyenda --- hablaremos de ello más adelante).

```{r}
#| fig-alt: >
#|   Diagrama de dispersión del kilometraje en carretera versus el tamaño del motor donde los puntos están coloreados
#|   por tipo de unidad. Se superponen curvas suaves para cada tipo de unidad.
#|   Las etiquetas de texto identifican las curvas como rueda delantera, rueda trasera y 4 ruedas.

ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  geom_text(
    data = label_info, 
    aes(x = displ, y = hwy, label = drive_type),
    fontface = "bold", size = 5, hjust = "right", vjust = "bottom"
  ) +
  theme(legend.position = "none")
```

Tenga en cuenta el uso de `hjust` y `vjust` para controlar la alineación de la etiqueta.

Sin embargo, el gráfico anotado que hicimos arriba es difícil de leer porque las etiquetas se superponen entre sí y con los puntos.
Podemos mejorar un poco las cosas cambiando a `geom_label()` que dibuja un rectángulo detrás del texto.
También usamos el parámetro `nudge_y` para mover las etiquetas ligeramente por encima de los puntos correspondientes:

```{r}
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles, donde
#|   los puntos se colorean según la clase de coche. Algunos puntos están etiquetados
#|   con el nombre del coche. Las etiquetas son recuadros con fondo blanco transparente.

ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  geom_label(
    data = label_info, 
    aes(x = displ, y = hwy, label = drive_type),
    fontface = "bold", size = 5, hjust = "right", alpha = 0.5, nudge_y = 2,
  ) +
  theme(legend.position = "none")
```

Eso ayuda un poco, pero dos de las etiquetas aún se superponen entre sí.
Esto es difícil de arreglar aplicando la misma transformación para cada etiqueta.
En su lugar, podemos usar la función `geom_label_repel()` del paquete ggrepel.
Este útil paquete ajustará automáticamente las etiquetas para que no se superpongan:

```{r}
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles, donde
#|   los puntos se colorean según la clase de coche. Algunos puntos están etiquetados
#|   con el nombre del coche. Las etiquetas son cajas con fondo blanco y transparente.
#|   y colocados para que no se superpongan.

ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  geom_label_repel(
    data = label_info, 
    aes(x = displ, y = hwy, label = drive_type),
    fontface = "bold", size = 5, nudge_y = 2,
  ) +
  theme(legend.position = "none")
```

También puede usar la misma idea para resaltar ciertos puntos en un diagrama con `geom_text_repel()` del paquete ggrepel.
Tenga en cuenta otra técnica útil utilizada aquí: agregamos una segunda capa de puntos grandes y huecos para resaltar aún más los puntos etiquetados.

```{r}
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles. Puntos
#|   donde el kilometraje en carretera es superior a 40 y superior a 20 con el tamaño del motor
#|   los 5 anteriores son rojos, con un círculo rojo hueco y etiquetados con el nombre del modelo
#|   del carro.

potential_outliers <- mpg |>
  filter(hwy > 40 | (hwy > 20 & displ > 5))
  
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  geom_text_repel(data = potential_outliers, aes(label = model)) +
  geom_point(data = potential_outliers, color = "red") +
  geom_point(data = potential_outliers, color = "red", size = 3, shape = "circle open")
```

Alternativamente, es posible que solo desee agregar una sola etiqueta al gráfico, pero aún necesitará crear un marco de datos.
A menudo, desea que la etiqueta esté en la esquina del gráfico, por lo que es conveniente crear un nuevo marco de datos usando `summarize()` para calcular los valores máximos de x e y.

```{r}
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles. Sobre el
#|   esquina superior derecha, insertada un poco desde la esquina, hay una anotación que
#|   dice "El aumento del tamaño del motor está relacionado con la disminución de la economía de combustible".
#|   El texto ocupa dos líneas.

label_info <- mpg |>
  summarize(
    displ = max(displ),
    hwy = max(hwy),
    label = "El aumento del tamaño del motor está \nrelacionado con la disminución de la economía de combustible."
  )

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  geom_text(
    data = label_info, aes(label = label), 
    vjust = "top", hjust = "right"
  )
```

Si desea colocar el texto exactamente en los bordes del gráfico, puede usar set `displ = Inf` y `hwy = Inf` en el cuadro anterior, en lugar de los valores máximos calculados.

Alternativamente, podemos agregar la anotación sin crear un nuevo marco de datos, usando `annotate()`.
Esta función agrega un geom a un gráfico, pero no asigna variables de un marco de datos a una estética.
El primer argumento de esta función, `geom`, es el objeto geométrico que desea utilizar para la anotación.

```{r}
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles. Sobre el
#|   esquina superior derecha, al ras de la esquina, es una anotación que
#|   dice "El aumento del tamaño del motor está relacionado con la disminución de la economía de combustible".
#|   El texto ocupa dos líneas..

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  annotate(
    geom = "text", x = Inf, y = Inf,
    label = "El aumento del tamaño del motor está \nrelacionado con la disminución de la economía de combustible.",
    vjust = "top", hjust = "right"
  )
```

También puede usar una geom de etiqueta en lugar de una geom de texto como hicimos antes, establecer la estética como el color.
Otro enfoque para llamar la atención sobre una característica de la trama es usar un segmento geom con el argumento `arrow`.
La estética `x` e `y` definen la ubicación inicial del segmento y `xend` y `yend` para definir la ubicación final.

```{r}
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles. Un flecha
#|   roja que apunta hacia abajo sigue la tendencia de los puntos y la anotación
#|   junto a la flecha dice "El aumento del tamaño del motor está relacionado con
#|   la disminución de la economía de combustible". La flecha y el texto de la anotación son rojos.

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  annotate(
    geom = "label", x = 3.5, y = 38,
    label = "El aumento del tamaño del motor está \nrelacionado con la disminución de la economía de combustible.",
    hjust = "left", color = "red"
  ) +
  annotate(
    geom = "segment",
    x = 3, y = 35, xend = 5, yend = 25, color = "red",
    arrow = arrow(type = "closed")
  )
```

En estos ejemplos, dividimos manualmente la etiqueta en líneas usando `"\n"`.
Otro enfoque es usar `stringr::str_wrap()` para agregar automáticamente saltos de línea, dada la cantidad de caracteres que desea por línea:

```{r}
"El aumento del tamaño del motor está relacionado con la disminución de la economía de combustible." |>
  str_wrap(width = 40) |>
  writeLines()
```

Recuerde, además de `geom_text()`, tiene muchos otros geoms en ggplot2 disponibles para ayudar a anotar su gráfico.
Un par de ideas:

-   Use `geom_hline()` y `geom_vline()` para agregar líneas de referencia.
    A menudo los hacemos gruesos (`linewidth = 2`) y blancos (`color = white`), y los dibujamos debajo de la capa de datos principal.
    Eso los hace fáciles de ver, sin desviar la atención de los datos.

-   Usa `geom_rect()` para dibujar un rectángulo alrededor de los puntos de interés.
    Los límites del rectángulo están definidos por la estética `xmin`, `xmax`, `ymin`, `ymax`.

-   Usa `geom_segment()` con el argumento `arrow` para llamar la atención sobre un punto con una flecha.
    Use la estética `x` e `y` para definir la ubicación inicial, y `xend` y `yend` para definir la ubicación final.

¡El único límite es su imaginación (y su paciencia con las anotaciones de posicionamiento para que sean estéticamente agradables)!

### Ejercicios

1.  Usa `geom_text()` con infinitas posiciones para colocar texto en las cuatro esquinas del gráfico.

2.  Use `annotate()` para agregar un punto geom en el medio de su último gráfico sin tener que crear un tibble.
    Personaliza la forma, el tamaño o el color del punto.

3.  ¿Cómo interactúan las etiquetas con `geom_text()` con las facetas?
    ¿Cómo se puede agregar una etiqueta a una sola faceta?
    ¿Cómo se puede poner una etiqueta diferente en cada faceta?
    (Sugerencia: piense en los datos subyacentes).

4.  ¿Qué argumentos de `geom_label()` controlan la apariencia del cuadro de fondo?

5.  ¿Cuáles son los cuatro argumentos de `arrow()`?
    ¿Cómo trabajan?
    Cree una serie de diagramas que demuestren las opciones más importantes.

## Escalas

La tercera forma en que puede mejorar su trama para la comunicación es ajustar las escalas.
Las escalas controlan el mapeo de valores de datos a cosas que puedes percibir.

### Escalas predeterminadas

Normalmente, ggplot2 agrega escalas automáticamente.
Por ejemplo, cuando escribe:

```{r}
#| label: default-scales
#| fig-show: "hide"

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class))
```

ggplot2 agrega automáticamente escalas predeterminadas detrás de escena:

```{r}
#| fig-show: "hide"

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_color_discrete()
```

Tenga en cuenta el esquema de nombres para las escalas: `scale_` seguido del nombre de la estética, luego `_`, luego el nombre de la escala.
Las escalas predeterminadas se nombran según el tipo de variable con la que se alinean: continuous, discrete, datetime, o date.
Hay muchas escalas no predeterminadas que aprenderá a continuación.

Las escalas predeterminadas se eligieron cuidadosamente para hacer un buen trabajo con una amplia gama de entradas.
Sin embargo, es posible que desee anular los valores predeterminados por dos razones:

-   Es posible que desee modificar algunos de los parámetros de la escala predeterminada.
    Esto le permite hacer cosas como cambiar las pausas en los ejes o las etiquetas de las teclas en la leyenda.

-   Es posible que desee reemplazar la escala por completo y usar un algoritmo completamente diferente.
    A menudo, puede hacerlo mejor que el predeterminado porque sabe más sobre los datos.

### Marcas de eje y teclas de leyenda

Hay dos argumentos principales que afectan la apariencia de las marcas en los ejes y las teclas en la leyenda: `breaks` y `labels`.
Con `breaks` controla la posición de los ticks o los valores asociados con las teclas.
Con `labels` controla la etiqueta de texto asociada con cada marca/tecla.
El uso más común de `breaks` es anular la opción predeterminada:

```{r}
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles.
#|   El eje y tiene rupturas que comienzan en 15 y terminan en 40, aumentando en 5.

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  scale_y_continuous(breaks = seq(15, 40, by = 5))
```

Puede usar `labels` de la misma manera (un vector de caracteres de la misma longitud que `breaks`), pero también puede establecerlo en `NULL` para suprimir las etiquetas por completo.
Esto es útil para mapas o para publicar parcelas donde no puede compartir los números absolutos.

```{r}
#| fig-alt: >
#|   Diagrama de dispersión de la eficiencia de combustible en carretera frente al tamaño del motor de los automóviles.
#|   Los ejes x e y no tienen ninguna etiqueta en las marcas del eje.

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  scale_x_continuous(labels = NULL) +
  scale_y_continuous(labels = NULL)
```

El argumento `labels` junto con las funciones de etiquetado del paquete scales también es útil para formatear números como moneda, porcentaje, etc.
El gráfico de la izquierda muestra el etiquetado predeterminado con `label_dollar()`, que agrega un signo de dólar y una coma separadora de mil.
El gráfico de la derecha agrega más personalización al dividir los valores en dólares por 1000 y agregar un sufijo "K" (para "miles"), además de agregar cortes personalizados.
Tenga en cuenta que las rupturas (`breaks`) están en la escala original de los datos.

```{r}
#| layout-ncol: 2
#| fig-alt: >
#|   Dos diagramas de caja de lado a lado de precio versus corte de diamantes. Los valores atípicos
#|   son transparentes. En ambos gráficos, las etiquetas del eje y tienen formato de dólares.
#|   Las etiquetas del eje y en la gráfica de la izquierda comienzan en $0 y van hasta $15,000, aumentando
#|   por $5,000. Las etiquetas del eje y en la gráfica de la derecha comienzan en $1K y van a
#|   $19K, aumentando $6K.

# Izquierda
ggplot(diamonds, aes(x = cut, y = price)) +
  geom_boxplot(alpha = 0.05) +
  scale_y_continuous(labels = scales::label_dollar())

# Derecha
ggplot(diamonds, aes(x = cut, y = price)) +
  geom_boxplot(alpha = 0.05) +
  scale_y_continuous(
    labels = scales::label_dollar(scale = 1/1000, suffix = "K"), 
    breaks = seq(1000, 19000, by = 6000)
  )
```

Otra función de etiqueta útil es `label_percent()`:

```{r}
#| fig-alt: >
#|   Gráficos de barra segmentados de corte, llenos de niveles de claridad. En el eje y
#|   las etiquetas comienzan en 0% y van al 100%, aumentando en un 25%. El nombre de la 
#|   etiqueta del eje y es "Porcentaje".

ggplot(diamonds, aes(x = cut, fill = clarity)) +
  geom_bar(position = "fill") +
  scale_y_continuous(
    name = "Porcentaje", 
    labels = scales::label_percent()
  )
```

También puede usar `breaks` y `labels` para controlar la apariencia de las leyendas.
En conjunto, los ejes y las leyendas se denominan **guías**.
Los ejes se utilizan para la estética x e y; las leyendas se usan para todo lo demás.

Otro uso de las rupturas (`breaks`) es cuando tiene relativamente pocos puntos de datos y desea resaltar exactamente dónde ocurren las observaciones.
Por ejemplo, tome esta gráfica que muestra cuándo comenzó y terminó su mandato cada presidente de EE.
UU.

```{r}
#| fig-alt: >
#|   Gráfico lineal del número de identificación de los presidentes versus el año en que comenzaron su
#|   presidencia. El año de inicio se marca con un punto y un segmento que comienza
#|   allí y termina al final de la presidencia. Las etiquetas del eje x son
#|   formateado como años de dos dígitos que comienzan con un apóstrofe, por ejemplo, '53.

presidential |>
  mutate(id = 33 + row_number()) |>
  ggplot(aes(x = start, y = id)) +
  geom_point() +
  geom_segment(aes(xend = end, yend = id)) +
  scale_x_date(name = NULL, breaks = presidential$start, date_labels = "'%y")
```

Tenga en cuenta que la especificación de rupturas y etiquetas para las escalas de fecha y hora es un poco diferente:

-   `date_labels` toma una especificación de formato, de la misma forma que `parse_datetime()`.

-   `date_breaks` (no se muestra aquí), toma una cadena como "2 días" o "1 mes".

### Diseño de leyenda

You will most often use `breaks` and `labels` to tweak the axes.
While they both also work for legends, there are a few other techniques you are more likely to use.

To control the overall position of the legend, you need to use a `theme()` setting.
We'll come back to themes at the end of the chapter, but in brief, they control the non-data parts of the plot.
The theme setting `legend.position` controls where the legend is drawn:

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-height: 2
#| fig-alt: >
#|   Four scatterplots of highway fuel efficiency versus engine size of cars 
#|   where points are colored based on class of car. Clockwise, the legend 
#|   is placed on the left, top, bottom, and right of the plot.

base <- ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class))

base + theme(legend.position = "left")
base + theme(legend.position = "top")
base + theme(legend.position = "bottom")
base + theme(legend.position = "right") # the default
```

You can also use `legend.position = "none"` to suppress the display of the legend altogether.

To control the display of individual legends, use `guides()` along with `guide_legend()` or `guide_colorbar()`.
The following example shows two important settings: controlling the number of rows the legend uses with `nrow`, and overriding one of the aesthetics to make the points bigger.
This is particularly useful if you have used a low `alpha` to display many points on a plot.

```{r}
#| fig-alt: >
#|   Scatterplot of highway fuel efficiency versus engine size of cars 
#|   where points are colored based on class of car. Overlaid on the plot is a 
#|   smooth curve. The legend is in the bottom and classes are listed 
#|   horizontally in a row. The points in the legend are larger than the points 
#|   in the plot.

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme(legend.position = "bottom") +
  guides(color = guide_legend(nrow = 1, override.aes = list(size = 4)))
```

### Replacing a scale

Instead of just tweaking the details a little, you can instead replace the scale altogether.
There are two types of scales you're mostly likely to want to switch out: continuous position scales and color scales.
Fortunately, the same principles apply to all the other aesthetics, so once you've mastered position and color, you'll be able to quickly pick up other scale replacements.

It's very useful to plot transformations of your variable.
For example, it's easier to see the precise relationship between `carat` and `price` if we log transform them:

```{r}
#| fig-align: default
#| layout-ncol: 2
#| fig-width: 4
#| fig-height: 3
#| fig-alt: >
#|   Two plots of price versus carat of diamonds. Data binned and the color of 
#|   the rectangles representing each bin based on the number of points that 
#|   fall into that bin. In the plot on the right, price and carat values 
#|   are logged and the axis labels shows the logged values.

# Left
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_bin2d()

# Right
ggplot(diamonds, aes(x = log10(carat), y = log10(price))) +
  geom_bin2d()
```

However, the disadvantage of this transformation is that the axes are now labelled with the transformed values, making it hard to interpret the plot.
Instead of doing the transformation in the aesthetic mapping, we can instead do it with the scale.
This is visually identical, except the axes are labelled on the original data scale.

```{r}
#| fig-alt: >
#|   Plot of price versus carat of diamonds. Data binned and the color of 
#|   the rectangles representing each bin based on the number of points that 
#|   fall into that bin. The axis labels are on the original data scale.

ggplot(diamonds, aes(x = carat, y = price)) +
  geom_bin2d() + 
  scale_x_log10() + 
  scale_y_log10()
```

Another scale that is frequently customized is color.
The default categorical scale picks colors that are evenly spaced around the color wheel.
Useful alternatives are the ColorBrewer scales which have been hand tuned to work better for people with common types of color blindness.
The two plots below look similar, but there is enough difference in the shades of red and green that the dots on the right can be distinguished even by people with red-green color blindness.

```{r}
#| fig-align: default
#| layout-ncol: 2
#| fig-width: 4
#| fig-height: 3
#| fig-alt: >
#|   Two scatterplots of highway mileage versus engine size where points are 
#|   colored by drive type. The plot on the left uses the default 
#|   ggplot2 color palette and the plot on the right uses a different color 
#|   palette.

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv))

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv)) +
  scale_color_brewer(palette = "Set1")
```

Don't forget simpler techniques.
If there are just a few colors, you can add a redundant shape mapping.
This will also help ensure your plot is interpretable in black and white.

```{r}
#| fig-alt: >
#|   Two scatterplots of highway mileage versus engine size where both color 
#|   and shape of points are based on drive type. The color palette is not 
#|   the default ggplot2 palette.

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv, shape = drv)) +
  scale_color_brewer(palette = "Set1")
```

The ColorBrewer scales are documented online at <https://colorbrewer2.org/> and made available in R via the **RColorBrewer** package, by Erich Neuwirth.
@fig-brewer shows the complete list of all palettes.
The sequential (top) and diverging (bottom) palettes are particularly useful if your categorical values are ordered, or have a "middle".
This often arises if you've used `cut()` to make a continuous variable into a categorical variable.

```{r}
#| label: fig-brewer
#| echo: false
#| fig.cap: All colorBrewer scales.
#| fig.asp: 2.5
#| fig-alt: >
#|   All colorBrewer scales. One group goes from light to dark colors. 
#|   Another group is a set of non ordinal colors. And the last group has 
#|    diverging scales (from dark to light to dark again). Within each set 
#|    there are a number of palettes.

par(mar = c(0, 3, 0, 0))
RColorBrewer::display.brewer.all()
```

When you have a predefined mapping between values and colors, use `scale_color_manual()`.
For example, if we map presidential party to color, we want to use the standard mapping of red for Republicans and blue for Democrats:

```{r}
#| fig-alt: >
#|   Line plot of id number of presidents versus the year they started their 
#|   presidency. Start year is marked with a point and a segment that starts 
#|   there and ends at the end of the presidency. Democratic presidents are 
#|   represented in black and Republicans in red.

presidential |>
  mutate(id = 33 + row_number()) |>
  ggplot(aes(x = start, y = id, color = party)) +
  geom_point() +
  geom_segment(aes(xend = end, yend = id)) +
  scale_color_manual(values = c(Republican = "red", Democratic = "blue"))
```

For continuous color, you can use the built-in `scale_color_gradient()` or `scale_fill_gradient()`.
If you have a diverging scale, you can use `scale_color_gradient2()`.
That allows you to give, for example, positive and negative values different colors.
That's sometimes also useful if you want to distinguish points above or below the mean.

Another option is to use the viridis color scales.
The designers, Nathaniel Smith and Stéfan van der Walt, carefully tailored continuous color schemes that are perceptible to people with various forms of color blindness as well as perceptually uniform in both color and black and white.
These scales are available as continuous (`c`), discrete (`d`), and binned (`b`) palettes in ggplot2.

```{r}
#| fig-align: default
#| layout-ncol: 2
#| fig-width: 4
#| fig-asp: 1
#| fig-alt: >
#|   Three hex plots where the color of the hexes show the number of observations 
#|   that fall into that hex bin. The first plot uses the default, continuous 
#|   ggplot2 scale. The second plot uses the viridis, continuous scale, and the 
#|   third plot uses the viridis, binned scale.

df <- tibble(
  x = rnorm(10000),
  y = rnorm(10000)
)

ggplot(df, aes(x, y)) +
  geom_hex() +
  coord_fixed() +
  labs(title = "Default, continuous")

ggplot(df, aes(x, y)) +
  geom_hex() +
  coord_fixed() +
  scale_fill_viridis_c() +
  labs(title = "Viridis, continuous")

ggplot(df, aes(x, y)) +
  geom_hex() +
  coord_fixed() +
  scale_fill_viridis_b() +
  labs(title = "Viridis, binned")
```

Note that all color scales come in two variety: `scale_color_x()` and `scale_fill_x()` for the `color` and `fill` aesthetics respectively (the color scales are available in both UK and US spellings).

### Zooming

There are three ways to control the plot limits:

1.  Adjusting what data are plotted.
2.  Setting the limits in each scale.
3.  Setting `xlim` and `ylim` in `coord_cartesian()`.

To zoom in on a region of the plot, it's generally best to use `coord_cartesian()`.
Compare the following two plots:

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-height: 3
#| message: false

# Left
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth() +
  coord_cartesian(xlim = c(5, 7), ylim = c(10, 30))

# Right
mpg |>
  filter(displ >= 5, displ <= 7, hwy >= 10, hwy <= 30) |>
  ggplot(aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth()
```

You can also set the `limits` on individual scales.
Reducing the limits is basically equivalent to subsetting the data.
It is generally more useful if you want to *expand* the limits, for example, to match scales across different plots.
For example, if we extract two classes of cars and plot them separately, it's difficult to compare the plots because all three scales (the x-axis, the y-axis, and the color aesthetic) have different ranges.

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-height: 3

suv <- mpg |> filter(class == "suv")
compact <- mpg |> filter(class == "compact")

# Left
ggplot(suv, aes(x = displ, y = hwy, color = drv)) +
  geom_point()

# Right
ggplot(compact, aes(x = displ, y = hwy, color = drv)) +
  geom_point()
```

One way to overcome this problem is to share scales across multiple plots, training the scales with the `limits` of the full data.

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-height: 3

x_scale <- scale_x_continuous(limits = range(mpg$displ))
y_scale <- scale_y_continuous(limits = range(mpg$hwy))
col_scale <- scale_color_discrete(limits = unique(mpg$drv))

# Left
ggplot(suv, aes(x = displ, y = hwy, color = drv)) +
  geom_point() +
  x_scale +
  y_scale +
  col_scale

# Right
ggplot(compact, aes(x = displ, y = hwy, color = drv)) +
  geom_point() +
  x_scale +
  y_scale +
  col_scale
```

In this particular case, you could have simply used faceting, but this technique is useful more generally, if for instance, you want to spread plots over multiple pages of a report.

### Exercises

1.  Why doesn't the following code override the default scale?

    ```{r}
    #| fig-show: "hide"

    df <- tibble(
      x = rnorm(10000),
      y = rnorm(10000)
    )

    ggplot(df, aes(x, y)) +
      geom_hex() +
      scale_color_gradient(low = "white", high = "red") +
      coord_fixed()
    ```

2.  What is the first argument to every scale?
    How does it compare to `labs()`?

3.  Change the display of the presidential terms by:

    a.  Combining the two variants shown above.
    b.  Improving the display of the y axis.
    c.  Labelling each term with the name of the president.
    d.  Adding informative plot labels.
    e.  Placing breaks every 4 years (this is trickier than it seems!).

4.  Use `override.aes` to make the legend on the following plot easier to see.

    ```{r}
    #| fig-format: "png"
    #| out-width: "50%"
    #| fig-alt: >
    #|   Scatterplot of price versus carat of diamonds. The points are colored 
    #|   by cut of the diamonds and they're very transparent.

    ggplot(diamonds, aes(x = carat, y = price)) +
      geom_point(aes(color = cut), alpha = 1/20)
    ```

## Themes {#sec-themes}

Finally, you can customize the non-data elements of your plot with a theme:

```{r}
#| message: false

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_bw()
```

ggplot2 includes eight themes by default, as shown in @fig-themes.
Many more are included in add-on packages like **ggthemes** (<https://jrnold.github.io/ggthemes>), by Jeffrey Arnold.
You can also create your own themes, if you are trying to match a particular corporate or journal style.

```{r}
#| label: fig-themes
#| echo: false
#| fig-cap: The eight themes built-in to ggplot2.
#| fig-alt: >
#|   Eight barplots created with ggplot2, each 
#|   with one of the eight built-in themes: 
#|   theme_bw() - White background with grid lines,
#|   theme_light() - Light axes and grid lines,
#|   theme_classic() - Classic theme, axes but no grid
#|   lines, theme_linedraw() - Only black lines, 
#|   theme_dark() - Dark background for contrast, 
#|   theme_minimal() - Minimal theme, no background,
#|   theme_gray() - Gray background (default theme),
#|   theme_void() - Empty theme, only geoms are visible.

knitr::include_graphics("images/visualization-themes.png")
```

Many people wonder why the default theme has a gray background.
This was a deliberate choice because it puts the data forward while still making the grid lines visible.
The white grid lines are visible (which is important because they significantly aid position judgments), but they have little visual impact and we can easily tune them out.
The grey background gives the plot a similar typographic color to the text, ensuring that the graphics fit in with the flow of a document without jumping out with a bright white background.
Finally, the grey background creates a continuous field of color which ensures that the plot is perceived as a single visual entity.

It's also possible to control individual components of each theme, like the size and color of the font used for the y axis.
We've already seen that `legend.position` controls where the legend is drawn.
There are many other aspects of the legend that can be customized with `theme()`.
For example, in the plot below we change the direction of the legend as well as put a black border around it.
A few other helpful `theme()` components are used to change the placement for format of the title and caption text.

```{r}
ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point() +
  labs(
    title = "Highway mileage decreases as engine size increases",
    caption = "Source: https://fueleconomy.gov."
    ) +
  theme(
    legend.position = c(0.6, 0.7),
    legend.direction = "horizontal",
    legend.box.background = element_rect(color = "black"),
    plot.title = element_text(face = "bold"),
    plot.title.position = "plot",
    plot.caption.position = "plot",
    plot.caption = element_text(hjust = 0)
    )
```

For an overview of all `theme()` components, see help with `?theme`.
The [ggplot2 book](https://ggplot2-book.org/) is also a great place to go for the full details on theming.

### Exercises

1.  Pick a theme offered by the ggthemes package and apply it to the last plot you made.
2.  Make the axis labels of your plot blue and bolded.

## Layout

So far we talked about how to create and modify a single plot.
What if you have multiple plots you want to lay out in a certain way?
The patchwork package allows you to combine separate plots into the same graphic.
We loaded this package earlier in the chapter.

To place two plots next to each other, you can simply add them to each other.
Note that you first need to create the plots and save them as objects (in the following example they're called `p1` and `p2`).
Then, you place them next to each other with `+`.

```{r}
#| fig-alt: >
#|   Two plots (a scatterplot of highway mileage versus engine size and a 
#|   side-by-side boxplots of highway mileage versus drive train) placed next 
#|   to each other.

p1 <- ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  labs(title = "Plot 1")
p2 <- ggplot(mpg, aes(x = drv, y = hwy)) + 
  geom_boxplot() + 
  labs(title = "Plot 2")
p1 + p2
```

It's important to note that in the above code chunk we did not use a new function from the patchwork package.
Instead, the package added a new functionality to the `+` operator.

You can also create arbitrary plot layouts with patchwork.
In the following, `|` places the `p1` and `p3` next to each other and `/` moves `p2` to the next line.

```{r}
#| fig-alt: >
#|   Three plots laid out such that first and third plot are next to each other 
#|   and the second plot stretched beneath them. The first plot is a 
#|   scatterplot of highway mileage versus engine size, third plot is a 
#|   scatterplot of highway mileage versus city mileage, and the third plot is 
#|   side-by-side boxplots of highway mileage versus drive train) placed next 
#|   to each other.

p3 <- ggplot(mpg, aes(x = cty, y = hwy)) + 
  geom_point() + 
  labs(title = "Plot 3")
(p1 | p3) / p2
```

Additionally, patchwork allows you to collect legends from multiple plots into one common legend, customize the placement of the legend as well as dimensions of the plots, and add a common title, subtitle, caption, etc. to your plots.
In the following, we have 5 plots.
We have turned off the legends on the box plots and the scatterplot and collected the legends for the density plots at the top of the plot with `& theme(legend.position = "top")`.
Note the use of the `&` operator here instead of the usual `+`.
This is because we're modifying the theme for the patchwork plot as opposed to the individual ggplots.
The legend is placed on top, inside the `guide_area()`.
Finally, we have also customized the heights of the various components of our patchwork -- the guide has a height of 1, the box plots 3, density plots 2, and the faceted scatter plot 4.
Patchwork divides up the area you have allotted for your plot using this scale and places the components accordingly.

```{r}
#| fig-width: 10
#| fig-alt: >
#|   Five plots laid out such that first two plots are next to each other. Plots 
#|   three and four are underneath them. And the fifth plot stretches under them. 
#|   The patchworked plot is titled "City and highway mileage for cars with 
#|   different drive trains" and captioned "Source: Source: https://fueleconomy.gov". 
#|   The first two plots are side-by-side box plots. Plots 3 and 4 are density 
#|   plots. And the fifth plot is a faceted scatterplot. Each of these plots show 
#|   geoms colored by drive train, but the patchworked plot has only one legend 
#|   that applies to all of them, above the plots and beneath the title.

p1 <- ggplot(mpg, aes(x = drv, y = cty, color = drv)) + 
  geom_boxplot(show.legend = FALSE) + 
  labs(title = "Plot 1")

p2 <- ggplot(mpg, aes(x = drv, y = hwy, color = drv)) + 
  geom_boxplot(show.legend = FALSE) + 
  labs(title = "Plot 2")

p3 <- ggplot(mpg, aes(x = cty, color = drv, fill = drv)) + 
  geom_density(alpha = 0.5) + 
  labs(title = "Plot 3")

p4 <- ggplot(mpg, aes(x = hwy, color = drv, fill = drv)) + 
  geom_density(alpha = 0.5) + 
  labs(title = "Plot 4")

p5 <- ggplot(mpg, aes(x = cty, y = hwy, color = drv)) + 
  geom_point(show.legend = FALSE) + 
  facet_wrap(~drv) +
  labs(title = "Plot 5")

(guide_area() / (p1 + p2) / (p3 + p4) / p5) +
  plot_annotation(
    title = "City and highway mileage for cars with different drive trains",
    caption = "Source: Source: https://fueleconomy.gov."
  ) +
  plot_layout(
    guides = "collect",
    heights = c(1, 3, 2, 4)
    ) &
  theme(legend.position = "top")
```

If you'd like to learn more about combining and layout out multiple plots with patchwork, we recommend looking through the guides on the package website: <https://patchwork.data-imaginist.com>.

### Exercises

1.  What happens if you omit the parentheses in the following plot layout.
    Can you explain why this happens?

    ```{r}
    #| results: hide

    p1 <- ggplot(mpg, aes(x = displ, y = hwy)) + 
      geom_point() + 
      labs(title = "Plot 1")
    p2 <- ggplot(mpg, aes(x = drv, y = hwy)) + 
      geom_boxplot() + 
      labs(title = "Plot 2")
    p3 <- ggplot(mpg, aes(x = cty, y = hwy)) + 
      geom_point() + 
      labs(title = "Plot 3")

    (p1 | p2) / p3
    ```

2.  Using the three plots from the previous exercise, recreate the following patchwork.

    ```{r}
    #| echo: false
    #| fig-alt: >
    #|   Three plots: Plot 1 is a scatterplot of highway mileage versus engine size. 
    #|   Plot 2 is side-by-side box plots of highway mileage versus drive train. 
    #|   Plot 3 is side-by-side box plots of city mileage versus drive train. 
    #|   Plots 1 is on the first row. Plots 2 and 3 are on the next row, each span 
    #|   half the width of Plot 1. Plot 1 is labelled "Fig. A", Plot 2 is labelled 
    #|   "Fig. B", and Plot 3 is labelled "Fig. C".

    p1 / (p2 + p3) +
      plot_annotation(
        tag_levels = c("A"), 
        tag_prefix = "Fig. ",
        tag_suffix = ":"
      )
    ```

## Summary

In this chapter you've learned about adding plot labels such as title, subtitle, caption as well as modifying default axis labels, using annotation to add informational text to your plot or to highlight specific data points, customizing the axis scales, and changing the theme of your plot.
You've also learned about combining multiple plots in a single graph using both simple and complex plot layouts.

While you've so far learned about how to make many different types of plots and how to customize them using a variety of techniques, we've barely scratched the surface of what you can create with ggplot2.
If you want to get a comprehensive understanding of ggplot2, we recommend reading the book, [*ggplot2: Elegant Graphics for Data Analysis*](https://ggplot2-book.org).
Other useful resources are the [*R Graphics Cookbook*](https://r-graphics.org) by Winston Chang and [*Fundamentals of Data Visualization*](https://clauswilke.com/dataviz/) by Claus Wilke.

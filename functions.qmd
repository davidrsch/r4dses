# Funciones {#sec-functions}

```{r}
#| echo: false

source("_common.R")
```

## Introducci√≥n

Una de las mejores formas de mejorar su alcance como cient√≠fico de datos es escribir funciones.
Las funciones le permiten automatizar tareas comunes de una manera m√°s potente y general que copiar y pegar.
Escribir una funci√≥n tiene cuatro grandes ventajas sobre el uso de copiar y pegar:

1.  Puede dar a una funci√≥n un nombre sugerente que haga que su c√≥digo sea m√°s f√°cil de entender.

2.  A medida que cambian los requisitos, solo necesita actualizar el c√≥digo en un lugar, en lugar de muchos.

3.  Elimina la posibilidad de cometer errores incidentales al copiar y pegar (es decir, actualizar el nombre de una variable en un lugar, pero no en otro).

4.  Hace que sea m√°s f√°cil reutilizar el trabajo de un proyecto a otro, aumentando su productividad con el tiempo.

Una buena regla general es considerar escribir una funci√≥n siempre que haya copiado y pegado un bloque de c√≥digo m√°s de dos veces (es decir, ahora tiene tres copias del mismo c√≥digo).
En este cap√≠tulo, aprender√° acerca de tres tipos √∫tiles de funciones:

-   Las funciones vectoriales toman uno o m√°s vectores como entrada y devuelven un vector como salida.
-   Las funciones de marco de datos toman un marco de datos como entrada y devuelven un marco de datos como salida.
-   Funciones gr√°ficas que toman un marco de datos como entrada y devuelven un gr√°fico como salida.

Cada una de estas secciones incluye muchos ejemplos para ayudarlo a generalizar los patrones que ve.
Estos ejemplos no ser√≠an posibles sin la ayuda de la gente de Twitter, y le recomendamos que siga los enlaces en el comentario para ver inspiraciones originales.
Tambi√©n puede leer los tweets motivadores originales para [funciones generales](https://twitter.com/hadleywickham/status/1571603361350164486) y [funciones de gr√°ficas](https://twitter.com/hadleywickham/status/1574373127349575680) para ver a√∫n m√°s funciones.

### Requisitos previos

Agruparemos una variedad de funciones de todo el tidyverse.
Tambi√©n usaremos nycflights13 como fuente de datos familiares para usar nuestras funciones.

```{r}
#| message: false
library(tidyverse)
library(nycflights13)
```

## Funciones vectoriales

Comenzaremos con las funciones vectoriales: funciones que toman uno o m√°s vectores y devuelven un resultado vectorial.
Por ejemplo, eche un vistazo a este c√≥digo.
¬øQu√© hace?

```{r}
df <- tibble(
  a = rnorm(5),
  b = rnorm(5),
  c = rnorm(5),
  d = rnorm(5),
)

df |> mutate(
  a = (a - min(a, na.rm = TRUE)) / 
    (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)),
  b = (b - min(b, na.rm = TRUE)) / 
    (max(b, na.rm = TRUE) - min(a, na.rm = TRUE)),
  c = (c - min(c, na.rm = TRUE)) / 
    (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),
  d = (d - min(d, na.rm = TRUE)) / 
    (max(d, na.rm = TRUE) - min(d, na.rm = TRUE)),
)
```

Es posible que pueda descifrar que esto cambia la escala de cada columna para tener un rango de 0 a 1.
Pero, ¬øviste el error?
Cuando Hadley escribi√≥ este c√≥digo, cometi√≥ un error al copiar y pegar y olvid√≥ cambiar una `a` por una `b`.
Prevenir este tipo de error es una muy buena raz√≥n para aprender a escribir funciones.

### Escribiendo una funci√≥n

Para escribir una funci√≥n, primero debe analizar su c√≥digo repetido para determinar qu√© partes son constantes y qu√© partes var√≠an.
Si tomamos el c√≥digo anterior y lo extraemos de `mutate()`, es un poco m√°s f√°cil ver el patr√≥n porque cada repetici√≥n ahora es una l√≠nea:

```{r}
#| eval: false

(a - min(a, na.rm = TRUE)) / (max(a, na.rm = TRUE) - min(a, na.rm = TRUE))
(b - min(b, na.rm = TRUE)) / (max(b, na.rm = TRUE) - min(b, na.rm = TRUE))
(c - min(c, na.rm = TRUE)) / (max(c, na.rm = TRUE) - min(c, na.rm = TRUE))
(d - min(d, na.rm = TRUE)) / (max(d, na.rm = TRUE) - min(d, na.rm = TRUE))  
```

Para hacer esto un poco m√°s claro, podemos reemplazar el bit que var√≠a con `‚ñà`:

```{r}
#| eval: false
(‚ñà - min(‚ñà, na.rm = TRUE)) / (max(‚ñà, na.rm = TRUE) - min(‚ñà, na.rm = TRUE))
```

Para convertir esto en una funci√≥n necesitas tres cosas:

1.  Un **nombre**.
    Aqu√≠ usaremos `rescale01` porque esta funci√≥n cambia la escala de un vector para que est√© entre 0 y 1.

2.  Los **argumentos**.
    Los argumentos son cosas que var√≠an seg√∫n las llamadas y nuestro an√°lisis anterior nos dice que solo tenemos uno.
    Lo llamaremos `x` porque este es el nombre convencional para un vector num√©rico.

3.  El cuerpo\*\*.
    El cuerpo es el c√≥digo que se repite en todas las llamadas.

Luego creas una funci√≥n siguiendo la plantilla:

```{r}
name <- function(arguments) {
  body
}
```

Para este caso que conduce a:

```{r}
rescale01 <- function(x) {
  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
}
```

En este punto, puede probar con algunas entradas simples para asegurarse de haber capturado la l√≥gica correctamente:

```{r}
rescale01(c(-10, 0, 10))
rescale01(c(1, 2, 3, NA, 5))
```

Entonces puedes reescribir la llamada a `mutate()` como:

```{r}
df |> mutate(
  a = rescale01(a),
  b = rescale01(b),
  c = rescale01(c),
  d = rescale01(d),
)
```

(En @sec-iteration, aprender√° a usar `across()` para reducir a√∫n m√°s la duplicaci√≥n, por lo que todo lo que necesita es `df |> mutate(across(a:d, rescale01))`).

### Mejorando nuestra funci√≥n

Puede notar que la funci√≥n `rescale01()` hace un trabajo innecesario --- en lugar de calcular `min()` dos veces y `max()` una vez, podr√≠amos calcular tanto el m√≠nimo como el m√°ximo en un solo paso con `range( )`:

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
```

O puede probar esta funci√≥n en un vector que incluye un valor infinito:

```{r}
x <- c(1:10, Inf)
rescale01(x)
```

Ese resultado no es particularmente √∫til, por lo que podr√≠amos pedirle a `range()` que ignore valores infinitos:

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

rescale01(x)
```

Estos cambios ilustran un beneficio importante de las funciones: debido a que hemos movido el c√≥digo repetido a una funci√≥n, solo necesitamos hacer el cambio en un lugar.

### Funciones mutate

Ahora que tienes la idea b√°sica de las funciones, echemos un vistazo a un mont√≥n de ejemplos.
Comenzaremos mirando las funciones de "mutate", es decir, funciones que funcionan bien dentro de `mutate()` y `filter()` porque devuelven una salida de la misma longitud que la entrada.

Comencemos con una variaci√≥n simple de `rescale01()`.
Tal vez quiera calcular el puntaje Z, reescalar un vector para que tenga una media de cero y una desviaci√≥n est√°ndar de uno:

```{r}
z_score <- function(x) {
  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
}
```

O tal vez quieras terminar un `case_when()` sencillo y darle un nombre √∫til.
Por ejemplo, esta funci√≥n `clamp()` asegura que todos los valores de un vector se encuentran entre un m√≠nimo o un m√°ximo:

```{r}
clamp <- function(x, min, max) {
  case_when(
    x < min ~ min,
    x > max ~ max,
    .default = x
  )
}

clamp(1:10, min = 3, max = 7)
```

Por supuesto, las funciones no solo necesitan trabajar con variables num√©ricas.
Es posible que desee realizar una manipulaci√≥n repetida de cadenas.
Tal vez necesites hacer el primer car√°cter en may√∫sculas:

```{r}
first_upper <- function(x) {
  str_sub(x, 1, 1) <- str_to_upper(str_sub(x, 1, 1))
  x
}

first_upper("hello")
```

O tal vez desee eliminar los signos de porcentaje, las comas y los signos de d√≥lar de una cadena antes de convertirla en un n√∫mero:

```{r}
# https://twitter.com/NVlabormarket/status/1571939851922198530
clean_number <- function(x) {
  is_pct <- str_detect(x, "%")
  num <- x |> 
    str_remove_all("%") |> 
    str_remove_all(",") |> 
    str_remove_all(fixed("$")) |> 
    as.numeric()
  if_else(is_pct, num / 100, num)
}

clean_number("$12,300")
clean_number("45%")
```

A veces, sus funciones estar√°n altamente especializadas para un paso de an√°lisis de datos.
Por ejemplo, si tiene un mont√≥n de variables que registran valores faltantes como 997, 998 o 999, puede escribir una funci√≥n para reemplazarlos con `NA`:

```{r}
fix_na <- function(x) {
  if_else(x %in% c(997, 998, 999), NA, x)
}
```

Nos hemos centrado en ejemplos que toman un solo vector porque creemos que son los m√°s comunes.
Pero no hay raz√≥n para que su funci√≥n no pueda tomar m√∫ltiples entradas de vectores.

### Funciones summary

Otra familia importante de funciones vectoriales son las funciones de resumen, funciones que devuelven un √∫nico valor para usar en `summarize()`.
A veces, esto puede ser simplemente una cuesti√≥n de establecer uno o dos argumentos predeterminados:

```{r}
commas <- function(x) {
  str_flatten(x, collapse = ", ", last = " and ")
}

commas(c("cat", "dog", "pigeon"))
```

O podr√≠a terminar un c√°lculo simple, como el coeficiente de variaci√≥n, que divide la desviaci√≥n est√°ndar por la media:

```{r}
cv <- function(x, na.rm = FALSE) {
  sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)
}

cv(runif(100, min = 0, max = 50))
cv(runif(100, min = 0, max = 500))
```

O tal vez solo quiera hacer que un patr√≥n com√∫n sea m√°s f√°cil de recordar d√°ndole un nombre f√°cil de recordar:

```{r}
# https://twitter.com/gbganalyst/status/1571619641390252033
n_missing <- function(x) {
  sum(is.na(x))
} 
```

Tambi√©n puede escribir funciones con m√∫ltiples entradas vectoriales.
Por ejemplo, tal vez desee calcular el error de predicci√≥n absoluto medio para ayudarlo a comparar las predicciones del modelo con los valores reales:

```{r}
# https://twitter.com/neilgcurrie/status/1571607727255834625
mape <- function(actual, predicted) {
  sum(abs((actual - predicted) / actual)) / length(actual)
}
```

::: callout-note
## RStudio

Una vez que comience a escribir funciones, hay dos accesos directos de RStudio que son muy √∫tiles:

-   Para encontrar la definici√≥n de una funci√≥n que hayas escrito, coloca el cursor sobre el nombre de la funci√≥n y presiona `F2`.

-   Para saltar r√°pidamente a una funci√≥n, presione `Ctrl + .` para abrir el archivo difuso y el buscador de funciones y escriba las primeras letras del nombre de su funci√≥n.
    Tambi√©n puede navegar a archivos, secciones en Quarto y m√°s, lo que la convierte en una herramienta de navegaci√≥n muy √∫til.
:::

### Ejercicios

1.  Practique convertir los siguientes fragmentos de c√≥digo en funciones.
    Piensa en lo que hace cada funci√≥n.
    ¬øComo lo llamarias?
    ¬øCu√°ntos argumentos necesita?

    ```{r}
    #| eval: false

    mean(is.na(x))
    mean(is.na(y))
    mean(is.na(z))

    x / sum(x, na.rm = TRUE)
    y / sum(y, na.rm = TRUE)
    z / sum(z, na.rm = TRUE)

    round(x / sum(x, na.rm = TRUE) * 100, 1)
    round(y / sum(y, na.rm = TRUE) * 100, 1)
    round(z / sum(z, na.rm = TRUE) * 100, 1)
    ```

2.  En la segunda variante de `rescale01()`, los valores infinitos se dejan sin cambios.
    ¬øPuedes reescribir `rescale01()` para que `-Inf` se asigne a 0 e `Inf` se asigne a 1?

3.  Dado un vector de fechas de nacimiento, escribe una funci√≥n para calcular la edad en a√±os.

4.  Escriba sus propias funciones para calcular la varianza y la asimetr√≠a de un vector num√©rico.
    Puede buscar las definiciones en Wikipedia o en otro lugar.

5.  Escriba `both_na()`, una funci√≥n de resumen que toma dos vectores de la misma longitud y devuelve el n√∫mero de posiciones que tienen un `NA` en ambos vectores.

6.  Lea la documentaci√≥n para averiguar qu√© hacen las siguientes funciones.
    ¬øPor qu√© son √∫tiles a pesar de que son tan cortos?

    ```{r}
    is_directory <- function(x) {
      file.info(x)$isdir
    }
    is_readable <- function(x) {
      file.access(x, 4) == 0
    }
    ```

## Funciones de data frame

Las funciones vectoriales son √∫tiles para extraer c√≥digo que se repite dentro de un verbo dplyr.
Pero a menudo tambi√©n repetir√° los verbos, particularmente dentro de un pipe grande.
Cuando se d√© cuenta de que est√° copiando y pegando varios verbos varias veces, podr√≠a pensar en escribir una funci√≥n de data frame.
Las funciones de data frame funcionan como los verbos dplyr: toman un data frame como primer argumento, algunos argumentos adicionales que dicen qu√© hacer con √©l y devuelven un data frame o un vector.

Para permitirle escribir una funci√≥n que use verbos dplyr, primero le presentaremos el desaf√≠o de la indirecci√≥n y c√≥mo puede superarlo abrazando, `{{ }}`.
Con esta teor√≠a en su haber, le mostraremos un mont√≥n de ejemplos para ilustrar lo que podr√≠a hacer con ella.

### Evaluaci√≥n indirecta y ordenada

Cuando comienza a escribir funciones que usan verbos dplyr, r√°pidamente se encuentra con el problema de la indirecci√≥n.
Ilustremos el problema con una funci√≥n muy simple: `grouped_mean()`.
El objetivo de esta funci√≥n es calcular la media de `mean_var` agrupada por `group_var`:

```{r}
grouped_mean <- function(df, group_var, mean_var) {
  df |> 
    group_by(group_var) |> 
    summarize(mean(mean_var))
}
```

Si lo intentamos y lo usamos, obtenemos un error:

```{r}
#| error: true
diamonds |> grouped_mean(cut, carat)
```

Para hacer el problema un poco m√°s claro, podemos usar un marco de datos inventado:

```{r}
df <- tibble(
  mean_var = 1,
  group_var = "g",
  group = 1,
  x = 10,
  y = 100
)

df |> grouped_mean(group, x)
df |> grouped_mean(group, y)
```

Independientemente de c√≥mo llamemos a `grouped_mean()`, siempre hace `df |> group_by(group_var) |> resume(mean(mean_var))`, en lugar de `df |> group_by(group) |> resume(mean(x) )` o `df |> group_by(group) |> resume(mean(y))`.
Este es un problema de direccionamiento indirecto, y surge porque dplyr usa **evaluaci√≥n ordenada** para permitirle referirse a los nombres de las variables dentro de su marco de datos sin ning√∫n tratamiento especial.

La evaluaci√≥n ordenada es excelente el 95% de las veces porque hace que sus an√°lisis de datos sean muy concisos, ya que nunca tiene que decir de qu√© marco de datos proviene una variable; es obvio por el contexto.
La desventaja de la evaluaci√≥n ordenada surge cuando queremos envolver el c√≥digo tidyverse repetido en una funci√≥n.
Aqu√≠ necesitamos alguna forma de decirle a `group_mean()` y `summarize()` que no traten `group_var` y `mean_var` como el nombre de las variables, sino que busquen dentro de ellas la variable que realmente queremos usar.

La evaluaci√≥n ordenada incluye una soluci√≥n a este problema llamada **abrazar** ü§ó.
Abrazar una variable significa envolverla entre llaves para que (por ejemplo) `var` se convierta en `{{ var }}`.
Abrazar una variable le dice a dplyr que use el valor almacenado dentro del argumento, no el argumento como el nombre literal de la variable.
Una forma de recordar lo que est√° pasando es pensar en `{{ }}` como mirar hacia abajo en un t√∫nel --- `{{ var }}` har√° que una funci√≥n dplyr mire dentro de `var` en lugar de buscar una variable llamada `var`.

Entonces, para hacer que `grouped_mean()` funcione, necesitamos rodear `group_var` y `mean_var` con `{{ }}`:

```{r}
grouped_mean <- function(df, group_var, mean_var) {
  df |> 
    group_by({{ group_var }}) |> 
    summarize(mean({{ mean_var }}))
}

df |> grouped_mean(group, x)
```

¬°√âxito!

### ¬øCu√°ndo abrazar? {#sec-embracing}

Entonces, el desaf√≠o clave al escribir funciones de data frame es descubrir qu√© argumentos deben adoptarse.
Afortunadamente, esto es f√°cil porque puedes buscarlo en la documentaci√≥n üòÑ.
Hay dos t√©rminos para buscar en los documentos que corresponden a los dos subtipos m√°s comunes de evaluaci√≥n ordenada:

-   **Data-masking** (Enmascaramiento de datos): esto se usa en funciones como `arrange()`, `filter()` y `summarize()` que calculan con variables.

-   **Tidy-selection** (Selecci√≥n ordenada): esto se usa para funciones como `select()`, `relocate()` y `rename()` que seleccionan variables.

Su intuici√≥n sobre qu√© argumentos usan una evaluaci√≥n ordenada deber√≠a ser buena para muchas funciones comunes --- solo piense si puede calcular (por ejemplo, `x + 1`) o seleccionar (por ejemplo, `a:x`).

En las siguientes secciones, exploraremos los tipos de funciones √∫tiles que podr√≠a escribir una vez que comprenda la adopci√≥n.

### Casos de uso comunes

Si normalmente realiza el mismo conjunto de res√∫menes cuando realiza la exploraci√≥n inicial de datos, podr√≠a considerar incluirlos en una funci√≥n de ayuda:

```{r}
summary6 <- function(data, var) {
  data |> summarize(
    min = min({{ var }}, na.rm = TRUE),
    mean = mean({{ var }}, na.rm = TRUE),
    median = median({{ var }}, na.rm = TRUE),
    max = max({{ var }}, na.rm = TRUE),
    n = n(),
    n_miss = sum(is.na({{ var }})),
    .groups = "drop"
  )
}

diamonds |> summary6(carat)
```

(Cada vez que envuelve `summarize()` en un asistente, creemos que es una buena pr√°ctica configurar `.groups = "drop"` para evitar el mensaje y dejar los datos en un estado desagrupado).

Lo bueno de esta funci√≥n es que, debido a que envuelve `summarize()`, puede usarla en datos agrupados:

```{r}
diamonds |> 
  group_by(cut) |> 
  summary6(carat)
```

Adem√°s, dado que los argumentos para resumir son un enmascaramiento de datos, tambi√©n significa que el argumento `var` para `summary6()` es un enmascaramiento de datos.
Eso significa que tambi√©n puede resumir las variables calculadas:

```{r}
diamonds |> 
  group_by(cut) |> 
  summary6(log10(carat))
```

Para resumir varias variables, deber√° esperar hasta @sec-across, donde aprender√° a usar `across()`.

Otra funci√≥n auxiliar popular `summarize()` es una versi√≥n de `count()` que tambi√©n calcula proporciones:

```{r}
# https://twitter.com/Diabb6/status/1571635146658402309
count_prop <- function(df, var, sort = FALSE) {
  df |>
    count({{ var }}, sort = sort) |>
    mutate(prop = n / sum(n))
}

diamonds |> count_prop(clarity)
```

Esta funci√≥n tiene tres argumentos: `df`, `var` y `sort`, y solo `var` debe aceptarse porque se pasa a `count()`, que utiliza el enmascaramiento de datos para todas las variables.
Tenga en cuenta que usamos un valor predeterminado para `sort`, de modo que si el usuario no proporciona su propio valor, el valor predeterminado ser√° `FALSE`.

O tal vez quiera encontrar los valores √∫nicos ordenados de una variable para un subconjunto de los datos.
En lugar de proporcionar una variable y un valor para realizar el filtrado, permitiremos que el usuario proporcione una condici√≥n:

```{r}
unique_where <- function(df, condition, var) {
  df |> 
    filter({{ condition }}) |> 
    distinct({{ var }}) |> 
    arrange({{ var }})
}

# Encuentra todos los destinos en diciembre
flights |> unique_where(month == 12, dest)
```

Aqu√≠ adoptamos `condition` porque se pasa a `filter()` y `var` porque se pasa a `distinct()` y `arrange()`.

Hicimos todos estos ejemplos para tomar un data frame como el primer argumento, pero si est√° trabajando repetidamente con los mismos datos, puede tener sentido codificarlo.
Por ejemplo, la siguiente funci√≥n siempre funciona con el conjunto de datos de vuelos y siempre selecciona `time_hour`, `carrier` y `flight`, ya que forman la clave principal compuesta que le permite identificar una fila.

```{r}
subset_flights <- function(rows, cols) {
  flights |> 
    filter({{ rows }}) |> 
    select(time_hour, carrier, flight, {{ cols }})
}
```

### Enmascaramiento de datos vs selecci√≥n ordenada

A veces desea seleccionar variables dentro de una funci√≥n que usa enmascaramiento de datos.
Por ejemplo, imagina que quieres escribir un `count_missing()` que cuente el n√∫mero de observaciones que faltan en las filas.
Puedes intentar escribir algo como:

```{r}
#| error: true

count_missing <- function(df, group_vars, x_var) {
  df |> 
    group_by({{ group_vars }}) |> 
    summarize(
      n_miss = sum(is.na({{ x_var }})),
      .groups = "drop"
    )
}

flights |> 
  count_missing(c(year, month, day), dep_time)
```

Esto no funciona porque `group_by()` usa enmascaramiento de datos, no selecci√≥n ordenada.
Podemos solucionar ese problema usando la pr√°ctica funci√≥n `pick()`, que le permite usar la selecci√≥n ordenada dentro de las funciones de enmascaramiento de datos:

```{r}
count_missing <- function(df, group_vars, x_var) {
  df |> 
    group_by(pick({{ group_vars }})) |> 
    summarize(
      n_miss = sum(is.na({{ x_var }})),
      .groups = "drop"
  )
}

flights |> 
  count_missing(c(year, month, day), dep_time)
```

Otro uso conveniente de `pick()` es hacer una tabla de cuentas en 2D.
Aqu√≠ contamos usando todas las variables en las `filas` y `columnas`, luego usamos `pivot_wider()` para reorganizar los conteos en una cuadr√≠cula:

```{r}
# https://twitter.com/pollicipes/status/1571606508944719876
count_wide <- function(data, rows, cols) {
  data |> 
    count(pick(c({{ rows }}, {{ cols }}))) |> 
    pivot_wider(
      names_from = {{ cols }}, 
      values_from = n,
      names_sort = TRUE,
      values_fill = 0
    )
}

diamonds |> count_wide(c(clarity, color), cut)
```

Si bien nuestros ejemplos se han centrado principalmente en dplyr, la evaluaci√≥n ordenada tambi√©n respalda a tidyr, y si observa los documentos `pivot_wider()`, puede ver que `names_from` usa una selecci√≥n ordenada.

### Ejercicios

1.  Usando los conjuntos de datos de nycflights13, escriba una funci√≥n que:

    1.  Encuentra todos los vuelos que fueron cancelados (es decir, `is.na(arr_time)`) o retrasados por m√°s de una hora.

        ```{r}
        #| eval: false

        flights |> filter_severe()
        ```

    2.  Cuenta el n√∫mero de vuelos cancelados y el n√∫mero de vuelos retrasados por m√°s de una hora.

        ```{r}
        #| eval: false

        flights |> group_by(dest) |> summarize_severe()
        ```

    3.  Encuentra todos los vuelos que fueron cancelados o retrasados por m√°s de un n√∫mero de horas proporcionado por el usuario:

        ```{r}
        #| eval: false

        flights |> filter_severe(hours = 2)
        ```

    4.  Resume el clima para calcular el m√≠nimo, la media y el m√°ximo de una variable proporcionada por el usuario:

        ```{r}
        #| eval: false

        weather |> summarize_weather(temp)
        ```

    5.  Convierte la variable proporcionada por el usuario que utiliza la hora del reloj (por ejemplo, `dep_time`, `arr_time`, etc.) en una hora decimal (es decir, hours + (minutes/60)).

        ```{r}
        #| eval: false
        flights |> standardize_time(sched_dep_time)
        ```

2.  Para cada una de las siguientes funciones, enumere todos los argumentos que usan evaluaci√≥n ordenada y describa si usan enmascaramiento de datos o selecci√≥n ordenada: `distinct()`, `count()`, `group_by()`, `rename_with()`, `slice_min()`, `slice_sample()`.

3.  Generalice la siguiente funci√≥n para que pueda proporcionar cualquier n√∫mero de variables para contar.

    ```{r}
    count_prop <- function(df, var, sort = FALSE) {
      df |>
        count({{ var }}, sort = sort) |>
        mutate(prop = n / sum(n))
    }
    ```

## Funciones de gr√°ficas

En lugar de devolver un data frame, es posible que desee devolver un gr√°fico.
Afortunadamente, puedes usar las mismas t√©cnicas con ggplot2, porque `aes()` es una funci√≥n de enmascaramiento de datos.
Por ejemplo, imagina que est√°s haciendo muchos histogramas:

```{r}
#| fig-show: hide
diamonds |> 
  ggplot(aes(x = carat)) +
  geom_histogram(binwidth = 0.1)

diamonds |> 
  ggplot(aes(x = carat)) +
  geom_histogram(binwidth = 0.05)
```

¬øNo ser√≠a bueno si pudieras envolver esto en una funci√≥n de histograma?
Esto es muy f√°cil una vez que sabe que `aes ()` es una funci√≥n de enmascaramiento de datos y debe adoptar:

```{r}
#| fig-alt: |
#|   Un histograma de quilates de diamantes, con un rango de 0 a 5, que muestra una 
#|   distribuci√≥n unimodal sesgada a la derecha con un pico entre 0 y 1 quilate.

histogram <- function(df, var, binwidth = NULL) {
  df |> 
    ggplot(aes(x = {{ var }})) + 
    geom_histogram(binwidth = binwidth)
}

diamonds |> histogram(carat, 0.1)
```

Tenga en cuenta que `histogram()` devuelve un gr√°fico ggplot2, lo que significa que a√∫n puede agregar componentes adicionales si lo desea.
Solo recuerda cambiar de `|>` a `+`:

```{r}
#| fig.show: hide
diamonds |> 
  histogram(carat, 0.1) +
  labs(x = "Size (in carats)", y = "Number of diamonds")
```

### M√°s variables

Es sencillo agregar m√°s variables a la mezcla.
Por ejemplo, tal vez desee una manera f√°cil de observar si un conjunto de datos es lineal o no al superponer una l√≠nea suave y una l√≠nea recta:

```{r}
#| fig-alt: |
#|   Diagrama de dispersi√≥n de altura frente a masa de personajes de 
#|   StarWars que muestra una relaci√≥n positiva. Una curva suave de la relaci√≥n 
#|   se traza en rojo y la l√≠nea de mejor ajuste se traza en azul.

# https://twitter.com/tyler_js_smith/status/1574377116988104704
linearity_check <- function(df, x, y) {
  df |>
    ggplot(aes(x = {{ x }}, y = {{ y }})) +
    geom_point() +
    geom_smooth(method = "loess", formula = y ~ x, color = "red", se = FALSE) +
    geom_smooth(method = "lm", formula = y ~ x, color = "blue", se = FALSE) 
}

starwars |> 
  filter(mass < 1000) |> 
  linearity_check(mass, height)
```

O tal vez desee una alternativa a los diagramas de dispersi√≥n de colores para conjuntos de datos muy grandes en los que la superposici√≥n de gr√°ficos es un problema:

```{r}
#| fig-alt: |
#|   Gr√°fico hexagonal de precio frente a quilates de diamantes que muestra una 
#|   relaci√≥n positiva. Hay m√°s diamantes de menos de 2 quilates que de m√°s de 2 
#|   quilates.

# https://twitter.com/ppaxisa/status/1574398423175921665
hex_plot <- function(df, x, y, z, bins = 20, fun = "mean") {
  df |> 
    ggplot(aes(x = {{ x }}, y = {{ y }}, z = {{ z }})) + 
    stat_summary_hex(
      aes(color = after_scale(fill)), # make border same color as fill
      bins = bins, 
      fun = fun,
    )
}

diamonds |> hex_plot(carat, price, depth)
```

### Combinando con otros tidyverse

Algunos de los ayudantes m√°s √∫tiles combinan una pizca de manipulaci√≥n de datos con ggplot2.
Por ejemplo, si desea hacer un gr√°fico de barras verticales en el que ordene autom√°ticamente las barras en orden de frecuencia usando `fct_infreq()`.
Dado que el gr√°fico de barras es vertical, tambi√©n debemos invertir el orden habitual para obtener los valores m√°s altos en la parte superior:

```{r}
#| fig-alt: |
#|   Gr√°fica de barras de claridad de diamantes, donde la claridad est√° 
#|   en el eje y y los conteos est√°n en el eje x, y las barras est√°n ordenadas 
#|   en orden de frecuencia: SI1, VS2, SI2, VS1, VVS2, VVS1, IF, I1.

sorted_bars <- function(df, var) {
  df |> 
    mutate({{ var }} := fct_rev(fct_infreq({{ var }})))  |>
    ggplot(aes(y = {{ var }})) +
    geom_bar()
}

diamonds |> sorted_bars(clarity)
```

Tenemos que usar un nuevo operador aqu√≠, `:=`, porque estamos generando el nombre de la variable en funci√≥n de los datos proporcionados por el usuario.
Los nombres de las variables van en el lado izquierdo de `=`, pero la sintaxis de R no permite nada a la izquierda de `=` excepto un solo nombre literal.
Para solucionar este problema, usamos el operador especial `:=` que la evaluaci√≥n ordenada trata exactamente de la misma manera que `=`.

O tal vez desee que sea m√°s f√°cil dibujar un gr√°fico de barras solo para un subconjunto de los datos:

```{r}
#| fig-alt: |
#|   Diagrama de barra de claridad de diamantes. El m√°s com√∫n es SI1, luego SI2, 
#|   luego VS2, luego VS1, luego VVS2, luego VVS1, luego I1, luego por √∫ltimo IF.

conditional_bars <- function(df, condition, var) {
  df |> 
    filter({{ condition }}) |> 
    ggplot(aes(x = {{ var }})) + 
    geom_bar()
}

diamonds |> conditional_bars(cut == "Good", clarity)
```

Tambi√©n puede ser creativo y mostrar res√∫menes de datos de otras maneras.
Puede encontrar una aplicaci√≥n interesante en <https://gist.github.com/Gshotwell/b19ef520b6d56f61a830fabb3454965b>; utiliza las etiquetas de los ejes para mostrar el valor m√°s alto.
A medida que aprenda m√°s sobre ggplot2, el poder de sus funciones seguir√° aumentando.

Terminaremos con un caso m√°s complicado: etiquetar las parcelas que creas.

### Etiquetado

¬øRecuerdas la funci√≥n de histograma que te mostramos antes?

```{r}
histogram <- function(df, var, binwidth = NULL) {
  df |> 
    ggplot(aes(x = {{ var }})) + 
    geom_histogram(binwidth = binwidth)
}
```

¬øNo ser√≠a bueno si pudi√©ramos etiquetar la salida con la variable y el ancho del contenedor que se us√≥?
Para hacerlo, vamos a tener que pasar por debajo de las s√°banas de la evaluaci√≥n ordenada y usar una funci√≥n del paquete del que a√∫n no hemos hablado: rlang.
rlang es un paquete de bajo nivel que es utilizado por casi todos los dem√°s paquetes en el tidyverse porque implementa una evaluaci√≥n ordenada (as√≠ como muchas otras herramientas √∫tiles).

Para resolver el problema de etiquetado podemos usar `rlang::englue()`.
Esto funciona de manera similar a `str_glue()`, por lo que cualquier valor envuelto en `{ }` se insertar√° en la cadena.
Pero tambi√©n entiende `{{ }}`, que inserta autom√°ticamente el nombre de variable apropiado:

```{r}
#| fig-alt: |
#|   Histograma de quilates de diamantes, que va de 0 a 5. La distribuci√≥n es 
#|   unimodal y sesgada a la derecha con un pico entre 0 y 1 quilates.

histogram <- function(df, var, binwidth) {
  label <- rlang::englue("A histogram of {{var}} with binwidth {binwidth}")
  
  df |> 
    ggplot(aes(x = {{ var }})) + 
    geom_histogram(binwidth = binwidth) + 
    labs(title = label)
}

diamonds |> histogram(carat, 0.1)
```

Puede usar el mismo enfoque en cualquier otro lugar donde desee proporcionar una cadena en un gr√°fico ggplot2.

### Ejercicios

Cree una funci√≥n de trazado enriquecida implementando de forma incremental cada uno de los pasos a continuaci√≥n:

1.  Dibuje un diagrama de dispersi√≥n dado el conjunto de datos y las variables `x` e `y`.

2.  Agregue una l√≠nea de mejor ajuste (es decir, un modelo lineal sin errores est√°ndar).

3.  Agregue un t√≠tulo.

## Estilo

A R no le importa c√≥mo se llamen sus funciones o argumentos, pero los nombres marcan una gran diferencia para los humanos.
Idealmente, el nombre de su funci√≥n ser√° corto, pero evocar√° claramente lo que hace la funci√≥n.
¬°Eso es dif√≠cil!
Pero es mejor ser claro que breve, ya que el autocompletado de RStudio facilita la escritura de nombres largos.

Generalmente, los nombres de las funciones deben ser verbos y los argumentos deben ser sustantivos.
Hay algunas excepciones: los sustantivos est√°n bien si la funci√≥n calcula un sustantivo muy conocido (es decir, `mean()` es mejor que `compute_mean()`), o acceder a alguna propiedad de un objeto (es decir, `coef()` es mejor que `obtener_coeficientes()`).
Use su mejor juicio y no tenga miedo de cambiar el nombre de una funci√≥n si descubre un nombre mejor m√°s tarde.

```{r}
#| eval: false

# Demasiado corto
f()

# Ni verbo ni descriptivo
my_awesome_function()

# Largo pero no claro
impute_missing()
collapse_years()
```

A R tampoco le importa c√≥mo usa el espacio en blanco en sus funciones, pero a los futuros lectores s√≠.
Contin√∫e siguiendo las reglas de @sec-workflow-style.
Adem√°s, `function()` siempre debe ir seguida de corchetes ondulados (`{}`), y el contenido debe tener una sangr√≠a de dos espacios adicionales.
Esto hace que sea m√°s f√°cil ver la jerarqu√≠a en su c√≥digo rozando el margen izquierdo.

```{r}
# Faltan los dos espacios extras
density <- function(color, facets, binwidth = 0.1) {
diamonds |> 
  ggplot(aes(x = carat, y = after_stat(density), color = {{ color }})) +
  geom_freqpoly(binwidth = binwidth) +
  facet_wrap(vars({{ facets }}))
}

# Canalizaci√≥n con sangr√≠a incorrecta
density <- function(color, facets, binwidth = 0.1) {
  diamonds |> 
  ggplot(aes(x = carat, y = after_stat(density), color = {{ color }})) +
  geom_freqpoly(binwidth = binwidth) +
  facet_wrap(vars({{ facets }}))
}
```

Como puede ver, recomendamos poner espacios adicionales dentro de `{{ }}`.
Esto hace que sea muy obvio que algo inusual est√° sucediendo.

### Ejercicios

1.  Lea el c√≥digo fuente de cada una de las siguientes dos funciones, averig√ºe lo que hacen y luego piense en mejores nombres.

    ```{r}
    f1 <- function(string, prefix) {
      str_sub(string, 1, str_length(prefix)) == prefix
    }

    f3 <- function(x, y) {
      rep(y, length.out = length(x))
    }
    ```

2.  Tome una funci√≥n que haya escrito recientemente y dedique 5 minutos a pensar en un mejor nombre para ella y sus argumentos.

3.  Explique por qu√© `norm_r()`, `norm_d()` etc. ser√≠a mejor que `rnorm()`, `dnorm()`.
    Haga un caso para lo contrario.
    ¬øC√≥mo podr√≠a hacer los nombres a√∫n m√°s claros?

## Resumen

En este cap√≠tulo, aprendi√≥ a escribir funciones para tres escenarios √∫tiles: crear un vector, crear data frame o crear un gr√°fico.
En el camino, vio muchos ejemplos, que con suerte comenzaron a hacer fluir su creatividad y le dieron algunas ideas sobre d√≥nde las funciones podr√≠an ayudar a su c√≥digo de an√°lisis.

Solo le hemos mostrado lo m√≠nimo para comenzar con las funciones y hay mucho m√°s que aprender.
Algunos lugares para aprender m√°s son:

-   Para obtener m√°s informaci√≥n sobre la programaci√≥n con evaluaci√≥n ordenada, consulte recetas √∫tiles en [programaci√≥n con dplyr](https://dplyr.tidyverse.org/articles/programming.html) y [programaci√≥n con tidyr](https://tidyr.tidyverse.org/articles/programming.html) y obtenga m√°s informaci√≥n sobre la teor√≠a en [¬øQu√© es el enmascaramiento de datos y por qu√© necesito {{?](https://rlang.r-lib.org/reference/topic-data-mask.html).
-   Para obtener m√°s informaci√≥n sobre c√≥mo reducir la duplicaci√≥n en su c√≥digo ggplot2, lea el cap√≠tulo [Programaci√≥n con ggplot2](https://ggplot2-book.org/programming.html){.uri} del libro de ggplot2.
-   Para obtener m√°s consejos sobre el estilo de las funciones, consulta la [gu√≠a de estilo de tidyverse](https://style.tidyverse.org/functions.html){.uri}.

En el pr√≥ximo cap√≠tulo, nos sumergiremos en la iteraci√≥n, que le brinda m√°s herramientas para reducir la duplicaci√≥n de c√≥digo.

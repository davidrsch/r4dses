# Transformación de datos {#sec-data-transform}

```{r}
#| results: "asis"
#| echo: false
source("_common.R")
status("complete")
```

## Introducción

La visualización es una herramienta importante para generar información, pero es raro que obtenga los datos exactamente en la forma correcta que necesita.
A menudo, necesitará crear nuevas variables o resúmenes para ver los patrones más importantes, o tal vez solo quiera cambiar el nombre de las variables o reordenar las observaciones para que sea un poco más fácil trabajar con los datos.
Aprenderá cómo hacer todo eso (¡y más!) en este capítulo, que lo introducirá a la transformación de datos utilizando el paquete **dplyr** y un nuevo conjunto de datos en vuelos que partieron de la ciudad de Nueva York en 2013.

El objetivo de este capítulo es brindarle una descripción general de todas las herramientas clave para transformar un data frame.
Comenzaremos con funciones que operan en filas y luego en columnas de un data frame.
A continuación, introduciremos la capacidad de trabajar con grupos.
Terminaremos el capítulo con un caso de estudio que muestra estas funciones en acción y volveremos a las funciones con más detalle en capítulos posteriores, a medida que comencemos a profundizar en tipos específicos de datos (por ejemplo, números, cadenas, fechas).

### Requisitos previos

En este capítulo nos centraremos en el paquete dplyr, otro miembro central de tidyverse.
Ilustraremos las ideas clave usando datos del paquete nycflights13 y usaremos ggplot2 para ayudarnos a comprender los datos.

```{r}
#| label: setup

library(nycflights13)
library(tidyverse)
```

Tome nota del mensaje de conflictos que se imprime cuando carga el tidyverse.
Te dice que dplyr sobrescribe algunas funciones en base R.
Si desea utilizar la versión base de estas funciones después de cargar dplyr, deberá utilizar sus nombres completos: `stats::filter()` y `stats::lag()`.
Hasta ahora hemos ignorado en su mayoría de qué paquete proviene una función porque la mayoría de las veces no importa.
Sin embargo, conocer el paquete puede ayudarlo a encontrar ayuda y funciones relacionadas, por lo que cuando necesitemos ser precisos sobre de qué función proviene un paquete, usaremos la misma sintaxis que R: `nombrepaquete::nombrefuncion()`.

### nycflights13

Para explorar los verbos básicos de dplyr, usaremos `nycflights13::flights`.
Este conjunto de datos contiene todos los `r format(nrow(nycflights13::flights), big.mark = ",")` vuelos que partieron de la ciudad de Nueva York en 2013.
Los datos provienen de la [Oficina de Estadísticas de Transporte](http://www.trastats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0) de EE.
UU.
y están documentados en `?flights`.

```{r}
flights
```

Si ha usado R antes, puede notar que este data frame se imprime de manera un poco diferente a otros marcos de datos que ha visto.
Esto se debe a que es un **tibble**, un tipo especial de data frame utilizado por tidyverse para evitar algunos errores comunes.
La diferencia más importante es la forma en que se imprime: los tibbles están diseñados para grandes conjuntos de datos, por lo que solo muestran las primeras filas y solo las columnas que caben en una pantalla.
Hay algunas opciones para ver todo.
Si está utilizando RStudio, lo más conveniente es probablemente `View(flights)`, que abrirá una vista interactiva desplazable y filtrable.
De lo contrario, puede usar `print(flights, width = Inf)` para mostrar todas las columnas, o usar la llamada `glimpse()`:

```{r}
glimpse(flights)
```

En ambas vistas, los nombres de las variables van seguidos de abreviaturas que indican el tipo de cada variable: `<int>` es la abreviatura de entero, `<dbl>` es la abreviatura de doble (también conocido como número real), `<chr>` para carácter (también conocido como cadenas) y `<dttm>` para fecha y hora.
Estos son importantes porque las operaciones que puede realizar en una columna dependen mucho de su "tipo", y estos tipos se utilizan para organizar los capítulos en la siguiente sección del libro.

### Básicos de dplyr

Está a punto de aprender los verbos principales de dplyr que le permitirán resolver la gran mayoría de sus desafíos de manipulación de datos.
Pero antes de discutir sus diferencias individuales, vale la pena señalar lo que tienen en común:

1.  El primer argumento es siempre un data frame.

2.  Los argumentos subsiguientes describen qué hacer con el data frame, utilizando los nombres de las variables (sin comillas).

3.  El resultado es siempre un nuevo data frame.

Debido a que el primer argumento es un data frame y la salida es un data frame, los verbos dplyr funcionan bien con *pipe* `|>`.
*Pipe* toma el objeto resultante de su izquierda y la pasa a la función de su derecha de modo que `x |> f(y)` es equivalente a `f(x, y)`, y `x |> f(y) |> g(z)` es equivalente a into `g(f(x, y), z)`.
La forma más fácil de leer *pipe* es "entonces".
Eso hace posible tener una idea del siguiente código aunque aún no haya aprendido los detalles:

```{r}
#| eval: false

flights |>
  filter(dest == "IAH") |> 
  group_by(year, month, day) |> 
  summarize(
    arr_delay = mean(arr_delay, na.rm = TRUE)
  )
```

El código comienza con el conjunto de datos `flights`, luego lo filtra, luego lo agrupa y luego lo resume.
Volveremos a *pipe* y sus alternativas en @sec-pipes.

Los verbos de dplyr están organizados en cuatro grupos según lo que operan: **filas**, **columnas**, **grupos** o **tablas**.
En las siguientes secciones, aprenderá los verbos más importantes para filas, columnas y grupos, luego regresaremos a los verbos que funcionan en tablas en @sec-joins.
¡Vamos a empezar!

## Filas

Los verbos más importantes que operan en las filas son `filter()`, que cambia qué filas están presentes sin cambiar su orden, y `arrange()`, que cambia el orden de las filas sin cambiar cuáles están presentes.
Ambas funciones solo afectan a las filas y las columnas no se modifican.
También hablaremos de `distinct()`, que encuentra filas con valores únicos pero, a diferencia de `arrange()` y `filter()`, también puede modificar opcionalmente las columnas.

### `filter()`

`filter()` le permite mantener filas en función de los valores de las columnas [^data-transform-1].
El primer argumento es el data frame.
El segundo argumento y los subsiguientes son las condiciones que deben cumplirse para mantener la fila.
Por ejemplo, podríamos encontrar todos los vuelos que llegaron con más de 120 minutos (dos horas) de retraso:

[^data-transform-1]: Más adelante, aprenderá sobre la familia `slice_*()`, que le permite elegir filas en función de sus posiciones.

```{r}
flights |> 
  filter(arr_delay > 120)
```

Además de `>` (mayor que), puede usar `>=` (mayor o igual que), `<` (menor que), `<=` (menor o igual que), `==` (igual a) y `!=` (no igual a).
También puede usar `&` (y) o `|` (o) para combinar varias condiciones:

```{r}
# Vuelos que partieron el 1 de enero
flights |> 
  filter(month == 1 & day == 1)

# Vuelos que salieron en enero o febrero
flights |> 
  filter(month == 1 | month == 2)
```

Hay un atajo útil cuando estás combinando `|` y `==`: `%in%`.
Mantiene filas donde la variable es igual a uno de los valores de la derecha:

```{r}
# Una forma más corta de seleccionar vuelos que partieron en enero o febrero
flights |> 
  filter(month %in% c(1, 2))
```

Volveremos a estas comparaciones y operadores lógicos con más detalle en @sec-logicals.

Cuando ejecuta `filter()`, dplyr ejecuta la operación de filtrado, crea un nuevo data frame y luego lo imprime.
No modifica el conjunto de datos `flights` existente porque las funciones dplyr nunca modifican sus entradas.
Para guardar el resultado, debe usar el operador de asignación, `<-`:

```{r}
ene1 <- flights |> 
  filter(month == 1 & day == 1)
```

### Errores comunes

Cuando comienza con R, el error más fácil de cometer es usar `=` en lugar de `==` al probar la igualdad.
`filter()` te avisará cuando esto suceda:

```{r}
#| error: true

flights |> 
  filter(month = 1)
```

Otro error es escribir declaraciones "o" como lo haría en español:

```{r}
#| eval: false

flights |> 
  filter(month == 1 | 2)
```

Esto funciona, en el sentido de que no arroja un error, pero no hace lo que quieres.
Volveremos a lo que hace y por qué en @sec-boolean-operations.

### `arrange()`

`arrange()` cambia el orden de las filas según el valor de las columnas.
Se necesita un data frame y un conjunto de nombres de columna (o expresiones más complicadas) para ordenar.
Si proporciona más de un nombre de columna, cada columna adicional se usará para desempatar los valores de las columnas anteriores.
Por ejemplo, el siguiente código ordena por hora de salida, que se distribuye en cuatro columnas.

```{r}
flights |> 
  arrange(year, month, day, dep_time)
```

Puede usar `desc()` para reordenar por una columna en orden descendente.
Por ejemplo, este código muestra los vuelos más retrasados:

```{r}
flights |> 
  arrange(desc(dep_delay))
```

Puedes combinar `arrange()` y `filter()` para resolver problemas más complejos.
Por ejemplo, podríamos buscar los vuelos que se retrasaron más a la llegada y que salieron más o menos a tiempo:

```{r}
flights |> 
  filter(dep_delay <= 10 & dep_delay >= -10) |> 
  arrange(desc(arr_delay))
```

### `distinct()`

`distinct()` encuentra todas las filas únicas en un conjunto de datos, por lo que, en un sentido técnico, opera principalmente en las filas.
Sin embargo, la mayoría de las veces, querrá la combinación distinta de algunas variables, por lo que también puede proporcionar opcionalmente nombres de columna:

```{r}
# Esto eliminaría cualquier fila duplicada si hubiera alguna
flights |> 
  distinct()

# Esto encuentra todos los pares únicos de origen y destino.
flights |> 
  distinct(origin, dest)
```

Tenga en cuenta que si desea encontrar el número de duplicados o filas que no estaban duplicadas, es mejor que cambie `distinct()` por `count()` y luego filtre según sea necesario.

### Ejercicios

1.  Encuentra todos los vuelos que

    a.  Tuvo un retraso de llegada de dos o más horas.
    b.  Voló a Houston (`IAH` o `HOU`) C. Fueron operados por United, American o Delta
    c.  Salida en verano (julio, agosto y septiembre)
    d.  Llegó más de dos horas tarde, pero no se fue tarde
    e.  Se retrasaron al menos una hora, pero recuperaron más de 30 minutos en vuelo

2.  Ordene `flights` para encontrar los vuelos con mayores retrasos en la salida.
    Encuentra los vuelos que salieron más temprano en la mañana.

3.  Ordene `flights` para encontrar los vuelos más rápidos (Sugerencia: intente ordenar por un cálculo).

4.  ¿Hubo un vuelo todos los días de 2013?

5.  ¿Qué vuelos viajaron la mayor distancia?
    ¿Cuál recorrió la menor distancia?

6.  ¿Importa en qué orden usó `filter()` y `arrange()` si está usando ambos?
    ¿Por qué/por qué no?
    Piense en los resultados y cuánto trabajo tendrían que hacer las funciones.

## Columnas

Hay cuatro verbos importantes que afectan a las columnas sin cambiar las filas: `mutate()`, `select()`, `rename()` y `relocate()`.
`mutate()` crea nuevas columnas que son funciones de las columnas existentes; `select()`, `rename()` y `relocate()` cambian qué columnas están presentes, sus nombres o sus posiciones.
También hablaremos de `pull()` ya que le permite sacar una columna del data frame.

### `mutate()` {#sec-mutate}

El trabajo de `mutate()` es agregar nuevas columnas que se calculan a partir de las columnas existentes.
En los capítulos de transformación, aprenderá un gran conjunto de funciones que puede usar para manipular diferentes tipos de variables.
Por ahora, nos apegaremos al álgebra básica, que nos permite calcular la `ganancia`, cuánto tiempo recuperó un vuelo retrasado en el aire y la `velocidad` en millas por hora:

```{r}
flights |> 
  mutate(
    ganancia = dep_delay - arr_delay,
    velocidad = distance / air_time * 60
  )
```

De forma predeterminada, `mutate()` agrega nuevas columnas en el lado derecho de su conjunto de datos, lo que dificulta ver lo que está sucediendo aquí.
Podemos usar el argumento `.before` para agregar las variables al lado izquierdo [^data-transform-2]:

[^data-transform-2]: Recuerde que en RStudio, la forma más fácil de ver un conjunto de datos con muchas columnas es `View()`.

```{r}
flights |> 
  mutate(
    ganancia = dep_delay - arr_delay,
    velocidad = distance / air_time * 60,
    .before = 1
  )
```

El `.` es un signo de que `.before` es un argumento para la función, no el nombre de una nueva variable.
También puede usar `.after` para agregar después de una variable, y tanto en `.before` como en `.after` puede usar el nombre de la variable en lugar de una posición.
Por ejemplo, podríamos agregar las nuevas variables después de `day`:

```{r}
flights |> 
  mutate(
    ganancia = dep_delay - arr_delay,
    velocidad = distance / air_time * 60,
    .after = day
  )
```

Alternativamente, puede controlar qué variables se mantienen con el argumento `.keep`.
Un argumento particularmente útil es `"used"`, que le permite ver las entradas y salidas de sus cálculos:

```{r}
flights |> 
  mutate(
    ganancia = dep_delay - arr_delay,
    horas = air_time / 60,
    ganancia_por_hora = ganancia / horas,
    .keep = "used"
  )
```

### `select()` {#sec-select}

No es raro obtener conjuntos de datos con cientos o incluso miles de variables.
En esta situación, el primer desafío suele ser centrarse en las variables que le interesan.
`select()` le permite acercarse rápidamente a un subconjunto útil utilizando operaciones basadas en los nombres de las variables.
`select()` no es muy útil con los datos de los vuelos porque solo tenemos 19 variables, pero aún puedes hacerte una idea general de cómo funciona:

```{r}
# Seleccionar columnas por nombre
flights |> 
  select(year, month, day)

# Seleccionar todas las columnas entre year y day (incluyendolas)
flights |> 
  select(year:day)

# eleccionar todas las columnas excepto aquellas entre year y day (incluyendolas)
flights |> 
  select(!year:day)

# Seleccionar todas las columnas que son caracteres
flights |> 
  select(where(is.character))
```

Hay una serie de funciones auxiliares que puede usar dentro de `select()`:

-   `starts_with("abc")`: coincide con los nombres que comienzan con "abc".
-   `ends_with("xyz")`: encuentra nombres que terminan en "xyz".
-   `contains("ijk")`: encuentra nombres que contienen "ijk".
-   `num_range("x", 1:3)`: coincide con `x1`, `x2` y `x3`.

Ver `?select` para más detalles.
Una vez que conozca las expresiones regulares (el tema de @sec-regular-expressions), también podrá usar `matches()` para seleccionar variables que coincidan con un patrón.

Puede cambiar el nombre de las variables a medida que las selecciona con `select()` usando `=`.
El nuevo nombre aparece en el lado izquierdo de `=`, y la variable antigua aparece en el lado derecho:

```{r}
flights |> 
  select(tail_num = tailnum)
```

### `rename()`

Si solo desea conservar todas las variables existentes y cambiar el nombre de algunas, puede usar `rename()` en lugar de `select()`:

```{r}
flights |> 
  rename(tail_num = tailnum)
```

Funciona exactamente de la misma manera que `select()`, pero mantiene todas las variables que no están seleccionadas explícitamente.

Si tiene un montón de columnas con nombres inconsistentes y sería doloroso arreglarlas todas a mano, consulte `janitor::clean_names()` que proporciona una limpieza automatizada útil.

### `relocate()`

Usa `relocate()` para mover las variables.
Es posible que desee recopilar variables relacionadas juntas o mover variables importantes al frente.
Por defecto `relocate()` mueve las variables al frente:

```{r}
flights |> 
  relocate(time_hour, air_time)
```

Pero puedes usar los mismos argumentos `.before` y `.after` que `mutate()` para elegir dónde ponerlos:

```{r}
flights |> 
  relocate(year:dep_time, .after = time_hour)
flights |> 
  relocate(starts_with("arr"), .before = dep_time)
```

### Ejercicios

```{r}
#| eval: false
#| echo: false

# Para verificación de datos, no se usa en los resultados que se muestran en el libro
flights <- flights |> mutate(
  dep_time = hour * 60 + minute,
  arr_time = (arr_time %/% 100) * 60 + (arr_time %% 100),
  airtime2 = arr_time - dep_time,
  dep_sched = dep_time + dep_delay
)

ggplot(flights, aes(x = dep_sched)) + geom_histogram(binwidth = 60)
ggplot(flights, aes(x = dep_sched %% 60)) + geom_histogram(binwidth = 1)
ggplot(flights, aes(x = air_time - airtime2)) + geom_histogram()
```

1.  Compare `dep_time`, `sched_dep_time`, and `dep_delay`.

2.  Haga una lluvia de ideas sobre tantas formas como sea posible para seleccionar `dep_time`, `dep_delay`, `arr_time` y `arr_delay` de `flights`.

3.  ¿Qué sucede si incluye el nombre de una variable varias veces en una llamada `select()`?

4.  ¿Qué hace la función `any_of()`?
    ¿Por qué podría ser útil junto con este vector?

    ```{r}
    variables <- c("year", "month", "day", "dep_delay", "arr_delay")
    ```

5.  ¿Te sorprende el resultado de ejecutar el siguiente código?
    ¿Cómo tratan los ayudantes selectos el caso de forma predeterminada?
    ¿Cómo se puede cambiar ese valor predeterminado?

    ```{r}
    #| eval: false

    select(flights, contains("TIME"))
    ```

## Grupos

Hasta ahora ha aprendido acerca de las funciones que funcionan con filas y columnas.
dplyr se vuelve aún más poderoso cuando agrega la capacidad de trabajar con grupos.
En esta sección, nos centraremos en las funciones más importantes: `group_by()`, `summarize()` y la familia de funciones slice.

### `group_by()`

Use `group_by()` para dividir su conjunto de datos en grupos significativos para su análisis:

```{r}
flights |> 
  group_by(month)
```

`group_by()` no cambia los datos pero, si observa detenidamente el resultado, notará que ahora está "agrupado por" mes.
Esto significa que las operaciones posteriores ahora funcionarán "por mes".
`group_by()` no hace nada por sí mismo; en cambio, cambia el comportamiento de los verbos posteriores.

### `summarize()` {#sec-summarize}

La operación agrupada más importante es un resumen, que colapsa cada grupo en una sola fila.
En dplyr, esta operación la realiza `summarize()`[^data-transform-3], como se muestra en el siguiente ejemplo, que calcula el retraso de salida promedio por mes:

[^data-transform-3]: O `summarise()`, si prefiere inglés británico.

```{r}
flights |> 
  group_by(month) |> 
  summarize(
    delay = mean(dep_delay)
  )
```

¡UH oh!
Algo salió mal y todos nuestros resultados son `NA` (pronunciado "N-A"), el símbolo de R para el valor faltante.
Volveremos a discutir los valores faltantes en @sec-missing-values, pero por ahora los eliminaremos usando `na.rm = TRUE`:

```{r}
flights |> 
  group_by(month) |> 
  summarize(
    delay = mean(dep_delay, na.rm = TRUE)
  )
```

Puede crear cualquier cantidad de resúmenes en una sola llamada a `summarize()`.
Aprenderá varios resúmenes útiles en los próximos capítulos, pero un resumen muy útil es `n()`, que devuelve el número de filas en cada grupo:

```{r}
flights |> 
  group_by(month) |> 
  summarize(
    delay = mean(dep_delay, na.rm = TRUE), 
    n = n()
  )
```

¡Los medios y los conteos pueden llevarlo sorprendentemente lejos en la ciencia de datos!

### Las funciones `slice_`

Hay cinco funciones útiles que le permiten seleccionar filas específicas dentro de cada grupo:

-   `df |> slice_head(n = 1)` toma la primera fila de cada grupo.
-   `df |> slice_tail(n = 1)` toma la última fila de cada grupo.
-   `df |> slice_min(x, n = 1)` toma la fila con el valor más pequeño de `x`.
-   `df |> slice_max(x, n = 1)` toma la fila con el mayor valor de `x`.
-   `df |> slice_sample(n = 1)` toma una fila aleatoria.

Puede variar `n` para seleccionar más de una fila, o en lugar de `n =`, puede usar `prop = 0.1` para seleccionar (p. ej.) el 10 % de las filas de cada grupo.
Por ejemplo, el siguiente código encuentra el vuelo más retrasado a cada destino:

```{r}
flights |> 
  group_by(dest) |> 
  slice_max(arr_delay, n = 1)
```

Esto es similar a calcular el retraso máximo con `summarize()`, pero obtienes la fila completa en lugar del resumen único:

```{r}
flights |> 
  group_by(dest) |> 
  summarize(max_delay = max(arr_delay, na.rm = TRUE))
```

### Agrupación por múltiples variables

Puede crear grupos utilizando más de una variable.
Por ejemplo, podríamos hacer un grupo para cada día:

```{r}
daily <- flights |>  
  group_by(year, month, day)
daily
```

Cuando resume un tibble agrupado por más de una variable, cada resumen elimina el último grupo.
En retrospectiva, esta no fue una excelente manera de hacer que esta función funcionara, pero es difícil cambiarla sin romper el código existente.
Para que sea obvio lo que sucede, dplyr muestra un mensaje que le indica cómo puede cambiar este comportamiento:

```{r}
daily_flights <- daily |> 
  summarize(
    n = n()
  )
```

Si está satisfecho con este comportamiento, puede solicitarlo explícitamente para suprimir el mensaje:

```{r}
#| results: false

daily_flights <- daily |> 
  summarize(
    n = n(), 
    .groups = "drop_last"
  )
```

Alternativamente, cambie el comportamiento predeterminado configurando un valor diferente, por ejemplo `"drop"` para eliminar todas las agrupaciones o `"keep"` para conservar los mismos grupos.

### Desagrupar

También es posible que desee eliminar la agrupación fuera de `summarize()`.
Puedes hacer esto con `ungroup()`.

```{r}
daily |> 
  ungroup() |>
  summarize(
    delay = mean(dep_delay, na.rm = TRUE), 
    flights = n()
  )
```

Como puede ver, cuando resume un data frame sin agrupar, obtiene una sola fila porque dplyr trata todas las filas en un data frame sin agrupar como pertenecientes a un grupo.

### Ejercicios

1.  ¿Qué transportista tiene los peores retrasos?
    Desafío: ¿puede desentrañar los efectos de los malos aeropuertos frente a los malos transportistas?
    ¿Por qué/por qué no?
    (Pista: piense en `flights |> group_by(carrier, dest) |> summarize(n())`)

2.  Encuentra el vuelo más retrasado a cada destino.

3.  ¿Cómo varían los retrasos a lo largo del día?
    Ilustra tu respuesta con un gráfico.

4.  ¿Qué sucede si proporcionas una `n` negativa a `slice_min()` y amigos?

5.  Explique lo que hace `count()` en términos de los verbos dplyr que acaba de aprender.
    ¿Qué hace el argumento `sort` para `count()`?

6.  Supongamos que tenemos el siguiente data frame diminuto:

    ```{r}
    df <- tibble(
      x = 1:5,
      y = c("a", "b", "a", "a", "b"),
      z = c("K", "K", "L", "L", "K")
    )
    ```

    a.  ¿Qué hace el siguiente código?
        Ejecútelo, analice el resultado y describa lo que hace `group_by()`.

        ```{r}
        #| eval: false
            
        df |>
          group_by(y)
        ```

    b.  ¿Qué hace el siguiente código?
        Ejecútelo, analice el resultado y describa lo que hace `arrange()`.
        También comente en qué se diferencia del `group_by()` en la parte (a)?

        ```{r}
        #| eval: false
            
        df |>
          arrange(y)
        ```

    c.  ¿Qué hace el siguiente código?
        Ejecútelo, analice el resultado y describa lo que hace la *pipe*.

        ```{r}
        #| eval: false
            
        df |>
          group_by(y) |>
          summarize(mean_x = mean(x))
        ```

    d.  ¿Qué hace el siguiente código?
        Ejecútelo, analice el resultado y describa lo que hace la *pipe*.
        Luego, comenta lo que dice el mensaje.

        ```{r}
        #| eval: false
            
        df |>
          group_by(y, z) |>
          summarize(mean_x = mean(x))
        ```

    e.  ¿Qué hace el siguiente código?
        Ejecútelo, analice el resultado y describa lo que hace la *pipe*.
        ¿En qué se diferencia la salida de la del inciso d).

        ```{r}
        #| eval: false
            
        df |>
          group_by(y, z) |>
          summarize(mean_x = mean(x), .groups = "drop")
        ```

    f.  ¿Qué hacen las siguientes *pipes*?
        Ejecute ambos, analice los resultados y describa lo que hace cada *pipe*.
        ¿En qué se diferencian las salidas de las dos *pipes*?

        ```{r}
        #| eval: false
            
        df |>
          group_by(y, z) |>
          summarize(mean_x = mean(x))
            
        df |>
          group_by(y, z) |>
          mutate(mean_x = mean(x))
        ```

## Caso de estudio: agregados y tamaño de la muestra {#sec-sample-size}

Siempre que realice una agregación, siempre es una buena idea incluir un conteo (`n()`).
De esa manera, puede asegurarse de no sacar conclusiones basadas en cantidades muy pequeñas de datos.
Por ejemplo, veamos los aviones (identificados por su número de cola) que tienen los retrasos medios más altos:

```{r}
#| fig-alt: >
#|   Un histograma de frecuencia que muestra la distribución de los retrasos en los vuelos.
#|   La distribución es unimodal, con un gran pico alrededor de 0, y
#|   asimétrica: muy pocos vuelos salen con más de 30 minutos de antelación,
#|   pero los vuelos se retrasan hasta 5 horas.

delays <- flights |>  
  filter(!is.na(arr_delay), !is.na(tailnum)) |> 
  group_by(tailnum) |> 
  summarize(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

ggplot(delays, aes(x = delay)) + 
  geom_freqpoly(binwidth = 10)
```

¡Guau, hay algunos aviones que tienen un retraso *promedio* de 5 horas (300 minutos)!
Eso parece bastante sorprendente, así que dibujemos un diagrama de dispersión de la cantidad de vuelos frente al retraso promedio:

```{r}
#| fig-alt: >
#|   Un diagrama de dispersión que muestra el número de vuelos frente al retraso. Retrasos
#|   para aviones con un número muy pequeño de vuelos tienen una variabilidad muy alta
#|   (de -50 a ~300), pero la variabilidad disminuye rápidamente a medida que
#|   número de vuelos aumenta.

ggplot(delays, aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10)
```

No es sorprendente que haya una variación mucho mayor en el retraso promedio cuando hay pocos vuelos para un avión determinado.
La forma de este gráfico es muy característica: cada vez que traza una media (u otro resumen) frente al tamaño del grupo, verá que la variación disminuye a medida que aumenta el tamaño de la muestra[^data-transform-4].

[^data-transform-4]: \*tos\* el teorema del límite central \*tos\*.

Al mirar este tipo de gráfico, a menudo es útil filtrar los grupos con el menor número de observaciones, para que pueda ver más del patrón y menos de la variación extrema en los grupos más pequeños:

```{r}
#| warning: false
#| fig-alt: >
#|   Ahora que el eje y (retraso promedio) es más pequeño (-20 a 60 minutos),
#|   podemos ver una historia más complicada. La línea suave sugiere
#|   una disminución inicial en el retraso promedio de 10 minutos a 0 minutos
#|   a medida que el número de vuelos por avión aumenta de 25 a 100.
#|   A esto le sigue un aumento gradual hasta 10 minutos durante 250
#|   vuelos, luego una disminución gradual a ~5 minutos en 500 vuelos.

delays |>  
  filter(n > 25) |> 
  ggplot(aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10) + 
  geom_smooth(se = FALSE)
```

Tenga en cuenta el práctico patrón para combinar ggplot2 y dplyr.
Es un poco molesto tener que cambiar de `|>` a `+`, pero no es una molestia una vez que aprendes a hacerlo.

Hay otra variación común en este patrón que podemos ver en algunos datos sobre jugadores de béisbol.
El siguiente código utiliza datos del paquete **Lahman** para comparar la proporción de veces que un jugador golpea la pelota frente a la cantidad de intentos que realiza:

```{r}
batters <- Lahman::Batting |> 
  group_by(playerID) |> 
  summarize(
    perf = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
    n = sum(AB, na.rm = TRUE)
  )
batters
```

Cuando graficamos la habilidad del bateador (medida por el promedio de bateo, `ba`) contra el número de oportunidades para batear la pelota (medida por el turno al bate, `ab`), se ven dos patrones:

1.  Como arriba, la variación en nuestro agregado disminuye a medida que obtenemos más puntos de datos.

2.  Hay una correlación positiva entre la habilidad (`perf`) y las oportunidades de golpear la pelota (`n`) porque obviamente los equipos quieren dar a sus mejores bateadores la mayor cantidad de oportunidades de golpear la pelota.

```{r}
#| warning: false
#| fig-alt: >
#|   Un diagrama de dispersión del número de oportunidades de bateo vs. rendimiento de bateo
#|   superpuesto con una línea suavizada. El rendimiento medio aumenta considerablemente
#|   de 0,2 cuando n es 1 a 0,25 cuando n es ~1000. Rendimiento medio
#|   continúa aumentando linealmente en una pendiente mucho menos profunda alcanzando
#|   ~0,3 cuando n es ~15.000.

batters |> 
  filter(n > 100) |> 
  ggplot(aes(x = n, y = perf)) +
    geom_point(alpha = 1 / 10) + 
    geom_smooth(se = FALSE)
```

Esto también tiene implicaciones importantes para la clasificación.
Si selecciona ingenuamente `desc(ba)`, las personas con los mejores promedios de bateo son claramente afortunadas, no hábiles:

```{r}
batters |> 
  arrange(desc(perf))
```

Puede encontrar una buena explicación de este problema y cómo superarlo en <http://varianceexplained.org/r/empirical_bayes_baseball/> y <https://www.evanmiller.org/how-not-to-sort-by-average-rating.html>.

## Resumen

En este capítulo, ha aprendido las herramientas que proporciona dplyr para trabajar con marcos de datos.
Las herramientas se agrupan aproximadamente en tres categorías: las que manipulan las filas (como `filter()` y `arrange()`, las que manipulan las columnas (como `select()` y `mutate()`), y las que que manipulan grupos (como `group_by()` y `summarize()`).
En este capítulo, nos hemos centrado en estas herramientas de "data frame completo", pero aún no ha aprendido mucho sobre lo que puede hacer con la variable individual.
Volveremos a eso en la parte Transformar del libro, donde cada capítulo le brindará herramientas para un tipo específico de variable.

Por ahora, volveremos al flujo de trabajo, y en el próximo capítulo aprenderá más sobre *pipe*, `|>`, por qué la recomendamos y un poco de la historia que conduce desde `%>%` de Magrittr.
para basar `|>` de R.
